Sjasm Z80 Assembler v0.42c - www.xl2s.tk             [2015.11.02 - 19:33:55]

rom.asm
Errors: 0

       1   00:C000                      ; ROM
       2   00:C000                      ;
       3   00:C000                      ; This is the very start of the EPNET ROM
       4   00:C000                      ;
       5   00:C000                      ;==============================================================================
       6   00:C000                      ;
       7   00:C000                      ; This file is part of the EPNET software
       8   00:C000                      ;
       9   00:C000                      ; Copyright (C) 2015  Bruce Tanner
      10   00:C000                      ;
      11   00:C000                      ;    This program is free software: you can redistribute it and/or modify
      12   00:C000                      ;    it under the terms of the GNU General Public License as published by
      13   00:C000                      ;    the Free Software Foundation, either version 3 of the License, or
      14   00:C000                      ;    (at your option) any later version.
      15   00:C000                      ;
      16   00:C000                      ;    This program is distributed in the hope that it will be useful,
      17   00:C000                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      18   00:C000                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      19   00:C000                      ;    GNU General Public License for more details.
      20   00:C000                      ;
      21   00:C000                      ;    You should have received a copy of the GNU General Public License
      22   00:C000                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      23   00:C000                      ;
      24   00:C000                      ; If you do use or modify this file, either for its original purpose or for
      25   00:C000                      ; something new, I'd love to hear about it! I can be contacted by email at:
      26   00:C000                      ;
      27   00:C000                      ; brucetanner@btopenworld.com
      28   00:C000                      ;
      29   00:C000                      ;==============================================================================
      30   00:C000                      ;
      31   00:C000                                      org 0c000h
      32   00:C000                      ;
      33   00:C000                                      db	"EXOS_ROM"		;ROM header
      33   00:C000  45 58 4F 53 5F 52 4F 4D 
      34   00:C008  20 4B                               dw	device.devices-8000h	; Page 1 pointer to device desc
      35   00:C00A  C3 14 C0            		jp	entry			; ROM entry point from EXOS
      36   00:C00D                      ;
      37   00:C00D                      ;
      38   00:C00D                      ; These locations in the ROM are non-standard, but fixed for EPNET
      39   00:C00D                      ;
      40   00:C00D                      ; Normally EPNET finds it's i/o from it's ROM segment number. But if this byte
      41   00:C00D                      ; is non-zero, it specifies the I/O to use instead
      42   00:C00D  00                  io:		db	0		; Card I/O address; 0=>use ROM/2
      43   00:C00E                      ;
      44   00:C00E                      ; The MAC address is here. It must be different for each EPNET card!
      45   00:C00E  00 00 F6 42 42 00   mac:		db	00h,00h,0f6h,42h,42h,00h	; Our MAC address
      46   00:C014                      ;
      47   00:C014                      ;
      48   00:C014  FD 21 00 F0         entry:		ld	iy,vars
      49   00:C018                      ;
      50   00:C018  79                  		ld	a,c
      51   00:C019  3D                  		dec	a
      52   00:C01A  28 0E               		jr	z,cold_reset	; Action code 1: cold reset
      53   00:C01C                      ;
      54   00:C01C  3D                  		dec	a		; Action code 2: command string
      55   00:C01D  CA 74 C0                            jp	z,command.command
      56   00:C020                      ;
      57   00:C020  3D                  		dec	a		; Action code 3: HELP string
      58   00:C021  CA 30 C0                            jp	z,command.help
      59   00:C024                      ;
      60   00:C024  3D                  		dec	a		; Action code 4: EXOS variable
      61   00:C025  3D                  		dec	a		; Action code 5: Explain error code
      62   00:C026  CA AB C9            		jp	z,exos.explain
      63   00:C029                      ;
      64   00:C029  C9                                  ret
      65   00:C02A                      ;
      66   00:C02A  CD 21 CF            cold_reset:	call	util.varszero	; Initialize private RAM area
      67   00:C02D  0E 01               		ld	c,1		; Preserve 1 action code
      68   00:C02F  C9                  		ret
      69   00:C030                      ;
      70   00:C030                      ;
      71   00:C030                      		include	main.asm
       1.  00:C030                      ; MAIN
       2.  00:C030                      ;
       3.  00:C030                      ; This is the main program file, and just includes all the other modules.
       4.  00:C030                      ;
       5.  00:C030                      ;==============================================================================
       6.  00:C030                      ;
       7.  00:C030                      ; This file is part of the EPNET software
       8.  00:C030                      ;
       9.  00:C030                      ; Copyright (C) 2015  Bruce Tanner
      10.  00:C030                      ;
      11.  00:C030                      ;    This program is free software: you can redistribute it and/or modify
      12.  00:C030                      ;    it under the terms of the GNU General Public License as published by
      13.  00:C030                      ;    the Free Software Foundation, either version 3 of the License, or
      14.  00:C030                      ;    (at your option) any later version.
      15.  00:C030                      ;
      16.  00:C030                      ;    This program is distributed in the hope that it will be useful,
      17.  00:C030                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      18.  00:C030                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      19.  00:C030                      ;    GNU General Public License for more details.
      20.  00:C030                      ;
      21.  00:C030                      ;    You should have received a copy of the GNU General Public License
      22.  00:C030                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      23.  00:C030                      ;
      24.  00:C030                      ; If you do use or modify this file, either for its original purpose or for
      25.  00:C030                      ; something new, I'd love to hear about it! I can be contacted by email at:
      26.  00:C030                      ;
      27.  00:C030                      ; brucetanner@btopenworld.com
      28.  00:C030                      ;
      29.  00:C030                      ;==============================================================================
      30.  00:C030                      ;
      31.  00:C030                      ; At the heart of the program is socket.c, which talks to the WIZ chip socket
      32.  00:C030                      ; interface. Protocol modules such as UDP, TCP and IPRAW in turn talk to
      33.  00:C030                      ; socket.c. The higher-level protocols such as DHCP, PING and FTP then talk to
      34.  00:C030                      ; the protocol modules.
      35.  00:C030                      ;                                                                               
      36.  00:C030                      ;  -------------------------------------------------------------               
      37.  00:C030                      ; |                               EXOS                          |               
      38.  00:C030                      ;  -------------------------------------------------------------                
      39.  00:C030                      ;               ^                                 ^                             
      40.  00:C030                      ;               |                                 |                             
      41.  00:C030                      ;               v                                 |                             
      42.  00:C030                      ;  -------------------------                      |                             
      43.  00:C030                      ; |     EXOS ROM ENTRY      |                     |                             
      44.  00:C030                      ;  ------------------------                       |                             
      45.  00:C030                      ;              ^ ^                                |                             
      46.  00:C030                      ;             /   \                               |                             
      47.  00:C030                      ;            /     \                              |                             
      48.  00:C030                      ;           v       v                             v                             
      49.  00:C030                      ;  ---------------------------               -----------                        
      50.  00:C030                      ; | ftp: device | commandsasm |             |   io.asm  |                       
      51.  00:C030                      ;  ---------------------------              | trace.asm |                       
      52.  00:C030                      ;      ^            ^^^                      -----------                        
      53.  00:C030                      ;      |           / | \                                                        
      54.  00:C030                      ;      |          /  |  \                                                       
      55.  00:C030                      ;      |         /   |   \                                                      
      56.  00:C030                      ;      |        /    |    \                                                     
      57.  00:C030                      ;      |       /     |     \                                                    
      58.  00:C030                      ;      |      /      |      \                                                   
      59.  00:C030                      ;      |     /       |       \                                                  
      60.  00:C030                      ;      |    /        |        \                                                 
      61.  00:C030                      ;      |   /         |         \                                                
      62.  00:C030                      ;      v  v          v          v                                               
      63.  00:C030                      ;  --------------------------------------                                       
      64.  00:C030                      ; | http.asm|    sntp.asm   |            |                                      
      65.  00:C030                      ; | ftp.asm |    dhcp.asm   |  ping.asm  |                                      
      66.  00:C030                      ;  --------------------------------------                                       
      67.  00:C030                      ;      ^            ^             ^                                             
      68.  00:C030                      ;      |            |             |                                             
      69.  00:C030                      ;      v            v             v                                             
      70.  00:C030                      ;  --------------------------------------                                       
      71.  00:C030                      ; | tcp.asm |    udp.asm    |  ipraw.asm |                                      
      72.  00:C030                      ;  --------------------------------------                                       
      73.  00:C030                      ;      ^            ^             ^                                             
      74.  00:C030                      ;      |            |             |                                             
      75.  00:C030                      ;      v            v             v                                             
      76.  00:C030                      ;  --------------------------------------+----------------------                
      77.  00:C030                      ; |             socket.asm               |      wiz.asm         |               
      78.  00:C030                      ;  -------------------------------------------------------------                
      79.  00:C030                      ;                   ^                               ^                           
      80.  00:C030                      ;                   |                               |                           
      81.  00:C030                      ;                   v                               v                           
      82.  00:C030                      ;  =============================================================                
      83.  00:C030                      ; | WIZ socket registers                 | WIZ common registers |               
      84.  00:C030                      ;  =============================================================                
      85.  00:C030                      ;
      86.  00:C030                      ;
      87.  00:C030                      	include version.asm
       1:  00:C030                      ; VERSION
       2:  00:C030                      ;
       3:  00:C030                      ; This just contains the verion number of the system
       4:  00:C030                      ;
       5:  00:C030                      		module	version
       6:  00:C030                      ;
       7:  00:C030                      ;==============================================================================
       8:  00:C030                      ;
       9:  00:C030                      ; This file is part of the EPNET software
      10:  00:C030                      ;
      11:  00:C030                      ; Copyright (C) 2015  Bruce Tanner
      12:  00:C030                      ;
      13:  00:C030                      ;    This program is free software: you can redistribute it and/or modify
      14:  00:C030                      ;    it under the terms of the GNU General Public License as published by
      15:  00:C030                      ;    the Free Software Foundation, either version 3 of the License, or
      16:  00:C030                      ;    (at your option) any later version.
      17:  00:C030                      ;
      18:  00:C030                      ;    This program is distributed in the hope that it will be useful,
      19:  00:C030                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      20:  00:C030                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      21:  00:C030                      ;    GNU General Public License for more details.
      22:  00:C030                      ;
      23:  00:C030                      ;    You should have received a copy of the GNU General Public License
      24:  00:C030                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      25:  00:C030                      ;
      26:  00:C030                      ; If you do use or modify this file, either for its original purpose or for
      27:  00:C030                      ; something new, I'd love to hear about it! I can be contacted by email at:
      28:  00:C030                      ;
      29:  00:C030                      ; brucetanner@btopenworld.com
      30:  00:C030                      ;
      31:  00:C030                      ;==============================================================================
      32:  00:C030                      ;
      33:  00:C030  (00:0030)           major		equ	'0'
      34:  00:C030  (00:0031)           minor		equ	'1'
      35:  00:C030  (00:0031)           revision	equ	'1'
      36:  00:C030                      ;
      37:  00:C030                      ;
      38:  00:C030                      ; History:
      39:  00:C030                      ;
      40:  00:C030                      ; VERSION	DATE		DESCRIPTION
      41:  00:C030                      ; 0.11		ongoing
      42:  00:C030                      ; 0.10		unknown		Initial version sent to lgb
      43:  00:C030                      ;
      44:  00:C030                      ;
      45:  00:C030                      		endmodule
      88.  00:C030                      	include	debug.asm
       1:  00:C030                      ; DEBUG
       2:  00:C030                      ;
       3:  00:C030                      ; Some useful macros for debugging. Comment out the fo0llowing line to
       4:  00:C030                      ; assemble a non-debugging version:
       5:  00:C030                      ;
       6:  00:C030                      		define	DEBUG
       7:  00:C030                      ;
       8:  00:C030                      ;==============================================================================
       9:  00:C030                      ;
      10:  00:C030                      ; This file is part of the EPNET software
      11:  00:C030                      ;
      12:  00:C030                      ; Copyright (C) 2015  Bruce Tanner
      13:  00:C030                      ;
      14:  00:C030                      ;    This program is free software: you can redistribute it and/or modify
      15:  00:C030                      ;    it under the terms of the GNU General Public License as published by
      16:  00:C030                      ;    the Free Software Foundation, either version 3 of the License, or
      17:  00:C030                      ;    (at your option) any later version.
      18:  00:C030                      ;
      19:  00:C030                      ;    This program is distributed in the hope that it will be useful,
      20:  00:C030                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      21:  00:C030                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      22:  00:C030                      ;    GNU General Public License for more details.
      23:  00:C030                      ;
      24:  00:C030                      ;    You should have received a copy of the GNU General Public License
      25:  00:C030                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      26:  00:C030                      ;
      27:  00:C030                      ; If you do use or modify this file, either for its original purpose or for
      28:  00:C030                      ; something new, I'd love to hear about it! I can be contacted by email at:
      29:  00:C030                      ;
      30:  00:C030                      ; brucetanner@btopenworld.com
      31:  00:C030                      ;
      32:  00:C030                      ;==============================================================================
      33:  00:C030                      ;
      34:  00:C030                      		macro POKE ch
      35:  00:C030                    < 		 ifdef	DEBUG
      36:  00:C030                    < 		  push	af
      37:  00:C030                    < 		  ld	a,ch
      38:  00:C030                    < 		  call	io.char
      39:  00:C030                    < 		  pop	af
      40:  00:C030                    < 		 endif
      41:  00:C030                    < 		endm
      42:  00:C030                      ;
      43:  00:C030                      		macro POKEcc cond,ch
      44:  00:C030                    < 		 ifdef DEBUG
      45:  00:C030                    < 		  push	af
      46:  00:C030                    < 		  ld	a,ch
      47:  00:C030                    < 		  call	cond,io.char
      48:  00:C030                    < 		  pop	af
      49:  00:C030                    < 		 endif
      50:  00:C030                    < 		endm
      51:  00:C030                      ;
      52:  00:C030                      		macro POKEBYTE reg
      53:  00:C030                    < 		 ifdef	DEBUG
      54:  00:C030                    < 		  push	af
      55:  00:C030                    < 		  ld	a,reg
      56:  00:C030                    < 		  call	io.byte
      57:  00:C030                    < 		  pop	af
      58:  00:C030                    < 		 endif
      59:  00:C030                    < 		endm
      60:  00:C030                      ;
      61:  00:C030                      		macro POKEBYTEcc cond, reg
      62:  00:C030                    < 		 ifdef	DEBUG
      63:  00:C030                    < 		  push	af
      64:  00:C030                    < 		  ld	a,reg
      65:  00:C030                    < 		  call	cond,io.byte
      66:  00:C030                    < 		  pop	af
      67:  00:C030                    < 		 endif
      68:  00:C030                    < 		endm
      89.  00:C030                      ;
      90.  00:C030                      	include	ep.asm
       1:  00:C030                      ; EP
       2:  00:C030                      ;
       3:  00:C030                      ; This module contains various Enterprise hardware constants (i/o ports etc)
       4:  00:C030                      ;
       5:  00:C030                      		module	ep
       6:  00:C030                      ;
       7:  00:C030                      ;==============================================================================
       8:  00:C030                      ;
       9:  00:C030                      ; This file is part of the EPNET software
      10:  00:C030                      ;
      11:  00:C030                      ; Copyright (C) 2015  Bruce Tanner
      12:  00:C030                      ;
      13:  00:C030                      ;    This program is free software: you can redistribute it and/or modify
      14:  00:C030                      ;    it under the terms of the GNU General Public License as published by
      15:  00:C030                      ;    the Free Software Foundation, either version 3 of the License, or
      16:  00:C030                      ;    (at your option) any later version.
      17:  00:C030                      ;
      18:  00:C030                      ;    This program is distributed in the hope that it will be useful,
      19:  00:C030                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      20:  00:C030                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      21:  00:C030                      ;    GNU General Public License for more details.
      22:  00:C030                      ;
      23:  00:C030                      ;    You should have received a copy of the GNU General Public License
      24:  00:C030                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      25:  00:C030                      ;
      26:  00:C030                      ; If you do use or modify this file, either for its original purpose or for
      27:  00:C030                      ; something new, I'd love to hear about it! I can be contacted by email at:
      28:  00:C030                      ;
      29:  00:C030                      ; brucetanner@btopenworld.com
      30:  00:C030                      ;
      31:  00:C030                      ;==============================================================================
      32:  00:C030                      ;
      33:  00:C030  (00:00B0)           P0	equ	0b0h	; Page 0 register
      34:  00:C030  (00:00B1)           P1	equ	0b1h	; Page 1 register
      35:  00:C030  (00:00B2)           P2	equ	0b2h	; Page 2 register
      36:  00:C030  (00:00B3)           P3	equ	0b3h	; Page 3 register
      37:  00:C030                      ;
      38:  00:C030                      ;
      39:  00:C030                      ;
      40:  00:C030                      		endmodule
      91.  00:C030                      ;
      92.  00:C030                      	include command.asm
       1:  00:C030                      ; COMMAND
       2:  00:C030                      ;
       3:  00:C030                      ; This module implements the EXOS commands
       4:  00:C030                      ;
       5:  00:C030                      		module command
       6:  00:C030                      ;
       7:  00:C030                      ;==============================================================================
       8:  00:C030                      ;
       9:  00:C030                      ; This file is part of the EPNET software
      10:  00:C030                      ;
      11:  00:C030                      ; Copyright (C) 2015  Bruce Tanner
      12:  00:C030                      ;
      13:  00:C030                      ;    This program is free software: you can redistribute it and/or modify
      14:  00:C030                      ;    it under the terms of the GNU General Public License as published by
      15:  00:C030                      ;    the Free Software Foundation, either version 3 of the License, or
      16:  00:C030                      ;    (at your option) any later version.
      17:  00:C030                      ;
      18:  00:C030                      ;    This program is distributed in the hope that it will be useful,
      19:  00:C030                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      20:  00:C030                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      21:  00:C030                      ;    GNU General Public License for more details.
      22:  00:C030                      ;
      23:  00:C030                      ;    You should have received a copy of the GNU General Public License
      24:  00:C030                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      25:  00:C030                      ;
      26:  00:C030                      ; If you do use or modify this file, either for its original purpose or for
      27:  00:C030                      ; something new, I'd love to hear about it! I can be contacted by email at:
      28:  00:C030                      ;
      29:  00:C030                      ; brucetanner@btopenworld.com
      30:  00:C030                      ;
      31:  00:C030                      ;==============================================================================
      32:  00:C030                      ; help
      33:  00:C030                      ;
      34:  00:C030                      ; Passed a command at (DE), looks to see if it is one of our commands and
      35:  00:C030                      ; prints help text if it is.
      36:  00:C030                      ;
      37:  00:C030                      ; In:  B=length. 0 if it's general help ie. just :HELP rather than :HELP <cmd>
      38:  00:C030                      ;     DE->command
      39:  00:C030                      ;
      40:  00:C030  78                  help:		ld	a,b		; See if it's general or specific HELP
      41:  00:C031  B7                  		or	a
      42:  00:C032  20 1F               		jr	nz,specific
      43:  00:C034                      ;
      44:  00:C034  D5                  		push	de		; General help so just print message
      45:  00:C035  C5                  		push	bc
      46:  00:C036  11 3D C4            		 ld	de,version_str
      47:  00:C039  CD 3D CE            		 call	io.str
      48:  00:C03C  C1                  		pop	bc
      49:  00:C03D  D1                  		pop	de
      50:  00:C03E  C9                  		ret			; Preserving DE and B
      51:  00:C03F                      ;		
      52:  00:C03F  21 7E C3            nothelpnet:	ld	hl,main_tab	; Find command in our command table
      53:  00:C042  CD A4 C0            		call	find		; HL=offset into command table
      54:  00:C045  D8                  		ret	c		; Cy=>Not found
      55:  00:C046                      ;
      56:  00:C046                      ;
      57:  00:C046  11 86 C3            		ld	de,main_help_tab; Find help text ptr in help table
      58:  00:C049  19                  help_cmd:	add	hl,de
      59:  00:C04A  5E                  		ld	e,(hl)		; Get pointer to command help text
      60:  00:C04B  23                  		inc	hl
      61:  00:C04C  56                  		ld	d,(hl)
      62:  00:C04D                      ;
      63:  00:C04D  CD 3D CE            helpout:	CALL	io.str
      64:  00:C050  AF                  		xor	a
      65:  00:C051  4F                                  ld	c,a		; C=0 => recognized
      66:  00:C052  C9                                  ret
      67:  00:C053                      ;
      68:  00:C053  21 65 C9            specific:	ld	hl,net_str	; HELP NET?
      69:  00:C056  CD 8F C0                            call	compare
      70:  00:C059  20 E4               		jr	nz,nothelpnet	; Go & check for other commands if not
      71:  00:C05B                      ;
      72:  00:C05B  06 03               		ld 	b,net_str_len	; Skip NET to find sub-command
      73:  00:C05D  CD C8 C0            		call	skip
      74:  00:C060                      ;
      75:  00:C060  28 0D               nethelp:	jr	z,.helpnet	; Go if none
      76:  00:C062                      ;
      77:  00:C062  21 92 C3            		ld	hl,net_tab	; Find command in our command table
      78:  00:C065  CD A4 C0            		call	find		; HL=offset into command table
      79:  00:C068  38 05               		jr	c,.helpnet	; Go if not found
      80:  00:C06A                      ;
      81:  00:C06A  11 A4 C3            		ld	de,net_help_tab	; Find help text ptr in help table
      82:  00:C06D  18 DA               		jr	help_cmd
      83:  00:C06F                      ;
      84:  00:C06F  11 52 C4            .helpnet:	ld	de,net_help_str	; HELP NET with no extra commands
      85:  00:C072  18 D9               		jr	helpout		; Just print general NET help
      86:  00:C074                      ;
      87:  00:C074                      ;
      88:  00:C074                      ;------------------------------------------------------------------------------
      89:  00:C074                      ; command
      90:  00:C074                      ;
      91:  00:C074                      ; Passed a command at (DE), looks to see if it one of ours and executes it if so.
      92:  00:C074                      ;
      93:  00:C074                      ; In:  B=length
      94:  00:C074                      ;     DE->command
      95:  00:C074                      ; Out: C=0 and A=error code if command recognised, else B & DE preserved
      96:  00:C074                      ;
      97:  00:C074                      command:
      98:  00:C074  21 7E C3            		ld	hl,main_tab	; Find command in our command table
      99:  00:C077  CD A4 C0            		call	find		; HL=offset into command table
     100:  00:C07A  D8                  		ret	c		; Cy=>Not found
     101:  00:C07B                      ;
     102:  00:C07B  F5                  		push	af		; Save flags from find
     103:  00:C07C  3A 00 F0            		 ld	a,(vars.trace)	; If tracing is on set up _tab video cols
     104:  00:C07F  B7                  		 or	a		;   before jumping to command
     105:  00:C080  C4 8D D0            		 call	nz,trace.set_cols
     106:  00:C083  F1                  		pop	af		; F=result from find
     107:  00:C084                      ;
     108:  00:C084  D5                  		push	de
     109:  00:C085  11 8C C3            		 ld	de,main_cmd_tab
     110:  00:C088  19                  		 add	hl,de
     111:  00:C089  D1                  		pop	de
     112:  00:C08A  7E                  jp_cmd:		ld	a,(hl)		; Get poointer to command routine
     113:  00:C08B  23                  		inc	hl
     114:  00:C08C  66                  		ld	h,(hl)
     115:  00:C08D  6F                  		ld	l,a
     116:  00:C08E  E9                  @jphl:		jp	(hl)		; Jump to command
     117:  00:C08F                      ;
     118:  00:C08F                      ;
     119:  00:C08F                      ;------------------------------------------------------------------------------
     120:  00:C08F                      ; compare
     121:  00:C08F                      ;
     122:  00:C08F                      ; Checks to see if the command at (DE) is the same as that at (HL).
     123:  00:C08F                      ; (HL) is length byte first; B is the length of the user's command
     124:  00:C08F                      ; In:  DE->user's command, length byte first
     125:  00:C08F                      ;       B=length of user's command (ie. first word)
     126:  00:C08F                      ;      HL->Command string in upper case, length byte first
     127:  00:C08F                      ;       Z=>command matches
     128:  00:C08F                      ;
     129:  00:C08F                      compare:
     130:  00:C08F  78                   		ld	 a,b		; Compare length first
     131:  00:C090  BE                                  cp	 (hl)
     132:  00:C091  C0                                  ret	 nz		; Not the same so command does not match
     133:  00:C092                      ;
     134:  00:C092  C5                                  push	 bc		; Save length of command word
     135:  00:C093  D5                                  push	 de		; And -> start of command
     136:  00:C094  13                                   inc	 de
     137:  00:C095  23                                   inc	 hl
     138:  00:C096  1A                  .loop          	 ld	 a,(de)
     139:  00:C097  CD 3C CF            		 call	 util.upper
     140:  00:C09A  96                                   sub	 (hl)		; See if chars the same
     141:  00:C09B  20 04                                jr	 nz,.notequal	; Go with NZ if not
     142:  00:C09D                      ;
     143:  00:C09D  23                                   inc	 hl		; Else compare next char
     144:  00:C09E  13                                   inc	 de
     145:  00:C09F  10 F5                                djnz	 .loop		; Still Z when end
     146:  00:C0A1                      ;
     147:  00:C0A1  D1                  .notequal       pop	 de		; Return DE->command
     148:  00:C0A2  C1                                  pop	 bc		; B=length
     149:  00:C0A3  C9                                  ret
     150:  00:C0A4                      ;
     151:  00:C0A4                      ;
     152:  00:C0A4                      ;------------------------------------------------------------------------------
     153:  00:C0A4                      ; find
     154:  00:C0A4                      ;
     155:  00:C0A4                      ; Finds a command in table of commands that we understand
     156:  00:C0A4                      ; 
     157:  00:C0A4                      ; In:  DE->command
     158:  00:C0A4                      ;       B=length of command (up to first space)
     159:  00:C0A4                      ;      HL->table of command strings
     160:  00:C0A4                      ; Out: DE not corrupted
     161:  00:C0A4                      ;      BC not corrupted, except B=length of next word if found
     162:  00:C0A4                      ;      Cy=>not found, else Z according to B
     163:  00:C0A4                      ;      NZ=>not found
     164:  00:C0A4                      ;      HL=offset into table if found
     165:  00:C0A4                      ;
     166:  00:C0A4                      find:
     167:  00:C0A4  E5                  		push	hl		; Save start of table
     168:  00:C0A5                      ;
     169:  00:C0A5  E5                  .loop:		 push	hl		; Save current entry pointer
     170:  00:C0A6                      ;
     171:  00:C0A6  7E                  		  ld	a,(hl)		; Get pointer to string from table in HL
     172:  00:C0A7  23                  		  inc	hl
     173:  00:C0A8  66                  		  ld	h,(hl)
     174:  00:C0A9  6F                  		  ld	l,a
     175:  00:C0AA  B4                  		  or	h
     176:  00:C0AB  28 0A               		  jr	z,.end		; 0 => end of table, A=0
     177:  00:C0AD                      ;
     178:  00:C0AD  CD 8F C0            		  call	compare		; See if string = command
     179:  00:C0B0  E1                  		 pop	hl		; HL->back to table entry
     180:  00:C0B1  28 08               		 jr	z,.gotcmd	; Got match
     181:  00:C0B3                      ;
     182:  00:C0B3  23                  		 inc	hl		; Point to next table entry
     183:  00:C0B4  23                  		 inc	hl
     184:  00:C0B5  18 EE               		 jr	.loop		; Try next command in table
     185:  00:C0B7                      
     186:  00:C0B7  E1                  .end:		 pop	hl		; Drop current table pointer
     187:  00:C0B8  E1                  		pop	hl		; Drop start of table pointer
     188:  00:C0B9  37                  		scf			; Cy=>not found
     189:  00:C0BA  C9                  		ret
     190:  00:C0BB                      ;
     191:  00:C0BB  EB                  .gotcmd:	 ex	de,hl		; HL->command, DE->table entry
     192:  00:C0BC  E3                  		 ex	(sp),hl		; (SP)->command, HL->start of table
     193:  00:C0BD  EB                  		 ex	de,hl		; HL->table entry, DE->start of table
     194:  00:C0BE  B7                  		 or	a
     195:  00:C0BF  ED 52               		 sbc	hl,de		; HL=offset into table
     196:  00:C0C1                      ;
     197:  00:C0C1  D1                  		pop	de		; DE->command
     198:  00:C0C2                      ;
     199:  00:C0C2  E5                  		push	hl
     200:  00:C0C3  CD C8 C0            		 call	skip
     201:  00:C0C6  E1                  		pop	hl
     202:  00:C0C7                      ;
     203:  00:C0C7  C9                  		ret
     204:  00:C0C8                      ;
     205:  00:C0C8                      ;
     206:  00:C0C8                      ;------------------------------------------------------------------------------
     207:  00:C0C8                      ; skip
     208:  00:C0C8                      ;
     209:  00:C0C8                      ; Takes an EXOS command string at (DE) and skips B chars, returning the length
     210:  00:C0C8                      ; of the next word in B in EXOS-compatible manner.
     211:  00:C0C8                      ;
     212:  00:C0C8                      ; In:  DE->length byte of a command and is adjusted to skip B bytes
     213:  00:C0C8                      ;       B=number of chars to skip
     214:  00:C0C8                      ; Out: DE adjusted
     215:  00:C0C8                      ;       B=length of the next word
     216:  00:C0C8                      ;      AF=flags set according to B (ie. Z if no more command) and NC
     217:  00:C0C8                      ;
     218:  00:C0C8                      skip:
     219:  00:C0C8  EB                  		ex	de,hl		; HL->command
     220:  00:C0C9  E5                  		push	hl		; Save start of command
     221:  00:C0CA  7D                  		 ld	a,l		; Add on B bytes
     222:  00:C0CB  80                  		 add	a,b
     223:  00:C0CC  6F                  		 ld	l,a
     224:  00:C0CD  30 01               		 jr	nc,.skipinc
     225:  00:C0CF                      ;
     226:  00:C0CF  24                  		 inc	h
     227:  00:C0D0                      .skipinc:
     228:  00:C0D0  E3                  		 ex	(sp),hl		; (SP)=adjusted command ptr, HL->start
     229:  00:C0D1  7E                  		 ld	a,(hl)		; Get and adjust length byte
     230:  00:C0D2  90                  		 sub	b
     231:  00:C0D3  47                  		 ld	b,a
     232:  00:C0D4  E1                  		pop	hl		; HL=adjusted command ptr
     233:  00:C0D5  EB                  		ex	de,hl		; Back in DE
     234:  00:C0D6                      		    ;
     235:  00:C0D6                      		    ;
     236:  00:C0D6                      		    ;
     237:  00:C0D6                      ;
     238:  00:C0D6                      ;------------------------------------------------------------------------------
     239:  00:C0D6                      ; unspace
     240:  00:C0D6                      ;
     241:  00:C0D6                      ; Skips leading spaces from a command at (DE)
     242:  00:C0D6                      ;
     243:  00:C0D6                      ; In:  DE->buffer length byte of command but the length is actually in B
     244:  00:C0D6                      ;       B=length of command
     245:  00:C0D6                      ; Out: DE may have been incremented but a new length byte is at (DE)
     246:  00:C0D6                      ;       B=length of the next word
     247:  00:C0D6                      ;      AF=flags set according to B (ie. Z if no more command) and NC
     248:  00:C0D6                      ;
     249:  00:C0D6                      unspace:
     250:  00:C0D6  04                  		inc	b		; Adjust for first time round loop
     251:  00:C0D7  13                  .loop:		inc	de		; Next char in command
     252:  00:C0D8  05                  		dec	b		; Dec length
     253:  00:C0D9  28 05               		jr	z,.setlen
     254:  00:C0DB  1A                  		ld	a,(de)
     255:  00:C0DC  FE 20               		cp	' '
     256:  00:C0DE  28 F7               		jr	z,.loop		; Skip if space
     257:  00:C0E0                      ;
     258:  00:C0E0  1B                  .setlen:	dec	de		; DE->length byte
     259:  00:C0E1  78                  		ld	a,b
     260:  00:C0E2  12                  		ld	(de),a		; New length byte
     261:  00:C0E3                      
     262:  00:C0E3                      ; To make it EXOS compatible we need the length of the first command in B
     263:  00:C0E3  6B                  		ld	l,e		; HL->length byte of command
     264:  00:C0E4  62                  		ld	h,d
     265:  00:C0E5  06 FF               		ld	b,-1		; Count of chars in first word
     266:  00:C0E7  23                  .count:  	inc	hl
     267:  00:C0E8  04                  		inc	b		; B == length byte => end of line
     268:  00:C0E9  1A                  		ld	a,(de)
     269:  00:C0EA  90                  		sub	b
     270:  00:C0EB  28 05               		jr	z,.ret		; A=0
     271:  00:C0ED                      ;
     272:  00:C0ED  7E                  		ld	a,(hl)
     273:  00:C0EE  D6 20               		sub	' '
     274:  00:C0F0  20 F5               		jr	nz,.count
     275:  00:C0F2                      ;
     276:  00:C0F2  B0                  .ret:		or	b		; NC
     277:  00:C0F3  C9                  		ret
     278:  00:C0F4                      ;
     279:  00:C0F4                      ;
     280:  00:C0F4                      ;==============================================================================
     281:  00:C0F4                      ; NET command
     282:  00:C0F4                      ;
     283:  00:C0F4  28 16               net:		jr	z,.nonet
     284:  00:C0F6                      ;
     285:  00:C0F6  21 92 C3            		ld	hl,net_tab	; Find command in our command table
     286:  00:C0F9  CD A4 C0            		call	find		; HL=offset into command table
     287:  00:C0FC  38 09               		jr	c,.badnet	; Go if not found
     288:  00:C0FE                      ;
     289:  00:C0FE  D5                  		push	de
     290:  00:C0FF  11 B4 C3            		 ld	de,net_cmd_tab
     291:  00:C102  19                  		 add	hl,de
     292:  00:C103  D1                  		pop	de
     293:  00:C104  C3 8A C0            		jp	jp_cmd		; Jump to command code
     294:  00:C107                      ;
     295:  00:C107                      ;
     296:  00:C107  3E 6C               .badnet:	ld	a,exos.ERR_BADOPT
     297:  00:C109  0E 00               		ld	c,0
     298:  00:C10B  C9                  		ret
     299:  00:C10C                      ;
     300:  00:C10C  11 52 C4            .nonet:		ld	de,net_help_str
     301:  00:C10F  CD 3D CE            		call	io.str
     302:  00:C112  AF                  		xor	a
     303:  00:C113  4F                  		ld	c,a
     304:  00:C114  C9                  		ret
     305:  00:C115                      ;
     306:  00:C115                      ;
     307:  00:C115                      ;------------------------------------------------------------------------------
     308:  00:C115                      ; NET START and NET DIAG commands
     309:  00:C115                      ;
     310:  00:C115                      ; NET DIAG is exactly the same as NET START except that it enables diagnostic
     311:  00:C115                      ; tracing.
     312:  00:C115                      ;
     313:  00:C115                      net_diag:
     314:  00:C115  FD 6E 00            		ld	l,(iy+vars._trace)
     315:  00:C118  E5                  		push	hl		; Save trace flags
     316:  00:C119  FD CB 00 C6         		 set	vars.trace.diag,(iy+vars._trace); Trace mode for diag
     317:  00:C11D  CD 25 C1            		 call	net_start	; Otherwise as :NET START
     318:  00:C120  E1                  		pop	hl		; L=saved trace flags
     319:  00:C121  FD 75 00            		ld	(iy+vars._trace),l	; Restore trace flags
     320:  00:C124  C9                  		ret
     321:  00:C125                      ;
     322:  00:C125                      ;
     323:  00:C125  FD CB 03 86         net_start:	res	vars.init.wiz,(iy+vars._init)	; Pretend not started
     324:  00:C129                      		    ;
     325:  00:C129                      		    ;
     326:  00:C129                      		    ;
     327:  00:C129                      ;
     328:  00:C129                      ;
     329:  00:C129                      ; This is like net_start but is called from most other commands to make sure
     330:  00:C129                      ; the network is started.
     331:  00:C129                      ;
     332:  00:C129                      ; Preserves DE and B.
     333:  00:C129                      ; Returns C=0.
     334:  00:C129                      ;
     335:  00:C129  D5                  netstart:	push	de
     336:  00:C12A  C5                  		push	bc
     337:  00:C12B  CD 15 D4            		 call	wiz.init	; Attempt to initialise WIZ module
     338:  00:C12E                      ;
     339:  00:C12E  9F                  do_dhcp:	 sbc	a,a		; NC=>0, Cy=>ff
     340:  00:C12F  E6 6E               		 and	exos.ERR_NONET	; 0 or .ERR_NONET
     341:  00:C131  20 10               		 jr	nz,.chk_stop	; Go if couldn't start
     342:  00:C133                      
     343:  00:C133  CD 7C D5            		 call	wiz.check_ip	; Check for duplicate IP address
     344:  00:C136  9F                  		 sbc	a,a
     345:  00:C137  E6 66               		 and	exos.ERR_DUPIP
     346:  00:C139  20 0B               		 jr	nz,.ret
     347:  00:C13B                      ;	 
     348:  00:C13B  CD D4 DF            		 call	dhcp.init	; Attempt to initilaise DHCP
     349:  00:C13E  9F                  		 sbc	a,a		; A=0 if NC (& still NC)
     350:  00:C13F  E6 6F               		 and	exos.ERR_DHCP	; 0 or .ERR_DHCP
     351:  00:C141  28 03               		 jr	z,.ret		; Go if no error
     352:  00:C143                      ;
     353:  00:C143                      .chk_stop:	 ; An error was returned - see if due to the STOP key
     354:  00:C143  CD A2 C9            		 call	exos.check_stop
     355:  00:C146  C1                  .ret:		pop	bc
     356:  00:C147  D1                  		pop	de
     357:  00:C148  0E 00               		ld	c,0		; Command recognised
     358:  00:C14A  B7                  		or	a		; Z or NZ according to error
     359:  00:C14B  C9                  		ret
     360:  00:C14C                      ;
     361:  00:C14C                      ;
     362:  00:C14C                      ;------------------------------------------------------------------------------
     363:  00:C14C                      ; FTP command
     364:  00:C14C                      ;
     365:  00:C14C                      ; Syntax:
     366:  00:C14C                      ;
     367:  00:C14C                      ;	:FTP
     368:  00:C14C                      ;	:FTP <ip> or <url>
     369:  00:C14C                      ;	:FTP DIR, :FTP CD etc etc
     370:  00:C14C                      ;
     371:  00:C14C  28 23               ftp:		jr	z,.noftp
     372:  00:C14E                      ;
     373:  00:C14E  CD 29 C1            		call	netstart	; Make sure the net is started
     374:  00:C151  C0                  		ret	nz		; Return if couldn't
     375:  00:C152                      ;		
     376:  00:C152  CD B5 CE            		call	status.start	; Start waiting indicator
     377:  00:C155                      ;
     378:  00:C155  21 C4 C3            		ld	hl,ftp_tab	; Find FTP command in command table
     379:  00:C158  CD A4 C0            		call	find		; HL=offset into command table
     380:  00:C15B  38 0F               		jr	c,.badcmd	; Go if not found
     381:  00:C15D                      ;
     382:  00:C15D  D5                  		push	de		; Save command ptr
     383:  00:C15E  11 E2 C3            		 ld	de,ftp_cmd_tab
     384:  00:C161  19                  		 add	hl,de
     385:  00:C162  D1                  		pop	de
     386:  00:C163  CD 8A C0            		call	jp_cmd
     387:  00:C166                      ;
     388:  00:C166  F5                  		push	af
     389:  00:C167  CD A9 CE            		call	status.stop	; Stop waiting indicator
     390:  00:C16A  F1                  		pop	af
     391:  00:C16B  C9                  		ret
     392:  00:C16C                      ;
     393:  00:C16C  3E 6C               .badcmd:	ld	a,exos.ERR_BADOPT
     394:  00:C16E  0E 00               		ld	c,0
     395:  00:C170  C9                  		ret
     396:  00:C171                      ;
     397:  00:C171  11 14 C6            .noftp:		ld	de,ftp_help_str
     398:  00:C174  CD 3D CE            		call	io.str
     399:  00:C177  AF                  		xor	a
     400:  00:C178  0E 00               .ret:		ld	c,0
     401:  00:C17A  C9                  		ret
     402:  00:C17B                      ;
     403:  00:C17B                      ftp_login:
     404:  00:C17B                      					; ftp pathname
     405:  00:C17B  21 46 F0            		ld	hl,vars.ftp.ip
     406:  00:C17E  D5                  		push	de
     407:  00:C17F  C5                  		push	bc
     408:  00:C180  CD 78 CF            		 call	util.get_ip
     409:  00:C183  C1                  		pop	bc
     410:  00:C184  D1                  		pop	de
     411:  00:C185                      ;
     412:  00:C185  3E 6D               		ld	a,exos.ERR_BADIP	; Error if bad IP address
     413:  00:C187  38 19               		jr	c,.ret
     414:  00:C189                      ;
     415:  00:C189  CD C8 C0            		call	skip		; DE->next arg
     416:  00:C18C                      ;
     417:  00:C18C  21 46 F0            		ld	hl,vars.ftp.ip
     418:  00:C18F  3E 01               		ld	a,1		; Always use socket 1
     419:  00:C191  D5                  		push	de
     420:  00:C192  CD 34 E7            		 call	ftp.open_control
     421:  00:C195  D1                  		pop	de
     422:  00:C196  3E 6B               		ld	a,exos.ERR_NOCON
     423:  00:C198  38 08               		jr	c,.ret
     424:  00:C19A                      ;
     425:  00:C19A  CD 6C E7            		call	ftp.login
     426:  00:C19D  3E 6B               		ld	a,exos.ERR_NOCON
     427:  00:C19F  38 01               		jr	c,.ret
     428:  00:C1A1                      
     429:  00:C1A1                      
     430:  00:C1A1  AF                  		xor	a
     431:  00:C1A2  F5                  .ret:		push	af
     432:  00:C1A3  B7                  		or	a
     433:  00:C1A4  3E 01               		ld	a,1
     434:  00:C1A6  C4 73 DF            		call	nz,tcp.close	; Close if we're returning an error
     435:  00:C1A9  F1                  		pop	af
     436:  00:C1AA  0E 00               		ld	c,0
     437:  00:C1AC  C9                  		ret
     438:  00:C1AD                      ;
     439:  00:C1AD                      ;
     440:  00:C1AD  3E 01               ftp_logout:	ld	a,1
     441:  00:C1AF  CD 39 E8            		call	ftp.logout
     442:  00:C1B2  3E 01               		ld	a,1
     443:  00:C1B4  CD 73 DF            		call	tcp.close
     444:  00:C1B7  AF                  		xor	a
     445:  00:C1B8  4F                  		ld	c,a
     446:  00:C1B9  C9                  		ret
     447:  00:C1BA                      ;
     448:  00:C1BA  3E 01               ftp_status:	ld	a,1
     449:  00:C1BC  CD 9F E8            		call	ftp.status
     450:  00:C1BF  0E 00               		ld	c,0
     451:  00:C1C1  C9                  		ret
     452:  00:C1C2                      ;
     453:  00:C1C2  3E 01               ftp_cd:		ld	a,1
     454:  00:C1C4  CD A7 E8            		call	ftp.chdir
     455:  00:C1C7  0E 00               		ld	c,0
     456:  00:C1C9  C9                  		ret
     457:  00:C1CA                      ;
     458:  00:C1CA                      ftp_md:
     459:  00:C1CA  3E 01               		ld	a,1
     460:  00:C1CC  CD D6 E8            		call	ftp.mkdir
     461:  00:C1CF  0E 00               		ld	c,0
     462:  00:C1D1  C9                  		ret
     463:  00:C1D2                      ;
     464:  00:C1D2                      ftp_rd:
     465:  00:C1D2  3E 01               		ld	a,1
     466:  00:C1D4  CD DE E8            		call	ftp.rmdir
     467:  00:C1D7  0E 00               		ld	c,0
     468:  00:C1D9  C9                  		ret
     469:  00:C1DA                      ;
     470:  00:C1DA                      ftp_del:
     471:  00:C1DA  3E 01               		ld	a,1
     472:  00:C1DC  CD E6 E8            		call	ftp.del
     473:  00:C1DF  0E 00               		ld	c,0
     474:  00:C1E1  C9                  		ret
     475:  00:C1E2                      ;
     476:  00:C1E2                      ;
     477:  00:C1E2                      ftp_ren:
     478:  00:C1E2  D5                  		push	de		; Save ->first arg
     479:  00:C1E3  C5                  		push	bc		; Save first arg length
     480:  00:C1E4  CD C8 C0            		 call	skip
     481:  00:C1E7  C1                  		pop	bc		; B=first arg length
     482:  00:C1E8  E1                  		pop	hl		; HL->first arg
     483:  00:C1E9  70                  		ld	(hl),b		; Set proper length
     484:  00:C1EA                      ;
     485:  00:C1EA  EB                  		ex	de,hl		; DE->first arg, HL->second arg
     486:  00:C1EB  3E 01               		ld	a,1
     487:  00:C1ED  CD EE E8            		call	ftp.ren
     488:  00:C1F0  0E 00               		ld	c,0
     489:  00:C1F2  C9                  		ret
     490:  00:C1F3                      ;
     491:  00:C1F3  3E 01               ftp_dir:	ld	a,1
     492:  00:C1F5  CD 42 E8            		call	ftp.dir
     493:  00:C1F8  0E 00               		ld	c,0
     494:  00:C1FA  C9                  		ret
     495:  00:C1FB                      ;
     496:  00:C1FB                      ;
     497:  00:C1FB                      ;------------------------------------------------------------------------------
     498:  00:C1FB                      ; PING command
     499:  00:C1FB                      ;
     500:  00:C1FB                      ; eg. :NET PING 192.168.1.64
     501:  00:C1FB                      ;
     502:  00:C1FB                      ping:
     503:  00:C1FB  28 2A               		jr	z,.noping	; No args - just print help text
     504:  00:C1FD                      ;
     505:  00:C1FD  CD 29 C1            		call	netstart	; Make sure the network is started
     506:  00:C200  C0                  		ret	nz		; Ret if error starting
     507:  00:C201                      ;
     508:  00:C201  C5                  		push	bc
     509:  00:C202  D5                  		push	de
     510:  00:C203  21 3C F0            		 ld	hl,vars.ping.ip
     511:  00:C206  CD 78 CF            		 call	util.get_ip	; Read IP address from command line
     512:  00:C209  D1                  		pop	de
     513:  00:C20A  C1                  		pop	bc
     514:  00:C20B                      ;
     515:  00:C20B  3E 6D               		ld	a,exos.ERR_BADIP
     516:  00:C20D  38 15               		jr	c,.ret		; Go if invalid
     517:  00:C20F                      ;
     518:  00:C20F  CD C8 C0            		call	skip		; Make sure nothing following
     519:  00:C212  3E 6D               		ld	a,exos.ERR_BADIP
     520:  00:C214  20 0E               		jr	nz,.ret		; Go if there was
     521:  00:C216                      ;
     522:  00:C216  21 3C F0            		ld	hl,vars.ping.ip
     523:  00:C219  CD 92 E4            		call	ping.init	; Do ping
     524:  00:C21C  9F                  		sbc	a,a		; A=0 if NC (& still NC)
     525:  00:C21D  30 05               		jr	nc,.ret
     526:  00:C21F                      ;
     527:  00:C21F  3E 6E               		ld	a,exos.ERR_NONET
     528:  00:C221  CD A2 C9            		call	exos.check_stop
     529:  00:C224  0E 00               .ret:		ld	c,0
     530:  00:C226  C9                  		ret
     531:  00:C227                      ;
     532:  00:C227  11 FA C7            .noping:	ld	de,ping_help_str
     533:  00:C22A  CD 3D CE            		call	io.str
     534:  00:C22D  AF                  		xor	a
     535:  00:C22E  4F                  		ld	c,a
     536:  00:C22F  C9                  		ret
     537:  00:C230                      ;
     538:  00:C230                      ;
     539:  00:C230                      ;------------------------------------------------------------------------------
     540:  00:C230                      ; TRACE command
     541:  00:C230                      ;
     542:  00:C230                      ; Use: TRACE [ON|RAW|OFF]* 
     543:  00:C230                      ;
     544:  00:C230                      ; eg. :NET TRACE		- Same as :NET TRACE ON
     545:  00:C230                      ;     :NET TRACE ON		- Turns on protocol and socket tracing
     546:  00:C230                      ;     :NET TRACE RAW		- As n:TRACE ON but additionally raw bytes
     547:  00:C230                      ;     :NET TRACE OFF		- All tracing off
     548:  00:C230                      ;
     549:  00:C230                      ; So it is not possible to just have raw bytes.
     550:  00:C230                      ;
     551:  00:C230                      ; Currently all the EPNET code allows each protocol to be enabled separately,
     552:  00:C230                      ; but this is over complicated for the user command so we just have ON and RAW.
     553:  00:C230                      ;
     554:  00:C230  3E 7E               trace:		ld	a,vars.trace.all_mask; ON (all but raw & diag)
     555:  00:C232  28 0F               		jr	z,.noarg	; Default to ON if no args
     556:  00:C234                      ;
     557:  00:C234  21 4E C2            		ld	hl,trace_str_tab; Find trace command in command table
     558:  00:C237  CD A4 C0            		call	find		; HL=offset into command table
     559:  00:C23A  38 0D               		jr	c,.badcmd	; Go if not found
     560:  00:C23C                      ;
     561:  00:C23C  11 56 C2            		ld	de,trace_value_tab
     562:  00:C23F  CB 3D               		srl	l		; /2 cos 1-byte table
     563:  00:C241  19                  		add	hl,de
     564:  00:C242  7E                  		ld	a,(hl)
     565:  00:C243  32 00 F0            .noarg:		ld	(vars.trace),a
     566:  00:C246  AF                  		xor	a		; No error
     567:  00:C247  4F                  		ld	c,a		; Command recognized
     568:  00:C248  C9                  		ret
     569:  00:C249                      ;
     570:  00:C249  3E 6C               .badcmd:	ld	a,exos.ERR_BADOPT
     571:  00:C24B  0E 00               		ld	c,0
     572:  00:C24D  C9                  		ret
     573:  00:C24E                      ;
     574:  00:C24E                      ;
     575:  00:C24E  59 C2               trace_str_tab:	dw	 on_str		; :TRACE <opt>
     576:  00:C250  5D C2               		dw	off_str
     577:  00:C252  62 C2               		dw	raw_str
     578:  00:C254  00 00               		dw	0
     579:  00:C256                      ;
     580:  00:C256  7F                  trace_value_tab:db	low ~vars.trace.raw_mask; ON => all but raw bit on
     581:  00:C257  00                  		db	0			; 0  => all off
     582:  00:C258  FF                  		db	0ffh			; RAW=> all on
     583:  00:C259                      ;
     584:  00:C259                      ;
     585:  00:C259                      ; These need length bytes (for command table) AND terminating nulls (for
     586:  00:C259                      ; printing)!
     587:  00:C259                      ;
     588:  00:C259  02 4F 4E 00         on_str:		db	2,"ON",0
     589:  00:C25D  03 4F 46 46 00      off_str:	db	3,"OFF",0
     590:  00:C262  03 52 41 57 00      raw_str:	db	3,"RAW",0
     591:  00:C267                      ;
     592:  00:C267                      ;
     593:  00:C267                      ;------------------------------------------------------------------------------
     594:  00:C267                      ; STATUS command
     595:  00:C267                      ;
     596:  00:C267                      ; The NET STATUS command. Prints out current IP address etc
     597:  00:C267                      ;
     598:  00:C267  28 16               status:		jr	z,.doit
     599:  00:C269                      ;
     600:  00:C269  21 25 C3            		ld	hl,.surprise_str
     601:  00:C26C  CD 8F C0            		call	compare
     602:  00:C26F  20 09               		jr	nz,.badopt
     603:  00:C271                      ;
     604:  00:C271  11 10 C3            		ld	de,.easteregg_str
     605:  00:C274  CD 3D CE            		call	io.str
     606:  00:C277                      ;
     607:  00:C277  AF                  .ret:		xor	a
     608:  00:C278  4F                  		ld	c,a
     609:  00:C279  C9                  		ret
     610:  00:C27A                      ;
     611:  00:C27A  3E 6C               .badopt:	ld	a,exos.ERR_BADOPT
     612:  00:C27C  0E 00               		ld	c,0
     613:  00:C27E  C9                  		ret
     614:  00:C27F                      
     615:  00:C27F  CD 29 C1            .doit:		call	netstart	; Make sure EPNET has started
     616:  00:C282  C0                  		ret	nz		; Return if error starting
     617:  00:C283                      ;
     618:  00:C283  CD C6 D5            		call	wiz.get_MAC	; Print MAC address
     619:  00:C286  11 28 C3            		ld	de,.mac_str
     620:  00:C289  CD 3D CE            		call	io.str
     621:  00:C28C  CD 82 CD            		call	io.mac
     622:  00:C28F  CD 28 CE            		call	io.crlf
     623:  00:C292                      ;
     624:  00:C292  CD DD D5            		call	wiz.get_ip	; Print IP address
     625:  00:C295  11 2E C3            		ld	de,.ip_str
     626:  00:C298  CD 1D CE            		call	io.ipcrlf
     627:  00:C29B                      ;
     628:  00:C29B  CD F4 D5            		call	wiz.get_subnet	; Print subnet mask
     629:  00:C29E  11 33 C3            		ld	de,.subnet_str
     630:  00:C2A1  CD 1D CE            		call	io.ipcrlf
     631:  00:C2A4                      ;
     632:  00:C2A4  CD 34 D6            		call	wiz.get_gateway	; Print gateway
     633:  00:C2A7  11 3C C3            		ld	de,.gateway_str
     634:  00:C2AA  CD 1D CE            		call	io.ipcrlf
     635:  00:C2AD                      ;
     636:  00:C2AD                      		; Print each socket status
     637:  00:C2AD  11 45 C3            		ld	de,.heading
     638:  00:C2B0  CD 3D CE            		call	io.str
     639:  00:C2B3  AF                  		xor	a		; Start with socket 0
     640:  00:C2B4  F5                  .loop:		push	af		; Save socket number
     641:  00:C2B5  CD AE CD            		 call	io.short	; Print socket number
     642:  00:C2B8  CD 31 CE            		 call	io.space
     643:  00:C2BB  F1                  		pop	af		; A=socket number
     644:  00:C2BC                      ;
     645:  00:C2BC  F5                  		push	af		; Save socket number
     646:  00:C2BD  CD B6 DA            		 call	socket.status	; HL=Sn_SSR value
     647:  00:C2C0  4D                  		 ld	c,l		; Save status
     648:  00:C2C1  7D                  		 ld	a,l		; A=Sn_SSR value, high byte ignored
     649:  00:C2C2  FE 00               		 cp	w5300.Sn_SSR_CLOSED
     650:  00:C2C4  28 0B               		 jr	z,.doneowner	; Don't print owner if closed
     651:  00:C2C6                      ;
     652:  00:C2C6  F1                  		pop	af		; A=socket number
     653:  00:C2C7  F5                  		push	af		; Save socket number
     654:  00:C2C8  C5                  		 push	bc		; Save status in C
     655:  00:C2C9  CD CD DB            		  call	socket.get_owner; HL->owner string
     656:  00:C2CC  EB                  		  ex	de,hl		; DE->owner
     657:  00:C2CD  CD 3D CE            		  call	io.str		; Print owner
     658:  00:C2D0  C1                  		 pop	bc		; C=socket status
     659:  00:C2D1                      ;
     660:  00:C2D1  CD 35 CE            .doneowner:	 call	io.tab
     661:  00:C2D4  F1                  		pop	af		; A=socket number
     662:  00:C2D5                      ;
     663:  00:C2D5  F5                  		push	af		; Save socket number
     664:  00:C2D6  79                  		 ld	a,c		; A=status value
     665:  00:C2D7  F5                  		 push	af		; Save status value
     666:  00:C2D8  CD C7 DA            		  call	socket.status_str	; HL->descriptive string
     667:  00:C2DB  38 05               		  jr	c,.nostr	; Go with Cy if not found
     668:  00:C2DD                      ;
     669:  00:C2DD  EB                  		  ex	de,hl		; DE->string
     670:  00:C2DE  CD 3D CE            		  call	io.str		; Print status description
     671:  00:C2E1  B7                  		  or	a		; NC
     672:  00:C2E2  DC ED CD            .nostr:		  call	c,io.byte	; No string so print number
     673:  00:C2E5  F1                  		 pop	af		; Get status value
     674:  00:C2E6  FE 17               		 cp	w5300.Sn_SSR_ESTAB
     675:  00:C2E8  20 1A               		 jr	nz,.doneone	; Go if not TCP ESTABLISHED state
     676:  00:C2EA                      ;
     677:  00:C2EA  F1                  		pop	af		; A=socket number
     678:  00:C2EB  F5                  		push	af		; Save socket number
     679:  00:C2EC  21 11 F0            		 ld	hl,vars.command.ip	; HL->buffer for IP
     680:  00:C2EF  E5                  		 push	hl		; Save->buffer for IP
     681:  00:C2F0  CD E8 D9            		  call	socket.read_DIPR	; Read IP
     682:  00:C2F3  CD 07 DA            		  call	socket.read_DPORTR	; HL=DPORTR
     683:  00:C2F6  4D                  		  ld	c,l
     684:  00:C2F7  44                  		  ld	b,h		; BC=port number
     685:  00:C2F8  E1                  		 pop	hl		; HL->ip address
     686:  00:C2F9                      ;
     687:  00:C2F9  C5                  		 push	bc		; Save port
     688:  00:C2FA  11 67 C3            		  ld	de,.to_str	; Print " to "
     689:  00:C2FD  CD 3D CE            		  call	io.str
     690:  00:C300  C1                  		 pop	bc		; BC=port
     691:  00:C301  CD A2 CD            		 call	io.ip_port	; Print IP and port
     692:  00:C304  CD 28 CE            .doneone:	 call	io.crlf
     693:  00:C307  F1                  		pop	af		; A=socket number
     694:  00:C308  3C                  		inc	a		; Next socket
     695:  00:C309  FE 08               		cp	wiz.SOCKETS	; Done all?
     696:  00:C30B  38 A7               		jr	c,.loop		; Do next if not
     697:  00:C30D                      ;
     698:  00:C30D  AF                  		xor	a		; No error
     699:  00:C30E  4F                  		ld	c,a		; Command recognised
     700:  00:C30F  C9                  		ret
     701:  00:C310                      ;
     702:  00:C310                      .easteregg_str:	db	"Written by BT 2015",CR,LF,0
     702:  00:C310  57 72 69 74 74 65 6E 20 62 79 20 42 54 20 32 30 
     702:  00:C320  31 35 0D 0A 00 
     703:  00:C325                      ;
     704:  00:C325  02 34 32            .surprise_str:	db	2,"42"
     705:  00:C328                      ;
     706:  00:C328  4D 41 43 3A 09 00   .mac_str:	db	"MAC:\t",0
     707:  00:C32E  49 50 3A 09 00      .ip_str:	db	"IP:\t",0
     708:  00:C333                      .subnet_str:	db	"Subnet:\t",0
     708:  00:C333  53 75 62 6E 65 74 3A 09 00 
     709:  00:C33C                      .gateway_str:	db	"Gateway:",0
     709:  00:C33C  47 61 74 65 77 61 79 3A 00 
     710:  00:C345                      ;
     711:  00:C345  0D 0A               .heading:	db	CR,LF
     712:  00:C347                      		db	"S OWNER\tSTATE",CR,LF
     712:  00:C347  53 20 4F 57 4E 45 52 09 53 54 41 54 45 0D 0A 
     713:  00:C356                      		db	"--------------",CR,LF
     713:  00:C356  2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 0D 0A 
     714:  00:C366  00                  		db	0
     715:  00:C367                      ;
     716:  00:C367  20 74 6F 20 00      .to_str:	db	" to ",0
     717:  00:C36C                      ;
     718:  00:C36C                      ;
     719:  00:C36C                      ;------------------------------------------------------------------------------
     720:  00:C36C                      ; TIME command
     721:  00:C36C                      ;
     722:  00:C36C                      ; The NET TIME command. Gets the time and date from the network
     723:  00:C36C                      ;
     724:  00:C36C  CD 29 C1            time:		call	netstart
     725:  00:C36F  C0                  		ret	nz
     726:  00:C370                      ;		
     727:  00:C370  CD 05 E6            		call	ntp.init
     728:  00:C373  9F                  		sbc	a,a		; A=0 if NC (& still NC)
     729:  00:C374  30 05               		jr	nc,.ret
     730:  00:C376                      ;
     731:  00:C376  3E 67               		ld	a,exos.ERR_NOTIME
     732:  00:C378  CD A2 C9            		call	exos.check_stop
     733:  00:C37B                      ;
     734:  00:C37B  0E 00               .ret:		ld	c,0		; Command recognised
     735:  00:C37D  C9                  		ret
     736:  00:C37E                      ;
     737:  00:C37E                      ;
     738:  00:C37E                      ;------------------------------------------------------------------------------
     739:  00:C37E                      ; main commands - string table, help string table and jump table in same order!
     740:  00:C37E                      ;
     741:  00:C37E  65 C9               main_tab:	dw	 net_str
     742:  00:C380  69 C9               		dw	 ftp_str
     743:  00:C382  78 C9               		dw	ping_str
     744:  00:C384  00 00               		dw	0
     745:  00:C386                      ;
     746:  00:C386  52 C4               main_help_tab:	dw	 net_help_str	; Same order as above
     747:  00:C388  14 C6               		dw	 ftp_help_str
     748:  00:C38A  FA C7               		dw	ping_help_str
     749:  00:C38C                      ;
     750:  00:C38C  F4 C0               main_cmd_tab:	dw	net		; Same order as above
     751:  00:C38E  4C C1               		dw	ftp
     752:  00:C390  FB C1               		dw	ping
     753:  00:C392                      ;
     754:  00:C392                      ;
     755:  00:C392                      ;------------------------------------------------------------------------------
     756:  00:C392                      ; NET sub-commands - string table, help string table and jump table in same order!
     757:  00:C392                      ;
     758:  00:C392  72 C9               net_tab:	dw	 start_str
     759:  00:C394  6D C9               		dw	  diag_str
     760:  00:C396  69 C9               		dw	   ftp_str
     761:  00:C398  7D C9               		dw	 trace_str
     762:  00:C39A  78 C9               		dw	  ping_str
     763:  00:C39C  83 C9               		dw	status_str
     764:  00:C39E  8A C9               		dw	  time_str
     765:  00:C3A0  8F C9               		dw	  help_str
     766:  00:C3A2  00 00               		dw	0
     767:  00:C3A4                      ;
     768:  00:C3A4  CB C5               net_help_tab:	dw	 start_help_str	; Same order as above
     769:  00:C3A6  8A C5               		dw	  diag_help_str
     770:  00:C3A8  14 C6               		dw	   ftp_help_str
     771:  00:C3AA  46 C8               		dw	 trace_help_str
     772:  00:C3AC  FA C7               		dw	  ping_help_str
     773:  00:C3AE  F3 C8               		dw	status_help_str
     774:  00:C3B0  1E C9               		dw	  time_help_str
     775:  00:C3B2  52 C4               		dw	  help_help_str
     776:  00:C3B4                      ;
     777:  00:C3B4  25 C1               net_cmd_tab:	dw	net_start	; Same order as above
     778:  00:C3B6  15 C1               		dw	net_diag
     779:  00:C3B8  4C C1               		dw	ftp
     780:  00:C3BA  30 C2               		dw	trace
     781:  00:C3BC  FB C1               		dw	ping
     782:  00:C3BE  67 C2               		dw	status
     783:  00:C3C0  6C C3               		dw	time
     784:  00:C3C2  60 C0               		dw	nethelp
     785:  00:C3C4                      ;
     786:  00:C3C4                      ;
     787:  00:C3C4                      ;------------------------------------------------------------------------------
     788:  00:C3C4                      ; FTP sub-commands - string table and jump table, in same order!
     789:  00:C3C4                      ;
     790:  00:C3C4  FE C3               ftp_tab:	dw	login_str
     791:  00:C3C6  04 C4               		dw	logout_str
     792:  00:C3C8  83 C9               		dw	status_str
     793:  00:C3CA  0B C4               		dw	dir_str
     794:  00:C3CC  0F C4               		dw	cd_str
     795:  00:C3CE  12 C4               		dw	del_str
     796:  00:C3D0  16 C4               		dw	era_str
     797:  00:C3D2  1A C4               		dw	erase_str
     798:  00:C3D4  20 C4               		dw	ren_str
     799:  00:C3D6  24 C4               		dw	rename_str
     800:  00:C3D8  2B C4               		dw	md_str
     801:  00:C3DA  2E C4               		dw	mkdir_str
     802:  00:C3DC  34 C4               		dw	rd_str
     803:  00:C3DE  37 C4               		dw	rmdir_str
     804:  00:C3E0  00 00               		dw	0
     805:  00:C3E2                      ;
     806:  00:C3E2  7B C1               ftp_cmd_tab:	dw	ftp_login	; :FTP LOGIN
     807:  00:C3E4  AD C1               		dw	ftp_logout	; :FTP LOGOUT
     808:  00:C3E6  BA C1               		dw	ftp_status	; :FTP STATUS
     809:  00:C3E8  F3 C1               		dw	ftp_dir		; :FTP DIR
     810:  00:C3EA  C2 C1               		dw	ftp_cd		; :FTP CD
     811:  00:C3EC  DA C1               		dw	ftp_del		; :FTP DEL
     812:  00:C3EE  DA C1               		dw	ftp_del		; :FTP ERA
     813:  00:C3F0  DA C1               		dw	ftp_del		; :FTP_ERASE
     814:  00:C3F2  E2 C1               		dw	ftp_ren		; :FTP REN
     815:  00:C3F4  E2 C1               		dw	ftp_ren		; :FTP RENAME
     816:  00:C3F6  CA C1               		dw	ftp_md		; :FTP MD
     817:  00:C3F8  CA C1               		dw	ftp_md		; :FTP MKDIR
     818:  00:C3FA  D2 C1               		dw	ftp_rd		; :FTP RD
     819:  00:C3FC  D2 C1               		dw	ftp_rd		; :FTP RMDIR
     820:  00:C3FE                      ;
     821:  00:C3FE                      ;
     822:  00:C3FE                      ;
     823:  00:C3FE  05 4C 4F 47 49 4E   login_str:	db	5,"LOGIN"
     824:  00:C404                      logout_str:	db	6,"LOGOUT"
     824:  00:C404  06 4C 4F 47 4F 55 54 
     825:  00:C40B  03 44 49 52         dir_str:	db	3,"DIR"
     826:  00:C40F  02 43 44            cd_str:		db	2,"CD"
     827:  00:C412  03 44 45 4C         del_str:	db	3,"DEL"
     828:  00:C416  03 45 52 41         era_str:	db	3,"ERA"
     829:  00:C41A  05 45 52 41 53 45   erase_str:	db	5,"ERASE"
     830:  00:C420  03 52 45 4E         ren_str:	db	3,"REN"
     831:  00:C424                      rename_str:	db	6,"RENAME"
     831:  00:C424  06 52 45 4E 41 4D 45 
     832:  00:C42B  02 4D 44            md_str:		db	2,"MD"
     833:  00:C42E  05 4D 4B 44 49 52   mkdir_str:	db	5,"MKDIR"
     834:  00:C434  02 52 44            rd_str:		db	2,"RD"
     835:  00:C437  05 52 4D 44 49 52   rmdir_str:	db	5,"RMDIR"
     836:  00:C43D                      ;
     837:  00:C43D                      ;------------------------------------------------------------------------------
     838:  00:C43D                      ; HELP text
     839:  00:C43D                      ;
     840:  00:C43D                      version_str:	db	"NET   version "
     840:  00:C43D  4E 45 54 20 20 20 76 65 72 73 69 6F 6E 20 
     841:  00:C44B  30 2E 31 31 0D 0A   		db	version.major, ".", version.minor, version.revision,CR,LF
     842:  00:C451  00                  		db	0
     843:  00:C452                      ;
     844:  00:C452                      ; 40 col screen limit:	 |........|.........|.........|.........|
     845:  00:C452                      ;
     846:  00:C452                      help_help_str:
     847:  00:C452                      net_help_str	db	"Available :NET commands:",CR,LF
     847:  00:C452  41 76 61 69 6C 61 62 6C 65 20 3A 4E 45 54 20 63 
     847:  00:C462  6F 6D 6D 61 6E 64 73 3A 0D 0A 
     848:  00:C46C  0D 0A               		db	CR,LF
     849:  00:C46E                      		db	"NET START  starts the network", CR,LF
     849:  00:C46E  4E 45 54 20 53 54 41 52 54 20 20 73 74 61 72 74 
     849:  00:C47E  73 20 74 68 65 20 6E 65 74 77 6F 72 6B 0D 0A 
     850:  00:C48D                      		db	"NET DIAG   helps diagnose problems",CR,LF
     850:  00:C48D  4E 45 54 20 44 49 41 47 20 20 20 68 65 6C 70 73 
     850:  00:C49D  20 64 69 61 67 6E 6F 73 65 20 70 72 6F 62 6C 65 
     850:  00:C4AD  6D 73 0D 0A 
     851:  00:C4B1                      		db	"NET FTP    FTP commands",CR,LF
     851:  00:C4B1  4E 45 54 20 46 54 50 20 20 20 20 46 54 50 20 63 
     851:  00:C4C1  6F 6D 6D 61 6E 64 73 0D 0A 
     852:  00:C4CA                      		db	"NET PING   tests network communication",CR,LF
     852:  00:C4CA  4E 45 54 20 50 49 4E 47 20 20 20 74 65 73 74 73 
     852:  00:C4DA  20 6E 65 74 77 6F 72 6B 20 63 6F 6D 6D 75 6E 69 
     852:  00:C4EA  63 61 74 69 6F 6E 0D 0A 
     853:  00:C4F2                      		db	"NET TRACE  sets diagnostic tracing",CR,LF
     853:  00:C4F2  4E 45 54 20 54 52 41 43 45 20 20 73 65 74 73 20 
     853:  00:C502  64 69 61 67 6E 6F 73 74 69 63 20 74 72 61 63 69 
     853:  00:C512  6E 67 0D 0A 
     854:  00:C516                      		db	"NET STATUS shows network status",CR,LF
     854:  00:C516  4E 45 54 20 53 54 41 54 55 53 20 73 68 6F 77 73 
     854:  00:C526  20 6E 65 74 77 6F 72 6B 20 73 74 61 74 75 73 0D 
     854:  00:C536  0A 
     855:  00:C537                      		db	"NET TIME   sets the system time & date",CR,LF
     855:  00:C537  4E 45 54 20 54 49 4D 45 20 20 20 73 65 74 73 20 
     855:  00:C547  74 68 65 20 73 79 73 74 65 6D 20 74 69 6D 65 20 
     855:  00:C557  26 20 64 61 74 65 0D 0A 
     856:  00:C55F  0D 0A               		db	CR,LF
     857:  00:C561                      		db	"Type :HELP NET <cmd> for specific help",CR,LF
     857:  00:C561  54 79 70 65 20 3A 48 45 4C 50 20 4E 45 54 20 3C 
     857:  00:C571  63 6D 64 3E 20 66 6F 72 20 73 70 65 63 69 66 69 
     857:  00:C581  63 20 68 65 6C 70 0D 0A 
     858:  00:C589  00                  		db	0
     859:  00:C58A                      ;
     860:  00:C58A                      diag_help_str	db	"NET DIAG is the same as NET START "
     860:  00:C58A  4E 45 54 20 44 49 41 47 20 69 73 20 74 68 65 20 
     860:  00:C59A  73 61 6D 65 20 61 73 20 4E 45 54 20 53 54 41 52 
     860:  00:C5AA  54 20 
     861:  00:C5AC                      		db	"but with diagnostic messages",CR,LF,0
     861:  00:C5AC  62 75 74 20 77 69 74 68 20 64 69 61 67 6E 6F 73 
     861:  00:C5BC  74 69 63 20 6D 65 73 73 61 67 65 73 0D 0A 00 
     862:  00:C5CB                      ;
     863:  00:C5CB                      start_help_str	db	"NET START starts the network and ",CR,LF
     863:  00:C5CB  4E 45 54 20 53 54 41 52 54 20 73 74 61 72 74 73 
     863:  00:C5DB  20 74 68 65 20 6E 65 74 77 6F 72 6B 20 61 6E 64 
     863:  00:C5EB  20 0D 0A 
     864:  00:C5EE                      		db	"gets the IP address etc. using DHCP",CR,LF
     864:  00:C5EE  67 65 74 73 20 74 68 65 20 49 50 20 61 64 64 72 
     864:  00:C5FE  65 73 73 20 65 74 63 2E 20 75 73 69 6E 67 20 44 
     864:  00:C60E  48 43 50 0D 0A 
     865:  00:C613  00                  		db	0
     866:  00:C614                      ;
     867:  00:C614                      ftp_help_str	db	"NET FTP connects to a remote FTP server "
     867:  00:C614  4E 45 54 20 46 54 50 20 63 6F 6E 6E 65 63 74 73 
     867:  00:C624  20 74 6F 20 61 20 72 65 6D 6F 74 65 20 46 54 50 
     867:  00:C634  20 73 65 72 76 65 72 20 
     868:  00:C63C                      		db	"and provides various commands:",CR,LF
     868:  00:C63C  61 6E 64 20 70 72 6F 76 69 64 65 73 20 76 61 72 
     868:  00:C64C  69 6F 75 73 20 63 6F 6D 6D 61 6E 64 73 3A 0D 0A 
     869:  00:C65C  0D 0A               		db	CR,LF
     870:  00:C65E                      		db	"FTP LOGIN <ip> connects to a server",CR,LF
     870:  00:C65E  46 54 50 20 4C 4F 47 49 4E 20 3C 69 70 3E 20 63 
     870:  00:C66E  6F 6E 6E 65 63 74 73 20 74 6F 20 61 20 73 65 72 
     870:  00:C67E  76 65 72 0D 0A 
     871:  00:C683                      		db	"FTP LOGOUT disconnects from a server",CR,LF
     871:  00:C683  46 54 50 20 4C 4F 47 4F 55 54 20 64 69 73 63 6F 
     871:  00:C693  6E 6E 65 63 74 73 20 66 72 6F 6D 20 61 20 73 65 
     871:  00:C6A3  72 76 65 72 0D 0A 
     872:  00:C6A9                      		db	"FTP STATUS displays server information",CR,LF
     872:  00:C6A9  46 54 50 20 53 54 41 54 55 53 20 64 69 73 70 6C 
     872:  00:C6B9  61 79 73 20 73 65 72 76 65 72 20 69 6E 66 6F 72 
     872:  00:C6C9  6D 61 74 69 6F 6E 0D 0A 
     873:  00:C6D1                      		db	"FTP DIR    lists remote directory",CR,LF
     873:  00:C6D1  46 54 50 20 44 49 52 20 20 20 20 6C 69 73 74 73 
     873:  00:C6E1  20 72 65 6D 6F 74 65 20 64 69 72 65 63 74 6F 72 
     873:  00:C6F1  79 0D 0A 
     874:  00:C6F4                      		db	"FTP CD     changes remote directory",CR,LF
     874:  00:C6F4  46 54 50 20 43 44 20 20 20 20 20 63 68 61 6E 67 
     874:  00:C704  65 73 20 72 65 6D 6F 74 65 20 64 69 72 65 63 74 
     874:  00:C714  6F 72 79 0D 0A 
     875:  00:C719                      		db	"FTP DEL    deletes remote files",CR,LF
     875:  00:C719  46 54 50 20 44 45 4C 20 20 20 20 64 65 6C 65 74 
     875:  00:C729  65 73 20 72 65 6D 6F 74 65 20 66 69 6C 65 73 0D 
     875:  00:C739  0A 
     876:  00:C73A                      		db	"FTP REN    renames remote files",CR,LF
     876:  00:C73A  46 54 50 20 52 45 4E 20 20 20 20 72 65 6E 61 6D 
     876:  00:C74A  65 73 20 72 65 6D 6F 74 65 20 66 69 6C 65 73 0D 
     876:  00:C75A  0A 
     877:  00:C75B                      		db	"FTP MD     makes dremote directory",CR,LF
     877:  00:C75B  46 54 50 20 4D 44 20 20 20 20 20 6D 61 6B 65 73 
     877:  00:C76B  20 64 72 65 6D 6F 74 65 20 64 69 72 65 63 74 6F 
     877:  00:C77B  72 79 0D 0A 
     878:  00:C77F                      		db	"FTP RD     removes remote directory",CR,LF
     878:  00:C77F  46 54 50 20 52 44 20 20 20 20 20 72 65 6D 6F 76 
     878:  00:C78F  65 73 20 72 65 6D 6F 74 65 20 64 69 72 65 63 74 
     878:  00:C79F  6F 72 79 0D 0A 
     879:  00:C7A4  0D 0A               		db	CR,LF
     880:  00:C7A6                      		db	"After using :FTP LOGIN the EXOS "
     880:  00:C7A6  41 66 74 65 72 20 75 73 69 6E 67 20 3A 46 54 50 
     880:  00:C7B6  20 4C 4F 47 49 4E 20 74 68 65 20 45 58 4F 53 20 
     881:  00:C7C6                      		db	"FTP: device can be used,",CR,LF
     881:  00:C7C6  46 54 50 3A 20 64 65 76 69 63 65 20 63 61 6E 20 
     881:  00:C7D6  62 65 20 75 73 65 64 2C 0D 0A 
     882:  00:C7E0                      		db	"eg. LOAD \"ftp:test.bas\"",CR,LF 
     882:  00:C7E0  65 67 2E 20 4C 4F 41 44 20 22 66 74 70 3A 74 65 
     882:  00:C7F0  73 74 2E 62 61 73 22 0D 0A 
     883:  00:C7F9  00                  		db	0
     884:  00:C7FA                      ;
     885:  00:C7FA                      ping_help_str	db	"NET PING <ip|url> tests communication "
     885:  00:C7FA  4E 45 54 20 50 49 4E 47 20 3C 69 70 7C 75 72 6C 
     885:  00:C80A  3E 20 74 65 73 74 73 20 63 6F 6D 6D 75 6E 69 63 
     885:  00:C81A  61 74 69 6F 6E 20 
     886:  00:C820                      		db	"with other computers on the network",CR,LF
     886:  00:C820  77 69 74 68 20 6F 74 68 65 72 20 63 6F 6D 70 75 
     886:  00:C830  74 65 72 73 20 6F 6E 20 74 68 65 20 6E 65 74 77 
     886:  00:C840  6F 72 6B 0D 0A 
     887:  00:C845  00                  		db	0
     888:  00:C846                      ;
     889:  00:C846                      trace_help_str	db	"NET TRACE ON|RAW|OFF sets diagnostic "
     889:  00:C846  4E 45 54 20 54 52 41 43 45 20 4F 4E 7C 52 41 57 
     889:  00:C856  7C 4F 46 46 20 73 65 74 73 20 64 69 61 67 6E 6F 
     889:  00:C866  73 74 69 63 20 
     890:  00:C86B                      		db	"network trace options:",CR,LF
     890:  00:C86B  6E 65 74 77 6F 72 6B 20 74 72 61 63 65 20 6F 70 
     890:  00:C87B  74 69 6F 6E 73 3A 0D 0A 
     891:  00:C883  0D 0A               		db	CR,LF
     892:  00:C885                      		db	"NET TRACE ON  Traces protocols",CR,LF
     892:  00:C885  4E 45 54 20 54 52 41 43 45 20 4F 4E 20 20 54 72 
     892:  00:C895  61 63 65 73 20 70 72 6F 74 6F 63 6F 6C 73 0D 0A 
     893:  00:C8A5                      		db	"NET TRACE RAW As ON but also raw bytes",CR,LF
     893:  00:C8A5  4E 45 54 20 54 52 41 43 45 20 52 41 57 20 41 73 
     893:  00:C8B5  20 4F 4E 20 62 75 74 20 61 6C 73 6F 20 72 61 77 
     893:  00:C8C5  20 62 79 74 65 73 0D 0A 
     894:  00:C8CD                      		db	"NET TRACE OFF Turns off all tracing",CR,LF
     894:  00:C8CD  4E 45 54 20 54 52 41 43 45 20 4F 46 46 20 54 75 
     894:  00:C8DD  72 6E 73 20 6F 66 66 20 61 6C 6C 20 74 72 61 63 
     894:  00:C8ED  69 6E 67 0D 0A 
     895:  00:C8F2  00                  		db	0
     896:  00:C8F3                      ;
     897:  00:C8F3                      status_help_str:db	"NET STATUS shows current IP address etc.",CR,LF
     897:  00:C8F3  4E 45 54 20 53 54 41 54 55 53 20 73 68 6F 77 73 
     897:  00:C903  20 63 75 72 72 65 6E 74 20 49 50 20 61 64 64 72 
     897:  00:C913  65 73 73 20 65 74 63 2E 0D 0A 
     898:  00:C91D  00                  		db	0
     899:  00:C91E                      ;
     900:  00:C91E                      time_help_str:	db	"NET TIME updates the system time and "
     900:  00:C91E  4E 45 54 20 54 49 4D 45 20 75 70 64 61 74 65 73 
     900:  00:C92E  20 74 68 65 20 73 79 73 74 65 6D 20 74 69 6D 65 
     900:  00:C93E  20 61 6E 64 20 
     901:  00:C943                      		db	"date from the network using NTP",CR,LF
     901:  00:C943  64 61 74 65 20 66 72 6F 6D 20 74 68 65 20 6E 65 
     901:  00:C953  74 77 6F 72 6B 20 75 73 69 6E 67 20 4E 54 50 0D 
     901:  00:C963  0A 
     902:  00:C964  00                  		db	0
     903:  00:C965                      ;
     904:  00:C965  03 4E 45 54         net_str		db	3,"NET"
     905:  00:C969  (00:0003)           net_str_len	equ	$-net_str-1
     906:  00:C969  03 46 54 50         ftp_str		db	3,"FTP"
     907:  00:C96D  04 44 49 41 47      diag_str:	db	4,"DIAG"
     908:  00:C972  05 53 54 41 52 54   start_str:	db	5,"START"
     909:  00:C978  04 50 49 4E 47      ping_str:	db	4,"PING"
     910:  00:C97D  05 54 52 41 43 45   trace_str:	db	5,"TRACE"
     911:  00:C983                      status_str:	db	6,"STATUS"
     911:  00:C983  06 53 54 41 54 55 53 
     912:  00:C98A  04 54 49 4D 45      time_str:	db	4,"TIME"
     913:  00:C98F  04 48 45 4C 50      help_str:	db	4,"HELP"
     914:  00:C994                      ;
     915:  00:C994                      ;
     916:  00:C994                      ;
     917:  00:C994                      		endmodule
      93.  00:C994                      ;
      94.  00:C994                      	include	exos.asm
       1:  00:C994                      ; EXOS
       2:  00:C994                      ;
       3:  00:C994                      ; This module contains EXOS-specific things
       4:  00:C994                      ;
       5:  00:C994                      ;==============================================================================
       6:  00:C994                      ;
       7:  00:C994                      ; This file is part of the EPNET software
       8:  00:C994                      ;
       9:  00:C994                      ; Copyright (C) 2015  Bruce Tanner
      10:  00:C994                      ;
      11:  00:C994                      ;    This program is free software: you can redistribute it and/or modify
      12:  00:C994                      ;    it under the terms of the GNU General Public License as published by
      13:  00:C994                      ;    the Free Software Foundation, either version 3 of the License, or
      14:  00:C994                      ;    (at your option) any later version.
      15:  00:C994                      ;
      16:  00:C994                      ;    This program is distributed in the hope that it will be useful,
      17:  00:C994                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      18:  00:C994                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      19:  00:C994                      ;    GNU General Public License for more details.
      20:  00:C994                      ;
      21:  00:C994                      ;    You should have received a copy of the GNU General Public License
      22:  00:C994                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      23:  00:C994                      ;
      24:  00:C994                      ; If you do use or modify this file, either for its original purpose or for
      25:  00:C994                      ; something new, I'd love to hear about it! I can be contacted by email at:
      26:  00:C994                      ;
      27:  00:C994                      ; brucetanner@btopenworld.com
      28:  00:C994                      ;
      29:  00:C994                      ;==============================================================================
      30:  00:C994                      ;
      31:  00:C994                      		macro EXOS n
      32:  00:C994                    < 		 rst 30H
      33:  00:C994                    < 		 db  n
      34:  00:C994                    < 		endm
      35:  00:C994                      ;
      36:  00:C994                      		module	exos
      37:  00:C994                      ;
      38:  00:C994                      ;------------------------------------------------------------------------------
      39:  00:C994                      ;
      40:  00:C994                      ;		        EXOS FIXED VARIABLES
      41:  00:C994                      ;		      ========================
      42:  00:C994                      ;
      43:  00:C994                      ;
      44:  00:C994  (00:BFFF)           USR_P3		equ	0BFFFh	;Four segments which were in Z-80 space
      45:  00:C994  (00:BFFE)           USR_P2		equ	0BFFEh	; when EXOS was last called.
      46:  00:C994  (00:BFFD)           USR_P1		equ	0BFFDh
      47:  00:C994  (00:BFFC)           USR_P0		equ	0BFFCh
      48:  00:C994                      
      49:  00:C994  (00:BFFA)           STACK_LIMIT	equ	0BFFAh	;Bottom limit of stack for devices.
      50:  00:C994                      
      51:  00:C994  (00:BFF8)           RST_ADDR	equ	0BFF8h	;Warm reset address
      52:  00:C994                      
      53:  00:C994  (00:BFF6)           ST_POINTER	equ	0BFF6h	;Address of status line RAM
      54:  00:C994  (00:BFF4)           LP_POINTER	equ	0BFF4h	;Address of start of video LPT.
      55:  00:C994                      
      56:  00:C994  (00:BFF3)           PORTB5		equ	0BFF3h	;Current contents of Z-80 port 0B5h.
      57:  00:C994                      
      58:  00:C994  (00:BFF2)           FLAG_SOFT_IRQ	equ	0BFF2h	;Flag <>0 to cause software interrupt.
      59:  00:C994                      
      60:  00:C994  (00:BFF0)           SEC_COUNTER	equ	0BFF0h	;16-bit second counter
      61:  00:C994                      
      62:  00:C994  (00:BFEE)           CR_DISP		equ	0BFEEh	;Flag <>0 to supress signon display
      63:  00:C994                      
      64:  00:C994  (00:BFED)           USER_ISR	equ	0BFEDh	;User's interrupt routine address.
      65:  00:C994                      ;
      66:  00:C994                      ;
      67:  00:C994                      ;------------------------------------------------------------------------------
      68:  00:C994                      ;
      69:  00:C994                      ;			FUNCTION CODES
      70:  00:C994                      ;		      ==================
      71:  00:C994                      ;
      72:  00:C994                      ;
      73:  00:C994  (00:0000)           FN_RESET	equ	0		; Reset system
      74:  00:C994  (00:0001)           FN_OPEN		equ	1		; Open channel
      75:  00:C994  (00:0002)           FN_CREATE	equ	2		; Create channel
      76:  00:C994  (00:0003)           FN_CLOSE	equ	3		; Close channel
      77:  00:C994  (00:0004)           FN_DEST		equ	4		; Destroy channel
      78:  00:C994  (00:0005)           FN_RDCH		equ	5		; Read character
      79:  00:C994  (00:0006)           FN_RDBLK	equ	6		; Read block
      80:  00:C994  (00:0007)           FN_WRCH		equ	7		; Write character
      81:  00:C994  (00:0008)           FN_WRBLK	equ	8		; Write block
      82:  00:C994  (00:0009)           FN_RSTAT	equ	9		; Read status
      83:  00:C994  (00:000A)           FN_SSTAT	equ	10		; Set channel status 
      84:  00:C994  (00:000B)           FN_SFUNC	equ	11		; Special function
      85:  00:C994  (00:0010)           FN_EVAR		equ	16		; Set/read/toggle EXOS variable
      86:  00:C994  (00:0011)           FN_CAPT		equ	17		; Capture channel
      87:  00:C994  (00:0012)           FN_REDIR	equ	18		; Re-direct channel
      88:  00:C994  (00:0013)           FN_DDEV		equ	19		; Set default device
      89:  00:C994  (00:0014)           FN_SYSS		equ	20		; Return system status
      90:  00:C994  (00:0015)           FN_LINK		equ	21		; Link device
      91:  00:C994  (00:0016)           FN_READB	equ	22		; Read EXOS boundary
      92:  00:C994  (00:0017)           FN_SETB		equ	23		; Set USER boundary
      93:  00:C994  (00:0018)           FN_ALLOC	equ	24		; Allocate segment
      94:  00:C994  (00:0019)           FN_FREE		equ	25		; Free segment
      95:  00:C994  (00:001A)           FN_ROMS		equ	26		; Locate ROMs
      96:  00:C994  (00:001B)           FN_BUFF		equ	27		; Allocate channel buffer
      97:  00:C994  (00:001C)           FN_ERRMSG	equ	28		; Return error message.
      98:  00:C994  (00:001D)           FN_LD		equ	29		; Load module
      99:  00:C994  (00:001E)           FN_REL		equ	30		; Load relocatable module
     100:  00:C994  (00:001F)           FN_STIME	equ	31		; Set time
     101:  00:C994  (00:0020)           FN_RTIME	equ	32		; Read time
     102:  00:C994  (00:0021)           FN_SDATE	equ	33		; Set date
     103:  00:C994  (00:0022)           FN_RDATE	equ	34		; Read date
     104:  00:C994                      
     105:  00:C994                      
     106:  00:C994                      
     107:  00:C994                      
     108:  00:C994                      ;******************************************************************************
     109:  00:C994                      ;
     110:  00:C994                      ;
     111:  00:C994                      ;			ERROR CODES
     112:  00:C994                      ;		     =================
     113:  00:C994                      ;
     114:  00:C994                      ;
     115:  00:C994                      ;	General errors returned by the EXOS kernel 
     116:  00:C994                      ;
     117:  00:C994  (00:00FF)           ERR_IFUNC	equ	0FFh	;Invalid function code
     118:  00:C994  (00:00FE)           ERR_ILLFN	equ	0FEh	;EXOS function call not allowed
     119:  00:C994  (00:00FD)           ERR_INAME	equ	0FDh	;Invalid name string
     120:  00:C994  (00:00FC)           ERR_STACK	equ	0FCh	;Insufficient stack
     121:  00:C994                      ;
     122:  00:C994  (00:00FB)           ERR_ICHAN	equ	0FBh	;Channel does not exist.
     123:  00:C994  (00:00FA)           ERR_NODEV	equ	0FAh	;Device does not exist  (OPEN/CREATE)
     124:  00:C994  (00:00F9)           ERR_CHANX	equ	0F9h	;Channel already exists (OPEN/CREATE)
     125:  00:C994  (00:00F8)           ERR_NOBUF	equ	0F8h	;No ALLOCATE BUFFER call made (OPEN/CREATE)
     126:  00:C994  (00:00F7)           ERR_NORAM	equ	0F7h	;Insufficient RAM for buffer.
     127:  00:C994  (00:00F6)           ERR_NOVID	equ	0F6h	;Insufficient video RAM.
     128:  00:C994                      ;
     129:  00:C994  (00:00F5)           ERR_NOSEG	equ	0F5h	;No free segments (ALLOCATE SEG)
     130:  00:C994  (00:00F4)           ERR_ISEG	equ	0F4h	;Invalid segment (FREE SEGequ SET BOUNDARY)
     131:  00:C994  (00:00F3)           ERR_IBOUN	equ	0F3h	;Invalid user boundary (SET USER BOUND)
     132:  00:C994  (00:00F2)           ERR_IVAR	equ	0F2h	;Invalid EXOS variable number 
     133:  00:C994  (00:00F1)           ERR_IDESC	equ	0F1h	;Invalid device descriptor type (LINK DEV)
     134:  00:C994                      ;
     135:  00:C994  (00:00F0)           ERR_NOSTR	equ	0F0h	;String not recognized by ROMs.
     136:  00:C994  (00:00EF)           ERR_ASCII	equ	0EFh	;Not a valid enterprise module header
     137:  00:C994  (00:00EE)           ERR_ITYPE	equ	0EEh	;Un-recognized module type
     138:  00:C994  (00:00ED)           ERR_IREL	equ	0EDh	;Invalid relocatable file 
     139:  00:C994  (00:00EC)           ERR_NOMOD	equ	0ECh	;End of file module found
     140:  00:C994                      ;
     141:  00:C994  (00:00EB)           ERR_ITIME	equ	0EBh	;Invalid time or date 
     142:  00:C994                      ;               
     143:  00:C994                      ;               
     144:  00:C994                      ;               
     145:  00:C994                      ;	errors rturned by various devices
     146:  00:C994                      ;              
     147:  00:C994  (00:00EA)           ERR_ISPEC	equ	0EAh	;Invalid special function code
     148:  00:C994  (00:00E9)           ERR_CH2ND	equ	0E9h	;Attempt to open second channel
     149:  00:C994  (00:00E8)           ERR_IUNIT	equ	0E8h	;Invalid unit number specified for OPEN/CRTE
     150:  00:C994  (00:00E7)           ERR_NOFN	equ	0E7h	;Function not supported
     151:  00:C994  (00:00E6)           ERR_ESC	equ	0E6h	;Invalid escape character
     152:  00:C994  (00:00E5)           ERR_STOP	equ	0E5h	;Stop key pressed
     153:  00:C994  (00:00E4)           ERR_EOF	equ	0E4h	;Unexpected end of file
     154:  00:C994  (00:00E3)           ERR_PROT	equ	0E3h	;Protection violation
     155:  00:C994                      ;
     156:  00:C994                      ;
     157:  00:C994                      ;
     158:  00:C994                      ;	Keyboard errors
     159:  00:C994                      
     160:  00:C994  (00:00E2)           ERR_KFSPC	equ	0E2h	;Run out of function key space
     161:  00:C994                      ;                               
     162:  00:C994                      ;                               
     163:  00:C994                      ;                               
     164:  00:C994                      ;	Sound errors            
     165:  00:C994                      ;                               
     166:  00:C994  (00:00E1)           ERR_SENV	equ	0E1h	;Envelope is too big or number 255.
     167:  00:C994  (00:00E0)           ERR_SENBF	equ	0E0h	;Not enough room to define envelope
     168:  00:C994  (00:00DF)           ERR_SQFUL	equ	0DFh	;Sound queue is full (and WAIT_SND <> 0)
     169:  00:C994                      ;                               
     170:  00:C994                      ;                               
     171:  00:C994                      ;                               
     172:  00:C994                      ;	Video errors            
     173:  00:C994                      ;                               
     174:  00:C994  (00:00DE)           ERR_VSIZE	equ	0DEh	;Invalid X or Y size to OPEN
     175:  00:C994  (00:00DD)           ERR_VMODE	equ	0DDh	;Invalid video mode to OPEN
     176:  00:C994  (00:00DC)           ERR_VDISP	equ	0DCh	;Naff parameter to DISPLAY
     177:  00:C994  (00:00DB)           ERR_VLOAD	equ	0DBh	;Invalid file to LOAD
     178:  00:C994                      ;        
     179:  00:C994  (00:00DA)           ERR_VROW	equ	0DAh	;Invalid row number to scroll
     180:  00:C994  (00:00D9)           ERR_VCURS	equ	0D9h	;Attempt to move cursor off page
     181:  00:C994  (00:00D8)           ERR_VBEAM	equ	0D8h	;Attept to move beam off page
     182:  00:C994                      ;                               
     183:  00:C994                      ;                               
     184:  00:C994                      ;                               
     185:  00:C994                      ;	Serial/Network erors
     186:  00:C994                      ;                               
     187:  00:C994  (00:00D7)           ERR_SEROP	equ	0D7h	;Serial device open - cannot use network
     188:  00:C994  (00:00D6)           ERR_NOADR	equ	0D6h	;ADDR_NET not set up
     189:  00:C994  (00:00D5)           ERR_NETOP	equ	0D5h	;Network link already exists
     190:  00:C994                      ;                               
     191:  00:C994                      ;                               
     192:  00:C994                      ;                               
     193:  00:C994                      ;	Editor errors           
     194:  00:C994                      ;                               
     195:  00:C994  (00:00D4)           ERR_EVID	equ	0D4h	;Video channel error
     196:  00:C994  (00:00D3)           ERR_EKEY	equ	0D3h	;Keyboard channel error
     197:  00:C994  (00:00D2)           ERR_EDINV	equ	0D2h	;Editor - invalid LOAD file
     198:  00:C994  (00:00D1)           ERR_EDBUF	equ	0D1h	;Editor - Buffer full in LOAD
     199:  00:C994                      ;                               
     200:  00:C994                      ;                               
     201:  00:C994                      ;                               
     202:  00:C994                      ;	Cassette errors         
     203:  00:C994                      ;                               
     204:  00:C994  (00:00D0)           ERR_CCRC	equ	0D0h	;CRC error from cassette driver
     205:  00:C994                      ;
     206:  00:C994                      ;
     207:  00:C994                      ;
     208:  00:C994                      ;	EPNET errors
     209:  00:C994                      ;
     210:  00:C994  (00:006F)           ERR_LAST	equ	06fh		;Last EPNET error code number
     211:  00:C994                      ;
     212:  00:C994  (00:006F)           ERR_DHCP	equ	ERR_LAST-0	;Timeout trying to get IP values via DHCP
     213:  00:C994  (00:006E)           ERR_NONET	equ	ERR_LAST-1	;Cannot communicate with WIZ chip
     214:  00:C994  (00:006D)           ERR_BADIP	equ	ERR_LAST-2	;Invalid IP address
     215:  00:C994  (00:006C)           ERR_BADOPT	equ	ERR_LAST-3	;Invalid command option
     216:  00:C994  (00:006B)           ERR_NOCON	equ	ERR_LAST-4	;Cannot open connection
     217:  00:C994  (00:006A)           ERR_TIMEOUT	equ	ERR_LAST-5	;No response from server
     218:  00:C994  (00:0069)           ERR_FTP		equ	ERR_LAST-6	;Unexpected FTP error
     219:  00:C994  (00:0068)           ERR_NOFIL	equ	ERR_LAST-7	;File not found
     220:  00:C994  (00:0067)           ERR_NOTIME	equ	ERR_LAST-8	;Cannot get time
     221:  00:C994  (00:0066)           ERR_DUPIP	equ	ERR_LAST-9	;Duplicate IP address on network
     222:  00:C994  (00:0065)           ERR_FTPDATA	equ	ERR_LAST-10	;Cannot open data connection
     223:  00:C994  (00:0064)           ERR_BADHTTP	equ	ERR_LAST-11	;Invalid HTTP response
     224:  00:C994                      ;
     225:  00:C994  (00:0064)           ERR_FIRST	equ	ERR_LAST-11
     226:  00:C994                      ;
     227:  00:C994                      ;
     228:  00:C994                      ;------------------------------------------------------------------------------
     229:  00:C994                      ;
     230:  00:C994                      ;		  WARNING CODES
     231:  00:C994                      ;		=================
     232:  00:C994                      ;
     233:  00:C994  (00:007F)           ERR_SHARE	equ	07Fh		;Shared segment allocated
     234:  00:C994                      ;
     235:  00:C994                      ;
     236:  00:C994                      ;
     237:  00:C994                      ;******************************************************************************
     238:  00:C994                      ;
     239:  00:C994                      ;
     240:  00:C994                      ;			  EXOS VARIABLE NUMBERS
     241:  00:C994                      ;			=========================
     242:  00:C994                      ;
     243:  00:C994                      ;
     244:  00:C994                      ;
     245:  00:C994                      ;
     246:  00:C994  (00:0000)           VAR_IRQ_ENABLE	equ	0	; Interrupt enable bits.
     247:  00:C994                      ;
     248:  00:C994  (00:0001)           VAR_FLAG_SIRQ	equ	1	; Flag to cause a software interrupt.
     249:  00:C994  (00:0002)           VAR_CODE_SIRQ	equ	2	; Software Interrupt code.
     250:  00:C994                      ;
     251:  00:C994  (00:0003)           VAR_DEF_TYPE	equ	3	; Type of default device.
     252:  00:C994  (00:0004)           VAR_DEF_CHAN	equ	4	; Default channel number.
     253:  00:C994                      ;
     254:  00:C994  (00:0005)           VAR_TIMER	equ	5	; 1Hz down counter.
     255:  00:C994                      ;
     256:  00:C994  (00:0006)           VAR_LOCK_KEY	equ	6	; Keyboard lock status.
     257:  00:C994  (00:0007)           VAR_CLICK_KEY	equ	7	; Key click enable/disable.
     258:  00:C994  (00:0008)           VAR_STOP_IRQ	equ	8	; Software interrupt on STOP key.
     259:  00:C994  (00:0009)           VAR_KEY_IRQ	equ	9	; Software interrupt on any key press.
     260:  00:C994  (00:000A)           VAR_RATE_KEY	equ	10	; Keyboard auto-repeat rate.
     261:  00:C994  (00:000B)           VAR_DELAY_KEY	equ	11	; Delay before auto-repeat starts.
     262:  00:C994                      ;
     263:  00:C994  (00:000C)           VAR_TAPE_SND	equ	12	; Tape sound enable/dispable.
     264:  00:C994                      ;
     265:  00:C994  (00:000D)           VAR_WAIT_SND	equ	13	; Sound driver waiting if buffer full
     266:  00:C994  (00:000E)           VAR_MUTE_SND	equ	14	; Sound mute enable/disable.
     267:  00:C994  (00:000F)           VAR_BUF_SND	equ	15	; Sound envelope storage size.
     268:  00:C994                      ;
     269:  00:C994  (00:0010)           VAR_BAUD_SER	equ	16	; Serial baud rate.
     270:  00:C994  (00:0011)           VAR_FORM_SER	equ	17	; Serial word format.
     271:  00:C994  (00:0012)           VAR_ADDR_NET	equ	18	; Network address of this machine
     272:  00:C994  (00:0013)           VAR_NET_IRQ	equ	19	; Software interrupt on network.
     273:  00:C994  (00:0014)           VAR_CHAN_NET	equ	20	; Channel for network block.
     274:  00:C994  (00:0015)           VAR_MACH_NET	equ	21	; Source machine for network block.
     275:  00:C994                      ;
     276:  00:C994  (00:0016)           VAR_MODE_VID	equ	22	; Video mode.
     277:  00:C994  (00:0017)           VAR_COLR_VID	equ	23	; Video colour mode.
     278:  00:C994  (00:0018)           VAR_X_SIZ_VID	equ	24	; Video X page size.
     279:  00:C994  (00:0019)           VAR_Y_SIZ_VID	equ	25	; Video Y page size.
     280:  00:C994                      ;
     281:  00:C994  (00:001A)           VAR_ST_FLAG	equ	26	; Status line displayed flag.
     282:  00:C994  (00:001B)           VAR_BORD_VID	equ	27	; Border colour.
     283:  00:C994  (00:001C)           VAR_BIAS_VID	equ	28	; Fixed bias colour.
     284:  00:C994                      ;
     285:  00:C994  (00:001D)           VAR_VID_EDIT	equ	29	; Video channel number.
     286:  00:C994  (00:001E)           VAR_KEY_EDIT	equ	30	; Keyboard channel number.
     287:  00:C994  (00:001F)           VAR_BUF_EDIT	equ	31	; Size of edit buffer.
     288:  00:C994  (00:0020)           VAR_FLG_EDIT	equ	32	; Editor control flags
     289:  00:C994                      ;
     290:  00:C994  (00:0021)           VAR_SP_TAPE	equ	33	; Cassette I/O speed.
     291:  00:C994  (00:0022)           VAR_PROTECT	equ	34	; Cassette protection control
     292:  00:C994  (00:0023)           VAR_LV_TAPE	equ	35	; Cassette level control
     293:  00:C994  (00:0024)           VAR_REM1	equ	36	; Cassette remote 1
     294:  00:C994  (00:0025)           VAR_REM2	equ	37	; Cassette remote 2
     295:  00:C994                      ;
     296:  00:C994  (00:0026)           VAR_SPRITE	equ	38	; Sprite colour priority
     297:  00:C994                      ;
     298:  00:C994  (00:0027)           VAR_RANDOM	equ	39	; Random interrupt counter
     299:  00:C994                      ;
     300:  00:C994                      ;
     301:  00:C994                      ;
     302:  00:C994                      ;******************************************************************************
     303:  00:C994                      ;
     304:  00:C994                      ;
     305:  00:C994                      ;		SOFTWARE INTERRUPT CODES
     306:  00:C994                      ;	      ============================
     307:  00:C994                      ;
     308:  00:C994                      ;
     309:  00:C994  (00:0010)           INT_FKEY	equ	10h		;Function keys 10h...1Fh
     310:  00:C994  (00:0020)           INT_STOP	equ	20h		;Stop key
     311:  00:C994  (00:0021)           INT_KEY		equ	21h		;'any key' 21h
     312:  00:C994                      ;
     313:  00:C994  (00:0030)           INT_NET		equ	30h		;Network data received.
     314:  00:C994                      ;
     315:  00:C994  (00:0040)           INT_TIME	equ	40h		;TIMER reached zero
     316:  00:C994                      ;
     317:  00:C994                      ;
     318:  00:C994                      ;
     319:  00:C994                      ;------------------------------------------------------------------------------
     320:  00:C994                      ;
     321:  00:C994                      ;
     322:  00:C994                      ;		SPECIAL FUNCTION CODES
     323:  00:C994                      ;	      ==========================
     324:  00:C994                      ;
     325:  00:C994                      ;
     326:  00:C994  (00:0001)           FN_VID_DISP	equ	01h		; VIDEO - Display page
     327:  00:C994  (00:0002)           FN_VID_SIZE	equ	02h		; VIDEO - Return page size & mode
     328:  00:C994  (00:0003)           FN_VID_ADDR	equ	03h		; VIDEO - Return page address
     329:  00:C994  (00:0004)           FN_VID_FONT	equ	04h		; VIDEO - Initialise character font
     330:  00:C994                      ;
     331:  00:C994  (00:0008)           FN_KEY_FKEY	equ	08h		; KEYBOARD - Program function key
     332:  00:C994  (00:0009)           FN_KEY_JOY	equ	09h		; KEYBOARD - Read joystick
     333:  00:C994                      ;
     334:  00:C994  (00:0010)           FN_NET_FLSH	equ	10h		; NETWORK  - Flush buffer
     335:  00:C994  (00:0011)           FN_NET_CLR	equ	11h		; NETWORK  - Clear buffers
     336:  00:C994                      ;
     337:  00:C994  (00:0018)           FN_ED_MARG	equ	18h 		; EDITOR   - Set margins
     338:  00:C994  (00:0019)           FN_ED_CHLD	equ	19h		; EDITOR   - Load document file
     339:  00:C994  (00:001A)           FN_ED_CHSV	equ	1Ah		; EDITOR   - Save document file
     340:  00:C994                      ;
     341:  00:C994                      ;
     342:  00:C994                      ;
     343:  00:C994                      ;------------------------------------------------------------------------------
     344:  00:C994                      ;
     345:  00:C994                      ;
     346:  00:C994                      ;		ROM ACTION CODES
     347:  00:C994                      ;	      ====================
     348:  00:C994                      ;
     349:  00:C994                      ;
     350:  00:C994  (00:0000)           ACT_NULL	equ	00h		;Do nothing.
     351:  00:C994  (00:0001)           ACT_COLD	equ	01h		;Cold restart.
     352:  00:C994  (00:0002)           ACT_STR		equ	02h		;Pass user string
     353:  00:C994  (00:0003)           ACT_HELP	equ	03h		;Help string
     354:  00:C994  (00:0004)           ACT_EVAR	equ	04h		;Unknown EXOS variable
     355:  00:C994  (00:0005)           ACT_ERR		equ	05h		;Explain error code
     356:  00:C994  (00:0006)           ACT_LOAD	equ	06h		;Load module of given type
     357:  00:C994  (00:0007)           ACT_RAM		equ	07h		;Claim RAM 
     358:  00:C994  (00:0008)           ACT_INIT	equ	08h		;Initialise ROM
     359:  00:C994                      ;
     360:  00:C994                      ;
     361:  00:C994                      ;
     362:  00:C994                      ;------------------------------------------------------------------------------
     363:  00:C994                      ;
     364:  00:C994                      ;
     365:  00:C994                      ;		LOAD MODULE HEADER TYPES
     366:  00:C994                      ;	      ============================
     367:  00:C994                      ;
     368:  00:C994                      ;
     369:  00:C994  (00:0000)           MOD_ASCII	equ	00h		;ASCII file 
     370:  00:C994  (00:0001)           MOD_4TH		equ	01h		;FORTH
     371:  00:C994  (00:0002)           MOD_REL		equ	02h		;Relocatable module
     372:  00:C994  (00:0003)           MOD_XBAS	equ	03h		;Multiple BASIC program
     373:  00:C994  (00:0004)           MOD_BAS		equ	04h		;Single BASIC program
     374:  00:C994  (00:0005)           MOD_APP		equ	05h		;New applications program
     375:  00:C994  (00:0006)           MOD_XABS	equ	06h		;Absolute system extension
     376:  00:C994  (00:0007)           MOD_XREL	equ	07h		;Relocatable system extension
     377:  00:C994  (00:0008)           MOD_EDIT	equ	08h		;Editor document file
     378:  00:C994  (00:0009)           MOD_LISP	equ	09h		;Lisp memory image
     379:  00:C994  (00:000A)           MOD_EOF		equ	0Ah		;End of file module 
     380:  00:C994  (00:000B)           MOD_VID		equ	0Bh		;Video page file.
     381:  00:C994                      ;
     382:  00:C994                      ;
     383:  00:C994                      ;------------------------------------------------------------------------------
     384:  00:C994                      ; is_stop
     385:  00:C994                      ;
     386:  00:C994                      ; Returns with Cy set if the stop key is pressed. Nothing else corrupted.
     387:  00:C994                      ;
     388:  00:C994  F5                  is_stop:	push	af
     389:  00:C995  3A F2 BF            		ld	a,(exos.FLAG_SOFT_IRQ)
     390:  00:C998  FE 20               		cp	20h		; STOP key
     391:  00:C99A  28 03               		jr	z,.scfret
     392:  00:C99C                      ;
     393:  00:C99C  F1                  		pop	af
     394:  00:C99D  B7                  		or	a
     395:  00:C99E  C9                  		ret
     396:  00:C99F                      
     397:  00:C99F  F1                  .scfret:	pop	af
     398:  00:C9A0  37                  		scf
     399:  00:C9A1  C9                  		ret
     400:  00:C9A2                      ;
     401:  00:C9A2                      ;
     402:  00:C9A2                      ; check_stop
     403:  00:C9A2                      ;
     404:  00:C9A2                      ; Called with an error code in A, returns ERR_STOP instead (and Cy) if the stop ; key has been pressed.
     405:  00:C9A2                      ;
     406:  00:C9A2  CD 94 C9            check_stop:	call	is_stop
     407:  00:C9A5  3F                  		ccf
     408:  00:C9A6  D8                  		ret	c
     409:  00:C9A7                      ;
     410:  00:C9A7  3E E5               		ld	a,ERR_STOP
     411:  00:C9A9  37                  		scf
     412:  00:C9AA  C9                  		ret
     413:  00:C9AB                      ;
     414:  00:C9AB                      ;
     415:  00:C9AB                      ;------------------------------------------------------------------------------
     416:  00:C9AB                      ;
     417:  00:C9AB  78                  explain:	ld	a,b
     418:  00:C9AC                      ;
     419:  00:C9AC  D6 64               		sub	ERR_FIRST	; A=0-based error code if ours
     420:  00:C9AE  D8                  		ret	c		; Ret if error code < our lowest
     421:  00:C9AF                      ;
     422:  00:C9AF  FE 0C               		cp	ERR_LAST-ERR_FIRST+1
     423:  00:C9B1  D0                  		ret	nc		; Ret if erro code > our highest
     424:  00:C9B2                      ;
     425:  00:C9B2  21 C3 C9            		ld	hl,messages	; HL->table of message addresses
     426:  00:C9B5  5F                  		ld	e,a
     427:  00:C9B6  16 00               		ld	d,0		; DE=offset into table
     428:  00:C9B8  19                  		add	hl,de
     429:  00:C9B9  19                  		add	hl,de		; HL->message for error code
     430:  00:C9BA  5E                  		ld	e,(hl)
     431:  00:C9BB  23                  		inc	hl
     432:  00:C9BC  56                  		ld	d,(hl)		; DE->message
     433:  00:C9BD                      ;
     434:  00:C9BD  DB B3               		in	a,(ep.P3)	; Get page containing message
     435:  00:C9BF  47                  		ld	b,a		; B=page, DE->message
     436:  00:C9C0  0E 00               		ld	c,0		; C=0=>explained
     437:  00:C9C2  C9                  		ret
     438:  00:C9C3                      ;
     439:  00:C9C3                      
     440:  00:C9C3                      messages:				; Same order as error codes, lowest first!
     441:  00:C9C3  F8 CA               		dw	BADHTTP_str
     442:  00:C9C5  DB CA               		dw	FTPDATA_str
     443:  00:C9C7  BB CA               		dw	DUPIP_str
     444:  00:C9C9  9B CA               		dw	NOTIME_str
     445:  00:C9CB  7B CA               		dw	NOFIL_str
     446:  00:C9CD  66 CA               		dw	FTP_str
     447:  00:C9CF  4E CA               		dw	TIMEOUT_str
     448:  00:C9D1  3F CA               		dw	NOCON_str
     449:  00:C9D3  30 CA               		dw	BADOPT_str
     450:  00:C9D5  1D CA               		dw	BADIP_str
     451:  00:C9D7  FF C9               		dw	NONET_str
     452:  00:C9D9  DB C9               		dw	DHCP_str
     453:  00:C9DB                      ;
     454:  00:C9DB                      ;                                             1         2         3         4
     455:  00:C9DB                      ;                    screen col:     1        0         0         0         0
     456:  00:C9DB                      ;                                    |--------|---------|---------|---------|
     457:  00:C9DB                      ;                                    *** 
     458:  00:C9DB                      DHCP_str:	db	DHCP_str_len,	"Cannot get IP address etc with DHCP"
     458:  00:C9DB  23 43 61 6E 6E 6F 74 20 67 65 74 20 49 50 20 61 
     458:  00:C9EB  64 64 72 65 73 73 20 65 74 63 20 77 69 74 68 20 
     458:  00:C9FB  44 48 43 50 
     459:  00:C9FF  (00:0023)           DHCP_str_len	equ	$-DHCP_str-1	; -1 to exclude length byte itself
     460:  00:C9FF                      ;
     461:  00:C9FF                      NONET_str:	db	NONET_str_len,	"Cannot communicate with EPNET"
     461:  00:C9FF  1D 43 61 6E 6E 6F 74 20 63 6F 6D 6D 75 6E 69 63 
     461:  00:CA0F  61 74 65 20 77 69 74 68 20 45 50 4E 45 54 
     462:  00:CA1D  (00:001D)           NONET_str_len	equ	$-NONET_str-1	; -1 to exclude length byte itself
     463:  00:CA1D                      ;
     464:  00:CA1D                      BADIP_str:	db	BADIP_str_len,	"Invalid IP address"
     464:  00:CA1D  12 49 6E 76 61 6C 69 64 20 49 50 20 61 64 64 72 
     464:  00:CA2D  65 73 73 
     465:  00:CA30  (00:0012)           BADIP_str_len	equ	$-BADIP_str-1	; -1 to exclude length byte itself
     466:  00:CA30                      ;
     467:  00:CA30                      BADOPT_str:	db	BADOPT_str_len,	"Invalid option"
     467:  00:CA30  0E 49 6E 76 61 6C 69 64 20 6F 70 74 69 6F 6E 
     468:  00:CA3F  (00:000E)           BADOPT_str_len	equ	$-BADOPT_str-1	; -1 to exclude length byte itself
     469:  00:CA3F                      ;
     470:  00:CA3F                      NOCON_str:	db	NOCON_str_len,	"Cannot connect"
     470:  00:CA3F  0E 43 61 6E 6E 6F 74 20 63 6F 6E 6E 65 63 74 
     471:  00:CA4E  (00:000E)           NOCON_str_len	equ	$-NOCON_str-1	; -1 to exclude length byte itself
     472:  00:CA4E                      ;
     473:  00:CA4E                      TIMEOUT_str:	db	TIMEOUT_str_len,"No response from server"
     473:  00:CA4E  17 4E 6F 20 72 65 73 70 6F 6E 73 65 20 66 72 6F 
     473:  00:CA5E  6D 20 73 65 72 76 65 72 
     474:  00:CA66  (00:0017)           TIMEOUT_str_len	equ	$-TIMEOUT_str-1	; -1 to exclude length byte itself
     475:  00:CA66                      ;
     476:  00:CA66                      FTP_str:	db	FTP_str_len,	"Unexpected FTP error"
     476:  00:CA66  14 55 6E 65 78 70 65 63 74 65 64 20 46 54 50 20 
     476:  00:CA76  65 72 72 6F 72 
     477:  00:CA7B  (00:0014)           FTP_str_len	equ	$-FTP_str-1	; -1 to exclude length byte itself
     478:  00:CA7B                      ;
     479:  00:CA7B                      NOFIL_str:	db	NOFIL_str_len,	"File not found or access denied"
     479:  00:CA7B  1F 46 69 6C 65 20 6E 6F 74 20 66 6F 75 6E 64 20 
     479:  00:CA8B  6F 72 20 61 63 63 65 73 73 20 64 65 6E 69 65 64 
     480:  00:CA9B  (00:001F)           NOFIL_str_len	equ	$-NOFIL_str-1	; -1 to exclude length byte itself
     481:  00:CA9B                      ;
     482:  00:CA9B                      NOTIME_str:	db	NOTIME_str_len,	"Cannot get time & date with NTP"
     482:  00:CA9B  1F 43 61 6E 6E 6F 74 20 67 65 74 20 74 69 6D 65 
     482:  00:CAAB  20 26 20 64 61 74 65 20 77 69 74 68 20 4E 54 50 
     483:  00:CABB  (00:001F)           NOTIME_str_len	equ	$-NOTIME_str-1	; -1 to exclude length byte itself
     484:  00:CABB                      ;
     485:  00:CABB                      DUPIP_str:	db	DUPIP_str_len,	"Duplicate IP address on network"
     485:  00:CABB  1F 44 75 70 6C 69 63 61 74 65 20 49 50 20 61 64 
     485:  00:CACB  64 72 65 73 73 20 6F 6E 20 6E 65 74 77 6F 72 6B 
     486:  00:CADB  (00:001F)           DUPIP_str_len	equ	$-DUPIP_str-1	; -1 to exclude length byte itself
     487:  00:CADB                      ;
     488:  00:CADB                      FTPDATA_str:	db	FTPDATA_str_len, "Cannot open FTP data session"
     488:  00:CADB  1C 43 61 6E 6E 6F 74 20 6F 70 65 6E 20 46 54 50 
     488:  00:CAEB  20 64 61 74 61 20 73 65 73 73 69 6F 6E 
     489:  00:CAF8  (00:001C)           FTPDATA_str_len	equ	$-FTPDATA_str-1	; -1 to exclude length byte itself
     490:  00:CAF8                      ;
     491:  00:CAF8                      BADHTTP_str	db	BADHTTP_str_len, "Unexpected HTTP response"
     491:  00:CAF8  18 55 6E 65 78 70 65 63 74 65 64 20 48 54 54 50 
     491:  00:CB08  20 72 65 73 70 6F 6E 73 65 
     492:  00:CB11  (00:0018)           BADHTTP_str_len	equ	$-BADHTTP_str-1	; -1 to exclude length byte itself
     493:  00:CB11                      ;
     494:  00:CB11                      ;
     495:  00:CB11                      ;
     496:  00:CB11                      		endmodule
      95.  00:CB11                      	include	device.asm
       1:  00:CB11                      ; DEVICE
       2:  00:CB11                      ;
       3:  00:CB11                      ; This module contains the EXOS device drivers
       4:  00:CB11                      ;
       5:  00:CB11                      		module	device
       6:  00:CB11                      ;
       7:  00:CB11                      ;==============================================================================
       8:  00:CB11                      ;
       9:  00:CB11                      ; This file is part of the EPNET software
      10:  00:CB11                      ;
      11:  00:CB11                      ; Copyright (C) 2015  Bruce Tanner
      12:  00:CB11                      ;
      13:  00:CB11                      ;    This program is free software: you can redistribute it and/or modify
      14:  00:CB11                      ;    it under the terms of the GNU General Public License as published by
      15:  00:CB11                      ;    the Free Software Foundation, either version 3 of the License, or
      16:  00:CB11                      ;    (at your option) any later version.
      17:  00:CB11                      ;
      18:  00:CB11                      ;    This program is distributed in the hope that it will be useful,
      19:  00:CB11                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      20:  00:CB11                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      21:  00:CB11                      ;    GNU General Public License for more details.
      22:  00:CB11                      ;
      23:  00:CB11                      ;    You should have received a copy of the GNU General Public License
      24:  00:CB11                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      25:  00:CB11                      ;
      26:  00:CB11                      ; If you do use or modify this file, either for its original purpose or for
      27:  00:CB11                      ; something new, I'd love to hear about it! I can be contacted by email at:
      28:  00:CB11                      ;
      29:  00:CB11                      ; brucetanner@btopenworld.com
      30:  00:CB11                      ;
      31:  00:CB11                      ;==============================================================================
      32:  00:CB11                      ;
      33:  00:CB11                      ; This is the data kept in EXOS channel RAM.
      34:  00:CB11                      ;
      35:  00:CB11                      ; EXOS channel RAM is accessed at (ix-1), (ix-2)...etc so our data here is
      36:  00:CB11                      ; accessed with (ix-1-<item>) eg (ix-1-channel.socket)
      37:  00:CB11                      ;
      38:  00:CB11                      ; Other devices (eg. FTP:, HTTP: may need to keep other information in channel
      39:  00:CB11                      ; RAM but they all start with this so that common code can be used.
      40:  00:CB11                      ;
      41:  00:CB11                      		struct	channel		; Variables in EXOS channel RAM
      42:  00:CB11                    < socket		 byte			; WIZ socket # for this channel
      43:  00:CB11                    < 		ends
      44:  00:CB11                      ;
      45:  00:CB11                      ;
      46:  00:CB11                      ; FTP DEVICE
      47:  00:CB11                      ;
      48:  00:CB11                      ; The FTP device allows an EXOS user to open an EXOS channel to "FTP:xxx" and
      49:  00:CB11                      ; then to read and write to a file.
      50:  00:CB11                      ;
      51:  00:CB11  9A 4B               		dw	tcp_descriptor-8000h	; XX_NEXT Next device in P1
      52:  00:CB13  FE FF               		dw	-2		; XX_RAM	No RAM required
      53:  00:CB15  00                  ftp_type:	db	0		; DD_TYPE
      54:  00:CB16  20                  		db	20h		; DD_IRQFLAG (50Hz)
      55:  00:CB17  00                  		db	0		; DD_FLAGS
      56:  00:CB18  21 4B               		dw	ftp_entry-8000h	; DD_TAB in page 1
      57:  00:CB1A  00                  		db	0		; DD_TAB_SEG
      58:  00:CB1B  00                  		db	0		; DD_UNIT_COUNT
      59:  00:CB1C  03 46 54 50         		db	3,"FTP"		; DD_NAME
      60:  00:CB20                      devices:
      61:  00:CB20  0B                  ftp_descriptor:	db	$-ftp_type	; XX_SIZE
      62:  00:CB21                      ;
      63:  00:CB21  3D CB               ftp_entry:	dw	ftp_interrupt
      64:  00:CB23  53 CB               		dw	ftp_open
      65:  00:CB25  60 CB               		dw	ftp_create
      66:  00:CB27  6D CB               		dw	ftp_close
      67:  00:CB29  6D CB               		dw	ftp_close	; destroy
      68:  00:CB2B  72 CB               		dw	ftp_read_byte
      69:  00:CB2D  77 CB               		dw	ftp_read_block
      70:  00:CB2F  7C CB               		dw	ftp_write_byte
      71:  00:CB31  81 CB               		dw	ftp_write_block
      72:  00:CB33  86 CB               		dw	ftp_read_status
      73:  00:CB35  5C CD               		dw	write_status
      74:  00:CB37  5F CD               		dw	special
      75:  00:CB39  62 CD               		dw	init
      76:  00:CB3B  67 CD               		dw	moved
      77:  00:CB3D                      ;
      78:  00:CB3D                      ;------------------------------------------------------------------------------
      79:  00:CB3D                      ; ftp_interrupt
      80:  00:CB3D                      ;
      81:  00:CB3D                      ; The device driver interrupt routine
      82:  00:CB3D                      ;
      83:  00:CB3D  FD 21 00 F0         ftp_interrupt:	ld	iy,vars
      84:  00:CB41                      ;
      85:  00:CB41  2A 06 F0            		ld	hl,(vars.ticks)
      86:  00:CB44  23                  		inc	hl
      87:  00:CB45  22 06 F0            		ld	(vars.ticks),hl
      88:  00:CB48                      ;
      89:  00:CB48  21 0A F0            		ld	hl,vars.status.ticks
      90:  00:CB4B  34                  		inc	(hl)
      91:  00:CB4C  20 02               		jr	nz,.doneticks
      92:  00:CB4E                      ;
      93:  00:CB4E  36 10               		ld	(hl),status.DELAY
      94:  00:CB50                      .doneticks:
      95:  00:CB50                      ;
      96:  00:CB50  C3 5B E4            		jp	dhcp.interrupt
      97:  00:CB53                      ;
      98:  00:CB53                      ;
      99:  00:CB53                      ;------------------------------------------------------------------------------
     100:  00:CB53                      ; ftp_open
     101:  00:CB53                      ;
     102:  00:CB53                      ; In:  DE->filename, length byte first. Could be zero length. Uppercase.
     103:  00:CB53                      ;       C=unit number
     104:  00:CB53                      ftp_open:
     105:  00:CB53  D5                  		push	de		; Save->filename
     106:  00:CB54  11 02 00            		 ld	de,ftp.ftp_channel	; Allocate our channel RAM
     107:  00:CB57                      		 EXOS	exos.FN_BUFF
     107:  00:CB57  F7                >    rst 30H
     107:  00:CB58  1B                >    db  n
     108:  00:CB59  D1                  		pop	de		; DE->filename
     109:  00:CB5A  C0                  		ret	nz
     110:  00:CB5B                      ;
     111:  00:CB5B  3E 01               		ld	a,1		; Socket 1
     112:  00:CB5D  C3 AC EA            		jp	ftp.device_open
     113:  00:CB60                      ;
     114:  00:CB60                      ;
     115:  00:CB60                      ;------------------------------------------------------------------------------
     116:  00:CB60                      ; ftp_create
     117:  00:CB60                      ;
     118:  00:CB60                      ; In:  DE->filename, length byte first. Could be zero length. Uppercase.
     119:  00:CB60                      ;       C=unit number
     120:  00:CB60                      ftp_create:
     121:  00:CB60  D5                  		push	de		; Save->filename
     122:  00:CB61  11 02 00            		 ld	de,ftp.ftp_channel	; Allocate our channel RAM
     123:  00:CB64                      		 EXOS	exos.FN_BUFF
     123:  00:CB64  F7                >    rst 30H
     123:  00:CB65  1B                >    db  n
     124:  00:CB66  D1                  		pop	de		; DE->filename
     125:  00:CB67  C0                  		ret	nz
     126:  00:CB68                      ;
     127:  00:CB68  3E 01               		ld	a,1		; Socket 1
     128:  00:CB6A  C3 B1 EA            		jp	ftp.device_create
     129:  00:CB6D                      ;
     130:  00:CB6D                      ;
     131:  00:CB6D                      ;------------------------------------------------------------------------------
     132:  00:CB6D                      ; ftp_close
     133:  00:CB6D                      ;
     134:  00:CB6D                      ftp_close:
     135:  00:CB6D  3E 01               		ld	a,1		; Socket 1
     136:  00:CB6F  C3 E9 EA            		jp	ftp.device_close
     137:  00:CB72                      ;
     138:  00:CB72                      ;
     139:  00:CB72                      ;------------------------------------------------------------------------------
     140:  00:CB72                      ; ftp_read_byte
     141:  00:CB72                      ;
     142:  00:CB72                      ftp_read_byte:
     143:  00:CB72  3E 01               		ld	a,1		; Socket 1
     144:  00:CB74  C3 0B EB            		jp	ftp.device_read_byte
     145:  00:CB77                      ;
     146:  00:CB77                      ;
     147:  00:CB77                      ;------------------------------------------------------------------------------
     148:  00:CB77                      ; read_block
     149:  00:CB77                      ;
     150:  00:CB77                      ; In:  DE->buffer within user's paging
     151:  00:CB77                      ;      BC=byte count, could be 0
     152:  00:CB77                      ; Out: 
     153:  00:CB77                      ftp_read_block:
     154:  00:CB77  3E 01               		ld	a,1		; Socket 1
     155:  00:CB79  C3 2B EB            		jp	ftp.device_read_block
     156:  00:CB7C                      ;
     157:  00:CB7C                      ;
     158:  00:CB7C                      ;------------------------------------------------------------------------------
     159:  00:CB7C                      ; write_byte
     160:  00:CB7C                      ;
     161:  00:CB7C                      ftp_write_byte:
     162:  00:CB7C  3E 01               		ld	a,1		; Socket 1
     163:  00:CB7E  C3 48 EB            		jp	ftp.device_write_byte
     164:  00:CB81                      ;
     165:  00:CB81                      ;
     166:  00:CB81                      ;------------------------------------------------------------------------------
     167:  00:CB81                      ; write_block
     168:  00:CB81                      ;
     169:  00:CB81                      ; In:  DE->buffer within user's paging
     170:  00:CB81                      ;      BC=byte count, could be 0
     171:  00:CB81                      ftp_write_block:
     172:  00:CB81  3E 01               		ld	a,1		; Socket 1
     173:  00:CB83  C3 6B EB            		jp	ftp.device_write_block
     174:  00:CB86                      ;
     175:  00:CB86                      ;
     176:  00:CB86                      ;------------------------------------------------------------------------------
     177:  00:CB86                      ; read_status
     178:  00:CB86                      ;
     179:  00:CB86                      ftp_read_status:
     180:  00:CB86  3E 01               		ld	a,1		; Socket 1
     181:  00:CB88  C3 80 EB            		jp	ftp.device_status
     182:  00:CB8B                      ;
     183:  00:CB8B                      ;
     184:  00:CB8B                      ;==============================================================================
     185:  00:CB8B                      ; TCP DEVICE
     186:  00:CB8B                      ;
     187:  00:CB8B                      ; The TCP device allows an EXOS user to eg OPEN #42:"TCP:192.168.1.100:666"
     188:  00:CB8B                      ; to open a TCP link to the specified IP address and port.
     189:  00:CB8B                      ;
     190:  00:CB8B  0C 4C               		dw	http_descriptor-8000h	; XX_NEXT Next device in P1
     191:  00:CB8D  FE FF               		dw	-2		; XX_RAM	No RAM required
     192:  00:CB8F  00                  tcp_type:	db	0		; DD_TYPE
     193:  00:CB90  00                  		db	00h		; DD_IRQFLAG (50Hz)
     194:  00:CB91  00                  		db	0		; DD_FLAGS
     195:  00:CB92  9B 4B               		dw	tcp_entry-8000h	; DD_TAB in page 1
     196:  00:CB94  00                  		db	0		; DD_TAB_SEG
     197:  00:CB95  00                  		db	0		; DD_UNIT_COUNT
     198:  00:CB96  03 54 43 50         		db	3,"TCP"		; DD_NAME
     199:  00:CB9A  0B                  tcp_descriptor:	db	$-tcp_type	; XX_SIZE
     200:  00:CB9B                      ;
     201:  00:CB9B  67 CD               tcp_entry:	dw	interrupt
     202:  00:CB9D  B7 CB               		dw	tcp_open
     203:  00:CB9F  EF CB               		dw	tcp_create
     204:  00:CBA1  68 CD               		dw	close
     205:  00:CBA3  68 CD               		dw	close		; destroy
     206:  00:CBA5  CF CC               		dw	read_byte
     207:  00:CBA7  E9 CC               		dw	read_block
     208:  00:CBA9  0B CD               		dw	write_byte
     209:  00:CBAB  2A CD               		dw	write_block
     210:  00:CBAD  4B CD               		dw	read_status
     211:  00:CBAF  5C CD               		dw	write_status
     212:  00:CBB1  5F CD               		dw	special
     213:  00:CBB3  62 CD               		dw	init
     214:  00:CBB5  67 CD               		dw	moved
     215:  00:CBB7                      ;
     216:  00:CBB7                      ;
     217:  00:CBB7  (00:0002)           TCP_SOCKET	equ	2
     218:  00:CBB7                      ;
     219:  00:CBB7                      ;
     220:  00:CBB7                      ;------------------------------------------------------------------------------
     221:  00:CBB7                      ;
     222:  00:CBB7                      ; tcp_open
     223:  00:CBB7                      ;
     224:  00:CBB7                      ; In:  DE->filename, length byte first. Could be zero length. Uppercase.
     225:  00:CBB7                      ;       C=unit number
     226:  00:CBB7                      tcp_open:
     227:  00:CBB7  FD E5               		push	iy
     228:  00:CBB9  FD 21 00 F0         		 ld	iy,vars
     229:  00:CBBD                      ;
     230:  00:CBBD  D5                  		 push	de		; Save->filename
     231:  00:CBBE  11 01 00            		  ld	de,channel	; Channel RAM required
     232:  00:CBC1                      		  EXOS	exos.FN_BUFF
     232:  00:CBC1  F7                >    rst 30H
     232:  00:CBC2  1B                >    db  n
     233:  00:CBC3  D1                  		 pop	de		; DE->filename
     234:  00:CBC4  20 26               		 jr	nz,.ret
     235:  00:CBC6                      ;
     236:  00:CBC6  21 11 F0            		 ld	hl,vars.device.ip
     237:  00:CBC9  CD 45 CF            		 call	util.get_ip_port; HL=port, vars.device.ip filled in
     238:  00:CBCC  9F                  		 sbc	a,a
     239:  00:CBCD  E6 6D               		 and	exos.ERR_BADIP
     240:  00:CBCF  20 1B               		 jr	nz,.ret
     241:  00:CBD1                      ;
     242:  00:CBD1  E5                  		 push	hl		; Save dest port
     243:  00:CBD2  3E 02               		  ld	a,TCP_SOCKET
     244:  00:CBD4  DD 77 FF            		  ld	(ix-1-channel.socket),a
     245:  00:CBD7  21 2A 00            		  ld	hl,42		; Source port
     246:  00:CBDA  11 7E CD            		  ld	de,tcp_owner_str; Our name
     247:  00:CBDD  CD 23 DD            		  call	tcp.open
     248:  00:CBE0  E1                  		 pop	hl		; HL=dest port
     249:  00:CBE1  11 11 F0            		 ld	de,vars.device.ip; DE->ip address
     250:  00:CBE4  3E 02               		 ld	a,TCP_SOCKET
     251:  00:CBE6  D4 32 DF            		 call	nc,tcp.connect
     252:  00:CBE9  9F                  		 sbc	a,a
     253:  00:CBEA  E6 6B               		 and	exos.ERR_NOCON
     254:  00:CBEC                      ;
     255:  00:CBEC  FD E1               .ret:		pop	iy
     256:  00:CBEE  C9                  		ret
     257:  00:CBEF                      ;
     258:  00:CBEF                      ;
     259:  00:CBEF                      ;------------------------------------------------------------------------------
     260:  00:CBEF                      ; tcp_create
     261:  00:CBEF                      ;
     262:  00:CBEF                      ; In:  DE->filename, length byte first. Could be zero length. Uppercase.
     263:  00:CBEF                      ;       C=unit number
     264:  00:CBEF                      tcp_create:
     265:  00:CBEF  D5                  		push	de		; Save->filename
     266:  00:CBF0  11 01 00            		 ld	de,channel	; Channel RAM required
     267:  00:CBF3                      		 EXOS	exos.FN_BUFF
     267:  00:CBF3  F7                >    rst 30H
     267:  00:CBF4  1B                >    db  n
     268:  00:CBF5  D1                  		pop	de		; DE->filename
     269:  00:CBF6  C0                  		ret	nz
     270:  00:CBF7                      ;
     271:  00:CBF7  DD 36 FF 02         		ld	(ix-1-channel.socket),TCP_SOCKET
     272:  00:CBFB  C9                  		ret
     273:  00:CBFC                      ;
     274:  00:CBFC                      ;
     275:  00:CBFC                      ;==============================================================================
     276:  00:CBFC                      ; HTTP DEVICE
     277:  00:CBFC                      ;
     278:  00:CBFC                      ; The HTTP device allows an EXOS user to eg OPEN #42:"HTTP:192.168.1.100/file"
     279:  00:CBFC                      ; to open a TCP link to the specified IP address and read the file.
     280:  00:CBFC                      ;
     281:  00:CBFC  00 00               		dw	0		; XX_NEXT 0=>no more devices in ROM
     282:  00:CBFE  FE FF               		dw	-2		; XX_RAM	No RAM required
     283:  00:CC00  00                  http_type:	db	0		; DD_TYPE
     284:  00:CC01  00                  		db	00h		; DD_IRQFLAG (50Hz)
     285:  00:CC02  00                  		db	0		; DD_FLAGS
     286:  00:CC03  0D 4C               		dw	http_entry-8000h; DD_TAB in page 1
     287:  00:CC05  00                  		db	0		; DD_TAB_SEG
     288:  00:CC06  00                  		db	0		; DD_UNIT_COUNT
     289:  00:CC07  04 48 54 54 50      		db	4,"HTTP"	; DD_NAME
     290:  00:CC0C  0C                  http_descriptor:db	$-http_type	; XX_SIZE
     291:  00:CC0D                      ;
     292:  00:CC0D  67 CD               http_entry:	dw	interrupt
     293:  00:CC0F  29 CC               		dw	http_open
     294:  00:CC11  5C CD               		dw	nofn		; Create
     295:  00:CC13  68 CD               		dw	close
     296:  00:CC15  68 CD               		dw	close		; Destroy
     297:  00:CC17  CF CC               		dw	read_byte
     298:  00:CC19  E9 CC               		dw	read_block
     299:  00:CC1B  5C CD               		dw	nofn		; write_byte
     300:  00:CC1D  5C CD               		dw	nofn		; write_block
     301:  00:CC1F  4B CD               		dw	read_status
     302:  00:CC21  5C CD               		dw	write_status
     303:  00:CC23  5F CD               		dw	special
     304:  00:CC25  62 CD               		dw	init
     305:  00:CC27  67 CD               		dw	moved
     306:  00:CC29                      ;
     307:  00:CC29                      ;
     308:  00:CC29                      ;------------------------------------------------------------------------------
     309:  00:CC29                      ;
     310:  00:CC29                      ; http_open
     311:  00:CC29                      ;
     312:  00:CC29                      ; In:  DE->filename, length byte first. Could be zero length. Uppercase.
     313:  00:CC29                      ;       C=unit number
     314:  00:CC29                      http_open:
     315:  00:CC29  FD E5               		push	iy
     316:  00:CC2B  FD 21 00 F0         		 ld	iy,vars
     317:  00:CC2F                      ;
     318:  00:CC2F  D5                  		 push	de		; Save->filename
     319:  00:CC30  11 03 00            		  ld	de,http.http_channel	; Channel RAM required
     320:  00:CC33                      		  EXOS	exos.FN_BUFF
     320:  00:CC33  F7                >    rst 30H
     320:  00:CC34  1B                >    db  n
     321:  00:CC35  D1                  		 pop	de		; DE->filename
     322:  00:CC36  20 38               		 jr	nz,.ret
     323:  00:CC38                      ;
     324:  00:CC38                      		 ; First skip leading /s to allow HTTP://...
     325:  00:CC38  1A                  		 ld	a,(de)		; Get length byte
     326:  00:CC39  47                  		 ld	b,a		; B=length byte
     327:  00:CC3A  04                  		 inc	b		; To skip initial dec b
     328:  00:CC3B  05                  .slash.loop:	 dec	b
     329:  00:CC3C  28 0A               		 jr	z,.slash.done
     330:  00:CC3E                      ;
     331:  00:CC3E  13                  		 inc	de
     332:  00:CC3F  1A                  		 ld	a,(de)
     333:  00:CC40  FE 2F               		 cp	'/'
     334:  00:CC42  28 F7               		 jr	z,.slash.loop
     335:  00:CC44  FE 5C               		 cp	"\\"
     336:  00:CC46  28 F3               		 jr	z,.slash.loop
     337:  00:CC48                      ;
     338:  00:CC48                      		 ; Save host name in vars.device.host
     339:  00:CC48  D5                  .slash.done:	 push	de		; Save->URL
     340:  00:CC49  C5                  		 push	bc		; Save length in B
     341:  00:CC4A  21 53 F0            		  ld	hl,vars.device.host	; Copy host name to here
     342:  00:CC4D  04                  		  inc	b
     343:  00:CC4E  18 0C               		  jr	.host.djnz
     344:  00:CC50                      
     345:  00:CC50  1A                  .host.loop:	  ld	a,(de)
     346:  00:CC51  13                  		  inc	de
     347:  00:CC52  FE 2F               		  cp	'/'
     348:  00:CC54  28 08               		  jr	z,.host.done
     349:  00:CC56  FE 5C               		  cp	"\\"
     350:  00:CC58  28 04               		  jr	z,.host.done
     351:  00:CC5A                      ;
     352:  00:CC5A  77                  		  ld	(hl),a
     353:  00:CC5B  23                  		  inc	hl
     354:  00:CC5C  10 F2               .host.djnz:	  djnz	.host.loop
     355:  00:CC5E                      ;
     356:  00:CC5E                      		  ;inc	b
     357:  00:CC5E                      .host.done:	  ;dec	b		; Skip /
     358:  00:CC5E  36 00               		  ld	(hl),0		; Null-terminate host name
     359:  00:CC60  C1                  		 pop	bc		; B=length of URL
     360:  00:CC61  D1                  		 pop	de		; DE->URL
     361:  00:CC62                      ;
     362:  00:CC62  21 11 F0            		 ld	hl,vars.device.ip	; Read IP address to here
     363:  00:CC65  CD 82 CF            		 call	util._get_ip	; vars.device.ip=IP; DE->filename, B=len
     364:  00:CC68  9F                  		 sbc	a,a
     365:  00:CC69  E6 6D               		 and	exos.ERR_BADIP
     366:  00:CC6B  20 03               		 jr	nz,.ret
     367:  00:CC6D                      ;
     368:  00:CC6D  CD 1B EC            		 call	http.device_open
     369:  00:CC70                      ;
     370:  00:CC70  FD E1               .ret:		pop	iy
     371:  00:CC72  C9                  		ret
     372:  00:CC73                      ;
     373:  00:CC73                      ;
     374:  00:CC73                      ;------------------------------------------------------------------------------
     375:  00:CC73                      ; http_create
     376:  00:CC73                      ;
     377:  00:CC73                      ; In:  DE->filename, length byte first. Could be zero length. Uppercase.
     378:  00:CC73                      ;       C=unit number
     379:  00:CC73                      http_create:
     380:  00:CC73  3E E7               		ld	a,exos.ERR_NOFN
     381:  00:CC75  C9                  		ret
     382:  00:CC76                      ;
     383:  00:CC76                      ;
     384:  00:CC76                      ;==============================================================================
     385:  00:CC76                      ; GENERAL DEVICE ROUTINES
     386:  00:CC76                      ;
     387:  00:CC76                      ; The follwoing routines are general EXOS device routines suitable for most
     388:  00:CC76                      ; of the EXOS devices we implement. But some devices may require different
     389:  00:CC76                      ; routines eg. FTP: close closes the FTP data channel, not the control channel.
     390:  00:CC76                      ;
     391:  00:CC76                      ; The socket number is saved in the first byte of channel RAM at (ix-1) which
     392:  00:CC76                      ; allows different devies to use common same code.
     393:  00:CC76                      ;
     394:  00:CC76                      ;
     395:  00:CC76                      ; block
     396:  00:CC76                      ;
     397:  00:CC76                      ; This function implements a device's read_block and write_block.
     398:  00:CC76                      ;	
     399:  00:CC76                      ; DE points to the user's buffer. The buffer could cross segment boundaries so
     400:  00:CC76                      ; we must split the read/write up into chunks and use the user's paging which is
     401:  00:CC76                      ; stored in EXOS's variable area. It could also be an odd number of bytes
     402:  00:CC76                      ; in length which is a pain for the 16-bit WIZ chip. In fact even if it's
     403:  00:CC76                      ; even in length, it could be an odd number of bytes to the end of the segment.
     404:  00:CC76                      ;
     405:  00:CC76                      ; Here the main loop just does the splitting up of the block into
     406:  00:CC76                      ; single-segment reads/writes. We leave it to the TCP code to handle odd
     407:  00:CC76                      ; lengths, multiple TCP fragments and flushing any final odd byte.
     408:  00:CC76                      ;
     409:  00:CC76                      ; In:  IX->EXOS channel RAM, channel.socket=socket number
     410:  00:CC76                      ;      HL->tcp.read_block or tcp.write block
     411:  00:CC76                      ;      DE->user's buffer
     412:  00:CC76                      ;      BC=byte count
     413:  00:CC76                      ; Out: Cy=>error, A=return code (see tcp.read_block/tcb.write_block)
     414:  00:CC76                      ;
     415:  00:CC76                      block:
     416:  00:CC76  CD B5 CE            		call	status.start	; Start activity indicator
     417:  00:CC79                      ;
     418:  00:CC79                      .loop:
     419:  00:CC79  78                  		ld	a,b	; See if byte count=0
     420:  00:CC7A  B1                  		or	c
     421:  00:CC7B  28 4C               		jr	z,.ret	; All done!
     422:  00:CC7D                      ;
     423:  00:CC7D  E5                  		push	hl	; Save read/write func
     424:  00:CC7E                      
     425:  00:CC7E  69                  		 ld	l,c
     426:  00:CC7F  60                  		 ld	h,b	; HL=user's byte count
     427:  00:CC80                      		 ; Negating (2s-complement) a segment offset gives us the
     428:  00:CC80                      		 ; remaining bytes to ffff; anding with 3f then gives us the
     429:  00:CC80                      		 ; remaining bytes to end of segment
     430:  00:CC80  7B                  		 ld	a,e
     431:  00:CC81  2F                  		 cpl
     432:  00:CC82  4F                  		 ld	c,a
     433:  00:CC83  7A                  		 ld	a,d
     434:  00:CC84  2F                  		 cpl
     435:  00:CC85  E6 3F               		 and	3fh	; Turn pointer into seg offset
     436:  00:CC87  47                  		 ld	b,a
     437:  00:CC88  03                  		 inc	bc	; BC=amount left in segment, ie propsed read
     438:  00:CC89                      ;
     439:  00:CC89  B7                  		 or	a	; So deduct from user's total byte count
     440:  00:CC8A  ED 42               		 sbc	hl,bc	; HL=updated user's byte count after read
     441:  00:CC8C  30 06               		 jr	nc,.bcok
     442:  00:CC8E                      ;
     443:  00:CC8E  09                  		 add	hl,bc	; Oops it went -ve so get back user's remainder
     444:  00:CC8F  4D                  		 ld	c,l
     445:  00:CC90  44                  		 ld	b,h	; BC=user's remainder size to read
     446:  00:CC91  B7                  		 or	a
     447:  00:CC92  ED 62               		 sbc	hl,hl	; User's byte count now 0
     448:  00:CC94                      .bcok:
     449:  00:CC94                      		; So now:
     450:  00:CC94                      		; HL=updated user's byte count, 0 if none left to read
     451:  00:CC94                      		; DE=user's buffer pointer not yet updated
     452:  00:CC94                      		; BC=read size
     453:  00:CC94  E3                  		ex	(sp),hl	; HL->read/write function, (SP)=updated  count
     454:  00:CC95  D5                  		 push	de	; Save user's current pointer
     455:  00:CC96  C5                  		 push	bc	; Save amount we're about to read/write
     456:  00:CC97                      ;
     457:  00:CC97  DD 7E FF            		  ld	a,(ix-1-channel.socket)	; Get socket #
     458:  00:CC9A  08                  		  ex	af,af	; Save socket number in A'
     459:  00:CC9B  DB B1               		  in	a,(ep.P1); Save our page 1 as that's where we do the read
     460:  00:CC9D  F5                  		  push	af
     461:  00:CC9E  E5                  		   push	hl	; Save read/write func
     462:  00:CC9F  7A                  		    ld	a,d	; Get user's buffer Hi
     463:  00:CCA0  07                  		    rlca
     464:  00:CCA1  07                  		    rlca
     465:  00:CCA2  E6 03               		    and	3	; A=z80 page 0-3
     466:  00:CCA4  C6 FC               		    add	a,LOW exos.USR_P0
     467:  00:CCA6  6F                  		    ld	l,a
     468:  00:CCA7  26 BF               		    ld	h,HIGH exos.USR_P0	; HL->user's page in EXOS var
     469:  00:CCA9  7E                  		    ld	a,(hl)
     470:  00:CCAA  D3 B1               		    out	(ep.P1),a; Put user's page corresponding to (DE) into P1
     471:  00:CCAC  7A                  		    ld	a,d	; Adjust user's pointer to be a P1 pointer
     472:  00:CCAD  E6 3F               		    and	3fh
     473:  00:CCAF  F6 40               		    or	40h
     474:  00:CCB1  57                  		    ld	d,a
     475:  00:CCB2  E1                  		   pop	hl	; HL->read or write func
     476:  00:CCB3                      ;
     477:  00:CCB3                      		   ; So now:
     478:  00:CCB3                      		   ; User's buffer is paged into page 1
     479:  00:CCB3                      		   ; DE->user's buffer adjusted to point in page 1
     480:  00:CCB3                      		   ; BC=amount to read
     481:  00:CCB3                      		   ; HL->read/write func to call
     482:  00:CCB3  78                  		   ld	a,b
     483:  00:CCB4  B1                  		   or	c
     484:  00:CCB5  E5                  		   push	hl	; Save read/write func
     485:  00:CCB6  28 04               		    jr	z,.skipjphl
     486:  00:CCB8  08                  		    ex	af,af	; Get back socket in A
     487:  00:CCB9  CD 8E C0            		    call jphl	; Read/write it
     488:  00:CCBC  08                  .skipjphl:	    ex	af,af	; Save error code
     489:  00:CCBD  D1                  		   pop	de	; DE=read/write func
     490:  00:CCBE  F1                  		  pop	af	; A=our P1
     491:  00:CCBF  D3 B1               		  out	(ep.P1),a	; Restore our paging
     492:  00:CCC1                      ;
     493:  00:CCC1  C1                  		 pop	bc	; BC=amount just read
     494:  00:CCC2  E1                  		 pop	hl	; HL=user's buffer
     495:  00:CCC3                      ;
     496:  00:CCC3  09                  		 add	hl,bc	; Update user's pointer
     497:  00:CCC4  EB                  		 ex	de,hl	; DE=updated user's buffer, HL=read/write func
     498:  00:CCC5  C1                  		pop	bc	; BC=updated user's byte count
     499:  00:CCC6  08                  		ex	af,af	; Get back error code
     500:  00:CCC7  30 B0               		jr	nc,.loop
     501:  00:CCC9                      ;
     502:  00:CCC9  F5                  .ret:		push	af
     503:  00:CCCA  CD A9 CE            	 	 call	status.stop		; Stop activity indicator
     504:  00:CCCD  F1                  		pop	af
     505:  00:CCCE  C9                  		ret
     506:  00:CCCF                      ;
     507:  00:CCCF                      ;
     508:  00:CCCF                      ;------------------------------------------------------------------------------
     509:  00:CCCF                      ; read_byte
     510:  00:CCCF                      ;
     511:  00:CCCF                      read_byte:
     512:  00:CCCF  FD E5               		push	iy
     513:  00:CCD1  FD 21 00 F0         		 ld	iy,vars
     514:  00:CCD5                      ;
     515:  00:CCD5  CD B5 CE            		 call	status.start		; Start activity indicator
     516:  00:CCD8                      ;
     517:  00:CCD8  11 0E F0            		 ld	de,vars.device.byte	; 1 byte buffer
     518:  00:CCDB  01 01 00            		 ld	bc,1			; Read 1 byte
     519:  00:CCDE  DD 7E FF            		 ld	a,(ix-1-channel.socket)	; Get socket #
     520:  00:CCE1  CD 6F DD            		 call	tcp.read_block		; Read 1 byte
     521:  00:CCE4  FD 46 0E            		 ld	b,(iy+vars.device._byte); Return 1 byte in B
     522:  00:CCE7                      ;
     523:  00:CCE7  18 0F               		 jr	read_ret
     524:  00:CCE9                      ;
     525:  00:CCE9                      ;
     526:  00:CCE9                      ;------------------------------------------------------------------------------
     527:  00:CCE9                      ; read_block
     528:  00:CCE9                      ;
     529:  00:CCE9                      ; In:  DE->buffer within user's paging
     530:  00:CCE9                      ;      BC=byte count, could be 0
     531:  00:CCE9                      ; Out: 
     532:  00:CCE9                      read_block:
     533:  00:CCE9  FD E5               		push	iy
     534:  00:CCEB  FD 21 00 F0         		 ld	iy,vars
     535:  00:CCEF                      ;
     536:  00:CCEF  CD B5 CE            		 call	status.start	; Start activity indicator
     537:  00:CCF2                      ;
     538:  00:CCF2  21 6F DD            		 ld	hl,tcp.read_block
     539:  00:CCF5  CD 76 CC            		 call	block
     540:  00:CCF8                      ;
     541:  00:CCF8  F5                  read_ret:	 push	af
     542:  00:CCF9  CD A9 CE            	 	  call	status.stop		; Stop activity indicator
     543:  00:CCFC  F1                  		 pop	af
     544:  00:CCFD                      ;
     545:  00:CCFD  FD E1               		pop	iy
     546:  00:CCFF  D0                  		ret	nc
     547:  00:CD00                      ;
     548:  00:CD00  D6 02               		sub	2
     549:  00:CD02  3E E4               		ld	a,exos.ERR_EOF
     550:  00:CD04  F8                  		ret	m		; Code 1=>socket closed
     551:  00:CD05                      ;
     552:  00:CD05  3E E5               		ld	a,exos.ERR_STOP
     553:  00:CD07  C8                  		ret	z		; Code 2=>STOP pressed
     554:  00:CD08                      ;
     555:  00:CD08  3E 6A               		ld	a,exos.ERR_TIMEOUT	; Code 3=>timeout
     556:  00:CD0A  C9                  		ret
     557:  00:CD0B                      ;;
     558:  00:CD0B                      ;
     559:  00:CD0B                      ;------------------------------------------------------------------------------
     560:  00:CD0B                      ; write_byte
     561:  00:CD0B                      ;
     562:  00:CD0B                      write_byte:
     563:  00:CD0B  FD E5               		push	iy
     564:  00:CD0D  FD 21 00 F0         		 ld	iy,vars
     565:  00:CD11                      ;
     566:  00:CD11  CD B5 CE            		 call	status.start	; Start activity indicator
     567:  00:CD14                      ;
     568:  00:CD14  11 0E F0            		 ld	de,vars.device.byte	; 1 byte buffer
     569:  00:CD17  78                  		 ld	a,b
     570:  00:CD18  12                  		 ld	(de),a
     571:  00:CD19  01 01 00            		 ld	bc,1
     572:  00:CD1C  DD 7E FF            		 ld	a,(ix-1-channel.socket)	; Get socket #
     573:  00:CD1F  CD 45 DE            		 call	tcp.write_block		; Write 1 byte
     574:  00:CD22  DD 7E FF            		 ld	a,(ix-1-channel.socket)	; Get socket #
     575:  00:CD25  D4 04 DF            		 call	nc,tcp.send
     576:  00:CD28  18 15               		 jr	writeret
     577:  00:CD2A                      ;;
     578:  00:CD2A                      ;
     579:  00:CD2A                      ;------------------------------------------------------------------------------
     580:  00:CD2A                      ; write_block
     581:  00:CD2A                      ;
     582:  00:CD2A                      ; In:  DE->buffer within user's paging
     583:  00:CD2A                      ;      BC=byte count, could be 0
     584:  00:CD2A                      write_block:
     585:  00:CD2A  FD E5               		push	iy
     586:  00:CD2C  FD 21 00 F0         		 ld	iy,vars
     587:  00:CD30                      ;
     588:  00:CD30  CD B5 CE            		 call	status.start	; Start activity indicator
     589:  00:CD33                      ;
     590:  00:CD33  21 45 DE            		 ld	hl,tcp.write_block
     591:  00:CD36  CD 76 CC            		 call	block
     592:  00:CD39  DD 7E FF            		 ld	a,(ix-1-channel.socket)	; Get socket #
     593:  00:CD3C  D4 04 DF            		 call	nc,tcp.send
     594:  00:CD3F                      ;
     595:  00:CD3F  9F                  writeret:	 sbc	a,a			; Cy->FF, NC->0
     596:  00:CD40  E6 6A               		 and	exos.ERR_TIMEOUT	; Cy->error code, 0 if no error
     597:  00:CD42  C0                  		 ret	nz
     598:  00:CD43                      ;
     599:  00:CD43  F5                  		 push	af
     600:  00:CD44  CD A9 CE            	 	  call	status.stop		; Stop activity indicator
     601:  00:CD47  F1                  		 pop	af
     602:  00:CD48  FD E1               		pop	iy
     603:  00:CD4A  C9                  		ret
     604:  00:CD4B                      ;
     605:  00:CD4B                      ;
     606:  00:CD4B                      ;------------------------------------------------------------------------------
     607:  00:CD4B                      ; read_status
     608:  00:CD4B                      ;
     609:  00:CD4B                      read_status:
     610:  00:CD4B  FD E5               		push	iy
     611:  00:CD4D  FD 21 00 F0         		 ld	iy,vars
     612:  00:CD51                      ;
     613:  00:CD51  DD 7E FF            		 ld	a,(ix-1-channel.socket)	; Get socket #
     614:  00:CD54  CD CF DE            		 call	tcp.status
     615:  00:CD57  4F                  		 ld	c,a		; 0=>char ready, FF=>EOF, 1=>no char
     616:  00:CD58  AF                  		 xor	a		; No error
     617:  00:CD59  FD E1               		pop	iy
     618:  00:CD5B  C9                  		ret
     619:  00:CD5C                      ;
     620:  00:CD5C                      ;
     621:  00:CD5C                      ;------------------------------------------------------------------------------
     622:  00:CD5C                      ; write_status
     623:  00:CD5C                      ;
     624:  00:CD5C                      write_status:
     625:  00:CD5C                      nofn:
     626:  00:CD5C  3E E7               		ld	a,exos.ERR_NOFN
     627:  00:CD5E  C9                  		ret
     628:  00:CD5F                      ;
     629:  00:CD5F                      ;
     630:  00:CD5F                      ;------------------------------------------------------------------------------
     631:  00:CD5F                      ; special
     632:  00:CD5F                      ;
     633:  00:CD5F                      special:
     634:  00:CD5F  3E E7               		ld	a,exos.ERR_NOFN
     635:  00:CD61  C9                  		ret
     636:  00:CD62                      ;
     637:  00:CD62                      ;
     638:  00:CD62                      ;------------------------------------------------------------------------------
     639:  00:CD62                      ; init
     640:  00:CD62                      ;
     641:  00:CD62  AF                  init:		xor	a
     642:  00:CD63  32 03 F0            		ld	(vars.init),a		; Pretend not initialised
     643:  00:CD66  C9                  		ret
     644:  00:CD67                      ;
     645:  00:CD67                      ;
     646:  00:CD67                      ;------------------------------------------------------------------------------
     647:  00:CD67                      ; moved
     648:  00:CD67                      ;
     649:  00:CD67                      moved:
     650:  00:CD67                      interrupt:
     651:  00:CD67  C9                  		ret
     652:  00:CD68                      ;
     653:  00:CD68                      ;
     654:  00:CD68                      ;------------------------------------------------------------------------------
     655:  00:CD68                      ; close
     656:  00:CD68                      ;
     657:  00:CD68                      close:
     658:  00:CD68  FD E5               		push	iy
     659:  00:CD6A  FD 21 00 F0         		 ld	iy,vars
     660:  00:CD6E                      ;		 
     661:  00:CD6E  CD B5 CE            		 call	status.start
     662:  00:CD71                      ;
     663:  00:CD71  DD 7E FF            		 ld	a,(ix-1-channel.socket)	; Get socket #
     664:  00:CD74  CD 73 DF            		 call	tcp.close	; Close it
     665:  00:CD77                      ;
     666:  00:CD77  CD A9 CE            		 call	status.stop
     667:  00:CD7A                      ;
     668:  00:CD7A  AF                  		 xor	a		; No error
     669:  00:CD7B  FD E1               		pop	iy
     670:  00:CD7D  C9                  		ret
     671:  00:CD7E                      ;
     672:  00:CD7E                      ;
     673:  00:CD7E  54 43 50 3A         tcp_owner_str:	db	"TCP:"
     674:  00:CD82                      ;
     675:  00:CD82                      ;
     676:  00:CD82                      ;
     677:  00:CD82                      		endmodule
      96.  00:CD82                      	include io.asm
       1:  00:CD82                      ; IO
       2:  00:CD82                      ;
       3:  00:CD82                      ; Various utillity functions to do I/O
       4:  00:CD82                      ;
       5:  00:CD82                      		module io
       6:  00:CD82                      ;
       7:  00:CD82                      ;==============================================================================
       8:  00:CD82                      ;
       9:  00:CD82                      ; This file is part of the EPNET software
      10:  00:CD82                      ;
      11:  00:CD82                      ; Copyright (C) 2015  Bruce Tanner
      12:  00:CD82                      ;
      13:  00:CD82                      ;    This program is free software: you can redistribute it and/or modify
      14:  00:CD82                      ;    it under the terms of the GNU General Public License as published by
      15:  00:CD82                      ;    the Free Software Foundation, either version 3 of the License, or
      16:  00:CD82                      ;    (at your option) any later version.
      17:  00:CD82                      ;
      18:  00:CD82                      ;    This program is distributed in the hope that it will be useful,
      19:  00:CD82                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      20:  00:CD82                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      21:  00:CD82                      ;    GNU General Public License for more details.
      22:  00:CD82                      ;
      23:  00:CD82                      ;    You should have received a copy of the GNU General Public License
      24:  00:CD82                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      25:  00:CD82                      ;
      26:  00:CD82                      ; If you do use or modify this file, either for its original purpose or for
      27:  00:CD82                      ; something new, I'd love to hear about it! I can be contacted by email at:
      28:  00:CD82                      ;
      29:  00:CD82                      ; brucetanner@btopenworld.com
      30:  00:CD82                      ;
      31:  00:CD82                      ;==============================================================================
      32:  00:CD82                      ;
      33:  00:CD82  (00:000D)           @CR		equ	13
      34:  00:CD82  (00:000A)           @LF		equ	10
      35:  00:CD82                      ;
      36:  00:CD82                      ;
      37:  00:CD82                      ;------------------------------------------------------------------------------
      38:  00:CD82                      ; mac
      39:  00:CD82                      ;
      40:  00:CD82                      ; Outputs a MAC address at (HL) in ASCII
      41:  00:CD82                      ;
      42:  00:CD82  06 06               mac:		ld	b,6
      43:  00:CD84                      ;
      44:  00:CD84  7E                  .loop:		ld	a,(HL)
      45:  00:CD85  23                  		inc	hl
      46:  00:CD86  CD ED CD            		call	io.byte
      47:  00:CD89  10 F9               		djnz	.loop
      48:  00:CD8B                      ;
      49:  00:CD8B  C9                  		ret
      50:  00:CD8C                      ;
      51:  00:CD8C                      ;
      52:  00:CD8C                      ;------------------------------------------------------------------------------
      53:  00:CD8C                      ; ip
      54:  00:CD8C                      ;
      55:  00:CD8C                      ; Outputs an IP address
      56:  00:CD8C                      ;
      57:  00:CD8C                      ; In:  HL->IP address
      58:  00:CD8C                      ;
      59:  00:CD8C  CD 9A CD            ip:		call	.num
      60:  00:CD8F  CD 95 CD            		call	.dotnum
      61:  00:CD92  CD 95 CD            		call	.dotnum
      62:  00:CD95  3E 2E               .dotnum:	ld	a,'.'
      63:  00:CD97  CD 00 CE            		call	io.char
      64:  00:CD9A  7E                  .num:		ld	a,(hl)
      65:  00:CD9B  23                  		inc	hl
      66:  00:CD9C  E5                  		push	hl
      67:  00:CD9D  CD AE CD            		 call	io.short
      68:  00:CDA0  E1                  		pop	hl
      69:  00:CDA1  C9                  		ret
      70:  00:CDA2                      ;
      71:  00:CDA2                      ;
      72:  00:CDA2                      ;------------------------------------------------------------------------------
      73:  00:CDA2                      ; ip_port
      74:  00:CDA2                      ;
      75:  00:CDA2                      ; Outputs an IP address and port number
      76:  00:CDA2                      ;
      77:  00:CDA2                      ; In:  HL->IP address
      78:  00:CDA2                      ;      BC=port no
      79:  00:CDA2                      ;
      80:  00:CDA2  C5                  ip_port:	push	bc		; Save port #
      81:  00:CDA3  CD 8C CD            		 call	ip		; Output IP address
      82:  00:CDA6  3E 3A               		 ld	a,':'
      83:  00:CDA8  CD 00 CE            		 call	char
      84:  00:CDAB  E1                  		pop	hl		; HL=port #
      85:  00:CDAC  18 03               		jr	int		; Output it
      86:  00:CDAE                      ;
      87:  00:CDAE                      ;
      88:  00:CDAE                      ;------------------------------------------------------------------------------
      89:  00:CDAE                      ; short, int
      90:  00:CDAE                      ;
      91:  00:CDAE                      ; Outputs a byte or a word in decimal
      92:  00:CDAE                      ;
      93:  00:CDAE                      ; In:  short: A=byte to output; int: HL=word to output
      94:  00:CDAE                      ; Out: B preserved, HL, DE, C, AF corrupted
      95:  00:CDAE                      ;
      96:  00:CDAE  6F                  short:		ld	l,a	; Just convert to 16-bit value in HL
      97:  00:CDAF  26 00               		ld	h,0
      98:  00:CDB1                      ;
      99:  00:CDB1  CB 81               int:		res	0,c	; 0=>no output yet (for leading 0 supression)
     100:  00:CDB3  11 10 27            		ld	de,10000
     101:  00:CDB6  CD D0 CD            		call	.divout	; Output 10,000s
     102:  00:CDB9  11 E8 03            		ld	de,1000
     103:  00:CDBC  CD D0 CD            		call	.divout	; Output 1,000s
     104:  00:CDBF  11 64 00            		ld	de,100
     105:  00:CDC2  CD D0 CD            		call	.divout	; Output 100s
     106:  00:CDC5  11 0A 00            		ld	de,10
     107:  00:CDC8  CD D0 CD            		call	.divout	; Output 10s
     108:  00:CDCB  11 01 00            		ld	de,1
     109:  00:CDCE  CB C1               		set	0,c	; Output 1s with leading 0s in case first 0
     110:  00:CDD0  CD DE CD            .divout:	call	.div16	; C=ASCII dividend, HL=remainder
     111:  00:CDD3  FE 30               		cp	'0'
     112:  00:CDD5  20 03               		jr	nz,.out	; Always output if not 0
     113:  00:CDD7                      ;
     114:  00:CDD7  CB 41               		bit	0,c	; Else only output if not first digit
     115:  00:CDD9  C8                  		ret	z
     116:  00:CDDA                      ;
     117:  00:CDDA  CB C1               .out:		set	0,c	; Output a digit so don't supress 0s now
     118:  00:CDDC  18 22               		jr	char
     119:  00:CDDE                      ;
     120:  00:CDDE                      ;
     121:  00:CDDE                      ;
     122:  00:CDDE                      ; HL<-remainder of HL/DE, A<-quotient in ASCII
     123:  00:CDDE  3E 2F               .div16:		ld	a,'0'-1		; -1 for first time round loop
     124:  00:CDE0  B7                  		or	a		; Loop operates with NC
     125:  00:CDE1  3C                  .loop:		inc	a
     126:  00:CDE2  ED 52               		sbc	hl,de
     127:  00:CDE4  30 FB               		jr	nc,.loop
     128:  00:CDE6                      ;
     129:  00:CDE6  19                  		add	hl,de		; Restore value from last iteration
     130:  00:CDE7  C9                  		ret
     131:  00:CDE8                      ;
     132:  00:CDE8                      ;
     133:  00:CDE8                      ;------------------------------------------------------------------------------
     134:  00:CDE8                      ; word, byte, char
     135:  00:CDE8                      ;
     136:  00:CDE8                      ; Outputs HL in hex, A in hex and A as a character respectively. Only AF
     137:  00:CDE8                      ; corrupted
     138:  00:CDE8                      ;
     139:  00:CDE8  7C                  word:		ld	a,h
     140:  00:CDE9  CD ED CD            		call	byte
     141:  00:CDEC  7D                  		ld	a,l
     142:  00:CDED                      		    ;
     143:  00:CDED                      		    ;
     144:  00:CDED                      		    ;
     145:  00:CDED                      ;
     146:  00:CDED  F5                  byte:		push	af
     147:  00:CDEE  0F                  		rrca
     148:  00:CDEF  0F                  		rrca
     149:  00:CDF0  0F                  		rrca
     150:  00:CDF1  0F                  		rrca
     151:  00:CDF2  CD F6 CD            		call	nib
     152:  00:CDF5  F1                  		pop	af
     153:  00:CDF6                      		   ;
     154:  00:CDF6                      		   ;
     155:  00:CDF6                      		   ;
     156:  00:CDF6                      ;
     157:  00:CDF6  E6 0F               nib:		and	0fh
     158:  00:CDF8  C6 30               		add	a,'0'
     159:  00:CDFA  FE 3A               		cp	'9'+1
     160:  00:CDFC  38 02               		jr	c,.nothex
     161:  00:CDFE                      ;
     162:  00:CDFE  C6 07               		add	a,'A'-'9'-1
     163:  00:CE00                      .nothex:
     164:  00:CE00                      		    ;
     165:  00:CE00                      		    ;
     166:  00:CE00                      		    ;
     167:  00:CE00                      ;
     168:  00:CE00  F5                  char:		push	af
     169:  00:CE01  C5                  		push	bc
     170:  00:CE02  D5                  		push	de
     171:  00:CE03  E5                  		push	hl
     172:  00:CE04  47                  		 ld	b,a
     173:  00:CE05  FE 0D               		 cp	CR
     174:  00:CE07  28 04               		 jr	z,.col0
     175:  00:CE09                      ;
     176:  00:CE09  FE 0A               		 cp	LF
     177:  00:CE0B  20 04               		 jr	nz,.notcol0
     178:  00:CE0D                      ;
     179:  00:CE0D  FD 36 05 FF         .col0:		 ld	(iy+vars._io.col),-1	; Will inc to 0		
     180:  00:CE11  FD 34 05            .notcol0:	 inc	(iy+vars._io.col)	; Next column
     181:  00:CE14  3E FF               		 ld	a,0ffh	; Default channel
     182:  00:CE16                      		 EXOS	exos.FN_WRCH
     182:  00:CE16  F7                >    rst 30H
     182:  00:CE17  07                >    db  n
     183:  00:CE18  E1                  		pop	hl
     184:  00:CE19  D1                  		pop	de
     185:  00:CE1A  C1                  		pop	bc
     186:  00:CE1B  F1                  		pop	af
     187:  00:CE1C  C9                  		ret
     188:  00:CE1D                      ;
     189:  00:CE1D                      ;
     190:  00:CE1D                      ;------------------------------------------------------------------------------
     191:  00:CE1D                      ;
     192:  00:CE1D  CD 3D CE            ipcrlf:		call	str
     193:  00:CE20  CD 8C CD            		call	ip
     194:  00:CE23                      ;
     195:  00:CE23  3A 05 F0            start:		ld	a,(vars.io.col)
     196:  00:CE26  B7                  		or	a
     197:  00:CE27  C8                  		ret	z
     198:  00:CE28                      ;
     199:  00:CE28  3E 0D               crlf:		ld	a,CR
     200:  00:CE2A  CD 00 CE            		call	char
     201:  00:CE2D  3E 0A               		ld	a,LF
     202:  00:CE2F  18 CF               		jr	char
     203:  00:CE31                      ;
     204:  00:CE31                      ;
     205:  00:CE31  3E 20               space:		ld	a,' '
     206:  00:CE33  18 CB               		jr	char
     207:  00:CE35                      ;
     208:  00:CE35                      ;
     209:  00:CE35  3E 09               tab:		ld	a,"\t"
     210:  00:CE37  18 C7               		jr	char
     211:  00:CE39                      ;
     212:  00:CE39                      ;
     213:  00:CE39                      ;------------------------------------------------------------------------------
     214:  00:CE39                      ; str
     215:  00:CE39                      ;
     216:  00:CE39                      ; Outputs a null-terminated string at (DE).
     217:  00:CE39                      ;
     218:  00:CE39                      ; line
     219:  00:CE39                      ;
     220:  00:CE39                      ; Outputs a LF-terminated string at (DE).
     221:  00:CE39                      ;
     222:  00:CE39                      ; In:  DE->string
     223:  00:CE39                      ; Out: DE->next string (if LF-terminated) or null
     224:  00:CE39                      ;      BC and AF corrupted.
     225:  00:CE39                      ;      HL preserved
     226:  00:CE39                      ;
     227:  00:CE39  06 0A               line:		ld	b,LF		; Stop at LF
     228:  00:CE3B  18 02               		jr	_str
     229:  00:CE3D                      
     230:  00:CE3D  06 00               str:		ld	b,0
     231:  00:CE3F  E5                  _str:		push	hl
     232:  00:CE40  D5                  		push	de		; Save ->start of string
     233:  00:CE41  68                  		 ld	l,b		; L=string terminator
     234:  00:CE42  01 FF FF            		 ld	bc,-1		; Zero length counter
     235:  00:CE45  18 07               		 jr	.start
     236:  00:CE47                      ;
     237:  00:CE47  FD 36 05 FF         .col0:		 ld	(iy+vars._io.col),-1	; Will inc to 0		
     238:  00:CE4B  FD 34 05            .loop:		 inc	(iy+vars._io.col)	; Next column
     239:  00:CE4E  1A                  .start:		 ld	a,(de)
     240:  00:CE4F  13                  		 inc	de
     241:  00:CE50  03                  		 inc	bc
     242:  00:CE51  FE 0D               		 cp	CR
     243:  00:CE53  28 F2               		 jr	z,.col0
     244:  00:CE55                      ;
     245:  00:CE55  BD                  		 cp	l
     246:  00:CE56  28 08               		 jr	z,.end
     247:  00:CE58                      ;
     248:  00:CE58  FE 0A               		 cp	LF
     249:  00:CE5A  28 EB               		 jr	z,.col0
     250:  00:CE5C                      ;
     251:  00:CE5C  B7                  		 or	a
     252:  00:CE5D  20 EC               		 jr	nz,.loop
     253:  00:CE5F                      ;
     254:  00:CE5F  1B                  		 dec	de		; Point back to null
     255:  00:CE60  EB                  .end:		 ex	de,hl		; HL->end of string, DE=caller's HL
     256:  00:CE61  E3                  		ex	(sp),hl		; (SP)->end of string, HL->start
     257:  00:CE62  EB                  		 ex	de,hl		; DE->start of string, HL->caller's HL
     258:  00:CE63                      ;
     259:  00:CE63  3E FF               		 ld	a,0ffh		; Default EXOS channel
     260:  00:CE65                      		 EXOS	exos.FN_WRBLK
     260:  00:CE65  F7                >    rst 30H
     260:  00:CE66  08                >    db  n
     261:  00:CE67                      ;
     262:  00:CE67  D1                  		pop	de		; DE->end of string
     263:  00:CE68  E1                  		pop	hl
     264:  00:CE69  C9                  		ret
     265:  00:CE6A                      ;
     266:  00:CE6A                      ;
     267:  00:CE6A                      ;------------------------------------------------------------------------------
     268:  00:CE6A                      ; cols
     269:  00:CE6A                      ;
     270:  00:CE6A                      ; Returns the number of display cols 
     271:  00:CE6A                      ;
     272:  00:CE6A                      ; We only output to the default channel so to find the number of cols we do a
     273:  00:CE6A                      ; video "special function" call to each channel in turn until we get a non-error
     274:  00:CE6A                      ; return, and assume this is the correct answer!
     275:  00:CE6A                      ;
     276:  00:CE6A                      ; Obviously this is a relatively time consuming process so the caller should
     277:  00:CE6A                      ; do it once (or at least infrequently) and save the result.
     278:  00:CE6A                      ;
     279:  00:CE6A                      ; It's not a 100% reliable method as there could be multiple video channels
     280:  00:CE6A                      ; which may or may not be actually displayed. But iof we find *any* 80 column
     281:  00:CE6A                      ; channels then we assume 80, otherwise 40.
     282:  00:CE6A                      ;
     283:  00:CE6A                      ; Out:  A=number of cols on display
     284:  00:CE6A                      ;      HL preserved
     285:  00:CE6A                      ;
     286:  00:CE6A  06 00               cols:		ld	b,0		; B=initial channel #
     287:  00:CE6C  78                  .loop:		ld	a,b		; Get channel
     288:  00:CE6D  C5                  		push	bc		; Save channel
     289:  00:CE6E  06 02               		 ld	b,exos.FN_VID_SIZE	; Return video: page size & mode
     290:  00:CE70                      		 EXOS	exos.FN_SFUNC
     290:  00:CE70  F7                >    rst 30H
     290:  00:CE71  0B                >    db  n
     291:  00:CE72  78                  		 ld	a,b		; A=# cols
     292:  00:CE73  C1                  		pop	bc		; B=channel
     293:  00:CE74  20 03               		jr	nz,.next	; Go if error (no a video channel)
     294:  00:CE76                      ;
     295:  00:CE76  FE 50               		cp	80		; No error, so we've found a vid chan
     296:  00:CE78  D0                  		ret	nc		; Return if 80 (or above!) cols
     297:  00:CE79                      ;
     298:  00:CE79  10 F1               .next:		djnz	.loop		; Try next channel
     299:  00:CE7B                      ;
     300:  00:CE7B  3E 28               		ld	a,40		; Default to 40 if no 80 col channels
     301:  00:CE7D  C9                  		ret
     302:  00:CE7E                      ;
     303:  00:CE7E                      ;
     304:  00:CE7E                      ;------------------------------------------------------------------------------
     305:  00:CE7E                      ; input
     306:  00:CE7E                      ;
     307:  00:CE7E                      ; Gets a line of input from the user.
     308:  00:CE7E                      ;
     309:  00:CE7E                      ; In:  DE->prompt string
     310:  00:CE7E                      ;      HL->buffer for input
     311:  00:CE7E                      ;       C=max length
     312:  00:CE7E                      ; Out: Cy if error
     313:  00:CE7E                      ;          buffer contains input, length byte first
     314:  00:CE7E                      ;
     315:  00:CE7E                      input:
     316:  00:CE7E  C5                  		push	bc	; Save max length
     317:  00:CE7F  CD 3D CE            		 call	str	; Print prompt
     318:  00:CE82                      ;
     319:  00:CE82                      		 ; Set EXOS editor flags to not return the prompt
     320:  00:CE82  01 20 01            		 ld	bc,1*256+exos.VAR_FLG_EDIT	; B=1=>write, C=var no.
     321:  00:CE85  16 18               		 ld	d,18h	; D= flags (NO_SOFT, NO_PROMPT)
     322:  00:CE87                      		 EXOS	exos.FN_EVAR
     322:  00:CE87  F7                >    rst 30H
     322:  00:CE88  10                >    db  n
     323:  00:CE89                      ;
     324:  00:CE89  C1                  		pop	bc	; C=max length
     325:  00:CE8A  06 00               		ld	b,0	; B=current length
     326:  00:CE8C                      ;
     327:  00:CE8C  E5                  		push	hl	; Save -> start of buffer
     328:  00:CE8D  23                  		 inc	hl	; Point passed length byte
     329:  00:CE8E  3E FF               .loop:		 ld	a,0ffh	; Read a char from EXOS default channel
     330:  00:CE90  C5                  		 push	bc
     331:  00:CE91                      		  EXOS	exos.FN_RDCH
     331:  00:CE91  F7                >    rst 30H
     331:  00:CE92  05                >    db  n
     332:  00:CE93  78                  		  ld	a,b	; Get char
     333:  00:CE94  C1                  		 pop	bc	; BC=count and limit
     334:  00:CE95  37                  		 scf
     335:  00:CE96  20 0E               		 jr	nz,.end	; Error
     336:  00:CE98                      ;
     337:  00:CE98  FE 0D               		 cp	CR	; End of input line?
     338:  00:CE9A  28 0A               		 jr	z,.end	; Go if yes
     339:  00:CE9C                      ;
     340:  00:CE9C  77                  .notcr:		 ld	(hl),a	; Save char
     341:  00:CE9D  78                  		 ld	a,b
     342:  00:CE9E  3C                  		 inc	a
     343:  00:CE9F  B9                  		 cp	c	; Max chars reached?
     344:  00:CEA0  28 EC               		 jr	z,.loop	; Ignore char if yes
     345:  00:CEA2                      ;
     346:  00:CEA2  47                  		 ld	b,a	; Save inc'd length
     347:  00:CEA3  23                  		 inc	hl	; Next buffer pos next time
     348:  00:CEA4  18 E8               		 jr	.loop
     349:  00:CEA6                      ;
     350:  00:CEA6  E1                  .end:		pop	hl	; HL-> start of buffer
     351:  00:CEA7  70                  		ld	(hl),b	; Length byte
     352:  00:CEA8  C9                  		ret
     353:  00:CEA9                      ;
     354:  00:CEA9                      ;
     355:  00:CEA9                      		endmodule
      97.  00:CEA9                      	include status.asm
       1:  00:CEA9                      ; STATUS
       2:  00:CEA9                      ;
       3:  00:CEA9                      ; This module provides routines for controlling the status line activity 
       4:  00:CEA9                      ; display.
       5:  00:CEA9                      ;
       6:  00:CEA9                      		module	status
       7:  00:CEA9                      ;
       8:  00:CEA9                      ;==============================================================================
       9:  00:CEA9                      ;
      10:  00:CEA9                      ; This file is part of the EPNET software
      11:  00:CEA9                      ;
      12:  00:CEA9                      ; Copyright (C) 2015  Bruce Tanner
      13:  00:CEA9                      ;
      14:  00:CEA9                      ;    This program is free software: you can redistribute it and/or modify
      15:  00:CEA9                      ;    it under the terms of the GNU General Public License as published by
      16:  00:CEA9                      ;    the Free Software Foundation, either version 3 of the License, or
      17:  00:CEA9                      ;    (at your option) any later version.
      18:  00:CEA9                      ;
      19:  00:CEA9                      ;    This program is distributed in the hope that it will be useful,
      20:  00:CEA9                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      21:  00:CEA9                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      22:  00:CEA9                      ;    GNU General Public License for more details.
      23:  00:CEA9                      ;
      24:  00:CEA9                      ;    You should have received a copy of the GNU General Public License
      25:  00:CEA9                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      26:  00:CEA9                      ;
      27:  00:CEA9                      ; If you do use or modify this file, either for its original purpose or for
      28:  00:CEA9                      ; something new, I'd love to hear about it! I can be contacted by email at:
      29:  00:CEA9                      ;
      30:  00:CEA9                      ; brucetanner@btopenworld.com
      31:  00:CEA9                      ;
      32:  00:CEA9                      ;==============================================================================
      33:  00:CEA9                      ;
      34:  00:CEA9                      ; "waiting" is indicated by an alternating large and small blue blob.
      35:  00:CEA9                      ; Network "activity" is indicated by the blob turning red.
      36:  00:CEA9                      ;
      37:  00:CEA9  (00:0027)           STATUS_POS	equ	39		; Position on status line of indicator
      38:  00:CEA9                      ;
      39:  00:CEA9  (00:001F)           STATUS_BLOB_L	equ	1fh		; Char used for big blob
      40:  00:CEA9  (00:000E)           STATUS_BLOB_S	equ	0eh		; Char used for small blob
      41:  00:CEA9                      ;
      42:  00:CEA9  (00:0010)           DELAY		equ	16		; Time in ticks before status flashing
      43:  00:CEA9                      ;
      44:  00:CEA9                      ;
      45:  00:CEA9                      ;------------------------------------------------------------------------------
      46:  00:CEA9                      ; start & stop
      47:  00:CEA9                      ;
      48:  00:CEA9                      ; Starts & stops the status line display. (Saves the current char on the
      49:  00:CEA9                      ; bit of the status line we use)
      50:  00:CEA9                      ;
      51:  00:CEA9                      ;  stop: restores the status line under the blob immediately.
      52:  00:CEA9                      ; start: starts the flashing blob but after a shot delay. This rtesults in a
      53:  00:CEA9                      ;        cleaner display, and brief operations do not even show a blob.
      54:  00:CEA9                      ;
      55:  00:CEA9                      ; Out:  Only AF corrupted
      56:  00:CEA9                      ;
      57:  00:CEA9                      stop:
      58:  00:CEA9  E5                  		push	hl			; Save caller's HL
      59:  00:CEAA  21 0D F0            		 ld	hl,vars.status.byte	; HL->saved status line char
      60:  00:CEAD  7E                  		 ld	a,(hl)			; Get saved byte
      61:  00:CEAE  36 00               		 ld	(hl),0			; Not waiting now
      62:  00:CEB0  E1                  		pop	hl			; HL=caller's HL
      63:  00:CEB1  B7                  		or	a
      64:  00:CEB2  20 21               		jr	nz,blob			; Put it back
      65:  00:CEB4                      ;
      66:  00:CEB4  C9                  		ret
      67:  00:CEB5                      ;
      68:  00:CEB5                      start:
      69:  00:CEB5  E5                  		push	hl			; Save caller's HL
      70:  00:CEB6  2A F6 BF            		 ld	hl,(exos.ST_POINTER)	; HL->status line
      71:  00:CEB9  7D                  		 ld	a,l
      72:  00:CEBA  C6 27               		 add	a,STATUS_POS
      73:  00:CEBC  6F                  		 ld	l,a			; HL->our position on status line
      74:  00:CEBD  22 0B F0            		 ld	(vars.status.pos),hl	; Save it for efficiency
      75:  00:CEC0                      ;
      76:  00:CEC0  7E                  		 ld	a,(hl)			; Get current char there
      77:  00:CEC1  32 0D F0            		 ld	(vars.status.byte),a	; Save it
      78:  00:CEC4                      ;
      79:  00:CEC4  FD 36 0A 00         		 ld	(iy+vars.status._ticks),0; Zero ticks so blob
      80:  00:CEC8  E1                  		pop	hl			;   not show initially
      81:  00:CEC9  C9                  		ret
      82:  00:CECA                      ;
      83:  00:CECA                      ;
      84:  00:CECA                      ; waiting
      85:  00:CECA                      ;
      86:  00:CECA                      ; Shows the "waiting" indicator on the status line. (blue blob).
      87:  00:CECA                      ;
      88:  00:CECA                      ; This is called repeatedly in wait loops, and uses the interrupt tick counter
      89:  00:CECA                      ; to alternate the blue blob between small and large blob.
      90:  00:CECA                      ;
      91:  00:CECA                      ; Out:  Only AF corrupted
      92:  00:CECA                      ;
      93:  00:CECA                      waiting:
      94:  00:CECA  3A 0D F0            		ld	a,(vars.status.byte)	; See if status.start called
      95:  00:CECD  B7                  		or	a
      96:  00:CECE  C8                  		ret	z			; Do nothing if not
      97:  00:CECF                      ;
      98:  00:CECF  3A 0A F0            		ld	a,(vars.status.ticks)	; A=interrupt tick count
      99:  00:CED2  FE 10               		cp	DELAY			; Time to flash blob?
     100:  00:CED4  D8                  		ret	c			; Return if not
     101:  00:CED5                      ;
     102:  00:CED5                      		; Here Cy=>red, NC=>blue blob
     103:  00:CED5  9F                  blob:		sbc	a,a			; A= Cy=>FF, NC=>0
     104:  00:CED6  E6 80               		and	80h			; A=80h (red) or 0 (blue)
     105:  00:CED8  F6 0E               		or	STATUS_BLOB_S		; Assume small blob
     106:  00:CEDA  FD CB 0A 5E         		bit	3,(iy+vars.status._ticks); Time for big blob? (~1/4 sec)
     107:  00:CEDE  20 02               		jr	nz,blob_char		; Go with A=small blob if not
     108:  00:CEE0                      ;
     109:  00:CEE0  EE 11               		xor	STATUS_BLOB_L xor STATUS_BLOB_S	; Toggle to big blob
     110:  00:CEE2  E5                  blob_char:	push	hl			; Save caller's HL
     111:  00:CEE3  2A 0B F0            		 ld	hl,(vars.status.pos)	; HL->our position on status line
     112:  00:CEE6  77                  		 ld	(hl),a			; Put big or small blob there
     113:  00:CEE7  E1                  		pop	hl			; HL=caller's HL
     114:  00:CEE8  C9                  		ret
     115:  00:CEE9                      ;
     116:  00:CEE9                      ;
     117:  00:CEE9                      ; activity
     118:  00:CEE9                      ;
     119:  00:CEE9                      ; Shows the "activity" indicator on the status line. (Red blob).
     120:  00:CEE9                      ;
     121:  00:CEE9                      ; It is called at the start of the low-level WIZ FIFO reading and writing loops
     122:  00:CEE9                      ; and displays a red blob immediately. It might be thus called without
     123:  00:CEE9                      ; status.start being called first, in which case it does nothing.
     124:  00:CEE9                      ;
     125:  00:CEE9                      ; Out:  Only AF corrupted
     126:  00:CEE9                      ;
     127:  00:CEE9                      activity:
     128:  00:CEE9  3A 0D F0            		ld	a,(vars.status.byte)	; See if status.start called
     129:  00:CEEC  B7                  		or	a
     130:  00:CEED  C8                  		ret	z			; Do nothing if not
     131:  00:CEEE                      ;
     132:  00:CEEE  37                  		scf				; Cy=>red blob
     133:  00:CEEF  18 E4               		jr	blob
     134:  00:CEF1                      ;
     135:  00:CEF1                      ;
     136:  00:CEF1                      inactivity:
     137:  00:CEF1  3A 0D F0            		ld	a,(vars.status.byte)	; See if status.start called
     138:  00:CEF4  B7                  		or	a
     139:  00:CEF5  C8                  		ret	z			; Do nothing if not
     140:  00:CEF6                      ;
     141:  00:CEF6  18 D2               		jr	waiting			; Remove red blob
     142:  00:CEF8                      ;
     143:  00:CEF8                      ;
     144:  00:CEF8                      ;
     145:  00:CEF8                      		endmodule
      98.  00:CEF8                      	include	util.asm
       1:  00:CEF8                      ; UTIL
       2:  00:CEF8                      ;
       3:  00:CEF8                      ; Various little utility functions
       4:  00:CEF8                      ;
       5:  00:CEF8                      		module	util
       6:  00:CEF8                      ;
       7:  00:CEF8                      ;==============================================================================
       8:  00:CEF8                      ;
       9:  00:CEF8                      ; This file is part of the EPNET software
      10:  00:CEF8                      ;
      11:  00:CEF8                      ; Copyright (C) 2015  Bruce Tanner
      12:  00:CEF8                      ;
      13:  00:CEF8                      ;    This program is free software: you can redistribute it and/or modify
      14:  00:CEF8                      ;    it under the terms of the GNU General Public License as published by
      15:  00:CEF8                      ;    the Free Software Foundation, either version 3 of the License, or
      16:  00:CEF8                      ;    (at your option) any later version.
      17:  00:CEF8                      ;
      18:  00:CEF8                      ;    This program is distributed in the hope that it will be useful,
      19:  00:CEF8                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      20:  00:CEF8                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      21:  00:CEF8                      ;    GNU General Public License for more details.
      22:  00:CEF8                      ;
      23:  00:CEF8                      ;    You should have received a copy of the GNU General Public License
      24:  00:CEF8                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      25:  00:CEF8                      ;
      26:  00:CEF8                      ; If you do use or modify this file, either for its original purpose or for
      27:  00:CEF8                      ; something new, I'd love to hear about it! I can be contacted by email at:
      28:  00:CEF8                      ;
      29:  00:CEF8                      ; brucetanner@btopenworld.com
      30:  00:CEF8                      ;
      31:  00:CEF8                      ;==============================================================================
      32:  00:CEF8                      ; copystr
      33:  00:CEF8                      ;
      34:  00:CEF8                      ; Copies one null-terminated string to a buffer
      35:  00:CEF8                      ;
      36:  00:CEF8                      ; In:  HL->str to be copied, null terminated
      37:  00:CEF8                      ;      DE->buffer
      38:  00:CEF8                      ; Out: Corrupts BC too!
      39:  00:CEF8                      ;      DE->terminating null
      40:  00:CEF8                      ;
      41:  00:CEF8  7E                  copystr:	ld	a,(hl)
      42:  00:CEF9  ED A0               		ldi
      43:  00:CEFB  B7                  		or	a
      44:  00:CEFC  20 FA               		jr	nz,copystr
      45:  00:CEFE                      ;
      46:  00:CEFE  1B                  		dec	de		; Point back to null
      47:  00:CEFF  C9                  		ret
      48:  00:CF00                      ;
      49:  00:CF00                      ;
      50:  00:CF00                      ;------------------------------------------------------------------------------
      51:  00:CF00                      ; copyarg
      52:  00:CF00                      ;
      53:  00:CF00                      ; Copies a length-byte-first string to a buffer, turning it into a null-
      54:  00:CF00                      ; terminated stirng. Only copies up to the first space
      55:  00:CF00                      ;
      56:  00:CF00                      ; In:  HL->arg to be copied, length byte first
      57:  00:CF00                      ;      DE->buffer
      58:  00:CF00                      ; Out: Corrupts BC too!
      59:  00:CF00                      ;      DE->terminating null
      60:  00:CF00                      ;
      61:  00:CF00  7E                  copyarg:	ld	a,(hl)		; Get length
      62:  00:CF01  B7                  		or	a
      63:  00:CF02  28 0E               		jr	z,.ret
      64:  00:CF04                      ;
      65:  00:CF04  23                  		inc	hl		; Point pased length byte
      66:  00:CF05  4F                  		ld	c,a
      67:  00:CF06  06 00               		ld	b,0		; BC=byte count
      68:  00:CF08  7E                  .loop:		ld	a,(hl)		; Only copy up to space if there is one
      69:  00:CF09  FE 20               		cp	' '
      70:  00:CF0B  28 05               		jr	z,.ret		; Stop if space found
      71:  00:CF0D                      ;
      72:  00:CF0D  ED A0               		ldi			; Copy byte, inc HL & DE, dec & test BC
      73:  00:CF0F  EA 08 CF            		jp	pe,.loop
      74:  00:CF12                      ;
      75:  00:CF12  AF                  .ret:		xor	a
      76:  00:CF13  12                  		ld	(de),a		; Null terminate it
      77:  00:CF14                      ;
      78:  00:CF14  C9                  		ret
      79:  00:CF15                      ;
      80:  00:CF15                      ;
      81:  00:CF15                      ;------------------------------------------------------------------------------
      82:  00:CF15                      ; strlen
      83:  00:CF15                      ;
      84:  00:CF15                      ; Returns in BC the length of the string at (HL)
      85:  00:CF15                      ;
      86:  00:CF15  01 FF FF            strlen:		ld	bc,-1
      87:  00:CF18  E5                  		push	hl
      88:  00:CF19                      ;
      89:  00:CF19  7E                  .loop:		ld	a,(hl)
      90:  00:CF1A  23                  		inc	hl
      91:  00:CF1B  03                  		inc	bc
      92:  00:CF1C  B7                  		or	a
      93:  00:CF1D  20 FA               		jr	nz,.loop
      94:  00:CF1F                      ;
      95:  00:CF1F  E1                  		pop	hl
      96:  00:CF20  C9                  		ret
      97:  00:CF21                      ;
      98:  00:CF21                      ;
      99:  00:CF21                      ;------------------------------------------------------------------------------
     100:  00:CF21                      ; memset
     101:  00:CF21                      ;
     102:  00:CF21                      ; In:  HL->buffer
     103:  00:CF21                      ;      BC=#bytes (must be >1!)
     104:  00:CF21                      ;      A=fill value
     105:  00:CF21                      ; Out: HL->buffer
     106:  00:CF21                      ;
     107:  00:CF21  21 00 F0            varszero:	ld	hl,vars
     108:  00:CF24  01 00 04            		ld	bc,vars.varsize
     109:  00:CF27                      ;
     110:  00:CF27  AF                  memzero:	xor	a
     111:  00:CF28                      ;
     112:  00:CF28                      memset:		
     113:  00:CF28  E5                  		push	hl
     114:  00:CF29  54                  		ld	d,h
     115:  00:CF2A  5D                  		ld	e,l
     116:  00:CF2B  13                  		inc	de
     117:  00:CF2C  77                  		ld	(hl),a
     118:  00:CF2D  0B                  		dec	bc	; We've just done the first byte!
     119:  00:CF2E  ED B0               		ldir
     120:  00:CF30  E1                  		pop	hl
     121:  00:CF31                      ;
     122:  00:CF31  C9                  		ret
     123:  00:CF32                      ;
     124:  00:CF32                      ;------------------------------------------------------------------------------
     125:  00:CF32                      ; memcmp
     126:  00:CF32                      ;
     127:  00:CF32                      ; Compares two blocks of memory
     128:  00:CF32                      ;
     129:  00:CF32                      ; Out: Z if (HL) = (DE) for B bytes
     130:  00:CF32                      ;
     131:  00:CF32  06 04               ipcmp:		ld	b,4
     132:  00:CF34  1A                  memcmp:		ld	a,(de)
     133:  00:CF35  BE                  		cp	(hl)
     134:  00:CF36  C0                  		ret	nz
     135:  00:CF37                      ;
     136:  00:CF37  13                  		inc	de
     137:  00:CF38  23                  		inc	hl
     138:  00:CF39  10 F9               		djnz	memcmp
     139:  00:CF3B                      ;
     140:  00:CF3B  C9                  		ret
     141:  00:CF3C                      ;
     142:  00:CF3C                      ;------------------------------------------------------------------------------
     143:  00:CF3C                      ; upper
     144:  00:CF3C                      ;
     145:  00:CF3C                      ; Upper cases A
     146:  00:CF3C                      ;
     147:  00:CF3C  FE 61               upper:		cp	'a'
     148:  00:CF3E  D8                  		ret	c
     149:  00:CF3F                      ;
     150:  00:CF3F  FE 7B               		cp	'z'+1
     151:  00:CF41  D0                  		ret	nc
     152:  00:CF42                      ;
     153:  00:CF42  D6 20               		sub	'a'-'A'
     154:  00:CF44  C9                  		ret
     155:  00:CF45                      ;
     156:  00:CF45                      ;
     157:  00:CF45                      ;------------------------------------------------------------------------------
     158:  00:CF45                      ; get_ip_port
     159:  00:CF45                      ;
     160:  00:CF45                      ; Reads an ASCII IP address and port number at (DE) to a 4-byte buffer at (HL)
     161:  00:CF45                      ; and a 16-bit port number in HL. The format is aaa.bbb.ccc.ddd:ppppp
     162:  00:CF45                      ;
     163:  00:CF45                      ; In:  HL->buffer for ip
     164:  00:CF45                      ;      DE->command line, length first
     165:  00:CF45                      ; Out: Cy=>not a valid IP address
     166:  00:CF45                      ;      HL=port number
     167:  00:CF45                      ;
     168:  00:CF45  1A                  get_ip_port:	ld	a,(de)
     169:  00:CF46  47                  		ld	b,a
     170:  00:CF47  13                  		inc	de
     171:  00:CF48  CD 82 CF            		call	_get_ip
     172:  00:CF4B  D8                  		ret	c
     173:  00:CF4C                      ;
     174:  00:CF4C  78                  		ld	a,b		; Must be at least :<digit> following
     175:  00:CF4D  D6 02               		sub	2
     176:  00:CF4F  37                  		scf
     177:  00:CF50  F8                  		ret	m
     178:  00:CF51                      ;
     179:  00:CF51  05                  		dec	b
     180:  00:CF52  1A                  		ld	a,(de)
     181:  00:CF53  13                  		inc	de
     182:  00:CF54  FE 2D               		cp	'-'
     183:  00:CF56  37                  		scf
     184:  00:CF57  C0                  		ret	nz
     185:  00:CF58                      ;
     186:  00:CF58  CD 60 CF            		call	_get_port
     187:  00:CF5B                      ;
     188:  00:CF5B  78                  		ld	a,b		; Make sure nothing following
     189:  00:CF5C  B7                  		or	a
     190:  00:CF5D  C8                  		ret	z
     191:  00:CF5E                      ;
     192:  00:CF5E  37                  		scf
     193:  00:CF5F  C9                  		ret
     194:  00:CF60                      ;
     195:  00:CF60                      ;
     196:  00:CF60  B7                  _get_port:	or	a
     197:  00:CF61  ED 62               		sbc	hl,hl		; HL=0 (16-bit accumulator)
     198:  00:CF63                      
     199:  00:CF63  CD BC CF            .loop:		call	get_dig
     200:  00:CF66  3F                  		ccf
     201:  00:CF67  D0                  		ret	nc		; End of number, NC=>no error
     202:  00:CF68                      		
     203:  00:CF68  13                  		inc	de		; Digit ok - point to next
     204:  00:CF69  C5                  		push	bc
     205:  00:CF6A                      		 ; 16-bit accululator *= 10
     206:  00:CF6A  29                  		 add	hl,hl		; *2
     207:  00:CF6B  4D                  		 ld	c,l
     208:  00:CF6C  44                  		 ld	b,h		; Save *2
     209:  00:CF6D  29                  		 add	hl,hl		; *4
     210:  00:CF6E  29                  		 add	hl,hl		; *8
     211:  00:CF6F  09                  		 add	hl,bc		; *10
     212:  00:CF70  4F                  		 ld	c,a
     213:  00:CF71  06 00               		 ld	b,0
     214:  00:CF73  09                  		 add	hl,bc		; Add on digit
     215:  00:CF74  C1                  		pop	bc
     216:  00:CF75  10 EC               		djnz	.loop
     217:  00:CF77                      ;
     218:  00:CF77  C9                  		ret
     219:  00:CF78                      ;
     220:  00:CF78                      ;
     221:  00:CF78                      ;------------------------------------------------------------------------------
     222:  00:CF78                      ; get_ip
     223:  00:CF78                      ;
     224:  00:CF78                      ; Reads an ASCII IP address at (DE) to a 4-byte buffer at (HL).
     225:  00:CF78                      ;
     226:  00:CF78                      ; In:  HL->buffer for ip
     227:  00:CF78                      ;      DE->command line, length first (length not used - see B)
     228:  00:CF78                      ;      B=length
     229:  00:CF78                      ; Out: Cy=>not a valid IP address
     230:  00:CF78                      ;
     231:  00:CF78  13                  get_ip:		inc	de		; Skip length byte (use B instead)
     232:  00:CF79  CD 82 CF            		call	_get_ip
     233:  00:CF7C  D8                  		ret	c
     234:  00:CF7D                      ;
     235:  00:CF7D  78                  		ld	a,b		; Make sure nothing following
     236:  00:CF7E  B7                  		or	a
     237:  00:CF7F  C8                  		ret	z
     238:  00:CF80                      ;
     239:  00:CF80  37                  		scf
     240:  00:CF81  C9                  		ret
     241:  00:CF82                      ;
     242:  00:CF82                      ;
     243:  00:CF82  CD 92 CF            _get_ip:	call	get_num8_dot
     244:  00:CF85  23                  		inc	hl
     245:  00:CF86  D4 92 CF            		call	nc,get_num8_dot
     246:  00:CF89  23                  		inc	hl
     247:  00:CF8A  D4 92 CF            		call	nc,get_num8_dot
     248:  00:CF8D  23                  		inc	hl
     249:  00:CF8E  D4 A2 CF            		call	nc,get_num8
     250:  00:CF91  C9                  		ret
     251:  00:CF92                      ;
     252:  00:CF92  CD A2 CF            get_num8_dot:	call	get_num8
     253:  00:CF95                      ;
     254:  00:CF95  05                  		dec	b
     255:  00:CF96  37                  		scf
     256:  00:CF97  F8                  		ret	m
     257:  00:CF98                      ;
     258:  00:CF98  1A                  		ld	a,(de)
     259:  00:CF99  13                  		inc	de
     260:  00:CF9A  FE 2E               		cp	'.'
     261:  00:CF9C  C8                  		ret	z
     262:  00:CF9D                      ;
     263:  00:CF9D  FE 2C               		cp	','	; Also allow , (for parsing FTP responses)
     264:  00:CF9F  C8                  		ret	z
     265:  00:CFA0                      
     266:  00:CFA0  37                  		scf
     267:  00:CFA1  C9                  		ret
     268:  00:CFA2                      ;
     269:  00:CFA2                      ;
     270:  00:CFA2                      ;------------------------------------------------------------------------------
     271:  00:CFA2                      ; get_num8
     272:  00:CFA2                      ;
     273:  00:CFA2                      ; Reads an ASCII 8-bit number from a length-byte string
     274:  00:CFA2                      ;
     275:  00:CFA2                      ; In:  DE->string
     276:  00:CFA2                      ;      HL->number
     277:  00:CFA2                      ;       B=length of data at (DE)
     278:  00:CFA2                      ; Out: DE->first non-numeric character
     279:  00:CFA2                      ;      HL->number
     280:  00:CFA2                      ;       B updated
     281:  00:CFA2                      ;      Cy=>bad number
     282:  00:CFA2                      ;
     283:  00:CFA2  CD BC CF            get_num8:	call	get_dig
     284:  00:CFA5  D8                  		ret	c
     285:  00:CFA6                      ;
     286:  00:CFA6  36 00               		ld	(hl),0
     287:  00:CFA8  CD BC CF            .loop:		call	get_dig
     288:  00:CFAB  3F                  		ccf
     289:  00:CFAC  D0                  		ret	nc
     290:  00:CFAD                      ;
     291:  00:CFAD  13                  		inc	de
     292:  00:CFAE  F5                  		push	af
     293:  00:CFAF  7E                  		ld	a,(hl)
     294:  00:CFB0  87                  		add	a,a
     295:  00:CFB1  4F                  		ld	c,a
     296:  00:CFB2  87                  		add	a,a
     297:  00:CFB3  87                  		add	a,a
     298:  00:CFB4  81                  		add	a,c
     299:  00:CFB5  4F                  		ld	c,a
     300:  00:CFB6  F1                  		pop	af
     301:  00:CFB7  81                  		add	a,c
     302:  00:CFB8  77                  		ld	(hl),a
     303:  00:CFB9  10 ED               		djnz	.loop
     304:  00:CFBB                      ;
     305:  00:CFBB  C9                  		ret
     306:  00:CFBC                      ;
     307:  00:CFBC                      ;
     308:  00:CFBC                      get_dig:
     309:  00:CFBC  1A                  		ld	a,(de)
     310:  00:CFBD  D6 30               isdig:		sub	'0'
     311:  00:CFBF  D8                  		ret	c
     312:  00:CFC0  FE 0A               		cp	10
     313:  00:CFC2  3F                  		ccf
     314:  00:CFC3  C9                  		ret
     315:  00:CFC4                      ;
     316:  00:CFC4                      ;
     317:  00:CFC4                      ;------------------------------------------------------------------------------
     318:  00:CFC4                      ; get_num16
     319:  00:CFC4                      ;
     320:  00:CFC4                      ; Reads an ASCII 16-bit number from a null-terminated string
     321:  00:CFC4                      ;
     322:  00:CFC4                      ; In:  DE->number
     323:  00:CFC4                      ; Out: DE->first non-numeric character
     324:  00:CFC4                      ;      HL=number
     325:  00:CFC4                      ;      Cy=>bad number
     326:  00:CFC4                      ;
     327:  00:CFC4                      get_num16:
     328:  00:CFC4  CD BC CF            		call	get_dig		; Must be at least 1 digit!
     329:  00:CFC7  D8                  		ret	c		; C=>error
     330:  00:CFC8                      ;
     331:  00:CFC8  B7                  		or	a
     332:  00:CFC9  ED 62               		sbc	hl,hl		; HL=0 (16-bit accumulator)
     333:  00:CFCB                      
     334:  00:CFCB  CD BC CF            .loop:		call	get_dig
     335:  00:CFCE  3F                  		ccf
     336:  00:CFCF  D0                  		ret	nc		; End of number, NC=>no error
     337:  00:CFD0                      		
     338:  00:CFD0  13                  		inc	de		; Digit ok - point to next
     339:  00:CFD1                      		; 16-bit accululator *= 10
     340:  00:CFD1  29                  		add	hl,hl		; *2
     341:  00:CFD2  4D                  		ld	c,l
     342:  00:CFD3  44                  		ld	b,h		; Save *2
     343:  00:CFD4  29                  		add	hl,hl		; *4
     344:  00:CFD5  29                  		add	hl,hl		; *8
     345:  00:CFD6  09                  		add	hl,bc		; *10
     346:  00:CFD7  4F                  		ld	c,a
     347:  00:CFD8  06 00               		ld	b,0
     348:  00:CFDA  09                  		add	hl,bc		; Add on digit
     349:  00:CFDB  18 EE               		jr	.loop
     350:  00:CFDD                      ;
     351:  00:CFDD                      ;
     352:  00:CFDD                      ;
     353:  00:CFDD                      		endmodule
      99.  00:CFDD                      	include trace.asm
       1:  00:CFDD                      ; TRACE
       2:  00:CFDD                      ;
       3:  00:CFDD                      ; Provides routines for outputting diagnostic info when in trace mode
       4:  00:CFDD                      ;
       5:  00:CFDD                      		module	trace
       6:  00:CFDD                      ;
       7:  00:CFDD                      ;==============================================================================
       8:  00:CFDD                      ;
       9:  00:CFDD                      ; This file is part of the EPNET software
      10:  00:CFDD                      ;
      11:  00:CFDD                      ; Copyright (C) 2015  Bruce Tanner
      12:  00:CFDD                      ;
      13:  00:CFDD                      ;    This program is free software: you can redistribute it and/or modify
      14:  00:CFDD                      ;    it under the terms of the GNU General Public License as published by
      15:  00:CFDD                      ;    the Free Software Foundation, either version 3 of the License, or
      16:  00:CFDD                      ;    (at your option) any later version.
      17:  00:CFDD                      ;
      18:  00:CFDD                      ;    This program is distributed in the hope that it will be useful,
      19:  00:CFDD                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      20:  00:CFDD                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      21:  00:CFDD                      ;    GNU General Public License for more details.
      22:  00:CFDD                      ;
      23:  00:CFDD                      ;    You should have received a copy of the GNU General Public License
      24:  00:CFDD                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      25:  00:CFDD                      ;
      26:  00:CFDD                      ; If you do use or modify this file, either for its original purpose or for
      27:  00:CFDD                      ; something new, I'd love to hear about it! I can be contacted by email at:
      28:  00:CFDD                      ;
      29:  00:CFDD                      ; brucetanner@btopenworld.com
      30:  00:CFDD                      ;
      31:  00:CFDD                      ;==============================================================================
      32:  00:CFDD                      ; diag.str
      33:  00:CFDD                      ;
      34:  00:CFDD                      ; Outputs a string if in diag trace mode
      35:  00:CFDD                      ;
      36:  00:CFDD                      ; In:  DE->string, null-terminated. First byte is trace module
      37:  00:CFDD                      ;
      38:  00:CFDD  11 84 D3            diag.ok:	ld	de,ok_str
      39:  00:CFE0  18 0D               		jr	diag.str
      40:  00:CFE2                      ;
      41:  00:CFE2  11 FF D0            diag.err:	ld	de,diag.errmsg
      42:  00:CFE5  18 08               		jr	diag.str
      43:  00:CFE7                      ;
      44:  00:CFE7  11 A2 D3            diag.dots:	ld	de,dots_str
      45:  00:CFEA  18 03               		jr	diag.str
      46:  00:CFEC                      ;
      47:  00:CFEC  CD F7 CF            diag.startstr:	call	diag.start
      48:  00:CFEF  FD CB 00 46         diag.str:	bit	vars.trace.diag,(iy+vars._trace)
      49:  00:CFF3  C8                  		ret	z		; Trace not on for this module
      50:  00:CFF4                      ;
      51:  00:CFF4  C3 3D CE            		jp	io.str
      52:  00:CFF7                      ;
      53:  00:CFF7                      ;
      54:  00:CFF7                      ; diag.start
      55:  00:CFF7                      ;
      56:  00:CFF7                      ; If in trace mode, outputs a CR, LF if we are not at the start of the line
      57:  00:CFF7  FD CB 00 46         diag.start:	bit	vars.trace.diag,(iy+vars._trace)
      58:  00:CFFB  C8                  		ret	z
      59:  00:CFFC                      ;
      60:  00:CFFC  3A 05 F0            		ld	a,(vars.io.col)
      61:  00:CFFF  B7                  		or	a
      62:  00:D000  C8                  		ret	z
      63:  00:D001                      		    ;
      64:  00:D001                      		    ;
      65:  00:D001                      		    ;
      66:  00:D001                      ;
      67:  00:D001                      ;
      68:  00:D001                      ; diag.crlf
      69:  00:D001                      ;
      70:  00:D001                      ; Outputs a CR and LFif in diag trace mode
      71:  00:D001                      ;
      72:  00:D001  3E 0D               diag.crlf:	ld	a,CR
      73:  00:D003  CD 08 D0            		call	diag.char
      74:  00:D006  3E 0A               		ld	a,LF
      75:  00:D008                      		    ;
      76:  00:D008                      		    ;
      77:  00:D008                      		    ;
      78:  00:D008                      ;
      79:  00:D008                      ;
      80:  00:D008                      ; diag.char
      81:  00:D008                      ;
      82:  00:D008                      ; Outputs a hex byte if in diag trace mode
      83:  00:D008                      ;
      84:  00:D008                      ; In: A = byte
      85:  00:D008  FD CB 00 46         diag.char:	bit	vars.trace.diag,(iy+vars._trace)
      86:  00:D00C  C8                  		ret	z
      87:  00:D00D                      ;
      88:  00:D00D  C3 00 CE            		jp	io.char
      89:  00:D010                      
      90:  00:D010                      ;
      91:  00:D010                      ;
      92:  00:D010                      ; diag.byte
      93:  00:D010                      ;
      94:  00:D010                      ; Outputs a hex byte if in diag trace mode
      95:  00:D010                      ;
      96:  00:D010                      ; In: A = byte
      97:  00:D010  FD CB 00 46         diag.byte:	bit	vars.trace.diag,(iy+vars._trace)
      98:  00:D014  C8                  		ret	z
      99:  00:D015                      ;
     100:  00:D015  C3 ED CD            		jp	io.byte
     101:  00:D018                      
     102:  00:D018                      ;
     103:  00:D018                      ;
     104:  00:D018                      ; diag.word
     105:  00:D018                      ;
     106:  00:D018                      ; Outputs a hex byte if in diag trace mode
     107:  00:D018                      ;
     108:  00:D018                      ; In: HL = byte
     109:  00:D018  FD CB 00 46         diag.word:	bit	vars.trace.diag,(iy+vars._trace)
     110:  00:D01C  C8                  		ret	z
     111:  00:D01D                      ;
     112:  00:D01D  C3 E8 CD            		jp	io.word
     113:  00:D020                      ;
     114:  00:D020                      ;
     115:  00:D020                      ; diag.mac
     116:  00:D020                      ;
     117:  00:D020                      ; Outputs a MAC address if in diag trace mode
     118:  00:D020                      ;
     119:  00:D020                      ; In: HL->MAC address
     120:  00:D020  FD CB 00 46         diag.mac:	bit	vars.trace.diag,(iy+vars._trace)
     121:  00:D024  C8                  		ret	z
     122:  00:D025                      ;
     123:  00:D025  C3 82 CD            		jp	io.mac
     124:  00:D028                      ;
     125:  00:D028                      ;
     126:  00:D028                      ; diag.ip
     127:  00:D028                      ;
     128:  00:D028                      ; Outputs an IP address if in diag trace mode
     129:  00:D028                      ;
     130:  00:D028                      ; In: HL->IP address
     131:  00:D028  FD CB 00 46         diag.ip:	bit	vars.trace.diag,(iy+vars._trace)
     132:  00:D02C  C8                  		ret	z
     133:  00:D02D                      ;
     134:  00:D02D  C3 8C CD            		jp	io.ip
     135:  00:D030                      ;
     136:  00:D030                      ;
     137:  00:D030                      ;------------------------------------------------------------------------------
     138:  00:D030                      ; Various little I/O routines called when in trace mode
     139:  00:D030                      ;
     140:  00:D030  CD 31 CE            bytes:		call	io.space
     141:  00:D033  CD B1 CD            		call	io.int
     142:  00:D036  11 A6 D3            		ld	de,bytes_str
     143:  00:D039  C3 3D CE            		jp	io.str
     144:  00:D03C                      ;
     145:  00:D03C  11 A2 D3            dots:		ld	de,dots_str
     146:  00:D03F  C3 3D CE            		jp	io.str
     147:  00:D042                      ;
     148:  00:D042                      
     149:  00:D042  38 0A               is_timeout:	jr	c,timeout
     150:  00:D044  38 0D               is_error:	jr	c,error
     151:  00:D046  11 84 D3            ok:		ld	de,ok_str
     152:  00:D049  CD 3D CE            		call	io.str
     153:  00:D04C  B7                  		or	a
     154:  00:D04D  C9                  		ret
     155:  00:D04E                      ;
     156:  00:D04E                      ;
     157:  00:D04E  11 89 D3            timeout:	ld	de,timeout_str
     158:  00:D051  18 03               		jr	err
     159:  00:D053  11 93 D3            error:		ld	de,error_str
     160:  00:D056  CD 94 C9            err:		call	exos.is_stop
     161:  00:D059  30 03               		jr	nc,.notstop
     162:  00:D05B                      ;
     163:  00:D05B  11 9B D3            		ld	de,stop_str
     164:  00:D05E  CD 3D CE            .notstop:	call	io.str
     165:  00:D061  37                  		scf
     166:  00:D062  C9                  		ret
     167:  00:D063                      ;
     168:  00:D063                      ;
     169:  00:D063                      ;------------------------------------------------------------------------------
     170:  00:D063                      ; dumpbytes, dumpchars
     171:  00:D063                      ;
     172:  00:D063                      ; Outputs a memory dump at (HL) for B bytes
     173:  00:D063                      ;
     174:  00:D063                      dumpbytes:
     175:  00:D063  CD 94 C9            .loop:		call	exos.is_stop
     176:  00:D066  D8                  		ret	c		; Return with Cy if STOP key presed
     177:  00:D067                      ;
     178:  00:D067  7E                  		ld	a,(hl)		; Get byte
     179:  00:D068  23                  		inc	hl
     180:  00:D069  CD ED CD            		call	io.byte		; Print it
     181:  00:D06C  CD 31 CE            		call	io.space	; Followed by a space
     182:  00:D06F  10 F2               		djnz	.loop
     183:  00:D071                      ;
     184:  00:D071  B7                  		or	a		; NC=>STOP not pressed
     185:  00:D072  C9                  		ret
     186:  00:D073                      ;
     187:  00:D073                      ;
     188:  00:D073                      dumpchars:
     189:  00:D073  CD 94 C9            .loop:		call	exos.is_stop
     190:  00:D076  D8                  		ret	c		; Return with Cy if STOP key presed
     191:  00:D077                      ;
     192:  00:D077  7E                  		ld	a,(hl)		; Get byte
     193:  00:D078  23                  		inc	hl
     194:  00:D079  FE A0               		cp	0a0h		; Chars >=A0 are editor control chars
     195:  00:D07B  30 04               		jr	nc,.dot
     196:  00:D07D                      ;
     197:  00:D07D  FE 20               		cp	' '		; Chars < space are control chars
     198:  00:D07F  30 02               		jr	nc,.ascii
     199:  00:D081                      ;
     200:  00:D081  3E 2E               .dot:		ld	a,'.'		; Turn control chars into .
     201:  00:D083  CD 00 CE            .ascii:		call	io.char
     202:  00:D086  10 EB               		djnz	.loop
     203:  00:D088                      ;
     204:  00:D088  CD 31 CE            		call	io.space
     205:  00:D08B  B7                  		or	a		; NC=>STOP not pressed
     206:  00:D08C  C9                  		ret
     207:  00:D08D                      ;
     208:  00:D08D                      ;
     209:  00:D08D                      ;------------------------------------------------------------------------------
     210:  00:D08D                      ; set_cols
     211:  00:D08D                      ;
     212:  00:D08D                      ; Sets the number of output columns. This is a relatively time
     213:  00:D08D                      ; consuming process so we don't do it frequently
     214:  00:D08D                      ;
     215:  00:D08D                      ; Out: Preserved HL, DE, BC
     216:  00:D08D                      ;
     217:  00:D08D                      set_cols:
     218:  00:D08D  D5                  		push	de
     219:  00:D08E  C5                  		push	bc
     220:  00:D08F  CD 6A CE            		call	io.cols		; Find & save # output cols
     221:  00:D092  C1                  		pop	bc
     222:  00:D093  D1                  		pop	de
     223:  00:D094  32 02 F0            		ld	(vars.trace.cols),a
     224:  00:D097  C9                  		ret
     225:  00:D098                      ;
     226:  00:D098                      ;
     227:  00:D098                      ; Trace strings - strings output during trace
     228:  00:D098                      ;
     229:  00:D098                      ; diag
     230:  00:D098                      diag.reset		db	"Reset WIZ at I/O port ",0
     230:  00:D098  52 65 73 65 74 20 57 49 5A 20 61 74 20 49 2F 4F 
     230:  00:D0A8  20 70 6F 72 74 20 00 
     231:  00:D0AF                      diag.id			db	"Read ID ",0
     231:  00:D0AF  52 65 61 64 20 49 44 20 00 
     232:  00:D0B8                      diag.writemac		db	"Set MAC address ",0
     232:  00:D0B8  53 65 74 20 4D 41 43 20 61 64 64 72 65 73 73 20 
     232:  00:D0C8  00 
     233:  00:D0C9                      diag.writeip		db	"Set IP address ",0
     233:  00:D0C9  53 65 74 20 49 50 20 61 64 64 72 65 73 73 20 00 
     234:  00:D0D9                      diag.subnet		db	"Set Subnet mask ",0
     234:  00:D0D9  53 65 74 20 53 75 62 6E 65 74 20 6D 61 73 6B 20 
     234:  00:D0E9  00 
     235:  00:D0EA                      diag.gateway		db	"Set Default Gateway ",0
     235:  00:D0EA  53 65 74 20 44 65 66 61 75 6C 74 20 47 61 74 65 
     235:  00:D0FA  77 61 79 20 00 
     236:  00:D0FF                      diag.errmsg:		db	"DIAG ERROR",0
     236:  00:D0FF  44 49 41 47 20 45 52 52 4F 52 00 
     237:  00:D10A                      diag.memory:		db	"Test WIZ memory...",0
     237:  00:D10A  54 65 73 74 20 57 49 5A 20 6D 65 6D 6F 72 79 2E 
     237:  00:D11A  2E 2E 00 
     238:  00:D11D  72 65 61 64 20 00   diag.memerr:		db	"read ",0
     239:  00:D123                      diag.expected:		db	" expected ",0
     239:  00:D123  20 65 78 70 65 63 74 65 64 20 00 
     240:  00:D12E  20 61 74 20 00      diag.at:		db	" at ",0
     241:  00:D133                      diag.timeout:		db	"TIMEOUT ERROR",0
     241:  00:D133  54 49 4D 45 4F 55 54 20 45 52 52 4F 52 00 
     242:  00:D141                      diag.dhcp:		db	"Getting IP parameters via DHCP...",0
     242:  00:D141  47 65 74 74 69 6E 67 20 49 50 20 70 61 72 61 6D 
     242:  00:D151  65 74 65 72 73 20 76 69 61 20 44 48 43 50 2E 2E 
     242:  00:D161  2E 00 
     243:  00:D163                      diag.ntp:		db	"Getting current time via NTP...",0
     243:  00:D163  47 65 74 74 69 6E 67 20 63 75 72 72 65 6E 74 20 
     243:  00:D173  74 69 6D 65 20 76 69 61 20 4E 54 50 2E 2E 2E 00 
     244:  00:D183                      ;
     245:  00:D183                      socket.connect:		db	"Connect to ",0
     245:  00:D183  43 6F 6E 6E 65 63 74 20 74 6F 20 00 
     246:  00:D18F                      socket.disconnect:	db	"Disconnect...",0
     246:  00:D18F  44 69 73 63 6F 6E 6E 65 63 74 2E 2E 2E 00 
     247:  00:D19D                      socket.close:		db	"Close...",0
     247:  00:D19D  43 6C 6F 73 65 2E 2E 2E 00 
     248:  00:D1A6  4F 70 65 6E 20 00   socket.open:		db	"Open ",0
     249:  00:D1AC  55 44 50 00         socket.udp:		db	"UDP",0
     250:  00:D1B0  49 50 00            socket.ipraw:		db	"IP",0
     251:  00:D1B3  54 43 50 00         socket.tcp:		db	"TCP",0
     252:  00:D1B7  3F 3F 3F 00         socket.unknown:		db	"???",0
     253:  00:D1BB                      socket.port:		db	" port ",0
     253:  00:D1BB  20 70 6F 72 74 20 00 
     254:  00:D1C2  20 62 79 20 00      socket.by:		db	" by ",0
     255:  00:D1C7                      ;
     256:  00:D1C7                      udp.rx:			db	"UDP rx from ",0
     256:  00:D1C7  55 44 50 20 72 78 20 66 72 6F 6D 20 00 
     257:  00:D1D4                      udp.tx:			db	"UDP tx to ",0
     257:  00:D1D4  55 44 50 20 74 78 20 74 6F 20 00 
     258:  00:D1DF                      udp.errmsg:		db	"UDP ERROR",CR,LF,0
     258:  00:D1DF  55 44 50 20 45 52 52 4F 52 0D 0A 00 
     259:  00:D1EB                      ;
     260:  00:D1EB                      tcp.rx:			db	"TCP rx",0
     260:  00:D1EB  54 43 50 20 72 78 00 
     261:  00:D1F2                      tcp.tx:			db	"TCP tx",0
     261:  00:D1F2  54 43 50 20 74 78 00 
     262:  00:D1F9                      ;
     263:  00:D1F9                      ipraw.rx:		db	"IPRAW rx from ",0
     263:  00:D1F9  49 50 52 41 57 20 72 78 20 66 72 6F 6D 20 00 
     264:  00:D208                      ipraw.tx:		db	"IPRAW tx to ",0
     264:  00:D208  49 50 52 41 57 20 74 78 20 74 6F 20 00 
     265:  00:D215                      ;
     266:  00:D215                      ;
     267:  00:D215                      dhcp.start:		db	"DHCP:start...",0
     267:  00:D215  44 48 43 50 3A 73 74 61 72 74 2E 2E 2E 00 
     268:  00:D223                      dhcp.discover:		db	"DHCP:tx Discover ",0
     268:  00:D223  44 48 43 50 3A 74 78 20 44 69 73 63 6F 76 65 72 
     268:  00:D233  20 00 
     269:  00:D235                      dhcp.request:		db	"DHCP:tx Request ",0
     269:  00:D235  44 48 43 50 3A 74 78 20 52 65 71 75 65 73 74 20 
     269:  00:D245  00 
     270:  00:D246                      dhcp.rx:		db	"DHCP:rx ",0
     270:  00:D246  44 48 43 50 3A 72 78 20 00 
     271:  00:D24F  20 49 50 3D 00      dhcp.gotip:		db	" IP=",0
     272:  00:D254                      dhcp.gotsubnet:		db	" subnet=",0
     272:  00:D254  20 73 75 62 6E 65 74 3D 00 
     273:  00:D25D                      dhcp.gotgateway:	db	" gateway=",0
     273:  00:D25D  20 67 61 74 65 77 61 79 3D 00 
     274:  00:D267                      dhcp.gotserver:		db	" server=",0
     274:  00:D267  20 73 65 72 76 65 72 3D 00 
     275:  00:D270                      dhcp.gotlease:		db	" lease=",0
     275:  00:D270  20 6C 65 61 73 65 3D 00 
     276:  00:D278  20 44 4E 53 3D 00   dhcp.gotdns:		db	" DNS=",0
     277:  00:D27E  20 4E 54 50 3D 00   dhcp.gotntp:		db	" NTP=",0
     278:  00:D284                      ;
     279:  00:D284                      dhcp.offer:		db	"Offer ",0
     279:  00:D284  4F 66 66 65 72 20 00 
     280:  00:D28B                      dhcp.decline:		db	"Decline ",0
     280:  00:D28B  44 65 63 6C 69 6E 65 20 00 
     281:  00:D294  41 63 6B 20 00      dhcp.ack:		db	"Ack ",0
     282:  00:D299  4E 61 6B 20 00      dhcp.nak:		db	"Nak ",0
     283:  00:D29E                      dhcp.type:		db	" bad Type ",0
     283:  00:D29E  20 62 61 64 20 54 79 70 65 20 00 
     284:  00:D2A9                      dhcp.end:		db	"DHCP:finished",CR,LF,0
     284:  00:D2A9  44 48 43 50 3A 66 69 6E 69 73 68 65 64 0D 0A 00 
     285:  00:D2B9                      dhcp.errmsg:		db	"DHCP ERROR",0
     285:  00:D2B9  44 48 43 50 20 45 52 52 4F 52 00 
     286:  00:D2C4                      dhcp.small:		db	"TOO SMALL",0
     286:  00:D2C4  54 4F 4F 20 53 4D 41 4C 4C 00 
     287:  00:D2CE                      dhcp.port:		db	"BAD PORT",0
     287:  00:D2CE  42 41 44 20 50 4F 52 54 00 
     288:  00:D2D7                      dhcp.op:		db	"BAD OP",0
     288:  00:D2D7  42 41 44 20 4F 50 00 
     289:  00:D2DE                      dhcp.addr:		db	"BAD ADDR",0
     289:  00:D2DE  42 41 44 20 41 44 44 52 00 
     290:  00:D2E7                      dhcp.xid:		db	"BAD XID",0
     290:  00:D2E7  42 41 44 20 58 49 44 00 
     291:  00:D2EF                      dhcp.cookie:		db	"BAD COOKIE",0
     291:  00:D2EF  42 41 44 20 43 4F 4F 4B 49 45 00 
     292:  00:D2FA                      dhcp.eop:		db	"BAD PACKET",0
     292:  00:D2FA  42 41 44 20 50 41 43 4B 45 54 00 
     293:  00:D305                      ;
     294:  00:D305                      ping.pinging:		db	"Pinging ",0
     294:  00:D305  50 69 6E 67 69 6E 67 20 00 
     295:  00:D30E                      ;
     296:  00:D30E                      ntp.tx:			db	"NTP:tx request to ",0
     296:  00:D30E  4E 54 50 3A 74 78 20 72 65 71 75 65 73 74 20 74 
     296:  00:D31E  6F 20 00 
     297:  00:D321                      ntp.rx:			db	"NTP:rx...",0
     297:  00:D321  4E 54 50 3A 72 78 2E 2E 2E 00 
     298:  00:D32B                      ;
     299:  00:D32B                      ;
     300:  00:D32B                      http.open:		db	"Connect to ",0
     300:  00:D32B  43 6F 6E 6E 65 63 74 20 74 6F 20 00 
     301:  00:D337  54 78 20 00         http.tx:		db	"Tx ",0
     302:  00:D33B  52 78 20 00         http.rx:		db	"Rx ",0
     303:  00:D33F  43 6F 64 65 3D 00   http.code:		db	"Code=",0
     304:  00:D345  53 69 7A 65 3D 00   http.size:		db	"Size=",0
     305:  00:D34B                      ;
     306:  00:D34B                      ;
     307:  00:D34B                      ftp.open:		db	"Connect to ",0
     307:  00:D34B  43 6F 6E 6E 65 63 74 20 74 6F 20 00 
     308:  00:D357                      ftp.login:		db	"Login...",0
     308:  00:D357  4C 6F 67 69 6E 2E 2E 2E 00 
     309:  00:D360  54 78 20 00         ftp.tx:			db	"Tx ",0
     310:  00:D364  52 78 20 00         ftp.rx:			db	"Rx ",0
     311:  00:D368  43 6C 6F 73 65 00   ftp.close:		db	"Close",0
     312:  00:D36E  70 61 73 76 3D 00   ftp.pasv:		db	"pasv=",0
     313:  00:D374  63 6F 64 65 3D 00   ftp.code:		db	"code=",0
     314:  00:D37A                      ftp.error_str:		db	"FTP ERROR",0
     314:  00:D37A  46 54 50 20 45 52 52 4F 52 00 
     315:  00:D384                      ;
     316:  00:D384                      ;
     317:  00:D384  4F 4B 0D 0A 00      ok_str:			db	"OK",CR,LF,0
     318:  00:D389                      timeout_str:		db	"TIMEOUT",CR,LF,0
     318:  00:D389  54 49 4D 45 4F 55 54 0D 0A 00 
     319:  00:D393                      error_str:		db	"ERROR",CR,LF,0
     319:  00:D393  45 52 52 4F 52 0D 0A 00 
     320:  00:D39B                      stop_str:		db	"STOP",CR,LF,0
     320:  00:D39B  53 54 4F 50 0D 0A 00 
     321:  00:D3A2  2E 2E 2E 00         dots_str:		db	"...",0
     322:  00:D3A6                      bytes_str:		db	" bytes",0
     322:  00:D3A6  20 62 79 74 65 73 00 
     323:  00:D3AD                      ;
     324:  00:D3AD                      
     325:  00:D3AD                      
     326:  00:D3AD                      
     327:  00:D3AD                      		endmodule
     100.  00:D3AD                      ;
     101.  00:D3AD                      	include w5300.asm
       1:  00:D3AD                      ; W5300
       2:  00:D3AD                      ;
       3:  00:D3AD                      ; All the constants required for using the WIZ W5300 chip
       4:  00:D3AD                      ;
       5:  00:D3AD                      		module w5300
       6:  00:D3AD                      ;
       7:  00:D3AD                      ;==============================================================================
       8:  00:D3AD                      ;
       9:  00:D3AD                      ; This file is part of the EPNET software
      10:  00:D3AD                      ;
      11:  00:D3AD                      ; Copyright (C) 2015  Bruce Tanner
      12:  00:D3AD                      ;
      13:  00:D3AD                      ;    This program is free software: you can redistribute it and/or modify
      14:  00:D3AD                      ;    it under the terms of the GNU General Public License as published by
      15:  00:D3AD                      ;    the Free Software Foundation, either version 3 of the License, or
      16:  00:D3AD                      ;    (at your option) any later version.
      17:  00:D3AD                      ;
      18:  00:D3AD                      ;    This program is distributed in the hope that it will be useful,
      19:  00:D3AD                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      20:  00:D3AD                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      21:  00:D3AD                      ;    GNU General Public License for more details.
      22:  00:D3AD                      ;
      23:  00:D3AD                      ;    You should have received a copy of the GNU General Public License
      24:  00:D3AD                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      25:  00:D3AD                      ;
      26:  00:D3AD                      ; If you do use or modify this file, either for its original purpose or for
      27:  00:D3AD                      ; something new, I'd love to hear about it! I can be contacted by email at:
      28:  00:D3AD                      ;
      29:  00:D3AD                      ; brucetanner@btopenworld.com
      30:  00:D3AD                      ;
      31:  00:D3AD                      ;==============================================================================
      32:  00:D3AD                      ;
      33:  00:D3AD                      ; Main directly-accessed registers
      34:  00:D3AD                      ;
      35:  00:D3AD  (00:0000)           MR0		equ	0		;Mode Register
      36:  00:D3AD  (00:0001)           MR1		equ	1
      37:  00:D3AD                      ;
      38:  00:D3AD  (00:0020)           MR0_WDF2	equ	20h		; Write Data Fetch time
      39:  00:D3AD  (00:0010)           MR0_WDF1	equ	10h
      40:  00:D3AD  (00:0008)           MR0_WDF0	equ	08h
      41:  00:D3AD                      ;
      42:  00:D3AD  (00:0080)           MR1_RST		equ	80h		; Reset
      43:  00:D3AD  (00:0020)           MR1_MT		equ	20h		; Memory test mode
      44:  00:D3AD  (00:0001)           MR1_IND		equ	01h		; Indirect Bus I/F Mode
      45:  00:D3AD                      ;
      46:  00:D3AD                      ;
      47:  00:D3AD  (00:0002)           IDM_AR0		equ	2		; Indirect Mode Address Register
      48:  00:D3AD  (00:0003)           IDM_AR1		equ	3
      49:  00:D3AD                      ;
      50:  00:D3AD  (00:0004)           IDM_DR0		equ	4		; Indirect Mode Data Register
      51:  00:D3AD  (00:0005)           IDM_DR1		equ	5
      52:  00:D3AD                      ;
      53:  00:D3AD                      ;
      54:  00:D3AD                      ;------------------------------------------------------------------------------
      55:  00:D3AD                      ; In Indirect Mode which EPNET uses, these are all accessed via AR and DR above
      56:  00:D3AD                      ;
      57:  00:D3AD                      ; COMMON registers
      58:  00:D3AD                      ;
      59:  00:D3AD  (00:0002)           IR		equ	02h
      60:  00:D3AD  (00:0002)           IR0		equ	IR+0		; Interrupt Register
      61:  00:D3AD  (00:0003)           IR1		equ	IR+1
      62:  00:D3AD                      ;
      63:  00:D3AD  (00:0004)           IMR		equ	04h
      64:  00:D3AD  (00:0004)           IMR0		equ	IMR+0		; Interrupt Mask Register
      65:  00:D3AD  (00:0005)           IMR1		equ	IMR+1
      66:  00:D3AD                      ;
      67:  00:D3AD  (00:0008)           SHAR	  	equ	08h		; Source Hardware Address Register (MAC!)
      68:  00:D3AD  (00:0008)           SHAR0		equ	SHAR+0
      69:  00:D3AD  (00:0009)           SHAR1		equ	SHAR+1
      70:  00:D3AD  (00:000A)           SHAR2		equ	SHAR+2
      71:  00:D3AD  (00:000B)           SHAR3		equ	SHAR+3
      72:  00:D3AD  (00:000C)           SHAR4		equ	SHAR+4
      73:  00:D3AD  (00:000D)           SHAR5		equ	SHAR+5
      74:  00:D3AD                      
      75:  00:D3AD  (00:0010)           GAR		equ	10h 		; Gateway Address Register
      76:  00:D3AD  (00:0010)           GAR0		equ	GAR+0
      77:  00:D3AD  (00:0011)           GAR1		equ	GAR+1
      78:  00:D3AD  (00:0012)           GAR2		equ	GAR+2
      79:  00:D3AD  (00:0013)           GAR3		equ	GAR+3
      80:  00:D3AD                      
      81:  00:D3AD  (00:0014)           SUBR		equ	14h		; Subnet Mask Register
      82:  00:D3AD  (00:0014)           SUBR0		equ	SUBR+0
      83:  00:D3AD  (00:0015)           SUBR1		equ	SUBR+1
      84:  00:D3AD  (00:0016)           SUBR2		equ	SUBR+2
      85:  00:D3AD  (00:0017)           SUBR3		equ	SUBR+3
      86:  00:D3AD                      
      87:  00:D3AD  (00:0018)           SIPR		equ	18h		; Source IP Address Register
      88:  00:D3AD  (00:0018)           SIPR0		equ	SIPR+0
      89:  00:D3AD  (00:0019)           SIPR1		equ	SIPR+1
      90:  00:D3AD  (00:001A)           SIPR2		equ	SIPR+2
      91:  00:D3AD  (00:001B)           SIPR3		equ	SIPR+3
      92:  00:D3AD                      
      93:  00:D3AD  (00:001C)           RTR		equ	1ch		; Retransmission Timeout-value Register
      94:  00:D3AD  (00:001C)           RTR0		equ	RTR+0
      95:  00:D3AD  (00:001D)           RTR1		equ	RTR+1
      96:  00:D3AD                      
      97:  00:D3AD  (00:001F)           RCR1		equ	1fh		; Retransmission Retry-count Register (RCR0 "reserved")
      98:  00:D3AD                      
      99:  00:D3AD  (00:0020)           TMS01R		equ	20h
     100:  00:D3AD  (00:0020)           TMSR0		equ	TMS01R+0	; Transmit Memory Size Register Socket 0
     101:  00:D3AD  (00:0021)           TMSR1		equ	TMS01R+1	; Transmit Memory Size Register Socket 1
     102:  00:D3AD  (00:0022)           TMS23R		equ	TMS01R+2
     103:  00:D3AD  (00:0022)           TMSR2		equ	TMS23R+0	; Transmit Memory Size Register Socket 2
     104:  00:D3AD  (00:0023)           TMSR3		equ	TMS23R+1	; Transmit Memory Size Register Socket 3
     105:  00:D3AD  (00:0024)           TMS45R		equ	TMS23R+2
     106:  00:D3AD  (00:0024)           TMSR4		equ	TMS45R+0	; Transmit Memory Size Register Socket 4
     107:  00:D3AD  (00:0025)           TMSR5		equ	TMS45R+1	; Transmit Memory Size Register Socket 5
     108:  00:D3AD  (00:0026)           TMS67R		equ	TMS45R+2
     109:  00:D3AD  (00:0026)           TMSR6		equ	TMS67R+0	; Transmit Memory Size Register Socket 6
     110:  00:D3AD  (00:0027)           TMSR7		equ	TMS67R+1	; Transmit Memory Size Register Socket 7
     111:  00:D3AD                      
     112:  00:D3AD  (00:0028)           RMS01R		equ	28h
     113:  00:D3AD  (00:0028)           RMSR0		equ	RMS01R+0	; Receive Memory Size Register Socket 0
     114:  00:D3AD  (00:0029)           RMSR1		equ	RMS01R+1	; Receive Memory Size Register Socket 1
     115:  00:D3AD  (00:002A)           RMS23R		equ	RMS01R+2
     116:  00:D3AD  (00:002A)           RMSR2		equ	RMS23R+0	; Receive Memory Size Register Socket 2
     117:  00:D3AD  (00:002B)           RMSR3		equ	RMS23R+1	; Receive Memory Size Register Socket 3
     118:  00:D3AD  (00:002C)           RMS45R		equ	RMS23R+2
     119:  00:D3AD  (00:002C)           RMSR4		equ	RMS45R+0	; Receive Memory Size Register Socket 4
     120:  00:D3AD  (00:002D)           RMSR5		equ	RMS45R+1	; Receive Memory Size Register Socket 5
     121:  00:D3AD  (00:002E)           RMS67R		equ	RMS45R+2
     122:  00:D3AD  (00:002E)           RMSR6		equ	RMS67R+0	; Receive Memory Size Register Socket 6
     123:  00:D3AD  (00:002F)           RMSR7		equ	RMS67R+1	; Receive Memory Size Register Socket 7
     124:  00:D3AD                      
     125:  00:D3AD  (00:0030)           MTYPER  	equ	30h		; Memory Block Type Register
     126:  00:D3AD  (00:0030)           MTYPER0		equ	MTYPER+0
     127:  00:D3AD  (00:0031)           MTYPER1		equ	MTYPER+1
     128:  00:D3AD                      
     129:  00:D3AD  (00:0032)           PATR0		equ	32h		; PPPoE Authentication Register
     130:  00:D3AD  (00:0033)           PATR1		equ	33h
     131:  00:D3AD                      
     132:  00:D3AD  (00:0037)           PTIMER1		equ	37h		; PPP LCP Request Time Register
     133:  00:D3AD                      
     134:  00:D3AD  (00:0038)           PMAGICR0	equ	38h		; PPP LCP Magic Number Register
     135:  00:D3AD  (00:0039)           PMAGICR1	equ	39h
     136:  00:D3AD                      
     137:  00:D3AD  (00:003C)           PSIDR0		equ	3ch		; PPP Session ID Register
     138:  00:D3AD  (00:003D)           PSIDR1		equ	3dh
     139:  00:D3AD                      
     140:  00:D3AD  (00:0040)           PDHAR0		equ	40h		; PPP Dest Hardware Address Register
     141:  00:D3AD  (00:0041)           PHARD1		equ	41h
     142:  00:D3AD  (00:0042)           PHARD2		equ	42h
     143:  00:D3AD  (00:0043)           PHARD3		equ	43h
     144:  00:D3AD  (00:0044)           PHARD4		equ	44h
     145:  00:D3AD  (00:0045)           PHARD5		equ	45h
     146:  00:D3AD                      
     147:  00:D3AD  (00:0048)           UIPR0		equ	48h		; Unreachable IP Address Register
     148:  00:D3AD  (00:0049)           UIPR1		equ	49h
     149:  00:D3AD  (00:004A)           UIPR2		equ	4ah
     150:  00:D3AD  (00:004B)           UIPR3		equ	4bh
     151:  00:D3AD                      
     152:  00:D3AD  (00:004C)           UPORTR0		equ	4ch		; Unreachable Port Number Register
     153:  00:D3AD  (00:004D)           UPORTR1		equ	4dh
     154:  00:D3AD                      
     155:  00:D3AD  (00:004E)           FMTUR0		equ	4eh		; Fragmant MTU Register
     156:  00:D3AD  (00:004F)           FMTUR1		equ	4fh
     157:  00:D3AD                      
     158:  00:D3AD  (00:0061)           P0_BRDYR1	equ	61h		; Pin BRDY0 Configure Register
     159:  00:D3AD  (00:0062)           P0_BDPTHR0 	equ	62h		; Pin BRDY0 Buffer Depth Register
     160:  00:D3AD  (00:0063)           P0_BDPTHR1 	equ	63h
     161:  00:D3AD                      
     162:  00:D3AD  (00:0065)           P1_BRDYR1	equ	65h		; Pin BRDY1 Configure Register
     163:  00:D3AD  (00:0066)           P1_BDPTHR0 	equ	66h		; Pin BRDY1 Buffer Depth Register
     164:  00:D3AD  (00:0067)           P1_BDPTHR1 	equ	67h
     165:  00:D3AD                      
     166:  00:D3AD  (00:0069)           P2_BRDYR1	equ	69h		; Pin BRDY2 Configure Register
     167:  00:D3AD  (00:006A)           P2_BDPTHR0 	equ	6ah		; Pin BRDY2 Buffer Depth Register
     168:  00:D3AD  (00:006B)           P2_BDPTHR1 	equ	6bh
     169:  00:D3AD                      
     170:  00:D3AD  (00:006D)           P3_BRDYR1	equ	6dh		; Pin BRDY3 Configure Register
     171:  00:D3AD  (00:006E)           P3_BDPTHR0 	equ	6eh		; Pin BRDY3 Buffer Depth Register
     172:  00:D3AD  (00:006F)           P3_BDPTHR1 	equ	6fh
     173:  00:D3AD                      ;
     174:  00:D3AD  (00:00FE)           IDR     	equ	0feh		; W5300 ID Register
     175:  00:D3AD  (00:00FE)           IDR0		equ	IDR
     176:  00:D3AD  (00:00FF)           IDR1		equ	IDR+1
     177:  00:D3AD                      ;
     178:  00:D3AD                      ;
     179:  00:D3AD                      ;------------------------------------------------------------------------------
     180:  00:D3AD                      ; SOCKET registers
     181:  00:D3AD                      ;
     182:  00:D3AD  (00:0200)           SOCKETS		equ	0x200		; First socket register
     183:  00:D3AD                      
     184:  00:D3AD  (00:0200)           SOCKET0		equ	SOCKETS+0
     185:  00:D3AD  (00:0240)           SOCKET1		equ	SOCKET0+040h
     186:  00:D3AD  (00:0280)           SOCKET2 	equ	SOCKET1+040h
     187:  00:D3AD  (00:02C0)           SOCKET3 	equ	SOCKET2+040h
     188:  00:D3AD  (00:0300)           SOCKET4 	equ	SOCKET3+040h
     189:  00:D3AD  (00:0340)           SOCKET5 	equ	SOCKET4+040h
     190:  00:D3AD  (00:0380)           SOCKET6 	equ	SOCKET5+040h
     191:  00:D3AD  (00:03C0)           SOCKET7 	equ	SOCKET6+040h
     192:  00:D3AD                      ;
     193:  00:D3AD                      ;
     194:  00:D3AD                      ; Offsets from socket base registers above
     195:  00:D3AD  (00:0000)           Sn_MR		equ	00h		; Socket Mode Register
     196:  00:D3AD  (00:0000)           Sn_MR0		equ	Sn_MR+0
     197:  00:D3AD  (00:0001)           Sn_MR1		equ	Sn_MR+1
     198:  00:D3AD  (00:0000)           Sn_MR_CLOSED	equ	00h
     199:  00:D3AD  (00:0001)           Sn_MR_TCP	equ	01h
     200:  00:D3AD  (00:0002)           Sn_MR_UDP	equ	02h
     201:  00:D3AD  (00:0003)           Sn_MR_IPRAW	equ	03h
     202:  00:D3AD  (00:0004)           Sn_MR_MACRAW	equ	04h
     203:  00:D3AD  (00:0005)           Sn_MR_PPPoE	equ	05h
     204:  00:D3AD  (00:0020)           Sn_MR_ND	equ	20h
     205:  00:D3AD                      ;
     206:  00:D3AD  (00:0002)           Sn_CR		equ	02h		; Socket Command register
     207:  00:D3AD  (00:0002)           Sn_CR0		equ	Sn_CR+0
     208:  00:D3AD  (00:0003)           Sn_CR1		equ	Sn_CR+1
     209:  00:D3AD  (00:0001)           Sn_CR_OPEN	equ	01h
     210:  00:D3AD  (00:0002)           Sn_CR_LISTEN	equ	02h
     211:  00:D3AD  (00:0004)           Sn_CR_CONNECT	equ	04h
     212:  00:D3AD  (00:0008)           Sn_CR_DISCON	equ	08h
     213:  00:D3AD  (00:0010)           Sn_CR_CLOSE	equ	10h
     214:  00:D3AD  (00:0020)           Sn_CR_SEND	equ	20h
     215:  00:D3AD  (00:0021)           Sn_CR_SEND_MAC	equ	21h
     216:  00:D3AD  (00:0022)           Sn_CR_SEND_KEEP	equ	22h
     217:  00:D3AD  (00:0040)           Sn_CR_RECV	equ	40h
     218:  00:D3AD                      ;
     219:  00:D3AD  (00:0004)           Sn_IMR		equ	04h		; Socket Interrupt Mask Register
     220:  00:D3AD  (00:0004)           Sn_IMR0		equ	Sn_IMR+0
     221:  00:D3AD  (00:0005)           Sn_IMR1		equ	Sn_IMR+1
     222:  00:D3AD                      ;
     223:  00:D3AD  (00:0006)           Sn_IR		equ	06h		; Socket Interrupt Register
     224:  00:D3AD  (00:0007)           Sn_IR1		equ	Sn_IR+1		; (IR0 "reserved")
     225:  00:D3AD  (00:0080)           Sn_IR_PRECV	equ	80h
     226:  00:D3AD  (00:0040)           Sn_IR_PFAIL	equ	40h
     227:  00:D3AD  (00:0020)           Sn_IR_PNEXT	equ	20h
     228:  00:D3AD  (00:0010)           Sn_IR_SENDOK	equ	10h
     229:  00:D3AD  (00:0008)           Sn_IR_TIMEOUT	equ	08h
     230:  00:D3AD  (00:0004)           Sn_IR_RECV	equ	04h
     231:  00:D3AD  (00:0002)           Sn_IR_DISCON	equ	02h
     232:  00:D3AD  (00:0001)           Sn_IR_CON	equ	01h
     233:  00:D3AD                      ;
     234:  00:D3AD  (00:0008)           Sn_SSR		equ	08h		; Socket Status Register
     235:  00:D3AD  (00:0009)           Sn_SSR1		equ	Sn_SSR+1	; (SSR0 "reserved")
     236:  00:D3AD  (00:0000)           Sn_SSR_CLOSED	equ	00h
     237:  00:D3AD  (00:0013)           Sn_SSR_INIT	equ	13h
     238:  00:D3AD  (00:0014)           Sn_SSR_LISTEN	equ	14h
     239:  00:D3AD  (00:0017)           Sn_SSR_ESTAB	equ	17h
     240:  00:D3AD  (00:001C)           Sn_SSR_WAIT	equ	1ch
     241:  00:D3AD  (00:0022)           Sn_SSR_UDP	equ	22h
     242:  00:D3AD  (00:0032)           Sn_SSR_IPRAW	equ	32h
     243:  00:D3AD  (00:0042)           Sn_SSR_MACRAW	equ	42h
     244:  00:D3AD  (00:005F)           Sn_SSR_PPPoE	equ	5fh
     245:  00:D3AD  (00:0015)           Sn_SSR_SYNSENT	equ	15h
     246:  00:D3AD  (00:0016)           Sn_SSR_SYNRECV	equ	16h
     247:  00:D3AD  (00:0018)           Sn_SSR_FIN_WAIT	equ	18h
     248:  00:D3AD  (00:001B)           Sn_SSR_TIME_WAIT equ	1bh
     249:  00:D3AD  (00:001D)           Sn_SSR_LAST_ACK	equ	1dh
     250:  00:D3AD  (00:0001)           Sn_SSR_ARP	equ	01h
     251:  00:D3AD                      ;
     252:  00:D3AD  (00:000A)           Sn_PORTR	equ	0ah		; Socket Source Port Register
     253:  00:D3AD                      ;
     254:  00:D3AD  (00:000C)           Sn_DHAR		equ	0ch		; Socket Dest Hardware Address Register
     255:  00:D3AD                      ;
     256:  00:D3AD  (00:0012)           Sn_DPORTR	equ	12h		; Socket Destination Port Register
     257:  00:D3AD                      ;
     258:  00:D3AD  (00:0014)           Sn_DIPR		equ	14h		; Socket Destination IP Address Register
     259:  00:D3AD  (00:0016)           Sn_DIPR2	equ	16h
     260:  00:D3AD                      ;
     261:  00:D3AD  (00:0018)           Sn_MSSR		equ	18h		; Socket Maximum Segment Size Register
     262:  00:D3AD                      ;
     263:  00:D3AD  (00:001A)           Sn_PORTOR	equ	1ah		; Socket Options Register
     264:  00:D3AD                      ;
     265:  00:D3AD  (00:001C)           Sn_TOSR		equ	1ch		; Socket TOS Register
     266:  00:D3AD                      ;
     267:  00:D3AD  (00:001E)           Sn_TTLR		equ	1eh		; Socket TTL Register
     268:  00:D3AD                      ;
     269:  00:D3AD  (00:0020)           Sn_TX_WRSR	equ	20h		; Socket Write Size Register
     270:  00:D3AD  (00:0022)           Sn_TX_WRSR2	equ	22h
     271:  00:D3AD                      ;
     272:  00:D3AD  (00:0024)           Sn_TX_FSR	equ	24h		; Socket Free Size Register
     273:  00:D3AD  (00:0026)           Sn_TX_FSR2	equ	26h
     274:  00:D3AD                      ;
     275:  00:D3AD  (00:0028)           Sn_RX_RSR	equ	28h		; Socket Receive Size Register
     276:  00:D3AD  (00:002A)           Sn_RX_RSR2	equ	2ah
     277:  00:D3AD                      ;
     278:  00:D3AD  (00:002C)           Sn_FRAGR	equ	2ch		; Socket Frag register
     279:  00:D3AD                      ;
     280:  00:D3AD  (00:002E)           Sn_TX_FIFOR	equ	2eh		; Socket 0 Tx FIFO Register
     281:  00:D3AD                      ;
     282:  00:D3AD  (00:0030)           Sn_RX_FIFOR	equ	30h		; Socket 0 Rx FIFO Register
     283:  00:D3AD                      ;
     284:  00:D3AD                      ;
     285:  00:D3AD                      
     286:  00:D3AD                      		endmodule
     102.  00:D3AD                      	include wiz.asm
       1:  00:D3AD                      ; WIZ
       2:  00:D3AD                      ;
       3:  00:D3AD                      ; Basic functions for accessing and initialising the WIZ module
       4:  00:D3AD                      ;
       5:  00:D3AD                      		module wiz
       6:  00:D3AD                      ;
       7:  00:D3AD                      ;==============================================================================
       8:  00:D3AD                      ;
       9:  00:D3AD                      ; This file is part of the EPNET software
      10:  00:D3AD                      ;
      11:  00:D3AD                      ; Copyright (C) 2015  Bruce Tanner
      12:  00:D3AD                      ;
      13:  00:D3AD                      ;    This program is free software: you can redistribute it and/or modify
      14:  00:D3AD                      ;    it under the terms of the GNU General Public License as published by
      15:  00:D3AD                      ;    the Free Software Foundation, either version 3 of the License, or
      16:  00:D3AD                      ;    (at your option) any later version.
      17:  00:D3AD                      ;
      18:  00:D3AD                      ;    This program is distributed in the hope that it will be useful,
      19:  00:D3AD                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      20:  00:D3AD                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      21:  00:D3AD                      ;    GNU General Public License for more details.
      22:  00:D3AD                      ;
      23:  00:D3AD                      ;    You should have received a copy of the GNU General Public License
      24:  00:D3AD                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      25:  00:D3AD                      ;
      26:  00:D3AD                      ; If you do use or modify this file, either for its original purpose or for
      27:  00:D3AD                      ; something new, I'd love to hear about it! I can be contacted by email at:
      28:  00:D3AD                      ;
      29:  00:D3AD                      ; brucetanner@btopenworld.com
      30:  00:D3AD                      ;
      31:  00:D3AD                      ;==============================================================================
      32:  00:D3AD                      ;
      33:  00:D3AD  (00:0008)           SOCKETS		equ	8
      34:  00:D3AD                      ;
      35:  00:D3AD                      ;
      36:  00:D3AD                      ;------------------------------------------------------------------------------
      37:  00:D3AD                      ; read_reg
      38:  00:D3AD                      ;
      39:  00:D3AD                      ; Reads a 16-bit wiz register. socket.asm contains an equivalent routine for
      40:  00:D3AD                      ; reading a per-socket wiz register.
      41:  00:D3AD                      ;
      42:  00:D3AD                      ; In:  DE: W5300 register
      43:  00:D3AD                      ; Out: HL=value read
      44:  00:D3AD                      ;      B,DE preserved
      45:  00:D3AD                      ;
      46:  00:D3AD  FD 4E 01            read_reg:	ld	c,(iy+vars._io)	; Address Register H
      47:  00:D3B0                      ;
      48:  00:D3B0  ED 51               		out	(c),d
      49:  00:D3B2  0C                  		inc	c		; Address Register L
      50:  00:D3B3                      ;
      51:  00:D3B3  ED 59               		out	(c),e
      52:  00:D3B5  0C                  		inc	c		; Data register H
      53:  00:D3B6                      ;
      54:  00:D3B6  ED 60               		in	h,(c)
      55:  00:D3B8  0C                  		inc	c		; Data Register L
      56:  00:D3B9                      ;
      57:  00:D3B9  ED 68               		in	l,(c)
      58:  00:D3BB                      ;
      59:  00:D3BB  C9                  		ret
      60:  00:D3BC                      ;
      61:  00:D3BC                      ;
      62:  00:D3BC                      ;------------------------------------------------------------------------------
      63:  00:D3BC                      ; write_reg
      64:  00:D3BC                      ;
      65:  00:D3BC                      ; Writes a 16-bit value to a wiz register. socket.asm contains an equivalent
      66:  00:D3BC                      ; routine for writing to a per-socket wiz register.
      67:  00:D3BC                      ;
      68:  00:D3BC                      ; In:  DE: W5300 register
      69:  00:D3BC                      ;      HL: value to write
      70:  00:D3BC                      ;      B,DE preserved
      71:  00:D3BC                      ;
      72:  00:D3BC  FD 4E 01            write_reg:	ld	c,(iy+vars._io)	; Address Register H
      73:  00:D3BF                      ;
      74:  00:D3BF  ED 51               		out	(c),d
      75:  00:D3C1  0C                  		inc	c		; Address Register L
      76:  00:D3C2                      ;
      77:  00:D3C2  ED 59               		out	(c),e
      78:  00:D3C4  0C                  		inc	c		; Data register H
      79:  00:D3C5                      ;
      80:  00:D3C5  ED 61               		out	(c),h
      81:  00:D3C7  0C                  		inc	c		; Data register L
      82:  00:D3C8                      ;
      83:  00:D3C8  ED 69               		out	(c),l
      84:  00:D3CA                      ;
      85:  00:D3CA  C9                  		ret
      86:  00:D3CB                      ;
      87:  00:D3CB                      ;
      88:  00:D3CB                      ;------------------------------------------------------------------------------
      89:  00:D3CB                      ; write_IP, write_MAC
      90:  00:D3CB                      ;
      91:  00:D3CB                      ; Reads a MAC/IP address from/to 3/2 successive WIZ registers
      92:  00:D3CB                      ;
      93:  00:D3CB                      ; In:  HL->MAC/IP address
      94:  00:D3CB                      ;      DE=WIZ register
      95:  00:D3CB                      ; Out: BC and all input registers corrupted
      96:  00:D3CB                      ;
      97:  00:D3CB  06 04               write_IP:	ld	b,4
      98:  00:D3CD  18 02               		jr	writeloop
      99:  00:D3CF                      ;
     100:  00:D3CF                      write_MAC:
     101:  00:D3CF  06 06               		ld	b,6
     102:  00:D3D1  FD 4E 01            writeloop:	ld	c,(iy+vars._io)	; Address Register H
     103:  00:D3D4                      ;
     104:  00:D3D4  ED 51               		out	(c),d
     105:  00:D3D6  0C                  		inc	c		; Address Register L
     106:  00:D3D7                      ;
     107:  00:D3D7  ED 59               		out	(c),e
     108:  00:D3D9  0C                  		inc	c		; Returnn pointing to data reg
     109:  00:D3DA                      ;
     110:  00:D3DA  1C                  		inc	e		; Next register next time
     111:  00:D3DB  1C                  		inc	e
     112:  00:D3DC                      ;
     113:  00:D3DC  ED A3               		outi
     114:  00:D3DE  0C                  		inc	c
     115:  00:D3DF                      ;
     116:  00:D3DF  ED A3               		outi
     117:  00:D3E1                      ;
     118:  00:D3E1  20 EE               		jr	nz,writeloop
     119:  00:D3E3                      ;
     120:  00:D3E3  C9                  		ret
     121:  00:D3E4                      ;
     122:  00:D3E4                      ;
     123:  00:D3E4                      ;------------------------------------------------------------------------------
     124:  00:D3E4                      ; read_IP, read_MAC
     125:  00:D3E4                      ;
     126:  00:D3E4                      ; In:  HL->MAC/IP address
     127:  00:D3E4                      ;      DE=WIZ register
     128:  00:D3E4                      ; Out: BC and all input registers corrupted
     129:  00:D3E4                      ;
     130:  00:D3E4  06 04               read_IP:	ld	b,4
     131:  00:D3E6  18 02               		jr	readloop
     132:  00:D3E8                      ;
     133:  00:D3E8  06 06               read_MAC:	ld	b,6
     134:  00:D3EA  FD 4E 01            readloop:	ld	c,(iy+vars._io)	; Address Register H
     135:  00:D3ED                      ;
     136:  00:D3ED  ED 51               		out	(c),d
     137:  00:D3EF  0C                  		inc	c		; Address Register L
     138:  00:D3F0                      ;
     139:  00:D3F0  ED 59               		out	(c),e
     140:  00:D3F2  0C                  		inc	c		; Returnn pointing to data reg
     141:  00:D3F3                      ;
     142:  00:D3F3  1C                  		inc	e		; Next register next time
     143:  00:D3F4  1C                  		inc	e
     144:  00:D3F5                      
     145:  00:D3F5  ED A2               		ini
     146:  00:D3F7  0C                  		inc	c
     147:  00:D3F8                      ;
     148:  00:D3F8  ED A2               		ini
     149:  00:D3FA                      ;
     150:  00:D3FA  20 EE               		jr	nz,readloop
     151:  00:D3FC                      ;
     152:  00:D3FC  C9                  		ret
     153:  00:D3FD                      ;
     154:  00:D3FD                      ;
     155:  00:D3FD                      ;------------------------------------------------------------------------------
     156:  00:D3FD                      ; init_mem
     157:  00:D3FD                      ;
     158:  00:D3FD                      ; Set up w5300 memory partitioning to 8k for receive and transmit for each
     159:  00:D3FD                      ; socket. Although the documentation says this is the default, all source
     160:  00:D3FD                      ; code I have seen does this and a WIZNET reply to a WIZNET forum post
     161:  00:D3FD                      ; suggests that this is necessary anyway
     162:  00:D3FD                      ;
     163:  00:D3FD                      init_mem:
     164:  00:D3FD  21 08 08            		ld	hl,0808h
     165:  00:D400                      ;
     166:  00:D400  11 20 00            		ld	de,w5300.TMS01R	; Set up tx memory
     167:  00:D403  CD 09 D4            		call	.write_x4
     168:  00:D406                      ;
     169:  00:D406  11 28 00            		ld	de,w5300.RMS01R	; Repeat for rx memory
     170:  00:D409                      .write_x4:	
     171:  00:D409  CD 0C D4            		call	.write_x2
     172:  00:D40C  CD 0F D4            .write_x2:	call	.write_x1
     173:  00:D40F  CD BC D3            .write_x1:	call	write_reg
     174:  00:D412  1C                  		inc	e
     175:  00:D413  1C                  		inc	e		; Next reg
     176:  00:D414                      ;
     177:  00:D414  C9                  		ret
     178:  00:D415                      ;
     179:  00:D415                      ;
     180:  00:D415                      ;------------------------------------------------------------------------------
     181:  00:D415                      ; init
     182:  00:D415                      ;
     183:  00:D415                      ; Initialises the W5300.
     184:  00:D415                      ;
     185:  00:D415                      ; Once initialised, just returns without doing anything. But :NET DIAG needs
     186:  00:D415                      ; to re-initialise, so it resets the initialized flags before calling
     187:  00:D415                      ;
     188:  00:D415                      ; Out: C set if error
     189:  00:D415                      ;
     190:  00:D415                      init:
     191:  00:D415                      		; Set up WIZ indirect mode and reset
     192:  00:D415  B7                  		or	a		; NC=>ok
     193:  00:D416  FD CB 03 46         		bit	vars.init.wiz,(iy+vars._init)
     194:  00:D41A  C0                  		ret	nz		; Already initialized, NC
     195:  00:D41B                      ;
     196:  00:D41B  AF                  		xor	a
     197:  00:D41C  32 03 F0            		ld	(vars.init),a	; Nothing initialised yet
     198:  00:D41F                      ;
     199:  00:D41F  11 98 D0            		ld	de,trace.diag.reset
     200:  00:D422  CD EF CF            		call	trace.diag.str
     201:  00:D425                      ;
     202:  00:D425  3A 0D C0            		ld	a,(io)		; Get fixed ROM i/o address byte
     203:  00:D428  B7                  		or	a		; Using fixed i/o?
     204:  00:D429  20 03               		jr	nz,.gotio	; <>0 => yes
     205:  00:D42B                      ;
     206:  00:D42B  DB B3               		in	a,(ep.P3)	; Else get our ROM seg no
     207:  00:D42D  0F                  		rrca			; /2 gives i/o base address
     208:  00:D42E  3C                  .gotio:		inc	a
     209:  00:D42F  3C                  		inc	a
     210:  00:D430  32 01 F0            		ld	(vars.io),a	; For efficiency we save the i/o+2
     211:  00:D433                      ;
     212:  00:D433  3D                  		dec	a
     213:  00:D434  3D                  		dec	a
     214:  00:D435  F5                  		push	af		; Save base i/o port
     215:  00:D436  CD 10 D0            		 call	trace.diag.byte	; Print it
     216:  00:D439  CD E7 CF            		 call	trace.diag.dots
     217:  00:D43C  F1                  		pop	af		; A=base i/o address
     218:  00:D43D                      ;
     219:  00:D43D  4F                  		ld	c,a		; C->w5300.MR0
     220:  00:D43E  3E 38               		ld	a,w5300.MR0_WDF2 or w5300.MR0_WDF1 or w5300.MR0_WDF0
     221:  00:D440  ED 79               		out	(c),a		; Initialise mode register
     222:  00:D442                      ;
     223:  00:D442  0C                  		inc	c		; MR1
     224:  00:D443  3E 81               		ld	a,w5300.MR1_IND or w5300.MR1_RST
     225:  00:D445  ED 79               		out	(c),a		; Set up indirect mode & reset
     226:  00:D447                      ;
     227:  00:D447                      		; Wait for at least 10mS for w5300's PLL to sync.
     228:  00:D447  CD 88 D5            		call	delay
     229:  00:D44A                      
     230:  00:D44A  3E 01               		ld	a,w5300.MR1_IND	; Make sure we're still in indirect mode
     231:  00:D44C  ED 79               		out	(c),a
     232:  00:D44E                      ;
     233:  00:D44E                      		; Clear Interrupt Mask Register (we don't use interrupts)
     234:  00:D44E  11 04 00            		ld	de,w5300.IMR
     235:  00:D451  21 00 00            		ld	hl,0
     236:  00:D454  CD BC D3            		call	write_reg
     237:  00:D457                      ;
     238:  00:D457  CD DD CF            		call	trace.diag.ok
     239:  00:D45A                      ;
     240:  00:D45A                      		; Make sure we can read the ID
     241:  00:D45A  11 AF D0            		ld	de,trace.diag.id
     242:  00:D45D  CD EF CF            		call	trace.diag.str
     243:  00:D460  CD E7 CF            		call	trace.diag.dots
     244:  00:D463                      ;
     245:  00:D463  11 FE 00            		ld	de,w5300.IDR
     246:  00:D466  CD AD D3            		call	read_reg
     247:  00:D469                      ;
     248:  00:D469  7C                  		ld	a,h
     249:  00:D46A  D6 53               		sub	53h		; Should get back 0x5300 for W5300
     250:  00:D46C  20 03               		jr	nz,.badid
     251:  00:D46E                      ;
     252:  00:D46E  B5                  		or	l
     253:  00:D46F  28 10               		jr	z,idok
     254:  00:D471                      ;
     255:  00:D471  CD 18 D0            .badid:		call	trace.diag.word
     256:  00:D474  CD E2 CF            diagerr:	call	trace.diag.err
     257:  00:D477  37                  		scf			; :-(
     258:  00:D478  C9                  		ret
     259:  00:D479                      ;
     260:  00:D479  11 33 D1            diagtimeout:	ld	de,trace.diag.timeout
     261:  00:D47C  CD EF CF            		call	trace.diag.str
     262:  00:D47F  37                  		scf
     263:  00:D480  C9                  		ret
     264:  00:D481                      ;
     265:  00:D481  CD DD CF            idok:		call	trace.diag.ok
     266:  00:D484                      ;
     267:  00:D484  CD FD D3            		call	init_mem	; Set up WIZ memory partitioning
     268:  00:D487                      ;
     269:  00:D487                      ;
     270:  00:D487                      		; Do memory test of WIZ memory
     271:  00:D487  11 0A D1            		ld	de,trace.diag.memory
     272:  00:D48A  CD EF CF            		call	trace.diag.str
     273:  00:D48D                      ;
     274:  00:D48D  11 30 00            		ld	de,w5300.MTYPER
     275:  00:D490  21 FF 00            		ld	hl,00ffh	; Top byte Rx, bottom Tx
     276:  00:D493  CD BC D3            		call	write_reg
     277:  00:D496                      ;	
     278:  00:D496  FD 4E 01            		ld	c,(iy+vars._io)
     279:  00:D499  0D                  		dec	c		; C->w5300.MR1
     280:  00:D49A  3E 21               		ld	a,w5300.MR1_IND or w5300.MR1_MT
     281:  00:D49C  ED 79               		out	(c),a		; Set up indirect mode & mem test
     282:  00:D49E                      ;
     283:  00:D49E  11 00 02            		ld	de,w5300.SOCKET0+w5300.Sn_MR
     284:  00:D4A1  21 01 00            		ld	hl,w5300.Sn_MR_TCP	; Open socket 0 in TCP mode
     285:  00:D4A4  CD BC D3            		call	write_reg
     286:  00:D4A7                      ;
     287:  00:D4A7  11 02 02            		ld	de,w5300.SOCKET0+w5300.Sn_CR
     288:  00:D4AA  21 01 00            		ld	hl,w5300.Sn_CR_OPEN
     289:  00:D4AD  CD BC D3            		call	write_reg	; Set OPEN command
     290:  00:D4B0                      ;
     291:  00:D4B0  1E 13               		ld	e,w5300.Sn_SSR_INIT
     292:  00:D4B2  CD 9F D5            		call	wait_SSR	; Wait for command to complete
     293:  00:D4B5  38 C2               		jr	c,diagtimeout
     294:  00:D4B7                      ;
     295:  00:D4B7                      
     296:  00:D4B7                      		; Now we test the WIZ memory but only in diag mode (for speed)
     297:  00:D4B7  FD CB 00 46         		bit	vars.trace.diag,(iy+vars._trace)
     298:  00:D4BB  28 5F               		jr	z,.finish	; NC
     299:  00:D4BD                      ;
     300:  00:D4BD                      		; Now write test values to socket tx memory
     301:  00:D4BD  21 00 00            		ld	hl,0		; Initial test value
     302:  00:D4C0  01 00 10            		ld	bc,8192/2	; Word count
     303:  00:D4C3  11 2E 02            .wloop:		ld	de,w5300.SOCKET0+w5300.Sn_TX_FIFOR
     304:  00:D4C6  C5                  		push	bc
     305:  00:D4C7  E5                  		push	hl
     306:  00:D4C8  CD BC D3            		call	write_reg
     307:  00:D4CB  E1                  		pop	hl
     308:  00:D4CC  C1                  		pop	bc
     309:  00:D4CD  24                  		inc	h		; Test value next time
     310:  00:D4CE  2C                  		inc	l
     311:  00:D4CF  0B                  		dec	bc
     312:  00:D4D0  78                  		ld	a,b
     313:  00:D4D1  B1                  		or	c
     314:  00:D4D2  20 EF               		jr	nz,.wloop
     315:  00:D4D4                      ;
     316:  00:D4D4                      		; See if we can read them back
     317:  00:D4D4  21 00 00            		ld	hl,0
     318:  00:D4D7  01 00 10            		ld	bc,8192/2
     319:  00:D4DA  11 2E 02            .rloop:		ld	de,w5300.SOCKET0+w5300.Sn_TX_FIFOR
     320:  00:D4DD  C5                  		push	bc
     321:  00:D4DE  E5                  		push	hl
     322:  00:D4DF  CD AD D3            		call	read_reg
     323:  00:D4E2  D1                  		pop	de
     324:  00:D4E3  C1                  		pop	bc
     325:  00:D4E4  B7                  		or	a
     326:  00:D4E5  ED 52               		sbc	hl,de
     327:  00:D4E7  28 2A               		jr	z,.rok
     328:  00:D4E9                      ;
     329:  00:D4E9  19                  		add	hl,de		; DE=expected value, HL=actual
     330:  00:D4EA                      ;
     331:  00:D4EA  C5                  		push	bc
     332:  00:D4EB  D5                  		push	de
     333:  00:D4EC  E5                  		push	hl
     334:  00:D4ED  11 1D D1            		ld	de,trace.diag.memerr
     335:  00:D4F0  CD EF CF            		call	trace.diag.str
     336:  00:D4F3  E1                  		pop	hl
     337:  00:D4F4  CD 18 D0            		call	trace.diag.word	; Print actual
     338:  00:D4F7  11 23 D1            		ld	de,trace.diag.expected
     339:  00:D4FA  CD EF CF            		call	trace.diag.str
     340:  00:D4FD  E1                  		pop	hl
     341:  00:D4FE  CD 18 D0            		call	trace.diag.word	; Print expected
     342:  00:D501  11 2E D1            		ld	de,trace.diag.at
     343:  00:D504  CD EF CF            		call	trace.diag.str
     344:  00:D507  E1                  		pop	hl
     345:  00:D508  CD 18 D0            		call	trace.diag.word	; Print location
     346:  00:D50B  3E 20               		ld	a,' '
     347:  00:D50D  CD 08 D0            		call	trace.diag.char
     348:  00:D510  37                  		scf
     349:  00:D511  18 09               		jr	.finish
     350:  00:D513                      ;
     351:  00:D513  EB                  .rok:		ex	de,hl		; HL=test value
     352:  00:D514  24                  		inc	h
     353:  00:D515  2C                  		inc	l
     354:  00:D516  0B                  		dec	bc
     355:  00:D517  78                  		ld	a,b
     356:  00:D518  B1                  		or	c
     357:  00:D519  20 BF               		jr	nz,.rloop
     358:  00:D51B                      ;
     359:  00:D51B  B7                  		or	a
     360:  00:D51C                      ;
     361:  00:D51C  F5                  .finish:	push	af		; C=>error
     362:  00:D51D  11 02 02            		ld	de,w5300.SOCKET0+w5300.Sn_CR
     363:  00:D520  21 10 00            		ld	hl,w5300.Sn_CR_CLOSE
     364:  00:D523  CD BC D3            		call	write_reg
     365:  00:D526                      ;
     366:  00:D526  1E 00               		ld	e,w5300.Sn_SSR_CLOSED
     367:  00:D528  CD 9F D5            		call	wait_SSR
     368:  00:D52B  DA 79 D4            		jp	c,diagtimeout
     369:  00:D52E                      ;
     370:  00:D52E  FD 4E 01            		ld	c,(iy+vars._io)
     371:  00:D531  0D                  		dec	c		; C->w5300.MR1
     372:  00:D532  3E 01               		ld	a,w5300.MR1_IND
     373:  00:D534  ED 79               		out	(c),a		; Set up indirect mode & no mem test
     374:  00:D536  F1                  		pop	af
     375:  00:D537  DA 74 D4            		jp	c,diagerr
     376:  00:D53A                      ;
     377:  00:D53A  CD DD CF            		call	trace.diag.ok
     378:  00:D53D                      ;
     379:  00:D53D                      ;
     380:  00:D53D                      		; Set the MAC address
     381:  00:D53D  11 B8 D0            		ld	de,trace.diag.writemac
     382:  00:D540  CD EF CF            		call	trace.diag.str
     383:  00:D543                      ;
     384:  00:D543  21 0E C0            		ld	hl,mac
     385:  00:D546  CD 20 D0            		call	trace.diag.mac
     386:  00:D549  CD E7 CF            		call	trace.diag.dots
     387:  00:D54C                      ;
     388:  00:D54C  21 0E C0            		ld	hl,mac
     389:  00:D54F  11 08 00            		ld	de,w5300.SHAR
     390:  00:D552  CD CF D3            		call	write_MAC
     391:  00:D555                      ;
     392:  00:D555                      		; Read it back & verify
     393:  00:D555  CD C6 D5            		call	get_MAC
     394:  00:D558  EB                  		ex	de,hl		; DE->MAC address
     395:  00:D559                      ;
     396:  00:D559  21 0E C0            		ld	hl,mac
     397:  00:D55C  11 11 F0            		ld	de,vars.diag.buffer
     398:  00:D55F  06 06               		ld	b,6
     399:  00:D561  1A                  .macloop:	ld	a,(de)
     400:  00:D562  13                  		inc	de
     401:  00:D563  BE                  		cp	(hl)
     402:  00:D564  23                  		inc	hl
     403:  00:D565  20 07               		jr	nz,.badmac
     404:  00:D567                      ;
     405:  00:D567  10 F8               		djnz	.macloop
     406:  00:D569                      ;
     407:  00:D569  CD DD CF            		call	trace.diag.ok
     408:  00:D56C  18 09               		jr	.macok
     409:  00:D56E                      ;
     410:  00:D56E  21 11 F0            .badmac:	ld	hl,vars.diag.buffer
     411:  00:D571  CD 20 D0            		call	trace.diag.mac
     412:  00:D574                      ;
     413:  00:D574  C3 74 D4            		jp	diagerr
     414:  00:D577                      ;
     415:  00:D577                      .macok:		
     416:  00:D577                      ;
     417:  00:D577  FD CB 03 C6         		set	vars.init.wiz,(iy+vars._init)
     418:  00:D57B  C9                  		ret
     419:  00:D57C                      ;
     420:  00:D57C                      ;
     421:  00:D57C                      ;------------------------------------------------------------------------------
     422:  00:D57C                      ; check_ip
     423:  00:D57C                      ;
     424:  00:D57C                      ; Called to see if we have a duplicate IP address on the network
     425:  00:D57C                      ;
     426:  00:D57C                      ; Out: Cy=>IP address conflict
     427:  00:D57C                      ;
     428:  00:D57C  11 02 00            check_ip:	ld	de,w5300.IR0
     429:  00:D57F  CD AD D3            		call	read_reg	; HL=IR0
     430:  00:D582  7C                  		ld	a,h		; A=high IR0
     431:  00:D583  E6 80               		and	80h		; A=NZ if IPCF (IP conflict) bit set
     432:  00:D585  C6 FF               		add	a,0ffh		; NZ=>Cy, Z=>NC
     433:  00:D587  C9                  		ret
     434:  00:D588                      ;
     435:  00:D588                      ;
     436:  00:D588                      ;------------------------------------------------------------------------------
     437:  00:D588                      ; delay
     438:  00:D588                      ;
     439:  00:D588                      ; We must wait at least 10mS after resetting the WIZ chip to allow its PLL
     440:  00:D588                      ; to lock on.
     441:  00:D588                      ;
     442:  00:D588                      ; The smallest resolution timer we have access to is the 20mS video interrupt.
     443:  00:D588                      ; So we wait for one interrupt and then wait for the next to ensure we wait
     444:  00:D588                      ; at least 20mS (it doesn't matter to the WIZ chip if we wait more than 10mS).
     445:  00:D588                      ;
     446:  00:D588  ED 5B 06 F0         delay:		ld	de,(vars.ticks)
     447:  00:D58C                      ;
     448:  00:D58C                      		; First wait for new tick
     449:  00:D58C  13                  		inc	de
     450:  00:D58D  2A 06 F0            .loopstart:	ld	hl,(vars.ticks)
     451:  00:D590  B7                  		or	a
     452:  00:D591  ED 52               		sbc	hl,de
     453:  00:D593  38 F8               		jr	c,.loopstart	; Wait for start of tick
     454:  00:D595                      ;
     455:  00:D595                      		; Then wait for end of next tick
     456:  00:D595  13                  		inc	de
     457:  00:D596  2A 06 F0            .loopend:	ld	hl,(vars.ticks)
     458:  00:D599  B7                  		or	a
     459:  00:D59A  ED 52               		sbc	hl,de
     460:  00:D59C  38 F8               		jr	c,.loopend
     461:  00:D59E                      ;
     462:  00:D59E  C9                  		ret
     463:  00:D59F                      ;
     464:  00:D59F                      ;
     465:  00:D59F                      ;------------------------------------------------------------------------------
     466:  00:D59F                      ; Waits for socket open or close to complete
     467:  00:D59F                      ;
     468:  00:D59F                      ; IN:  E=SN_SSR_xxx command to wait for
     469:  00:D59F                      ; Out: C=>timeout
     470:  00:D59F                      wait_SSR:
     471:  00:D59F  06 00               		ld	b,0		; Timeout, just in case
     472:  00:D5A1                      		; First wait for CR to become 0
     473:  00:D5A1  D5                  .wait_CR:	push	de
     474:  00:D5A2  11 02 02            		 ld	de,w5300.SOCKET0+w5300.Sn_CR
     475:  00:D5A5  C5                  		 push	bc
     476:  00:D5A6  CD AD D3            		  call	read_reg
     477:  00:D5A9  C1                  		 pop	bc
     478:  00:D5AA  D1                  		pop	de
     479:  00:D5AB  7C                  		ld	a,h
     480:  00:D5AC  B5                  		or	l
     481:  00:D5AD  28 04               		jr	z,.done_CR
     482:  00:D5AF                      ;
     483:  00:D5AF  10 F0               		djnz	.wait_CR
     484:  00:D5B1                      ;
     485:  00:D5B1  37                  		scf			; Timeout
     486:  00:D5B2  C9                  		ret
     487:  00:D5B3                      .done_CR:
     488:  00:D5B3                      ;
     489:  00:D5B3  06 00               		ld	b,0		; Timeout, just in case
     490:  00:D5B5                      		; Now wait for expected value in SSR
     491:  00:D5B5  D5                  .wait_SSR:	push	de
     492:  00:D5B6  11 08 02            		 ld	de,w5300.SOCKET0+w5300.Sn_SSR
     493:  00:D5B9  C5                  		 push	bc
     494:  00:D5BA  CD AD D3            		  call	read_reg
     495:  00:D5BD  C1                  		 pop	bc
     496:  00:D5BE  D1                  		pop	de
     497:  00:D5BF  7D                  		ld	a,l
     498:  00:D5C0  BB                  		cp	e
     499:  00:D5C1  C8                  		ret	z		; NC=>ok
     500:  00:D5C2                      ;
     501:  00:D5C2  10 F1               		djnz	.wait_SSR
     502:  00:D5C4                      ;
     503:  00:D5C4  37                  		scf
     504:  00:D5C5  C9                  		ret
     505:  00:D5C6                      ;
     506:  00:D5C6                      ;
     507:  00:D5C6                      ;
     508:  00:D5C6  11 08 00            get_MAC:	ld	de,w5300.SHAR
     509:  00:D5C9  21 11 F0            		ld	hl,vars.diag.buffer
     510:  00:D5CC  E5                  		push	hl
     511:  00:D5CD  CD E8 D3            		 call	read_MAC
     512:  00:D5D0  E1                  		pop	hl
     513:  00:D5D1                      ;
     514:  00:D5D1  C9                  		ret
     515:  00:D5D2                      ;
     516:  00:D5D2                      ;
     517:  00:D5D2                      ; In:  HL->IP address
     518:  00:D5D2                      ; Out: Cy=>error
     519:  00:D5D2                      
     520:  00:D5D2  11 C9 D0            set_ip:		ld	de,trace.diag.writeip
     521:  00:D5D5  CD EC CF            		call	trace.diag.startstr
     522:  00:D5D8                      ;
     523:  00:D5D8  11 18 00            		ld	de,w5300.SIPR
     524:  00:D5DB  18 25               		jr	setip
     525:  00:D5DD                      ;
     526:  00:D5DD                      ;
     527:  00:D5DD  11 18 00            get_ip:		ld	de,w5300.SIPR
     528:  00:D5E0                      ;
     529:  00:D5E0  21 11 F0            getip:		ld	hl,vars.diag.buffer
     530:  00:D5E3  E5                  		push	hl
     531:  00:D5E4  CD E4 D3            		 call	read_IP
     532:  00:D5E7  E1                  		pop	hl
     533:  00:D5E8  C9                  		ret
     534:  00:D5E9                      ;
     535:  00:D5E9                      ;
     536:  00:D5E9                      ; In:  HL->IP address
     537:  00:D5E9                      ; Out: Cy=>error
     538:  00:D5E9                      set_subnet:
     539:  00:D5E9  11 D9 D0            		ld	de,trace.diag.subnet
     540:  00:D5EC  CD EC CF            		call	trace.diag.startstr
     541:  00:D5EF                      ;
     542:  00:D5EF  11 14 00            		ld	de,w5300.SUBR
     543:  00:D5F2  18 0E               		jr	setip
     544:  00:D5F4                      ;
     545:  00:D5F4  11 14 00            get_subnet:	ld	de,w5300.SUBR
     546:  00:D5F7  18 E7               		jr	getip
     547:  00:D5F9                      ;
     548:  00:D5F9                      ;
     549:  00:D5F9                      ; In:  HL->IP address
     550:  00:D5F9                      ; Out: Cy=>error
     551:  00:D5F9                      set_gateway:
     552:  00:D5F9  11 EA D0            		ld	de,trace.diag.gateway
     553:  00:D5FC  CD EC CF            		call	trace.diag.startstr
     554:  00:D5FF                      ;
     555:  00:D5FF  11 10 00            		ld	de,w5300.GAR
     556:  00:D602                      ;
     557:  00:D602  D5                  setip:		push	de		; DE=WIZ register
     558:  00:D603  E5                  		push	hl		; HL->IP
     559:  00:D604  CD 28 D0            		call	trace.diag.ip
     560:  00:D607  CD E7 CF            		call	trace.diag.dots
     561:  00:D60A  E1                  		pop	hl
     562:  00:D60B  D1                  		pop	de
     563:  00:D60C                      ;
     564:  00:D60C  E5                  		push	hl
     565:  00:D60D  D5                  		push	de
     566:  00:D60E  CD CB D3            		call	write_IP
     567:  00:D611  D1                  		pop	de
     568:  00:D612  21 11 F0            		ld	hl,vars.diag.buffer
     569:  00:D615  CD E4 D3            		call	read_IP
     570:  00:D618  E1                  		pop	hl
     571:  00:D619                      ;
     572:  00:D619  11 11 F0            		ld	de,vars.diag.buffer
     573:  00:D61C  06 04               		ld	b,4
     574:  00:D61E  1A                  .loop:		ld	a,(de)
     575:  00:D61F  13                  		inc	de
     576:  00:D620  BE                  		cp	(hl)
     577:  00:D621  23                  		inc	hl
     578:  00:D622  20 07               		jr	nz,.badip
     579:  00:D624                      ;
     580:  00:D624  10 F8               		djnz	.loop
     581:  00:D626                      ;
     582:  00:D626  CD DD CF            		call	trace.diag.ok
     583:  00:D629                      ;
     584:  00:D629  B7                  		or	a		; No error
     585:  00:D62A  C9                  		ret
     586:  00:D62B                      ;
     587:  00:D62B  21 11 F0            .badip:		ld	hl,vars.diag.buffer
     588:  00:D62E  CD 28 D0            		call	trace.diag.ip
     589:  00:D631                      ;
     590:  00:D631  C3 74 D4            		jp	diagerr
     591:  00:D634                      ;
     592:  00:D634                      ;
     593:  00:D634  11 10 00            get_gateway:	ld	de,w5300.GAR
     594:  00:D637  18 A7               		jr	getip
     595:  00:D639                      ;
     596:  00:D639                      ;
     597:  00:D639                      ;
     598:  00:D639                      		endmodule
     103.  00:D639                      	include socket.asm
       1:  00:D639                      ; SOCKET
       2:  00:D639                      ;
       3:  00:D639                      ; This module implements an interface to the WIZ socket registers. It is used
       4:  00:D639                      ; by the protocol modules UDP.ASM, TCP.ASM and IPRAW.ASM.
       5:  00:D639                      ;
       6:  00:D639                      ;==============================================================================
       7:  00:D639                      ;
       8:  00:D639                      ; This file is part of the EPNET software
       9:  00:D639                      ;
      10:  00:D639                      ; Copyright (C) 2015  Bruce Tanner
      11:  00:D639                      ;
      12:  00:D639                      ;    This program is free software: you can redistribute it and/or modify
      13:  00:D639                      ;    it under the terms of the GNU General Public License as published by
      14:  00:D639                      ;    the Free Software Foundation, either version 3 of the License, or
      15:  00:D639                      ;    (at your option) any later version.
      16:  00:D639                      ;
      17:  00:D639                      ;    This program is distributed in the hope that it will be useful,
      18:  00:D639                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      19:  00:D639                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      20:  00:D639                      ;    GNU General Public License for more details.
      21:  00:D639                      ;
      22:  00:D639                      ;    You should have received a copy of the GNU General Public License
      23:  00:D639                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      24:  00:D639                      ;
      25:  00:D639                      ; If you do use or modify this file, either for its original purpose or for
      26:  00:D639                      ; something new, I'd love to hear about it! I can be contacted by email at:
      27:  00:D639                      ;
      28:  00:D639                      ; brucetanner@btopenworld.com
      29:  00:D639                      ;
      30:  00:D639                      ;==============================================================================
      31:  00:D639                      ;
      32:  00:D639                      ; The protocol interfaces take socket numbers as parameters, which need
      33:  00:D639                      ; to be converted to WIZ socket register numbers, which are offsets from
      34:  00:D639                      ; a socket base register. To do this efficiently this module identifies its
      35:  00:D639                      ; sockets as a socket base number in DE. The top two bits of E are the
      36:  00:D639                      ; bottom 2 bits of the socket number, and the bottom bit of D is the the top
      37:  00:D639                      ; bit of the socket number. Bit 1 of D is set. This means when the bottom
      38:  00:D639                      ; 6 bits of E are the socket register offset (the WIZ Sn_xxx constant), DE
      39:  00:D639                      ; is the correct WIZ register number.
      40:  00:D639                      ;
      41:  00:D639                      ; Ie. the socket number->base address mapping is:
      42:  00:D639                      ;
      43:  00:D639                      ; Socket    W5300 Base                D	       E (xxxxxx=WIZ Sn_xxx contant)
      44:  00:D639                      ; 00000000->00000010 00000000 (200h)  00000010 00xxxxxx
      45:  00:D639                      ; 00000001->00000010 01000000 (240h)  00000010 01xxxxxx
      46:  00:D639                      ; 00000010->00000010 10000000 (280h)  00000010 10xxxxxx
      47:  00:D639                      ; 00000011->00000010 11000000 (2c0h)  00000010 11xxxxxx
      48:  00:D639                      ; 00000100->00000011 00000000 (300h)  00000011 00xxxxxx
      49:  00:D639                      ; 00000101->00000011 01000000 (340h)  00000011 01xxxxxx
      50:  00:D639                      ; 00000110->00000011 10000000 (380h)  00000011 10xxxxxx
      51:  00:D639                      ; 00000111->00000011 11000000 (3c0h)  00000011 11xxxxxx
      52:  00:D639                      ;
      53:  00:D639                      ;
      54:  00:D639                      ; We also need to keep some per-socket variables and need to be able to
      55:  00:D639                      ; index into this efficiently. So we keep all the per-socket variables in one
      56:  00:D639                      ; 256-byte page (so 32 bytes/socket available). Thus we need to shift the
      57:  00:D639                      ; offset to the socket variable left and then shift DE right to get the low
      58:  00:D639                      ; byte of the address of the desired variable:
      59:  00:D639                      ;
      60:  00:D639                      ; Socket    LO RAM Address  D	     E       
      61:  00:D639                      ; 00000000->00000000 (00h)  00000010 00xxxxxx
      62:  00:D639                      ; 00000001->00100000 (20h)  00000010 01xxxxxx
      63:  00:D639                      ; 00000010->01000000 (40h)  00000010 10xxxxxx
      64:  00:D639                      ; 00000011->01100000 (60h)  00000010 11xxxxxx
      65:  00:D639                      ; 00000100->10000000 (80h)  00000011 00xxxxxx
      66:  00:D639                      ; 00000101->10100000 (a0h)  00000011 01xxxxxx
      67:  00:D639                      ; 00000110->11000000 (c0h)  00000011 10xxxxxx
      68:  00:D639                      ; 00000111->11100000 (e0h)  00000011 11xxxxxx
      69:  00:D639                      ;
      70:  00:D639                      ;
      71:  00:D639                      ; This macro convers a socket number in A to the base number in DE
      72:  00:D639                      ;
      73:  00:D639                      ;
      74:  00:D639                      		macro	SOCKET_GET_BASE
      75:  00:D639                    < 		 ld	de,0100h
      76:  00:D639                    < 		 rrca
      77:  00:D639                    < 		 rr	e
      78:  00:D639                    < 		 rrca
      79:  00:D639                    < 		 rr	e
      80:  00:D639                    < 		 rrca
      81:  00:D639                    < 		 rl	d
      82:  00:D639                    < 		endm
      83:  00:D639                      ;
      84:  00:D639                      ;
      85:  00:D639                      ; The same but for fixed socket 0 - more efficient
      86:  00:D639                      ;
      87:  00:D639                      		macro	SOCKET_GET_BASE_0
      88:  00:D639                    < 		 ld	de,0200h
      89:  00:D639                    < 		endm
      90:  00:D639                      ;
      91:  00:D639                      ;
      92:  00:D639                      ;------------------------------------------------------------------------------
      93:  00:D639                      ; This macro converts from the base number in DE and offset in A to a RAM
      94:  00:D639                      ; pointer in HL
      95:  00:D639                      		macro	SOCKET_GET_RAM
      96:  00:D639                    < 		 add	a,a
      97:  00:D639                    < 		 or	e
      98:  00:D639                    < 		 ld	l,a
      99:  00:D639                    < 		 ld	a,d
     100:  00:D639                    < 		 rrca
     101:  00:D639                    < 		 rr	l
     102:  00:D639                    < 		 ld	h,high vars.sockets
     103:  00:D639                    < 		endm
     104:  00:D639                      ;
     105:  00:D639                      ; Same but takes a fixed offset as a parameter
     106:  00:D639                      		macro	SOCKET_GET_VAR var
     107:  00:D639                    < 		 if	(var)=0
     108:  00:D639                    < 		  ld	a,e
     109:  00:D639                    < 		 else
     110:  00:D639                    < 		  ld	a,(var)*2
     111:  00:D639                    < 		  or	e
     112:  00:D639                    < 		 endif
     113:  00:D639                    < 		 ld	l,a
     114:  00:D639                    < 		 ld	a,d
     115:  00:D639                    < 		 rrca
     116:  00:D639                    < 		 rr	l
     117:  00:D639                    < 		 ld	h,high vars.sockets
     118:  00:D639                    < 		endm
     119:  00:D639                      ;
     120:  00:D639                      ; 
     121:  00:D639                      		module	socket
     122:  00:D639                      ;
     123:  00:D639                      ;
     124:  00:D639                      ; Structure of variables in per-socket RAM. DPORTR is a copy of the Sn_DPORTR
     125:  00:D639                      ; w5300 register that is necessary because a bug in the w5300 means its
     126:  00:D639                      ; SnDPORTR register cannot be read correctly
     127:  00:D639                      ;
     128:  00:D639                      		struct	vars
     129:  00:D639                    < owner		 word		; ->owner string
     130:  00:D639                    < tcp_connected	 byte		; NZ=>connected to remote party
     131:  00:D639                    < rx_size		 word
     132:  00:D639                    < rx_inhand	 word		; First byte FF => second byte buffered
     133:  00:D639                    < tx_size		 word
     134:  00:D639                    < tx_inhand	 word		; Second byte FF => first byte buffered!
     135:  00:D639                    < DPORTR		 word		; Copy of Sn_DPORTR
     136:  00:D639                    < 		ends
     137:  00:D639                      ;
     138:  00:D639                      ;
     139:  00:D639                      ;------------------------------------------------------------------------------
     140:  00:D639                      ; read_reg
     141:  00:D639                      ;
     142:  00:D639                      ; Reads a 16-bit socket register - as wiz.read_reg but for socket registers.
     143:  00:D639                      ;
     144:  00:D639                      ; In:  DE: W5300 socket base register
     145:  00:D639                      ;       A: Sn_xxx offset
     146:  00:D639                      ; Out: HL=value read
     147:  00:D639                      ;      DE,B preserved
     148:  00:D639                      ;
     149:  00:D639  FD 4E 01            read_reg:	ld	c,(iy+vars._io)	; Address Register H
     150:  00:D63C                      ;
     151:  00:D63C  ED 51               		out	(c),d
     152:  00:D63E  0C                  		inc	c		; Address Register L
     153:  00:D63F                      ;
     154:  00:D63F  B3                   		or	e
     155:  00:D640  ED 79               		out	(c),a
     156:  00:D642  0C                  		inc	c		; Data register H
     157:  00:D643                      ;
     158:  00:D643  ED 60               		in	h,(c)
     159:  00:D645  0C                  		inc	c		; Data Register L
     160:  00:D646                      ;
     161:  00:D646  ED 68               		in	l,(c)
     162:  00:D648                      ;
     163:  00:D648  C9                  		ret
     164:  00:D649                      ;
     165:  00:D649                      ;------------------------------------------------------------------------------
     166:  00:D649                      ; write_reg
     167:  00:D649                      ;
     168:  00:D649                      ; Writes a 16-bit socket register - as wiz.write_reg but for socket registers.
     169:  00:D649                      ;
     170:  00:D649                      ; In:  DE: W5300 socket base register
     171:  00:D649                      ;       A: Sn_xxx offset
     172:  00:D649                      ;      HL: value to write
     173:  00:D649                      ; Out: HL=value read
     174:  00:D649                      ;      HL,DE,B preserved
     175:  00:D649                      ;
     176:  00:D649  FD 4E 01            write_reg:	ld	c,(iy+vars._io)	; Address Register H
     177:  00:D64C                      ;
     178:  00:D64C  ED 51               		out	(c),d
     179:  00:D64E  0C                  		inc	c		; Address Register L
     180:  00:D64F                      ;
     181:  00:D64F  B3                  		or	e
     182:  00:D650  ED 79               		out	(c),a
     183:  00:D652  0C                  		inc	c		; Data register H
     184:  00:D653                      ;
     185:  00:D653  ED 61               		out	(c),h
     186:  00:D655  0C                  		inc	c		; Data register L
     187:  00:D656                      ;
     188:  00:D656  ED 69               		out	(c),l
     189:  00:D658                      ;
     190:  00:D658  C9                  		ret
     191:  00:D659                      ;
     192:  00:D659                      ;------------------------------------------------------------------------------
     193:  00:D659                      ;
     194:  00:D659                      ; read_FIFO
     195:  00:D659                      ;
     196:  00:D659                      ; Reads a block of words from a wiz rx fifo
     197:  00:D659                      ;
     198:  00:D659                      ; In:  HL->block
     199:  00:D659                      ;      DE=w5300 socket base register
     200:  00:D659                      ;      BC=byte count
     201:  00:D659                      ; Out: All input registers corrupted
     202:  00:D659                      ;
     203:  00:D659                      _read_FIFO:
     204:  00:D659                      ;
     205:  00:D659                      ; This version sets up B so that we can use INI's decrementing and testing 
     206:  00:D659                      ; of B, which is quicker, for an inner loop and D for an outer loop. We need to
     207:  00:D659                      ; fiddle the byte count registers a little, eg (all counts must be even!):
     208:  00:D659                      ;
     209:  00:D659                      ;   BC	 B (inner)	D (outer)
     210:  00:D659                      ; ----   ---------      ---------
     211:  00:D659                      ; 0001		01		1
     212:  00:D659                      ; 00fe		fe		1
     213:  00:D659                      ; 0100		00		1
     214:  00:D659                      ; 0101		01		2
     215:  00:D659                      ; 01fe		fe		2
     216:  00:D659                      ; 0200		00		2
     217:  00:D659                      ; 0201		01		3
     218:  00:D659                      ;
     219:  00:D659                      ; We also need to arrange the loops so that inc & dec of c, the i/o port, does
     220:  00:D659                      ; not corrupt the B loop count = 0 flag that INI puts in the overflow flag.
     221:  00:D659                      ;
     222:  00:D659  CD E9 CE            		call	status.activity
     223:  00:D65C                      
     224:  00:D65C  0B                  		dec	bc		; So BC=xx00 has correct outer loop count
     225:  00:D65D  79                  		ld	a,c		; A=inner loop count-1
     226:  00:D65E                      
     227:  00:D65E  FD 4E 01            		ld	c,(iy+vars._io)	; Address Register H
     228:  00:D661                      
     229:  00:D661  ED 51               		out	(c),d		; Output Address Register H
     230:  00:D663  0C                  		inc	c		; C->Address Register L
     231:  00:D664                      
     232:  00:D664  50                  		ld	d,b		; D=outer loop count-1
     233:  00:D665  14                  		inc	d		; D=outer loop count
     234:  00:D666  47                  		ld	b,a		; B=inner loop count-1
     235:  00:D667  04                  		inc	b		; B=inner loop count
     236:  00:D668                      
     237:  00:D668  3E 30               		ld	a,w5300.Sn_RX_FIFOR
     238:  00:D66A  B3                  		or	e		; A=Sn_xxx register number
     239:  00:D66B  ED 79               		out	(c),a		; Output address register L
     240:  00:D66D  0C                  		inc	c		; C->Data register H
     241:  00:D66E                      
     242:  00:D66E  0C                  		inc	c		; Compensate for initial dec c
     243:  00:D66F  0D                  .loop:		dec	c		;  4
     244:  00:D670  ED A2               		ini			; 16
     245:  00:D672  0C                  		inc	c		;  4
     246:  00:D673  ED A2               		ini			; 16
     247:  00:D675  C2 6F D6            		jp	nz,.loop	; 10
     248:  00:D678                      					; --
     249:  00:D678                      					; 50
     250:  00:D678                      
     251:  00:D678  15                  		dec	d		;  4
     252:  00:D679  20 F4               		jr	nz,.loop	; 10
     253:  00:D67B                      
     254:  00:D67B  C3 F1 CE            		jp	status.inactivity
     255:  00:D67E                      ;
     256:  00:D67E                      ;
     257:  00:D67E                      ;------------------------------------------------------------------------------
     258:  00:D67E                      ; write_FIFO
     259:  00:D67E                      ;
     260:  00:D67E                      ; Writes a block of words to a wiz tx fifo
     261:  00:D67E                      ;
     262:  00:D67E                      ; In:  HL->block
     263:  00:D67E                      ;      DE=wiz FIFO register number
     264:  00:D67E                      ;      BC=byte count (must be even)
     265:  00:D67E                      ; Out: HL->next word in black
     266:  00:D67E                      ;      All other input registers corrupted
     267:  00:D67E                      ;
     268:  00:D67E                      _write_FIFO:
     269:  00:D67E  CD E9 CE            		call	status.activity
     270:  00:D681                      
     271:  00:D681  0B                  		dec	bc		; So BC=xx00 has correct outer loop count
     272:  00:D682  79                  		ld	a,c		; A=inner loop count-1
     273:  00:D683                      
     274:  00:D683  FD 4E 01            		ld	c,(iy+vars._io)	; Address Register H
     275:  00:D686                      
     276:  00:D686  ED 51               		out	(c),d		; Output Address Register H
     277:  00:D688  0C                  		inc	c		; C->Address Register L
     278:  00:D689                      
     279:  00:D689  50                  		ld	d,b		; D=outer loop count-1
     280:  00:D68A  14                  		inc	d		; D=outer loop count
     281:  00:D68B  47                  		ld	b,a		; B=inner loop count-1
     282:  00:D68C  04                  		inc	b		; B=inner loop count
     283:  00:D68D                      
     284:  00:D68D  3E 2E               		ld	a,w5300.Sn_TX_FIFOR
     285:  00:D68F  B3                  		or	e		; A=Sn_xxx register number
     286:  00:D690  ED 79               		out	(c),a		; Output address register L
     287:  00:D692  0C                  		inc	c		; C->Data register H
     288:  00:D693                      ;
     289:  00:D693  0C                  		inc	c		; Compensate for initial dec c
     290:  00:D694  0D                  .loop:		dec	c		;  4 C->Data Register L
     291:  00:D695  ED A3               		outi			; 16
     292:  00:D697  0C                  		inc	c		;  4
     293:  00:D698  ED A3               		outi			; 16
     294:  00:D69A  C2 94 D6            		jp	nz,.loop	; 10
     295:  00:D69D                      					; --
     296:  00:D69D                      					; 50
     297:  00:D69D                      
     298:  00:D69D  15                  		dec	d		;  4
     299:  00:D69E  20 F4               		jr	nz,.loop	; 10
     300:  00:D6A0                      
     301:  00:D6A0  C3 F1 CE            		jp	status.inactivity
     302:  00:D6A3                      ;
     303:  00:D6A3                      ;
     304:  00:D6A3                      ;------------------------------------------------------------------------------
     305:  00:D6A3                      ; This is where raw trace mode is implemented. If raw mode is on the words are
     306:  00:D6A3                      ; output in a hex dump (but as bytes of course!)
     307:  00:D6A3                      ;
     308:  00:D6A3                      ; read_header is used to read the WIZ PACKET_INFO that is put in front of the
     309:  00:D6A3                      ; real data. It is the same as read_FIFO but in raw trace mode the output
     310:  00:D6A3                      ; bytes are followed by (header) to indicate they are WIZ-added data and
     311:  00:D6A3                      ; not actually part of the packet. The PACKET_INFO contains the actual
     312:  00:D6A3                      ; number of bytes in the following packet (Sn_RX_RSR also contains the number
     313:  00:D6A3                      ; of bytes but is always even, including a "dummy" byte at the end if the
     314:  00:D6A3                      ; packet is odd). Unfortunately the position of the byte count in PACKET_INFO
     315:  00:D6A3                      ; varies according to the protocol (UDP, TCP, IPRAW etc) (thanks WIZ!) so
     316:  00:D6A3                      ; it is up to the caller to save this in the per-socket variable. We could
     317:  00:D6A3                      ; read the protocol type here and act accordingly but as the caller knows their
     318:  00:D6A3                      ; own protocol it is easier just to do it there.
     319:  00:D6A3                      ;
     320:  00:D6A3                      ; In:   HL->block
     321:  00:D6A3                      ;       BC=byte count
     322:  00:D6A3                      ;       DE=reg base
     323:  00:D6A3                      read_header_0:	SOCKET_GET_BASE_0
     323:  00:D6A3  11 00 02          >    ld de,0200h
     324:  00:D6A6  FD CB 00 7E         read_header:	bit	vars.trace.raw,(iy+vars._trace)
     325:  00:D6AA  28 AD               		jr	z,_read_FIFO
     326:  00:D6AC                      ;
     327:  00:D6AC  3E 48               		ld	a,'H'
     328:  00:D6AE  18 0B               		jr	rd_FIFO
     329:  00:D6B0                      ;
     330:  00:D6B0                      ;
     331:  00:D6B0                      read_FIFO_0:	SOCKET_GET_BASE_0
     331:  00:D6B0  11 00 02          >    ld de,0200h
     332:  00:D6B3  FD CB 00 7E         read_FIFO:	bit	vars.trace.raw,(iy+vars._trace)
     333:  00:D6B7  28 A0               		jr	z,_read_FIFO
     334:  00:D6B9                      ;
     335:  00:D6B9                      
     336:  00:D6B9  3E 52               		ld	a,'R'
     337:  00:D6BB  F5                  rd_FIFO:	push	af
     338:  00:D6BC  E5                  		push	hl	; Save regs so we can dump buffer later
     339:  00:D6BD  D5                  		push	de
     340:  00:D6BE  C5                  		push	bc
     341:  00:D6BF                      ;
     342:  00:D6BF  CD 59 D6            		 call	_read_FIFO
     343:  00:D6C2                      ;
     344:  00:D6C2  C1                  		pop	bc
     345:  00:D6C3  D1                  		pop	de			; Restore base reg
     346:  00:D6C4  E1                  		pop	hl
     347:  00:D6C5  F1                  		pop	af
     348:  00:D6C6                      ;
     349:  00:D6C6                      ; Here A contains the dump type (R or T, Receive or Transmit)
     350:  00:D6C6                      ; HL->buffer, BC=byte count
     351:  00:D6C6  FD CB 04 46         dump:		bit	0,(iy+vars._socket.flushing)	; Supress raw output
     352:  00:D6CA  C0                  		ret	nz
     353:  00:D6CB                      ;
     354:  00:D6CB  CD 94 C9            		call	exos.is_stop	; Check BEFORE printing anything as this may
     355:  00:D6CE  D8                  		ret	c	;   get called several times after STOP
     356:  00:D6CF                      
     357:  00:D6CF  C5                  		push	bc
     358:  00:D6D0  D5                  		push	de
     359:  00:D6D1  E5                  		push	hl
     360:  00:D6D2                      ;
     361:  00:D6D2  F5                  		 push	af	; Start with new line but save dump type
     362:  00:D6D3  CD 23 CE            		  call	io.start
     363:  00:D6D6  F1                  		 pop	af
     364:  00:D6D7  CD 00 CE            		 call	io.char
     365:  00:D6DA                      ;
     366:  00:D6DA  7A                  		 ld	a,d	; Work out socket number from DE
     367:  00:D6DB  B3                  		 or	e	; Bit 0=socket(7),bits 6,7=socket(0,1)
     368:  00:D6DC  07                  		 rlca
     369:  00:D6DD  07                  		 rlca
     370:  00:D6DE  E6 07               		 and	7
     371:  00:D6E0  C6 30               		 add	a,'0'
     372:  00:D6E2  CD 00 CE            		 call	io.char	; Print socket number
     373:  00:D6E5  3E 3A               		 ld	a,':'
     374:  00:D6E7  CD 00 CE            		 call	io.char
     375:  00:D6EA                      ;
     376:  00:D6EA  CD E8 CD            		 call	io.word	; Print address
     377:  00:D6ED  CD 31 CE            		 call	io.space
     378:  00:D6F0                      ;
     379:  00:D6F0                      		 ; If there are loads of bytes we only output a few and then
     380:  00:D6F0                      		 ; print +n at end of line. The max is chosen so the
     381:  00:D6F0                      		 ; dump and +n fit nicely on the screen depending on the
     382:  00:D6F0                      		 ; number of columns
     383:  00:D6F0  E5                  		 push	hl		; Save ->data
     384:  00:D6F1  69                  		  ld	l,c		; HL=number of bytes to dump
     385:  00:D6F2  60                  		  ld	h,b
     386:  00:D6F3  11 10 00            		  ld	de,16		; 16 bytes max on an 80 col screen
     387:  00:D6F6  3A 02 F0            		  ld	a,(vars.trace.cols)
     388:  00:D6F9  FE 50               		  cp	80
     389:  00:D6FB  30 02               		  jr	nc,.gotcols
     390:  00:D6FD                      ;
     391:  00:D6FD  1E 08               		  ld	e,8		; 8 bytes max on a 40 col screen
     392:  00:D6FF  B7                  .gotcols:	  or	a
     393:  00:D700  ED 52               		  sbc	hl,de
     394:  00:D702  43                  		  ld	b,e		; B=max in case
     395:  00:D703  30 04               		  jr	nc,.ge		; Go if yes, HL=remaining, B=no.
     396:  00:D705                      ;
     397:  00:D705  21 00 00            		  ld	hl,0		; Otherwise no remaining
     398:  00:D708  41                  		  ld	b,c		; B=no. to dump
     399:  00:D709                      ;
     400:  00:D709                      .ge:		  ; So now (SP)->buffer, B=no. bytes to dump, HL=remaining
     401:  00:D709  E3                  		 ex	(sp),hl		; HL->buffer, (SP)=remaining
     402:  00:D70A  E5                  		  push	hl
     403:  00:D70B  C5                  		  push	bc
     404:  00:D70C  CD 63 D0            		   call	trace.dumpbytes
     405:  00:D70F  C1                  		  pop	bc
     406:  00:D710  E1                  		  pop	hl
     407:  00:D711  38 09               		  jr	c,.stop
     408:  00:D713                      ;
     409:  00:D713                      		  ; Only output ASCII version of bytes if 80 col screen
     410:  00:D713  3A 02 F0            		  ld	a,(vars.trace.cols)
     411:  00:D716  FE 50               		  cp	80
     412:  00:D718  3F                  		  ccf			; NC (=> not STOP) if <80
     413:  00:D719  DC 73 D0            		  call	c,trace.dumpchars	; Returns C if STOP
     414:  00:D71C  E1                  .stop:		 pop	hl		; HL=remaining words not dumped
     415:  00:D71D                      ;
     416:  00:D71D  38 0F               		 jr	c,.done		; Stop key pressed
     417:  00:D71F                      ;
     418:  00:D71F  7C                  		 ld	a,h
     419:  00:D720  B5                  		 or	l
     420:  00:D721  28 0B               		 jr	z,.done		; Don't print +n if n=0
     421:  00:D723                      ;
     422:  00:D723  3E 2B               		 ld	a,'+'
     423:  00:D725  CD 00 CE            		 call	io.char
     424:  00:D728  CD B1 CD            		 call	io.int
     425:  00:D72B  CD 31 CE            		 call	io.space
     426:  00:D72E                      ;
     427:  00:D72E  E1                  .done:		pop	hl
     428:  00:D72F  D1                  		pop	de
     429:  00:D730  C1                  		pop	bc
     430:  00:D731                      ;
     431:  00:D731  C9                  		ret
     432:  00:D732                      ;
     433:  00:D732                      ;
     434:  00:D732                      ; HL->block
     435:  00:D732                      ; BC=byte count
     436:  00:D732                      ; DE=reg base
     437:  00:D732                      ;
     438:  00:D732  D5                  write_FIFO:	push	de
     439:  00:D733                      ;
     440:  00:D733  3E 54               		ld	a,'T'
     441:  00:D735  FD CB 00 7E         		bit	vars.trace.raw,(iy+vars._trace)
     442:  00:D739  C4 C6 D6            		call	nz,dump
     443:  00:D73C                      ;
     444:  00:D73C  CD 7E D6            		call	_write_FIFO
     445:  00:D73F                      ;
     446:  00:D73F  D1                  		pop	de
     447:  00:D740  C9                  		ret
     448:  00:D741                      ;
     449:  00:D741                      ;
     450:  00:D741                      ;------------------------------------------------------------------------------
     451:  00:D741                      ; tomask
     452:  00:D741                      ;
     453:  00:D741                      ; Converts a socket number in A (not socket base!) to a bit mask 01h, 02h etc
     454:  00:D741  21 48 D7            tomask:		ld	hl,masktab
     455:  00:D744  85                  		add	a,l
     456:  00:D745  6F                  		ld	l,a
     457:  00:D746  7E                  		ld	a,(hl)
     458:  00:D747  C9                  		ret
     459:  00:D748                      ;
     460:  00:D748  (0000)              		align	8
     461:  00:D748                      masktab:	db	01h,02h,04h,08h,10h,20h,40h,80h
     461:  00:D748  01 02 04 08 10 20 40 80 
     462:  00:D750                      ;
     463:  00:D750                      ;
     464:  00:D750                      ;
     465:  00:D750                      ;------------------------------------------------------------------------------
     466:  00:D750                      ; open
     467:  00:D750                      ;
     468:  00:D750                      ; opens a WIZ socket.
     469:  00:D750                      ;
     470:  00:D750                      ; For TCP mode, SnDIPR and SnDPORTR must already be set up.
     471:  00:D750                      ;
     472:  00:D750                      ; The WIZ Sn_MR mode register needs different values for different modes.
     473:  00:D750                      ; Similarly once the open command has been issued different responses are
     474:  00:D750                      ; expected in SnSSR, as follows:
     475:  00:D750                      ;
     476:  00:D750                      ; Mode:    UDP        TCP         IPRAW
     477:  00:D750                      ; -------------------------------------------
     478:  00:D750                      ; Sn_MR:   Sn_MR_UDP  Sn_MR_TCP   Sn_MR_IPRAW
     479:  00:D750                      ; Sn_SSR:  Sn_SSR_UDP Sn_SSR_INIT Sn_SSR_IPRAW
     480:  00:D750                      ;
     481:  00:D750                      ; These values are passed in BC
     482:  00:D750                      ;
     483:  00:D750                      ; In:   A= socket number
     484:  00:D750                      ;       B= Sn_MR_UDP  or Sn_MR_TCP   as appropriate (see above)
     485:  00:D750                      ;       C= Sn_SSR_UDP or Sn_SSR_INIT as appropriate (see above)
     486:  00:D750                      ;      HL= our (source) port number
     487:  00:D750                      ;      DE->owner string
     488:  00:D750                      ; Out: Carry set if error
     489:  00:D750                      ;
     490:  00:D750                      open:
     491:  00:D750  FD CB 04 86         		res	0,(iy+vars._socket.flushing)	; Stop supress raw output
     492:  00:D754                      ;
     493:  00:D754  FD CB 00 4E         		bit	vars.trace.socket,(iy+vars._trace)
     494:  00:D758  28 45               		jr	z,.tracedone
     495:  00:D75A                      ;
     496:  00:D75A  F5                  		push	af			; Save socket number
     497:  00:D75B  C5                  		push	bc			; Save Sn_ values
     498:  00:D75C  E5                  		push	hl			; Save port number
     499:  00:D75D                      ;
     500:  00:D75D  D5                  		 push	de			; Save owner string
     501:  00:D75E  11 A6 D1            		  ld	de,trace.socket.open	; "  :Open "
     502:  00:D761  C5                  		  push	bc
     503:  00:D762  CD DD DB            		   call	trace_msg		; "Sn"
     504:  00:D765  C1                  		  pop	bc
     505:  00:D766                      ;
     506:  00:D766  78                  		  ld	a,b
     507:  00:D767  E6 0F               		  and	0fh
     508:  00:D769  11 AC D1            		  ld	de,trace.socket.udp	;         "UDP"
     509:  00:D76C  FE 02               		  cp	w5300.Sn_MR_UDP
     510:  00:D76E  28 11               		  jr	z,.protocol
     511:  00:D770                      ;
     512:  00:D770  11 B0 D1            		  ld	de,trace.socket.ipraw	;         "IP"
     513:  00:D773  FE 03               		  cp	w5300.Sn_MR_IPRAW
     514:  00:D775  28 0A               		  jr	z,.protocol
     515:  00:D777                      ;
     516:  00:D777  11 B3 D1            		  ld	de,trace.socket.tcp	;         "TCP"
     517:  00:D77A  FE 01               		  cp	w5300.Sn_MR_TCP
     518:  00:D77C  28 03               		  jr	z,.protocol
     519:  00:D77E                      ;
     520:  00:D77E  11 B7 D1            		  ld	de,trace.socket.unknown	;         "UNKNOWN"
     521:  00:D781  CD 3D CE            .protocol:	  call	io.str
     522:  00:D784                      ;
     523:  00:D784  11 BB D1            		  ld	de,trace.socket.port	; 	         " port "
     524:  00:D787  CD 3D CE            		  call	io.str
     525:  00:D78A                      ;
     526:  00:D78A  CD B1 CD            		  call	io.int			; Print port
     527:  00:D78D                      
     528:  00:D78D  11 C2 D1            		  ld	de,trace.socket.by	;                        " by "
     529:  00:D790  CD 3D CE            		  call	io.str
     530:  00:D793  D1                  		 pop	de			; DE->owner
     531:  00:D794                      ;
     532:  00:D794  D5                  		 push	de			; Save owner
     533:  00:D795  CD 3D CE            		  call	io.str			; Print ownser
     534:  00:D798  CD 3C D0            		  call	trace.dots
     535:  00:D79B  D1                  		 pop	de
     536:  00:D79C                      ;
     537:  00:D79C  E1                  		pop	hl
     538:  00:D79D  C1                  		pop	bc			; BC=Sn_xxx values
     539:  00:D79E  F1                  		pop	af			; A=socket number
     540:  00:D79F                      .tracedone:
     541:  00:D79F                      ;
     542:  00:D79F  E5                  		push	hl
     543:  00:D7A0  C5                  		push	bc
     544:  00:D7A1  D5                  		 push	de			; Save owner string
     545:  00:D7A2                      		  SOCKET_GET_BASE
     545:  00:D7A2  11 00 01          >    ld de,0100h
     545:  00:D7A5  0F                >    rrca
     545:  00:D7A6  CB 1B             >    rr e
     545:  00:D7A8  0F                >    rrca
     545:  00:D7A9  CB 1B             >    rr e
     545:  00:D7AB  0F                >    rrca
     545:  00:D7AC  CB 12             >    rl d
     546:  00:D7AE                      ;
     547:  00:D7AE                      		  SOCKET_GET_VAR 0		; HL->socket memory
     547:  00:D7AE                    >    if (var)=0
     547:  00:D7AE  7B                >     ld a,e
     547:  00:D7AF                    >    else
     547:  00:D7AF                    ~     ld a,(var)*2
     547:  00:D7AF                    ~     or e
     547:  00:D7AF                    ~    endif
     547:  00:D7AF  6F                >    ld l,a
     547:  00:D7B0  7A                >    ld a,d
     547:  00:D7B1  0F                >    rrca
     547:  00:D7B2  CB 1D             >    rr l
     547:  00:D7B4  26 F2             >    ld h,high vars.sockets
     548:  00:D7B6  01 20 00             		  ld	bc,vars.socket_size	; BC=size of socket memory
     549:  00:D7B9  D5                  		  push	de
     550:  00:D7BA  CD 27 CF            		   call	util.memzero		; Initialise socket memory to 0
     551:  00:D7BD  D1                  		  pop	de
     552:  00:D7BE  E1                  		 pop	hl			; HL->owner string
     553:  00:D7BF  3E 00               		 ld	a,vars.owner
     554:  00:D7C1  CD 9F DB            		 call	set_word
     555:  00:D7C4  C1                  		pop	bc
     556:  00:D7C5  E1                  		pop	hl
     557:  00:D7C6                      ;
     558:  00:D7C6  C5                  		push	bc			; Save command & status values
     559:  00:D7C7  3E 0A               		 ld	a,w5300.Sn_PORTR
     560:  00:D7C9  CD 49 D6            		 call	write_reg		; Set port number
     561:  00:D7CC  C1                  		pop	bc			; BC=command & status values
     562:  00:D7CD                      ;
     563:  00:D7CD  C5                  		push	bc
     564:  00:D7CE  3E 00               		 ld	a,w5300.Sn_MR
     565:  00:D7D0  68                  		 ld	l,b
     566:  00:D7D1  26 00               		 ld	h,0			; HL=command register value
     567:  00:D7D3  CD 49 D6            		 call	write_reg		; Set mode
     568:  00:D7D6  C1                  		pop	bc			; C=expected status
     569:  00:D7D7                      ;
     570:  00:D7D7  21 01 00            		ld	hl,w5300.Sn_CR_OPEN	; Issue open command
     571:  00:D7DA  CD 57 D8            		call	write_CR
     572:  00:D7DD  30 09               		jr	nc,.ok
     573:  00:D7DF                      ;
     574:  00:D7DF  21 10 00            		ld	hl,w5300.Sn_CR_CLOSE	; Error - make sure it's closed
     575:  00:D7E2  0E 00               		ld	c,w5300.Sn_SSR_CLOSED
     576:  00:D7E4  CD 57 D8            		call	write_CR
     577:  00:D7E7  37                  		scf
     578:  00:D7E8                      ;
     579:  00:D7E8  FD CB 00 4E         .ok:		bit	vars.trace.socket,(iy+vars._trace)
     580:  00:D7EC  C8                  		ret	z
     581:  00:D7ED                      ;
     582:  00:D7ED  C3 42 D0            		jp	trace.is_timeout
     583:  00:D7F0                      ;
     584:  00:D7F0                      ;
     585:  00:D7F0                      ;------------------------------------------------------------------------------
     586:  00:D7F0                      ; connect
     587:  00:D7F0                      ;
     588:  00:D7F0                      ; This is called after open for a TCP socket, and it puts the socket in client
     589:  00:D7F0                      ; TCP mode ie attempts to open a TCP/IP socket with a server
     590:  00:D7F0                      ;
     591:  00:D7F0                      ; This routine is really only for the TCP module - other users should call
     592:  00:D7F0                      ; tcp.connect.
     593:  00:D7F0                      ;
     594:  00:D7F0                      ; In:   A=socket number
     595:  00:D7F0                      ;      HL=dest (server) port no
     596:  00:D7F0                      ;      DE->dest (server) IP address
     597:  00:D7F0                      ; Out: Cy=>error
     598:  00:D7F0                      ;
     599:  00:D7F0                      connect:
     600:  00:D7F0  FD CB 00 4E         		bit	vars.trace.socket,(iy+vars._trace)
     601:  00:D7F4  28 16               		jr	z,.tracedone
     602:  00:D7F6                      ;
     603:  00:D7F6  F5                  		push	af		; Save socket number
     604:  00:D7F7  E5                  		push	hl		; Save port no
     605:  00:D7F8  D5                  		push	de		; Save ->IP address
     606:  00:D7F9  11 83 D1            		 ld	de,trace.socket.connect	; "  :Connect to "
     607:  00:D7FC  CD DD DB            		 call	trace_msg			; "Sn"
     608:  00:D7FF  4D                  		 ld	c,l
     609:  00:D800  44                  		 ld	b,h		; BC=port number
     610:  00:D801  E1                  		pop	hl		; HL->IP address
     611:  00:D802  E5                  		push	hl		; Save ->IP address
     612:  00:D803  CD A2 CD            		 call	io.ip_port
     613:  00:D806  CD 3C D0            		 call	trace.dots
     614:  00:D809  D1                  		pop	de		; DE->IP address
     615:  00:D80A  E1                  		pop	hl		; HL=port no
     616:  00:D80B  F1                  		pop	af		; A=socket number
     617:  00:D80C                      ;
     618:  00:D80C                      .tracedone:
     619:  00:D80C  E5                  		push	hl		; Save our port no.
     620:  00:D80D  EB                  		 ex	de,hl		; HL->IP adress
     621:  00:D80E  CD BD D9            		 call	write_DIPR	; Write dest IP address, DE=reg base
     622:  00:D811  E1                  		pop	hl		; HL=dest port no
     623:  00:D812                      ;
     624:  00:D812  CD DC D9            		call	write_DPORTR	; Write dest port no.
     625:  00:D815                      ;
     626:  00:D815  21 04 00            		ld	hl,w5300.Sn_CR_CONNECT	; Issue connect command
     627:  00:D818  0E 17               		ld	c,w5300.Sn_SSR_ESTAB
     628:  00:D81A  CD 57 D8            		call	write_CR
     629:  00:D81D  38 00               		jr	c,.error	; Go if error occured
     630:  00:D81F                      ;
     631:  00:D81F  FD CB 00 4E         .error:		bit	vars.trace.socket,(iy+vars._trace)
     632:  00:D823  C8                  		ret	z
     633:  00:D824                      
     634:  00:D824  D5                  		push	de		; Save socket reg base
     635:  00:D825  CD 44 D0            		call	 trace.is_error
     636:  00:D828  D1                  		pop	de
     637:  00:D829  C9                  		ret
     638:  00:D82A                      ;
     639:  00:D82A                      ;
     640:  00:D82A                      ;------------------------------------------------------------------------------
     641:  00:D82A                      ; disconnect
     642:  00:D82A                      ;
     643:  00:D82A                      ; In TCP mode this disconnects the TCP/IP link with the remote party.
     644:  00:D82A                      ;
     645:  00:D82A                      ; This routine is really only for the TCP module - other users should call
     646:  00:D82A                      ; tcp.disconnect.
     647:  00:D82A                      ;
     648:  00:D82A                      ; Unlike for the other protocols, if the WIZ socket is in TCP mode we must
     649:  00:D82A                      ; disconnect before closing. If we don't, the WIZ socket is closed but the
     650:  00:D82A                      ; TCP connection remains open (but unusable)!
     651:  00:D82A                      ;
     652:  00:D82A                      ; In:  A=socket no.
     653:  00:D82A                      ;
     654:  00:D82A                      disconnect:
     655:  00:D82A                      		SOCKET_GET_BASE
     655:  00:D82A  11 00 01          >    ld de,0100h
     655:  00:D82D  0F                >    rrca
     655:  00:D82E  CB 1B             >    rr e
     655:  00:D830  0F                >    rrca
     655:  00:D831  CB 1B             >    rr e
     655:  00:D833  0F                >    rrca
     655:  00:D834  CB 12             >    rl d
     656:  00:D836                      ;
     657:  00:D836                      _disconnect:
     658:  00:D836  FD CB 00 4E         		bit	vars.trace.socket,(iy+vars._trace)
     659:  00:D83A  28 0B               		jr	z,.donetrace
     660:  00:D83C                      ;
     661:  00:D83C  D5                  		push	de
     662:  00:D83D  CD F1 DB            		 call	_trace
     663:  00:D840                      ;
     664:  00:D840  11 8F D1            		 ld	de,trace.socket.disconnect
     665:  00:D843  CD 3D CE            		 call	io.str
     666:  00:D846  D1                  		pop	de
     667:  00:D847                      .donetrace:		
     668:  00:D847                      ;
     669:  00:D847  21 08 00            		ld	hl,w5300.Sn_CR_DISCON	; HL=Disconnect command
     670:  00:D84A                      ;		ld	c,w5300.Sn_SSR_CLOSED	; C=expected response
     671:  00:D84A  0E 18               		ld	c,w5300.Sn_SSR_FIN_WAIT	; C=expected response
     672:  00:D84C  CD 57 D8            		call	write_CR		; Send Disc
     673:  00:D84F                      ;
     674:  00:D84F  FD CB 00 4E         .donedisc:	bit	vars.trace.socket,(iy+vars._trace)
     675:  00:D853  C8                  		ret	z			; Return if not tracing
     676:  00:D854                      
     677:  00:D854  C3 44 D0            		jp	trace.is_error		; Else print ok/error
     678:  00:D857                      ;
     679:  00:D857                      ;
     680:  00:D857                      ;------------------------------------------------------------------------------
     681:  00:D857                      ; write_CR
     682:  00:D857                      ;
     683:  00:D857                      ; Writes to the socket's CR register and waits for the expected response
     684:  00:D857                      ;
     685:  00:D857                      ; In:  HL=Sn_CR_xxx command to write
     686:  00:D857                      ;      DE=WIZ socket base register
     687:  00:D857                      ;      C=Sn_SSR_xxx expected status response
     688:  00:D857                      ; Out: C=>timeout waiting for w5300
     689:  00:D857                      ;
     690:  00:D857                      write_CR:
     691:  00:D857  C5                  		push	bc		; Save expected response in C
     692:  00:D858  3E 02               		 ld	a,w5300.Sn_CR
     693:  00:D85A  CD 49 D6            		 call	write_reg	; Write command
     694:  00:D85D  C1                  		pop	bc		; C=expected response
     695:  00:D85E                      ;
     696:  00:D85E  C5                  .loop:		push	bc		; Save expected response
     697:  00:D85F  3E 08               		 ld	a,w5300.Sn_SSR
     698:  00:D861  CD 39 D6            		 call	read_reg
     699:  00:D864  C1                  		pop	bc		; C=expected response
     700:  00:D865  7D                  		ld	a,l
     701:  00:D866                      ;
     702:  00:D866  B9                  		cp	c
     703:  00:D867  C8                  		ret	z		; SSR as expectd, NC
     704:  00:D868                      ;
     705:  00:D868  FE 00               		cp	w5300.Sn_SSR_CLOSED
     706:  00:D86A  37                  		scf			; If it's closed it'll never change!
     707:  00:D86B  C8                  		ret	z
     708:  00:D86C                      
     709:  00:D86C  CD CA CE            		call	status.waiting	; Flash status line waiting indicator
     710:  00:D86F                      ;
     711:  00:D86F  CD 94 C9            		call	exos.is_stop	; See if stop key pressed
     712:  00:D872  D8                  		ret	c		; Ret with C if yes
     713:  00:D873                      ;	
     714:  00:D873  18 E9               		jr	.loop		; Wait a bit longer
     715:  00:D875                      ;
     716:  00:D875                      ;
     717:  00:D875                      ;------------------------------------------------------------------------------
     718:  00:D875                      ; available
     719:  00:D875                      ;
     720:  00:D875                      ; Returns the number of bytes available to read on an open socket
     721:  00:D875                      ;
     722:  00:D875                      ; In:  A=socket number
     723:  00:D875                      ; Out: HL=number of bytes available to read
     724:  00:D875                      ;      DE=socket base reg
     725:  00:D875                      ;       Z set according to HL
     726:  00:D875                      ;
     727:  00:D875  AF                  available_0:	xor	a
     728:  00:D876                      available:	SOCKET_GET_BASE
     728:  00:D876  11 00 01          >    ld de,0100h
     728:  00:D879  0F                >    rrca
     728:  00:D87A  CB 1B             >    rr e
     728:  00:D87C  0F                >    rrca
     728:  00:D87D  CB 1B             >    rr e
     728:  00:D87F  0F                >    rrca
     728:  00:D880  CB 12             >    rl d
     729:  00:D882                      ;
     730:  00:D882                      		; Just read Sn_RX_RSR. We don't check the high word because we
     731:  00:D882                      		; have configured the RX memory to be 8k so larger packets
     732:  00:D882                      		; amounts cannot be received
     733:  00:D882  3E 2A               _available:	ld	a,w5300.Sn_RX_RSR2
     734:  00:D884  CD 39 D6            		call	read_reg
     735:  00:D887                      ;
     736:  00:D887  7C                  		ld	a,h
     737:  00:D888  B5                  		or	l
     738:  00:D889  C9                  		ret			; Return with Z set appropriately
     739:  00:D88A                      ;
     740:  00:D88A                      ;
     741:  00:D88A                      ;------------------------------------------------------------------------------
     742:  00:D88A                      ; is_closed
     743:  00:D88A                      ;
     744:  00:D88A                      ; Sees if a socket has been closed. 
     745:  00:D88A                      ;
     746:  00:D88A                      ; In:  A=socket number
     747:  00:D88A                      ; Out: Z if socket has been closed
     748:  00:D88A                      ;
     749:  00:D88A                      is_closed:	SOCKET_GET_BASE
     749:  00:D88A  11 00 01          >    ld de,0100h
     749:  00:D88D  0F                >    rrca
     749:  00:D88E  CB 1B             >    rr e
     749:  00:D890  0F                >    rrca
     749:  00:D891  CB 1B             >    rr e
     749:  00:D893  0F                >    rrca
     749:  00:D894  CB 12             >    rl d
     750:  00:D896                      ;
     751:  00:D896                      _is_closed:	
     752:  00:D896  3E 08               		ld	a,w5300.Sn_SSR
     753:  00:D898  CD 39 D6            		call	read_reg
     754:  00:D89B  7D                  		ld	a,l
     755:  00:D89C                      ;
     756:  00:D89C  FE 00               		cp	w5300.Sn_SSR_CLOSED	; Socket has closed
     757:  00:D89E  C8                  		ret	z
     758:  00:D89F                      ;
     759:  00:D89F  FE 1C               		cp	w5300.Sn_SSR_WAIT	; FIN received from other end
     760:  00:D8A1  C8                  		ret	z
     761:  00:D8A2                      ;
     762:  00:D8A2  FE 18               		cp	w5300.Sn_SSR_FIN_WAIT	; In closing state
     763:  00:D8A4  C8                  		ret	z
     764:  00:D8A5                      ;
     765:  00:D8A5  FE 1B               		cp	w5300.Sn_SSR_TIME_WAIT	; In closing state
     766:  00:D8A7  C8                  		ret	z
     767:  00:D8A8                      ;
     768:  00:D8A8  FE 1D               		cp	w5300.Sn_SSR_LAST_ACK	; In closing state
     769:  00:D8AA  C9                  		ret
     770:  00:D8AB                      ;
     771:  00:D8AB                      ;
     772:  00:D8AB                      ;
     773:  00:D8AB                      ;------------------------------------------------------------------------------
     774:  00:D8AB                      ; read
     775:  00:D8AB                      ;
     776:  00:D8AB                      ; Reads from an open socket.
     777:  00:D8AB                      ;
     778:  00:D8AB                      ; We can only read words from the WIZ chip, not bytes, so to read the last
     779:  00:D8AB                      ; byte of an odd-length packet we read the last byte and a dummy byte. We
     780:  00:D8AB                      ; return Cy here if that is the case.
     781:  00:D8AB                      ;
     782:  00:D8AB                      ; In:   A=socket number
     783:  00:D8AB                      ;      HL->bufer for data
     784:  00:D8AB                      ;      BC=number of bytes to read
     785:  00:D8AB                      ; Out: C=>we've read last byte
     786:  00:D8AB                      ;      HL->rx_size
     787:  00:D8AB                      ;      DE=socket base register
     788:  00:D8AB                      ;
     789:  00:D8AB  AF                  read_0		xor	a
     790:  00:D8AC                      read:		SOCKET_GET_BASE
     790:  00:D8AC  11 00 01          >    ld de,0100h
     790:  00:D8AF  0F                >    rrca
     790:  00:D8B0  CB 1B             >    rr e
     790:  00:D8B2  0F                >    rrca
     790:  00:D8B3  CB 1B             >    rr e
     790:  00:D8B5  0F                >    rrca
     790:  00:D8B6  CB 12             >    rl d
     791:  00:D8B8                      
     792:  00:D8B8                      _read:
     793:  00:D8B8  C5                  		push	bc
     794:  00:D8B9  03                  		 inc	bc		; Round up to even number
     795:  00:D8BA  CB 81               		 res	0,c
     796:  00:D8BC  78                  		 ld	a,b
     797:  00:D8BD  B1                  		 or	c
     798:  00:D8BE  D5                  		 push	de
     799:  00:D8BF  C4 B3 D6            		  call	nz,read_FIFO	; Read data
     800:  00:D8C2  D1                  		 pop	de
     801:  00:D8C3  C1                  		pop	bc		; BC=bye count
     802:  00:D8C4                      
     803:  00:D8C4                      		; Update size remaining
     804:  00:D8C4                      		SOCKET_GET_VAR	vars.rx_size	; HL->rx_size
     804:  00:D8C4                    >    if (var)=0
     804:  00:D8C4                    ~     ld a,e
     804:  00:D8C4                    ~    else
     804:  00:D8C4  3E 06             >     ld a,(var)*2
     804:  00:D8C6  B3                >     or e
     804:  00:D8C7                    >    endif
     804:  00:D8C7  6F                >    ld l,a
     804:  00:D8C8  7A                >    ld a,d
     804:  00:D8C9  0F                >    rrca
     804:  00:D8CA  CB 1D             >    rr l
     804:  00:D8CC  26 F2             >    ld h,high vars.sockets
     805:  00:D8CE                      ;
     806:  00:D8CE  7E                  		ld	a,(hl)		; rx_size -= BC
     807:  00:D8CF  91                  		sub	c
     808:  00:D8D0  77                  		ld	(hl),a
     809:  00:D8D1  23                  		inc	hl
     810:  00:D8D2                      ;
     811:  00:D8D2  7E                  		ld	a,(hl)
     812:  00:D8D3  98                  		sbc	a,b
     813:  00:D8D4  77                  		ld	(hl),a
     814:  00:D8D5  30 06               		jr	nc,.donesize	; Go with NC if not gone -ve
     815:  00:D8D7                      ;
     816:  00:D8D7                      		; This can happen if it's an odd-sized packet eg. we read the
     817:  00:D8D7                      		; last word (because we can only read words) but it is in fact
     818:  00:D8D7                      		; just a single byte because there's only one byte remaining
     819:  00:D8D7                      		; unread in the packet
     820:  00:D8D7  AF                  		xor	a		; zero rx_size
     821:  00:D8D8  77                  		ld	(hl),a
     822:  00:D8D9  2B                  		dec	hl
     823:  00:D8DA  77                  		ld	(hl),a
     824:  00:D8DB  23                  		inc	hl
     825:  00:D8DC  37                  		scf			; Cy=>read end
     826:  00:D8DD  2B                  .donesize:	dec	hl		; HL->first byte of rx_size
     827:  00:D8DE                      ;
     828:  00:D8DE  C9                  		ret
     829:  00:D8DF                      ;
     830:  00:D8DF                      ;
     831:  00:D8DF                      ;------------------------------------------------------------------------------
     832:  00:D8DF                      ; read_byte
     833:  00:D8DF                      ;
     834:  00:D8DF                      ; This is a byte-by-byte read interface to a WIZ socket - a bit tricky
     835:  00:D8DF                      ; because of the word-by-word nature of the WIZ interface
     836:  00:D8DF                      ;
     837:  00:D8DF                      ; In:  A=socket number
     838:  00:D8DF                      ; Out: A=byte read
     839:  00:D8DF                      ;      HL,DE,BC preserved
     840:  00:D8DF                      ;      C=>no bytes were read
     841:  00:D8DF                      ;
     842:  00:D8DF  AF                  read_byte_0:	xor	a
     843:  00:D8E0  D5                  read_byte:	push	de
     844:  00:D8E1  E5                  		push	hl
     845:  00:D8E2                      ;
     846:  00:D8E2                      		 SOCKET_GET_BASE
     846:  00:D8E2  11 00 01          >    ld de,0100h
     846:  00:D8E5  0F                >    rrca
     846:  00:D8E6  CB 1B             >    rr e
     846:  00:D8E8  0F                >    rrca
     846:  00:D8E9  CB 1B             >    rr e
     846:  00:D8EB  0F                >    rrca
     846:  00:D8EC  CB 12             >    rl d
     847:  00:D8EE                      ;
     848:  00:D8EE                      		 SOCKET_GET_VAR vars.rx_inhand	; HL->rx_inhand
     848:  00:D8EE                    >    if (var)=0
     848:  00:D8EE                    ~     ld a,e
     848:  00:D8EE                    ~    else
     848:  00:D8EE  3E 0A             >     ld a,(var)*2
     848:  00:D8F0  B3                >     or e
     848:  00:D8F1                    >    endif
     848:  00:D8F1  6F                >    ld l,a
     848:  00:D8F2  7A                >    ld a,d
     848:  00:D8F3  0F                >    rrca
     848:  00:D8F4  CB 1D             >    rr l
     848:  00:D8F6  26 F2             >    ld h,high vars.sockets
     849:  00:D8F8                      ;
     850:  00:D8F8  7E                  		 ld	a,(hl)		; FF=>buffered byte, 0=>none
     851:  00:D8F9  3C                  		 inc	a
     852:  00:D8FA  20 05               		 jr	nz,.notgot
     853:  00:D8FC                      ;
     854:  00:D8FC  77                  		 ld	(hl),a		; 0=>no buffered byte anymore
     855:  00:D8FD  23                  		 inc	hl
     856:  00:D8FE  7E                  		 ld	a,(hl)		; Get byte
     857:  00:D8FF  18 23               		 jr	.okret
     858:  00:D901                      ;
     859:  00:D901  3E 03               .notgot:	 ld	a,vars.rx_size
     860:  00:D903  CD BF DB            		 call	get_word
     861:  00:D906  7C                  		 ld	a,h
     862:  00:D907  B5                  		 or	l
     863:  00:D908  37                  		 scf			; C=>nothing left to read
     864:  00:D909  28 1A               		 jr	z,.ret		; Byte count=0=>nothing left to read
     865:  00:D90B                      ;
     866:  00:D90B  C5                  		 push	bc
     867:  00:D90C                      ;
     868:  00:D90C                      		  SOCKET_GET_VAR vars.rx_inhand	; HL->rx_inhand
     868:  00:D90C                    >    if (var)=0
     868:  00:D90C                    ~     ld a,e
     868:  00:D90C                    ~    else
     868:  00:D90C  3E 0A             >     ld a,(var)*2
     868:  00:D90E  B3                >     or e
     868:  00:D90F                    >    endif
     868:  00:D90F  6F                >    ld l,a
     868:  00:D910  7A                >    ld a,d
     868:  00:D911  0F                >    rrca
     868:  00:D912  CB 1D             >    rr l
     868:  00:D914  26 F2             >    ld h,high vars.sockets
     869:  00:D916                      ;
     870:  00:D916  E5                  		  push	hl
     871:  00:D917  01 02 00            		   ld	bc,2
     872:  00:D91A  CD B8 D8            		   call	_read		; Read 2 bytes to rx_inhand
     873:  00:D91D  E1                  		  pop	hl
     874:  00:D91E  7E                  		  ld	a,(hl)		; Get first byte read
     875:  00:D91F  38 02               		  jr	c,.got1		; Go if only 1 byte was left to read
     876:  00:D921                      ;
     877:  00:D921  36 FF               		  ld	(hl),0ffh	; Else ff=>byte buffered in following
     878:  00:D923  C1                  .got1:		 pop	bc
     879:  00:D924  B7                  .okret:		 or	a		; NC=>not end of packet
     880:  00:D925  E1                  .ret:		pop	hl
     881:  00:D926  D1                  		pop	de
     882:  00:D927  C9                  		ret
     883:  00:D928                      ;
     884:  00:D928                      ;
     885:  00:D928                      ;------------------------------------------------------------------------------
     886:  00:D928                      ; read_flush
     887:  00:D928                      ;
     888:  00:D928                      ; The WIZ chip needs you to read every byte in the current packet, even if you
     889:  00:D928                      ; don't actually want it. Or you can close the socket, but then you don't get
     890:  00:D928                      ; any following packets.
     891:  00:D928                      ;
     892:  00:D928                      ; In:   A=socket number
     893:  00:D928                      ; Out: DE=socket base register
     894:  00:D928                      ;
     895:  00:D928  AF                  read_flush_0:	xor	a
     896:  00:D929                      read_flush:	SOCKET_GET_BASE
     896:  00:D929  11 00 01          >    ld de,0100h
     896:  00:D92C  0F                >    rrca
     896:  00:D92D  CB 1B             >    rr e
     896:  00:D92F  0F                >    rrca
     896:  00:D930  CB 1B             >    rr e
     896:  00:D932  0F                >    rrca
     896:  00:D933  CB 12             >    rl d
     897:  00:D935                      
     898:  00:D935  FD CB 04 C6         _read_flush:	set	0,(iy+vars._socket.flushing)	; Supress raw output
     899:  00:D939                      ;
     900:  00:D939  3E 03               		ld	a,vars.rx_size
     901:  00:D93B  CD BF DB            		call	get_word	; HL=no.bytes remaining
     902:  00:D93E                      ;
     903:  00:D93E  23                  		inc	hl		; Convert to even making sure we catch
     904:  00:D93F  CB 85               		res	0,l		;   odd byte at end of odd length packets
     905:  00:D941                      ;
     906:  00:D941                      .loop:		; In this loop HL=total # bytes to read (even!)
     907:  00:D941  7C                  		ld	a,h
     908:  00:D942  B5                  		or	l
     909:  00:D943  28 1A               		jr	z,.done		; No more to read
     910:  00:D945                      ;		
     911:  00:D945  01 2C 00            		ld	bc,vars.dhcp.packet_size	; BC=buffer size (even!)
     912:  00:D948  B7                  		or	a
     913:  00:D949  ED 42               		sbc	hl,bc		; HL=remainder after read
     914:  00:D94B  30 06               		jr	nc,.sizeok	; Go if still more after this read
     915:  00:D94D                      ;
     916:  00:D94D  09                  		add	hl,bc		; Else get back original size
     917:  00:D94E  4D                  		ld	c,l
     918:  00:D94F  44                  		ld	b,h		; BC=amount to read this time
     919:  00:D950  B7                  		or	a
     920:  00:D951  ED 62               		sbc	hl,hl		; HL=amount to read next time (0)
     921:  00:D953  E5                  .sizeok:	push	hl		; Save amount to read next time
     922:  00:D954  21 00 F3            		 ld	hl,vars.dhcp.packet	; Buffer to read to
     923:  00:D957  D5                  		 push	de
     924:  00:D958  CD B3 D6            		  call	read_FIFO
     925:  00:D95B  D1                  		 pop	de
     926:  00:D95C  E1                  		pop	hl		; HL=amount for next read
     927:  00:D95D  18 E2               		jr	.loop
     928:  00:D95F                      ;
     929:  00:D95F  FD CB 04 86         .done:		res	0,(iy+vars._socket.flushing)	; Stop supress raw output
     930:  00:D963                      ;
     931:  00:D963  3E 05               		ld	a,vars.rx_inhand
     932:  00:D965  B7                  		or	a
     933:  00:D966  ED 62               		sbc	hl,hl			; HL=0
     934:  00:D968  CD 9F DB            		call	set_word		; No buffered byte
     935:  00:D96B                      ;
     936:  00:D96B  3E 03               		ld	a,vars.rx_size
     937:  00:D96D  B7                  		or	a
     938:  00:D96E  ED 62               		sbc	hl,hl
     939:  00:D970  C3 9F DB            		jp	set_word
     940:  00:D973                      ;
     941:  00:D973                      ;
     942:  00:D973                      ;------------------------------------------------------------------------------
     943:  00:D973                      ; read_end
     944:  00:D973                      ;
     945:  00:D973                      ; Called when reading has finished. It can be called when we no longer want
     946:  00:D973                      ; the packet, so it needs to call read_flush because the WIZ w5300 insists
     947:  00:D973                      ; we read everything.
     948:  00:D973                      ;
     949:  00:D973                      ; _send_end can be called to send the RECV command to the w5300 if we are
     950:  00:D973                      ; certain everything has been read. (tcp.read_block does this because it
     951:  00:D973                      ; doesn't want to loose any bytes buffered in rx_inhand).
     952:  00:D973                      ;
     953:  00:D973                      ; In:  A=socket number
     954:  00:D973                      ; Out: DE=socket base register
     955:  00:D973                      ;
     956:  00:D973  AF                  read_end_0:	xor	a
     957:  00:D974                      read_end:	SOCKET_GET_BASE
     957:  00:D974  11 00 01          >    ld de,0100h
     957:  00:D977  0F                >    rrca
     957:  00:D978  CB 1B             >    rr e
     957:  00:D97A  0F                >    rrca
     957:  00:D97B  CB 1B             >    rr e
     957:  00:D97D  0F                >    rrca
     957:  00:D97E  CB 12             >    rl d
     958:  00:D980                      ;
     959:  00:D980  CD 35 D9            _read_end:	call	_read_flush		; Read any unread words
     960:  00:D983                      ;
     961:  00:D983  21 40 00            _send_end:	ld	hl,w5300.Sn_CR_RECV	; Received!
     962:  00:D986  3E 02               		ld	a,w5300.Sn_CR
     963:  00:D988  C3 49 D6            		jp	write_reg
     964:  00:D98B                      ;
     965:  00:D98B                      ;
     966:  00:D98B                      ;------------------------------------------------------------------------------
     967:  00:D98B                      ; write
     968:  00:D98B                      ;
     969:  00:D98B                      ; Writes to a previously open socket
     970:  00:D98B                      ;
     971:  00:D98B                      ; In:   A=socket number
     972:  00:D98B                      ;      HL->data to write
     973:  00:D98B                      ;      BC=byte count
     974:  00:D98B                      ; Out: Cy=>error
     975:  00:D98B                      ;
     976:  00:D98B  AF                  write_0:	xor	a
     977:  00:D98C                      write:		SOCKET_GET_BASE
     977:  00:D98C  11 00 01          >    ld de,0100h
     977:  00:D98F  0F                >    rrca
     977:  00:D990  CB 1B             >    rr e
     977:  00:D992  0F                >    rrca
     977:  00:D993  CB 1B             >    rr e
     977:  00:D995  0F                >    rrca
     977:  00:D996  CB 12             >    rl d
     978:  00:D998                      ;
     979:  00:D998  E5                  _write:		push	hl	; Save user's buffer ptr
     980:  00:D999  CD 0C DA            		 call	read_FSR; Check FSR to make sure there's enough room 
     981:  00:D99C  B7                  		 or	a
     982:  00:D99D  ED 42               		 sbc	hl,bc
     983:  00:D99F  E1                  		pop	hl
     984:  00:D9A0  D8                  		ret	c	; Shouldn't happen!
     985:  00:D9A1                      ;
     986:  00:D9A1  C5                  .bigenough:	push	bc	; Save byte count
     987:  00:D9A2  03                  		 inc	bc	; Round up to even # bytes
     988:  00:D9A3  CB 81               		 res	0,c
     989:  00:D9A5  CD 32 D7            		 call	write_FIFO
     990:  00:D9A8  C1                  		pop	bc	; BC=byte count just written
     991:  00:D9A9                      ;
     992:  00:D9A9                      add_tx_size:	SOCKET_GET_VAR vars.tx_size	; HL->tx_size
     992:  00:D9A9                    >    if (var)=0
     992:  00:D9A9                    ~     ld a,e
     992:  00:D9A9                    ~    else
     992:  00:D9A9  3E 0E             >     ld a,(var)*2
     992:  00:D9AB  B3                >     or e
     992:  00:D9AC                    >    endif
     992:  00:D9AC  6F                >    ld l,a
     992:  00:D9AD  7A                >    ld a,d
     992:  00:D9AE  0F                >    rrca
     992:  00:D9AF  CB 1D             >    rr l
     992:  00:D9B1  26 F2             >    ld h,high vars.sockets
     993:  00:D9B3  7E                  		ld	a,(hl)		; Add on amount just written
     994:  00:D9B4  81                  		add	a,c
     995:  00:D9B5  77                  		ld	(hl),a
     996:  00:D9B6  23                  		inc	hl
     997:  00:D9B7  7E                  		ld	a,(hl)
     998:  00:D9B8  88                  		adc	a,b
     999:  00:D9B9  77                  		ld	(hl),a
    1000:  00:D9BA                      ;
    1001:  00:D9BA  B7                  		or	a	; NC=>no error
    1002:  00:D9BB  C9                  		ret
    1003:  00:D9BC                      ;
    1004:  00:D9BC                      ;
    1005:  00:D9BC                      ;------------------------------------------------------------------------------
    1006:  00:D9BC                      ; write_DIPR and wrte_DPORTR
    1007:  00:D9BC                      ;
    1008:  00:D9BC                      ; These are called prior to write() to set up the destination IP address
    1009:  00:D9BC                      ; (when in UDP and IPRAW modes) and DPORTR (when in UDP mode).
    1010:  00:D9BC                      ;
    1011:  00:D9BC                      ; In:   A=socket number
    1012:  00:D9BC                      ;      HL->IP address
    1013:  00:D9BC                      ; Out: DE=reg base
    1014:  00:D9BC                      ;
    1015:  00:D9BC  AF                  write_DIPR_0:	xor	a
    1016:  00:D9BD                      write_DIPR:	SOCKET_GET_BASE
    1016:  00:D9BD  11 00 01          >    ld de,0100h
    1016:  00:D9C0  0F                >    rrca
    1016:  00:D9C1  CB 1B             >    rr e
    1016:  00:D9C3  0F                >    rrca
    1016:  00:D9C4  CB 1B             >    rr e
    1016:  00:D9C6  0F                >    rrca
    1016:  00:D9C7  CB 12             >    rl d
    1017:  00:D9C9                      ;
    1018:  00:D9C9  E5                  		push	hl		; Save ->IP address
    1019:  00:D9CA  06 14               		 ld	b,w5300.Sn_DIPR; Do first register
    1020:  00:D9CC  CD D4 D9            		 call	.doone
    1021:  00:D9CF  E1                  		pop	hl		; HL->IP address
    1022:  00:D9D0                      ;
    1023:  00:D9D0  06 16               		ld	b,w5300.Sn_DIPR2; Then second register
    1024:  00:D9D2  23                  		inc	hl
    1025:  00:D9D3  23                  		inc	hl
    1026:  00:D9D4                      ;
    1027:  00:D9D4  7E                  .doone:		ld	a,(hl)		; Repeat for 2nd word
    1028:  00:D9D5  23                  		inc	hl
    1029:  00:D9D6  6E                  		ld	l,(hl)
    1030:  00:D9D7  67                  		ld	h,a
    1031:  00:D9D8  78                  		ld	a,b
    1032:  00:D9D9  C3 49 D6            		jp	write_reg
    1033:  00:D9DC                      ;
    1034:  00:D9DC                      ;
    1035:  00:D9DC                      ; Due to a bug in the w5300, DPORTR cannot be read. So here we save the value
    1036:  00:D9DC                      ; in per-socket RAM as well as actually write it to the w5300.
    1037:  00:D9DC                      ;
    1038:  00:D9DC                      ; In: DE=reg base, probably left over from call to write_DIPR
    1039:  00:D9DC                      ;     HL=port number
    1040:  00:D9DC  E5                  write_DPORTR:	push	hl		; Save value
    1041:  00:D9DD  3E 0B               		 ld	a,vars.DPORTR
    1042:  00:D9DF  CD 9F DB            		 call	set_word	; Save copy of DPORTR
    1043:  00:D9E2  E1                  		pop	hl
    1044:  00:D9E3  3E 12               		ld	a,w5300.Sn_DPORTR
    1045:  00:D9E5  C3 49 D6            		jp	write_reg	; Write port #
    1046:  00:D9E8                      ;
    1047:  00:D9E8                      ;
    1048:  00:D9E8                      ;------------------------------------------------------------------------------
    1049:  00:D9E8                      ; read_DIPR and read_DPORTR
    1050:  00:D9E8                      ;
    1051:  00:D9E8                      ; These are called to get the IP address and socket number of an established
    1052:  00:D9E8                      ; copnnection.
    1053:  00:D9E8                      ;
    1054:  00:D9E8                      ; In:   A=socket number
    1055:  00:D9E8                      ;      HL->buffer for IP address
    1056:  00:D9E8                      ; Out: DE=socket reg base
    1057:  00:D9E8                      read_DIPR:
    1058:  00:D9E8                      		SOCKET_GET_BASE
    1058:  00:D9E8  11 00 01          >    ld de,0100h
    1058:  00:D9EB  0F                >    rrca
    1058:  00:D9EC  CB 1B             >    rr e
    1058:  00:D9EE  0F                >    rrca
    1058:  00:D9EF  CB 1B             >    rr e
    1058:  00:D9F1  0F                >    rrca
    1058:  00:D9F2  CB 12             >    rl d
    1059:  00:D9F4                      ;
    1060:  00:D9F4  3E 14               		ld	a,w5300.Sn_DIPR
    1061:  00:D9F6  CD FB D9            		call	.doone
    1062:  00:D9F9                      ;
    1063:  00:D9F9  3E 16               		ld	a,w5300.Sn_DIPR2
    1064:  00:D9FB  E5                  .doone:		push	hl		; Save ->IP buffer
    1065:  00:D9FC  CD 39 D6            		 call	read_reg	; HL=2 bytes of IP
    1066:  00:D9FF  4D                  		 ld	c,l
    1067:  00:DA00  44                  		 ld	b,h		; BC=2 bytes of IP
    1068:  00:DA01  E1                  		pop	hl		; HL->IP
    1069:  00:DA02  70                  		ld	(hl),b
    1070:  00:DA03  23                  		inc	hl
    1071:  00:DA04  71                  		ld	(hl),c
    1072:  00:DA05  23                  		inc	hl
    1073:  00:DA06  C9                  		ret
    1074:  00:DA07                      ;
    1075:  00:DA07                      ;
    1076:  00:DA07                      ; Due to a bug in the w5300, DPORTR cannot be read. So here we read the value
    1077:  00:DA07                      ; that was saved in per-socket RAM instead of reading from the w5300.
    1078:  00:DA07                      
    1079:  00:DA07                      ; In:  DE=reg base, probably left over from call to read_DIPR
    1080:  00:DA07                      ; Out: HL=port number
    1081:  00:DA07                      ;
    1082:  00:DA07  3E 0B               read_DPORTR:	ld	a,vars.DPORTR
    1083:  00:DA09  C3 BF DB            		jp	get_word	; HL=port number
    1084:  00:DA0C                      ;
    1085:  00:DA0C                      ;
    1086:  00:DA0C                      ;------------------------------------------------------------------------------
    1087:  00:DA0C                      ; read_FSR
    1088:  00:DA0C                      ;
    1089:  00:DA0C                      ; Returns in HL the number of bytes of free tx memory o0n the WIZ chip
    1090:  00:DA0C                      ;
    1091:  00:DA0C                      read_FSR:
    1092:  00:DA0C                      		; Strictly speaking FSR is a 32-bit value but as we've
    1093:  00:DA0C                      		; configured the w5300 tx memory to be 8k max on each socket,
    1094:  00:DA0C                      		; here we're only checking the LSW.
    1095:  00:DA0C  3E 26               		 ld	a,w5300.Sn_TX_FSR2; FSR is the high word, FSR2 the low
    1096:  00:DA0E  C5                  		 push	bc		; Save byte count
    1097:  00:DA0F  CD 39 D6            		  call	read_reg
    1098:  00:DA12  C1                  		 pop	bc
    1099:  00:DA13  C9                  		 ret
    1100:  00:DA14                      ;
    1101:  00:DA14                      ;
    1102:  00:DA14                      ;------------------------------------------------------------------------------
    1103:  00:DA14                      ; send
    1104:  00:DA14                      ;
    1105:  00:DA14                      ; Called after a series of writes to actually send the data.
    1106:  00:DA14                      ;
    1107:  00:DA14                      ; For UDP mode DIPR and DPORTR must be set up to indicate the destination
    1108:  00:DA14                      ; IP and port.
    1109:  00:DA14                      ;
    1110:  00:DA14                      ;  In: DE=socket base register
    1111:  00:DA14                      ; Out: Cy=>error
    1112:  00:DA14                      ;      DE preserved
    1113:  00:DA14                      ;
    1114:  00:DA14                      _send:
    1115:  00:DA14  B7                  		or	a
    1116:  00:DA15  ED 62               		sbc	hl,hl
    1117:  00:DA17  3E 20               		ld	a,w5300.Sn_TX_WRSR	; Write #bytes
    1118:  00:DA19  CD 49 D6            		call	write_reg
    1119:  00:DA1C                      ;
    1120:  00:DA1C  3E 07               		ld	a,vars.tx_size
    1121:  00:DA1E  CD BF DB            		call	get_word		; HL=no. bytes written
    1122:  00:DA21                      ;
    1123:  00:DA21                      ; Commented out for tcp.read_block sending 0 length packet to fix w5300 bug!
    1124:  00:DA21                      ;		ld	a,h
    1125:  00:DA21                      ;		or	l
    1126:  00:DA21                      ;		jr	z,.end			; Nothing to send!
    1127:  00:DA21                      ;
    1128:  00:DA21  3E 22               		ld	a,w5300.Sn_TX_WRSR2	; Tell WIZ
    1129:  00:DA23  CD 49 D6            		call	write_reg
    1130:  00:DA26                      ;
    1131:  00:DA26  3E 02               		ld	a,w5300.Sn_CR
    1132:  00:DA28  21 20 00            		ld	hl,w5300.Sn_CR_SEND
    1133:  00:DA2B  CD 49 D6            		call	write_reg		; Send it!
    1134:  00:DA2E                      ;
    1135:  00:DA2E                      ; Here we wait till the send has finished. It would be more efficient to
    1136:  00:DA2E                      ; return and let the z80 get on with other things while it is being sent,
    1137:  00:DA2E                      ; and to check for sending complete on entry (and socket close?) but for now
    1138:  00:DA2E                      ; it is simpler and less error prone to wait here. 100MBps Ethernet doesn't
    1139:  00:DA2E                      ; take very long to send in 4MHz Z80 time ie. the Z80 would not be able to
    1140:  00:DA2E                      ; do much before the send had compketed!
    1141:  00:DA2E                      ;
    1142:  00:DA2E  3E 06               .loop:		ld	a,w5300.Sn_IR
    1143:  00:DA30  CD 39 D6            		call	read_reg
    1144:  00:DA33  7D                  		ld	a,l
    1145:  00:DA34  E6 10               		and	w5300.Sn_IR_SENDOK
    1146:  00:DA36  20 1B               		jr	nz,.sendok
    1147:  00:DA38                      ;
    1148:  00:DA38  7D                  		ld	a,l
    1149:  00:DA39  E6 08               		and	w5300.Sn_IR_TIMEOUT
    1150:  00:DA3B  20 10               		jr	nz,.timeout
    1151:  00:DA3D                      ;
    1152:  00:DA3D  CD 96 D8            		call	_is_closed
    1153:  00:DA40  37                  		scf
    1154:  00:DA41  28 23               		jr	z,.end
    1155:  00:DA43                      
    1156:  00:DA43  CD CA CE            		call	status.waiting
    1157:  00:DA46                      ;
    1158:  00:DA46  CD 94 C9            		call	exos.is_stop	; Just in case we're looping forever
    1159:  00:DA49  38 1B               		jr	c,.end		;   (shouldn't happen!)
    1160:  00:DA4B                      ;
    1161:  00:DA4B  18 E1               		jr	.loop
    1162:  00:DA4D                      
    1163:  00:DA4D  37                  .timeout:	scf			; Return error
    1164:  00:DA4E  21 08 00            		ld	hl,w5300.Sn_IR_TIMEOUT
    1165:  00:DA51  18 04               		jr	.ret
    1166:  00:DA53                      ;
    1167:  00:DA53  B7                  .sendok:	or	a		; NC=>No error
    1168:  00:DA54  21 10 00            		ld	hl,w5300.Sn_IR_SENDOK
    1169:  00:DA57  F5                  .ret:		push	af		; Save error flag
    1170:  00:DA58  3E 06               		 ld	a,w5300.Sn_IR
    1171:  00:DA5A  CD 49 D6            		 call	write_reg	; Clear interrupt
    1172:  00:DA5D                      ;
    1173:  00:DA5D  B7                  		 or	a
    1174:  00:DA5E  ED 62               		 sbc	hl,hl		; HL=0
    1175:  00:DA60  3E 07               		 ld	a,vars.tx_size
    1176:  00:DA62  CD 9F DB            		 call	set_word	; Reset tx count
    1177:  00:DA65  F1                  		pop	af
    1178:  00:DA66                      ;
    1179:  00:DA66  FD CB 00 4E         .end:		bit	vars.trace.socket,(iy+vars._trace)
    1180:  00:DA6A  C8                  		ret	z
    1181:  00:DA6B                      ;
    1182:  00:DA6B  D5                  		push	de
    1183:  00:DA6C  CD 42 D0            		 call	trace.is_timeout
    1184:  00:DA6F  D1                  		pop	de
    1185:  00:DA70  C9                  		ret
    1186:  00:DA71                      ;
    1187:  00:DA71                      ;
    1188:  00:DA71                      ;------------------------------------------------------------------------------
    1189:  00:DA71                      ; keepalive
    1190:  00:DA71                      ;
    1191:  00:DA71                      ; Sends a TCP/IP "keep alive" packet
    1192:  00:DA71                      ;
    1193:  00:DA71                      ; In:  A=socket number (or DE=socket base reg at _keepalive:)
    1194:  00:DA71                      ;
    1195:  00:DA71                      ;keepalive:	SOCKET_GET_BASE
    1196:  00:DA71                      ;_keepalive:
    1197:  00:DA71                      ;		; To manually send a Keep Alive, auto-Keep Alives have to be
    1198:  00:DA71                      ;		; OFF so we save the current Keep Alive timer, set it to 0,
    1199:  00:DA71                      ;		; send the Keep Alive, and then restore it
    1200:  00:DA71                      ;		ld	a,w5300.Sn_PORTOR
    1201:  00:DA71                      ;		call	read_reg
    1202:  00:DA71                      ;		push	hl		; Save keep alive timer value
    1203:  00:DA71                      ;
    1204:  00:DA71                      ;		 ld	a,w5300.Sn_PORTOR
    1205:  00:DA71                      ;		 or	a
    1206:  00:DA71                      ;		 sbc	hl,hl		; H=Sn_KPALVTR=0, L=Sn_PROTOR=0
    1207:  00:DA71                      ;		 call	write_reg	; Make sure auto-keep-alives are OFF
    1208:  00:DA71                      ;
    1209:  00:DA71                      ;		 ld	hl,w5300.Sn_CR_SEND_KEEP; HL=Send Keepalive command value
    1210:  00:DA71                      ;		 ld	c,w5300.Sn_SSR_ESTAB	; C=expected status reg value
    1211:  00:DA71                      ;		 call	write_CR	; Send command
    1212:  00:DA71                      ;
    1213:  00:DA71                      ;		pop	hl		; HL=old keep alive timer value
    1214:  00:DA71                      ;		ld	a,w5300.Sn_PORTOR
    1215:  00:DA71                      ;		jp	write_reg	; Restore keep alive timer register
    1216:  00:DA71                      ;
    1217:  00:DA71                      ;
    1218:  00:DA71                      ;------------------------------------------------------------------------------
    1219:  00:DA71                      ; close
    1220:  00:DA71                      ;
    1221:  00:DA71                      ; Closes a previously opened socket
    1222:  00:DA71                      ;
    1223:  00:DA71                      ; In:  A=socket number
    1224:  00:DA71                      ;
    1225:  00:DA71  AF                  close_0:	xor	a
    1226:  00:DA72  F5                  close:		push	af		; Save socket no
    1227:  00:DA73                      		 SOCKET_GET_BASE	; DE=socket base reg
    1227:  00:DA73  11 00 01          >    ld de,0100h
    1227:  00:DA76  0F                >    rrca
    1227:  00:DA77  CB 1B             >    rr e
    1227:  00:DA79  0F                >    rrca
    1227:  00:DA7A  CB 1B             >    rr e
    1227:  00:DA7C  0F                >    rrca
    1227:  00:DA7D  CB 12             >    rl d
    1228:  00:DA7F                      ;
    1229:  00:DA7F  3E 06               		 ld	a,w5300.Sn_IR
    1230:  00:DA81  21 FF 00            		 ld	hl,0ffh
    1231:  00:DA84  CD 49 D6            		 call	write_reg	; Clear socket interrupt flags
    1232:  00:DA87  F1                  		pop	af		; A=socket number
    1233:  00:DA88                      ;
    1234:  00:DA88  F5                  		push	af		; Save socket number
    1235:  00:DA89  D5                  		 push	de		; Save reg base
    1236:  00:DA8A  CD 41 D7            		  call	tomask		; Get bitmask for socket
    1237:  00:DA8D  6F                  		  ld	l,a
    1238:  00:DA8E  26 00               		  ld	h,0
    1239:  00:DA90  11 02 00            		  ld	de,w5300.IR
    1240:  00:DA93  CD BC D3            		  call	wiz.write_reg	; Clear this socket's interrupt flag
    1241:  00:DA96  D1                  		 pop	de		; DE=reg base
    1242:  00:DA97  F1                  		pop	af		; A=socket number
    1243:  00:DA98                      ;
    1244:  00:DA98  F5                  		push	af
    1245:  00:DA99  D5                  		push	de
    1246:  00:DA9A  FD CB 00 4E         		 bit	vars.trace.socket,(iy+vars._trace)
    1247:  00:DA9E  11 9D D1            		 ld	de,trace.socket.close
    1248:  00:DAA1  C4 DD DB            		 call	nz,trace_msg
    1249:  00:DAA4  D1                  		pop	de
    1250:  00:DAA5  F1                  		pop	af		; A=socket no
    1251:  00:DAA6                      ;
    1252:  00:DAA6  21 10 00            		ld	hl,w5300.Sn_CR_CLOSE
    1253:  00:DAA9  0E 00               		ld	c,w5300.Sn_SSR_CLOSED	; C=expected response
    1254:  00:DAAB  CD 57 D8            		call	write_CR
    1255:  00:DAAE                      ;
    1256:  00:DAAE  FD CB 00 4E         		bit	vars.trace.socket,(iy+vars._trace)
    1257:  00:DAB2  C8                  		ret	z
    1258:  00:DAB3                      ;
    1259:  00:DAB3  C3 44 D0            		jp	trace.is_error
    1260:  00:DAB6                      ;
    1261:  00:DAB6                      ;
    1262:  00:DAB6                      ;------------------------------------------------------------------------------
    1263:  00:DAB6                      ; status
    1264:  00:DAB6                      ;
    1265:  00:DAB6                      ; Returns the open/slosed status of a socket
    1266:  00:DAB6                      ;
    1267:  00:DAB6                      ; In:   A=socket number
    1268:  00:DAB6                      ; Out: HL=Sn_SSR value
    1269:  00:DAB6                      ;
    1270:  00:DAB6                      status:		SOCKET_GET_BASE
    1270:  00:DAB6  11 00 01          >    ld de,0100h
    1270:  00:DAB9  0F                >    rrca
    1270:  00:DABA  CB 1B             >    rr e
    1270:  00:DABC  0F                >    rrca
    1270:  00:DABD  CB 1B             >    rr e
    1270:  00:DABF  0F                >    rrca
    1270:  00:DAC0  CB 12             >    rl d
    1271:  00:DAC2                      ;
    1272:  00:DAC2  3E 08               		ld	a,w5300.Sn_SSR
    1273:  00:DAC4  C3 39 D6            		jp	read_reg	; HL=Sn_SSR value
    1274:  00:DAC7                      ;
    1275:  00:DAC7                      ;
    1276:  00:DAC7                      ;------------------------------------------------------------------------------
    1277:  00:DAC7                      ; status_str
    1278:  00:DAC7                      ;
    1279:  00:DAC7                      ; In:   A=Sn_SSR value
    1280:  00:DAC7                      ; Out:  A preserved
    1281:  00:DAC7                      ;      HL->string if NC
    1282:  00:DAC7                      ;      NC=>Sn_SSR value was found
    1283:  00:DAC7                      ;
    1284:  00:DAC7                      status_str:
    1285:  00:DAC7  21 E2 DA            		ld	hl,.val_tab	; HL->table of values
    1286:  00:DACA  01 0F 00            		ld	bc,.val_tab_num	; BC=number of entries in table
    1287:  00:DACD  E5                  		push	hl		; Save start of table
    1288:  00:DACE  ED B1               		 cpir			; Look for Sn_SSR value in table
    1289:  00:DAD0  C1                  		pop	bc		; BC=start of table
    1290:  00:DAD1  37                  		scf
    1291:  00:DAD2  C0                  		ret	nz		; Return with Cy if not found
    1292:  00:DAD3                      ;
    1293:  00:DAD3  2B                  		dec	hl		; Point back to matching entry
    1294:  00:DAD4  B7                  		or	a
    1295:  00:DAD5  ED 42               		sbc	hl,bc		; HL=offset into table
    1296:  00:DAD7  01 F1 DA            		ld	bc,.str_tab	; BC->table of string pointers
    1297:  00:DADA  29                  		add	hl,hl		; *2 cos addresses
    1298:  00:DADB  09                  		add	hl,bc		; HL->string pointer
    1299:  00:DADC  4E                  		ld	c,(hl)
    1300:  00:DADD  23                  		inc	hl
    1301:  00:DADE  66                  		ld	h,(hl)
    1302:  00:DADF  69                  		ld	l,c		; HL->string
    1303:  00:DAE0  B7                  		or	a		; NC=>ok
    1304:  00:DAE1  C9                  		ret
    1305:  00:DAE2                      ;
    1306:  00:DAE2  00                  .val_tab:	db	w5300.Sn_SSR_CLOSED
    1307:  00:DAE3  13                  		db	w5300.Sn_SSR_INIT
    1308:  00:DAE4  14                  		db	w5300.Sn_SSR_LISTEN
    1309:  00:DAE5  17                  		db	w5300.Sn_SSR_ESTAB
    1310:  00:DAE6  1C                  		db	w5300.Sn_SSR_WAIT
    1311:  00:DAE7  22                  		db	w5300.Sn_SSR_UDP
    1312:  00:DAE8  32                  		db	w5300.Sn_SSR_IPRAW
    1313:  00:DAE9  42                  		db	w5300.Sn_SSR_MACRAW
    1314:  00:DAEA  5F                  		db	w5300.Sn_SSR_PPPoE
    1315:  00:DAEB  15                  		db	w5300.Sn_SSR_SYNSENT
    1316:  00:DAEC  16                  		db	w5300.Sn_SSR_SYNRECV
    1317:  00:DAED  18                  		db	w5300.Sn_SSR_FIN_WAIT
    1318:  00:DAEE  1B                  		db	w5300.Sn_SSR_TIME_WAIT
    1319:  00:DAEF  1D                  		db	w5300.Sn_SSR_LAST_ACK
    1320:  00:DAF0  01                  		db	w5300.Sn_SSR_ARP
    1321:  00:DAF1                      ;
    1322:  00:DAF1  (00:000F)           .val_tab_num	equ	$-.val_tab
    1323:  00:DAF1                      ;
    1324:  00:DAF1                      .str_tab:				; Same order as above!
    1325:  00:DAF1  0F DB               		dw	.str_CLOSED
    1326:  00:DAF3  16 DB                               dw	.str_INIT
    1327:  00:DAF5  23 DB                               dw	.str_LISTEN
    1328:  00:DAF7  2D DB                               dw	.str_ESTAB
    1329:  00:DAF9  37 DB                               dw	.str_WAIT
    1330:  00:DAFB  3F DB                               dw	.str_UDP
    1331:  00:DAFD  43 DB                               dw	.str_IPRAW
    1332:  00:DAFF  4A DB                               dw	.str_MACRAW
    1333:  00:DB01  52 DB                               dw	.str_PPPoE
    1334:  00:DB03  58 DB                               dw	.str_SYNSENT
    1335:  00:DB05  61 DB                               dw	.str_SYNRECV
    1336:  00:DB07  6E DB                               dw	.str_FIN_WAIT
    1337:  00:DB09  77 DB                               dw	.str_TIME_WAIT
    1338:  00:DB0B  81 DB                               dw	.str_LAST_ACK
    1339:  00:DB0D  8A DB                               dw	.str_ARP
    1340:  00:DB0F                      ;
    1341:  00:DB0F                      .str_CLOSED:	db	"Closed",0
    1341:  00:DB0F  43 6C 6F 73 65 64 00 
    1342:  00:DB16                      .str_INIT:	db	"Initialising",0
    1342:  00:DB16  49 6E 69 74 69 61 6C 69 73 69 6E 67 00 
    1343:  00:DB23                      .str_LISTEN:	db	"Listening",0
    1343:  00:DB23  4C 69 73 74 65 6E 69 6E 67 00 
    1344:  00:DB2D                      .str_ESTAB:	db	"Connected",0
    1344:  00:DB2D  43 6F 6E 6E 65 63 74 65 64 00 
    1345:  00:DB37                      .str_WAIT:	db	"Closing",0
    1345:  00:DB37  43 6C 6F 73 69 6E 67 00 
    1346:  00:DB3F  55 44 50 00         .str_UDP:	db	"UDP",0
    1347:  00:DB43                      .str_IPRAW:	db	"IP raw",0
    1347:  00:DB43  49 50 20 72 61 77 00 
    1348:  00:DB4A                      .str_MACRAW:	db	"MAC raw",0
    1348:  00:DB4A  4D 41 43 20 72 61 77 00 
    1349:  00:DB52  50 50 50 6F 45 00   .str_PPPoE:	db	"PPPoE",0
    1350:  00:DB58                      .str_SYNSENT:	db	"SYN Sent",0
    1350:  00:DB58  53 59 4E 20 53 65 6E 74 00 
    1351:  00:DB61                      .str_SYNRECV:	db	"SYN Received",0
    1351:  00:DB61  53 59 4E 20 52 65 63 65 69 76 65 64 00 
    1352:  00:DB6E                      .str_FIN_WAIT:	db	"FIN Wait",0
    1352:  00:DB6E  46 49 4E 20 57 61 69 74 00 
    1353:  00:DB77                      .str_TIME_WAIT:	db	"Time Wait",0
    1353:  00:DB77  54 69 6D 65 20 57 61 69 74 00 
    1354:  00:DB81                      .str_LAST_ACK:	db	"Last ACK",0
    1354:  00:DB81  4C 61 73 74 20 41 43 4B 00 
    1355:  00:DB8A                      .str_ARP:	db	"ARP request",0
    1355:  00:DB8A  41 52 50 20 72 65 71 75 65 73 74 00 
    1356:  00:DB96                      ;
    1357:  00:DB96                      ;
    1358:  00:DB96                      ;------------------------------------------------------------------------------
    1359:  00:DB96                      ; byteswapword
    1360:  00:DB96                      ;
    1361:  00:DB96                      ; Any WORDs that we read from the WIZ are in HILO order so need to be byte
    1362:  00:DB96                      ; swapped before we can use them naturally on the Z80.
    1363:  00:DB96                      ; In:  HL->word
    1364:  00:DB96                      ; Out: word byte swapped and returned in HL
    1365:  00:DB96                      ;
    1366:  00:DB96  46                  byteswapword:	ld	b,(hl)
    1367:  00:DB97  23                  		inc	hl
    1368:  00:DB98  4E                  		ld	c,(hl)
    1369:  00:DB99  70                  		ld	(hl),b
    1370:  00:DB9A  2B                  		dec	hl
    1371:  00:DB9B  71                  		ld	(hl),c
    1372:  00:DB9C  69                  		ld	l,c
    1373:  00:DB9D  60                  		ld	h,b
    1374:  00:DB9E  C9                  		ret
    1375:  00:DB9F                      ;
    1376:  00:DB9F                      ;
    1377:  00:DB9F                      ;------------------------------------------------------------------------------
    1378:  00:DB9F                      ; set_word
    1379:  00:DB9F                      ;
    1380:  00:DB9F                      ; Writes a 16-bit value to per-socket variable
    1381:  00:DB9F                      ;
    1382:  00:DB9F                      ; In:  A=var
    1383:  00:DB9F                      ;     DE=reg base
    1384:  00:DB9F                      ;     HL=value
    1385:  00:DB9F                      ;
    1386:  00:DB9F  E5                  set_word:	push	hl		; Save new value
    1387:  00:DBA0                      		 SOCKET_GET_RAM		; HL->variable
    1387:  00:DBA0  87                >    add a,a
    1387:  00:DBA1  B3                >    or e
    1387:  00:DBA2  6F                >    ld l,a
    1387:  00:DBA3  7A                >    ld a,d
    1387:  00:DBA4  0F                >    rrca
    1387:  00:DBA5  CB 1D             >    rr l
    1387:  00:DBA7  26 F2             >    ld h,high vars.sockets
    1388:  00:DBA9  EB                  		 ex	de,hl		; DE->variable, HL=reg base
    1389:  00:DBAA  E3                  		ex	(sp),hl		; HL=new value, (SP)=reg base
    1390:  00:DBAB  EB                  		 ex	de,hl		; HL->variable, DE=new value
    1391:  00:DBAC  73                  		 ld	(hl),e		; Save new value
    1392:  00:DBAD  23                  		 inc	hl
    1393:  00:DBAE  72                  		 ld	(hl),d
    1394:  00:DBAF  D1                  		 pop	de		; DE=reg base
    1395:  00:DBB0  C9                  		ret
    1396:  00:DBB1                      ;
    1397:  00:DBB1                      ;
    1398:  00:DBB1                      ;------------------------------------------------------------------------------
    1399:  00:DBB1                      ; get_word
    1400:  00:DBB1                      ;
    1401:  00:DBB1                      ; Reads a 16-bit value to per-socket variable
    1402:  00:DBB1                      ; In:   A=var
    1403:  00:DBB1                      ;      DE=reg base
    1404:  00:DBB1                      ; Out: HL=value
    1405:  00:DBB1                      ;
    1406:  00:DBB1                      get_rx_size:	SOCKET_GET_BASE
    1406:  00:DBB1  11 00 01          >    ld de,0100h
    1406:  00:DBB4  0F                >    rrca
    1406:  00:DBB5  CB 1B             >    rr e
    1406:  00:DBB7  0F                >    rrca
    1406:  00:DBB8  CB 1B             >    rr e
    1406:  00:DBBA  0F                >    rrca
    1406:  00:DBBB  CB 12             >    rl d
    1407:  00:DBBD  3E 03               		ld	a,vars.rx_size
    1408:  00:DBBF                      ;
    1409:  00:DBBF                      get_word:	SOCKET_GET_RAM
    1409:  00:DBBF  87                >    add a,a
    1409:  00:DBC0  B3                >    or e
    1409:  00:DBC1  6F                >    ld l,a
    1409:  00:DBC2  7A                >    ld a,d
    1409:  00:DBC3  0F                >    rrca
    1409:  00:DBC4  CB 1D             >    rr l
    1409:  00:DBC6  26 F2             >    ld h,high vars.sockets
    1410:  00:DBC8  7E                  		ld	a,(hl)
    1411:  00:DBC9  23                  		inc	hl
    1412:  00:DBCA  66                  		ld	h,(hl)
    1413:  00:DBCB  6F                  		ld	l,a
    1414:  00:DBCC  C9                  		ret
    1415:  00:DBCD                      ;
    1416:  00:DBCD                      ;
    1417:  00:DBCD                      ;------------------------------------------------------------------------------
    1418:  00:DBCD                      ; get_owner
    1419:  00:DBCD                      ;
    1420:  00:DBCD                      ; Returns the name of the socket opener
    1421:  00:DBCD                      ;
    1422:  00:DBCD                      ; In:    A=socket number
    1423:  00:DBCD                      ; Out:  HL->owner string
    1424:  00:DBCD                      ;
    1425:  00:DBCD                      get_owner:	SOCKET_GET_BASE
    1425:  00:DBCD  11 00 01          >    ld de,0100h
    1425:  00:DBD0  0F                >    rrca
    1425:  00:DBD1  CB 1B             >    rr e
    1425:  00:DBD3  0F                >    rrca
    1425:  00:DBD4  CB 1B             >    rr e
    1425:  00:DBD6  0F                >    rrca
    1425:  00:DBD7  CB 12             >    rl d
    1426:  00:DBD9  3E 00               		ld	a,vars.owner
    1427:  00:DBDB  18 E2               		jr	get_word
    1428:  00:DBDD                      ;
    1429:  00:DBDD                      ;
    1430:  00:DBDD                      ;------------------------------------------------------------------------------
    1431:  00:DBDD                      ; trace, trace_msg
    1432:  00:DBDD                      ;
    1433:  00:DBDD                      ; At the start of each trace line output, "Sn" is displayed (n is the port
    1434:  00:DBDD                      ; number).
    1435:  00:DBDD                      ;
    1436:  00:DBDD                      ; trace_msg is the same but prints the message at DE afterwards.
    1437:  00:DBDD                      ;
    1438:  00:DBDD                      ; In:  A=socket number
    1439:  00:DBDD                      ;     DE=->message to print
    1440:  00:DBDD                      ;
    1441:  00:DBDD  D5                  trace_msg:	push	de
    1442:  00:DBDE  CD E5 DB            		 call	trace
    1443:  00:DBE1  D1                  		pop	de
    1444:  00:DBE2  C3 3D CE            		jp	io.str
    1445:  00:DBE5                      ;		
    1446:  00:DBE5                      trace:		SOCKET_GET_BASE
    1446:  00:DBE5  11 00 01          >    ld de,0100h
    1446:  00:DBE8  0F                >    rrca
    1446:  00:DBE9  CB 1B             >    rr e
    1446:  00:DBEB  0F                >    rrca
    1446:  00:DBEC  CB 1B             >    rr e
    1446:  00:DBEE  0F                >    rrca
    1446:  00:DBEF  CB 12             >    rl d
    1447:  00:DBF1  CD 23 CE            _trace:		call	io.start
    1448:  00:DBF4  3E 53               		ld	a,'S'
    1449:  00:DBF6  CD 00 CE            		call	io.char
    1450:  00:DBF9  7A                  		ld	a,d		; Bit 0 = port bit 2
    1451:  00:DBFA  E6 01               		and	1
    1452:  00:DBFC  B3                  		or	e		; Bits 6,7 = port bits 0,1
    1453:  00:DBFD  07                  		rlca
    1454:  00:DBFE  07                  		rlca			; Bits 0,1,2 = port bits 0,1,2
    1455:  00:DBFF  C6 30               		add	a,'0'
    1456:  00:DC01  CD 00 CE            		call	io.char
    1457:  00:DC04  3E 3A               		ld	a,':'
    1458:  00:DC06  C3 00 CE            		jp	io.char
    1459:  00:DC09                      ;
    1460:  00:DC09                      ;
    1461:  00:DC09                      ;
    1462:  00:DC09                      		endmodule
    1463:  00:DC09                      		
     104.  00:DC09                      	include ipraw.asm
       1:  00:DC09                      ; IPRAW
       2:  00:DC09                      ;
       3:  00:DC09                      ; Implements an interface to the sockets of the WIZ chip in IPRAW mode
       4:  00:DC09                      ;
       5:  00:DC09                      		module	ipraw
       6:  00:DC09                      ;
       7:  00:DC09                      ;==============================================================================
       8:  00:DC09                      ;
       9:  00:DC09                      ; This file is part of the EPNET software
      10:  00:DC09                      ;
      11:  00:DC09                      ; Copyright (C) 2015  Bruce Tanner
      12:  00:DC09                      ;
      13:  00:DC09                      ;    This program is free software: you can redistribute it and/or modify
      14:  00:DC09                      ;    it under the terms of the GNU General Public License as published by
      15:  00:DC09                      ;    the Free Software Foundation, either version 3 of the License, or
      16:  00:DC09                      ;    (at your option) any later version.
      17:  00:DC09                      ;
      18:  00:DC09                      ;    This program is distributed in the hope that it will be useful,
      19:  00:DC09                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      20:  00:DC09                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      21:  00:DC09                      ;    GNU General Public License for more details.
      22:  00:DC09                      ;
      23:  00:DC09                      ;    You should have received a copy of the GNU General Public License
      24:  00:DC09                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      25:  00:DC09                      ;
      26:  00:DC09                      ; If you do use or modify this file, either for its original purpose or for
      27:  00:DC09                      ; something new, I'd love to hear about it! I can be contacted by email at:
      28:  00:DC09                      ;
      29:  00:DC09                      ; brucetanner@btopenworld.com
      30:  00:DC09                      ;
      31:  00:DC09                      ;==============================================================================
      32:  00:DC09                      ; open
      33:  00:DC09                      ;
      34:  00:DC09                      ; Opens a WIZ socket in IPRAW mode
      35:  00:DC09                      ;
      36:  00:DC09                      ; In: A=socket number
      37:  00:DC09                      ;     HL=port number
      38:  00:DC09                      ;     DE->owner string
      39:  00:DC09                      ; Out: Carry set if error
      40:  00:DC09                      ;
      41:  00:DC09  AF                  open_0:		xor	a
      42:  00:DC0A                      open:
      43:  00:DC0A  01 32 03            		ld	bc,w5300.Sn_MR_IPRAW*256+w5300.Sn_SSR_IPRAW
      44:  00:DC0D  C3 50 D7            		jp	socket.open		; Open socket in UDP mode
      45:  00:DC10                      ;
      46:  00:DC10                      ;
      47:  00:DC10                      ;------------------------------------------------------------------------------
      48:  00:DC10                      ; header
      49:  00:DC10                      ;
      50:  00:DC10                      ; Reads the WIZ's PACKET_INFO header for IPRAW mode
      51:  00:DC10                      ;
      52:  00:DC10                      ; In:  A=socket number
      53:  00:DC10                      ;
      54:  00:DC10  AF                  header_0:	xor	a
      55:  00:DC11                      header:
      56:  00:DC11                      		SOCKET_GET_BASE
      56:  00:DC11  11 00 01          >    ld de,0100h
      56:  00:DC14  0F                >    rrca
      56:  00:DC15  CB 1B             >    rr e
      56:  00:DC17  0F                >    rrca
      56:  00:DC18  CB 1B             >    rr e
      56:  00:DC1A  0F                >    rrca
      56:  00:DC1B  CB 12             >    rl d
      57:  00:DC1D                      ;
      58:  00:DC1D  21 11 F0            		ld	hl,vars.icmp.header		; Read W5300 header
      59:  00:DC20  01 06 00            		ld	bc,vars.icmp.header_size	; No. bytes in header
      60:  00:DC23  CD A6 D6            		call	socket.read_header
      61:  00:DC26                      ;
      62:  00:DC26  21 15 F0            		ld	hl,vars.icmp.size
      63:  00:DC29  CD 96 DB            		call	socket.byteswapword	; Byte swap
      64:  00:DC2C                      ;
      65:  00:DC2C  3E 03               		ld	a,socket.vars.rx_size
      66:  00:DC2E  CD 9F DB            		call	socket.set_word		; Save in per-socket variable
      67:  00:DC31                      ;
      68:  00:DC31  FD CB 00 4E          		bit	vars.trace.socket,(iy+vars._trace)
      69:  00:DC35  28 18               		jr	z,.ret
      70:  00:DC37                      ;
      71:  00:DC37  CD F1 DB            		call	socket._trace
      72:  00:DC3A                      ;		
      73:  00:DC3A  11 F9 D1            		ld	de,trace.ipraw.rx
      74:  00:DC3D  CD 3D CE            		call	io.str
      75:  00:DC40                      ;
      76:  00:DC40  21 11 F0            		ld	hl,vars.icmp.ip
      77:  00:DC43  CD 8C CD            		call	io.ip
      78:  00:DC46                      ;
      79:  00:DC46  2A 15 F0            		ld	hl,(vars.icmp.size)
      80:  00:DC49  CD 30 D0            		call	trace.bytes
      81:  00:DC4C  CD 31 CE            		call	io.space
      82:  00:DC4F                      ;
      83:  00:DC4F  2A 15 F0            .ret:		ld	hl,(vars.icmp.size)
      84:  00:DC52  7C                  		ld	a,h
      85:  00:DC53  B5                  		or	l
      86:  00:DC54  C9                  		ret
      87:  00:DC55                      ;
      88:  00:DC55                      ;
      89:  00:DC55                      ;------------------------------------------------------------------------------
      90:  00:DC55                      ; send
      91:  00:DC55                      ;
      92:  00:DC55                      ; Send whatever data has been writen to the Tx FIFO.
      93:  00:DC55                      ;
      94:  00:DC55                      ; In:  A=socket number
      95:  00:DC55                      ;     HL->ip address to send to
      96:  00:DC55                      ;      vars.icmp.ip = dest IP address to send to
      97:  00:DC55                      ; Out: NC=>ok
      98:  00:DC55                      ;
      99:  00:DC55  AF                  send_0:		xor	a
     100:  00:DC56  FD CB 00 4E         send:		bit	vars.trace.socket,(iy+vars._trace)
     101:  00:DC5A  28 2D               		jr	z,.notrace
     102:  00:DC5C                      ;
     103:  00:DC5C  F5                  		push	af		; Save socket no
     104:  00:DC5D  E5                  		 push	hl		; Save ->ip address
     105:  00:DC5E  CD E5 DB            		  call	socket.trace
     106:  00:DC61                      ;
     107:  00:DC61  11 08 D2            		  ld	de,trace.ipraw.tx
     108:  00:DC64  CD 3D CE            		  call	io.str
     109:  00:DC67  E1                  		 pop	hl		; HL->ip address
     110:  00:DC68  F1                  		pop	af		; A=socket number
     111:  00:DC69                      ;
     112:  00:DC69  F5                  		push	af		; Save socket number
     113:  00:DC6A  E5                  		 push	hl		; Save ->ip address
     114:  00:DC6B  F5                  		  push	af		; Save socket number
     115:  00:DC6C  CD 8C CD            		   call	io.ip		; Print dest ip address
     116:  00:DC6F  F1                  		  pop	af		; A=socket number
     117:  00:DC70                      ;
     118:  00:DC70                      		  SOCKET_GET_BASE
     118:  00:DC70  11 00 01          >    ld de,0100h
     118:  00:DC73  0F                >    rrca
     118:  00:DC74  CB 1B             >    rr e
     118:  00:DC76  0F                >    rrca
     118:  00:DC77  CB 1B             >    rr e
     118:  00:DC79  0F                >    rrca
     118:  00:DC7A  CB 12             >    rl d
     119:  00:DC7C  3E 07               		  ld	a,socket.vars.tx_size
     120:  00:DC7E  CD BF DB            		  call	socket.get_word	; HL=tx_size
     121:  00:DC81  CD 30 D0            		  call	trace.bytes	; Print it
     122:  00:DC84  CD 3C D0            		  call	trace.dots
     123:  00:DC87  E1                  		 pop	hl		; HL->IP address
     124:  00:DC88  F1                  		pop	af		; A=socket no
     125:  00:DC89                      ;
     126:  00:DC89  CD BD D9            .notrace:	call	socket.write_DIPR	; Also sets DE=base reg
     127:  00:DC8C                      ;
     128:  00:DC8C  C3 14 DA            		jp	socket._send	; Do the send
     129:  00:DC8F                      ;
     130:  00:DC8F                      ;
     131:  00:DC8F                      		endmodule
     132:  00:DC8F                      		
     105.  00:DC8F                      	include udp.asm
       1:  00:DC8F                      ; UDP
       2:  00:DC8F                      ;
       3:  00:DC8F                      ; Impements an interface to the sockets of the WIZ chip in UDP mode
       4:  00:DC8F                      ;
       5:  00:DC8F                      		module	udp
       6:  00:DC8F                      ;
       7:  00:DC8F                      ;==============================================================================
       8:  00:DC8F                      ;
       9:  00:DC8F                      ; This file is part of the EPNET software
      10:  00:DC8F                      ;
      11:  00:DC8F                      ; Copyright (C) 2015  Bruce Tanner
      12:  00:DC8F                      ;
      13:  00:DC8F                      ;    This program is free software: you can redistribute it and/or modify
      14:  00:DC8F                      ;    it under the terms of the GNU General Public License as published by
      15:  00:DC8F                      ;    the Free Software Foundation, either version 3 of the License, or
      16:  00:DC8F                      ;    (at your option) any later version.
      17:  00:DC8F                      ;
      18:  00:DC8F                      ;    This program is distributed in the hope that it will be useful,
      19:  00:DC8F                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      20:  00:DC8F                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      21:  00:DC8F                      ;    GNU General Public License for more details.
      22:  00:DC8F                      ;
      23:  00:DC8F                      ;    You should have received a copy of the GNU General Public License
      24:  00:DC8F                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      25:  00:DC8F                      ;
      26:  00:DC8F                      ; If you do use or modify this file, either for its original purpose or for
      27:  00:DC8F                      ; something new, I'd love to hear about it! I can be contacted by email at:
      28:  00:DC8F                      ;
      29:  00:DC8F                      ; brucetanner@btopenworld.com
      30:  00:DC8F                      ;
      31:  00:DC8F                      ;==============================================================================
      32:  00:DC8F                      ; open
      33:  00:DC8F                      ;
      34:  00:DC8F                      ; Opens a WIZ socket in UDP mode
      35:  00:DC8F                      ;
      36:  00:DC8F                      ; In: A=socket number
      37:  00:DC8F                      ;     HL=port number
      38:  00:DC8F                      ;     DE->owner string
      39:  00:DC8F                      ; Out: Carry set if error
      40:  00:DC8F  AF                  open_0:		xor	a
      41:  00:DC90                      open:
      42:  00:DC90  01 22 02            		ld	bc,w5300.Sn_MR_UDP*256+w5300.Sn_SSR_UDP
      43:  00:DC93  C3 50 D7            		jp	socket.open		; Open socket in UDP mode
      44:  00:DC96                      ;
      45:  00:DC96                      ;
      46:  00:DC96                      ;------------------------------------------------------------------------------
      47:  00:DC96                      ; header:
      48:  00:DC96                      ;
      49:  00:DC96                      ; Starts reading a packet from an open socket - we have to read the WIZ
      50:  00:DC96                      ; PACKET_INFO first and this is what this does.
      51:  00:DC96                      ;
      52:  00:DC96                      ; In:  A=socket number
      53:  00:DC96                      ; Out: NC=>no error
      54:  00:DC96                      ;       Z=>nothing to read
      55:  00:DC96                      ;      HL=no bytes in packet (0 if nothing read)
      56:  00:DC96                      ;      vars.upd.header filled if HL<>0
      57:  00:DC96                      ;
      58:  00:DC96  AF                  header_0:	xor	a
      59:  00:DC97  CD 76 D8            header:		call	socket.available; See if any bytes available to read
      60:  00:DC9A  C8                  		ret	z		; Nope
      61:  00:DC9B                      ;
      62:  00:DC9B                      ; A packet has been received. First 8 bytes are PACKET_INFO: ip address, port
      63:  00:DC9B                      ; and packet size
      64:  00:DC9B                      .gotdata:	; We rely on the w5300 behaving here - if there's some data
      65:  00:DC9B                      		; there must be at least a UDP header there
      66:  00:DC9B  01 08 00            		ld	bc,vars.udp.header_size	; Header = 4 words
      67:  00:DC9E  21 11 F0            		ld	hl,vars.udp.header
      68:  00:DCA1  D5                  		push	de
      69:  00:DCA2  CD A6 D6            		 call	socket.read_header	; Read header
      70:  00:DCA5  D1                  		pop	de			; DE=base reg
      71:  00:DCA6                      ;
      72:  00:DCA6  21 15 F0            		ld	hl,vars.udp.port	; Update header byte orders
      73:  00:DCA9  CD 96 DB            		call	socket.byteswapword
      74:  00:DCAC                      ;
      75:  00:DCAC  21 17 F0            		ld	hl,vars.udp.size
      76:  00:DCAF  CD 96 DB            		call	socket.byteswapword
      77:  00:DCB2                      ;
      78:  00:DCB2  3E 03               		ld	a,socket.vars.rx_size
      79:  00:DCB4  CD 9F DB            		call	socket.set_word		; Set up per-socket vars
      80:  00:DCB7                      ;
      81:  00:DCB7  FD CB 00 4E          		bit	vars.trace.socket,(iy+vars._trace)
      82:  00:DCBB  28 1C               		jr	z,.ret
      83:  00:DCBD                      ;
      84:  00:DCBD  CD F1 DB            		call	socket._trace
      85:  00:DCC0                      ;
      86:  00:DCC0  11 C7 D1            		ld	de,trace.udp.rx
      87:  00:DCC3  CD 3D CE            		call	io.str
      88:  00:DCC6                      ;
      89:  00:DCC6  21 11 F0            		ld	hl,vars.udp.ip
      90:  00:DCC9  ED 4B 15 F0         		ld	bc,(vars.udp.port)
      91:  00:DCCD  CD A2 CD            		call	io.ip_port
      92:  00:DCD0                      ;
      93:  00:DCD0  2A 17 F0            		ld	hl,(vars.udp.size)
      94:  00:DCD3  CD 30 D0            		call	trace.bytes
      95:  00:DCD6  CD 31 CE            		call	io.space
      96:  00:DCD9                      ;
      97:  00:DCD9  2A 17 F0            .ret:		ld	hl,(vars.udp.size)
      98:  00:DCDC  7C                  		ld	a,h
      99:  00:DCDD  B5                  		or	l
     100:  00:DCDE  C9                  		ret
     101:  00:DCDF                      ;
     102:  00:DCDF                      ;
     103:  00:DCDF                      ;------------------------------------------------------------------------------
     104:  00:DCDF                      ; send
     105:  00:DCDF                      ;
     106:  00:DCDF                      ; Having written the data with one or more calls to write(), this actually
     107:  00:DCDF                      ; sends the packet. The destination ip address and port are in vars.udp.ip and
     108:  00:DCDF                      ; vars.udp.port.
     109:  00:DCDF                      ;
     110:  00:DCDF                      ; In:  A=socket number
     111:  00:DCDF                      ;      vars.udp.ip = dest IP address to send to
     112:  00:DCDF                      ;      vars.udp.port = dest port no.
     113:  00:DCDF                      ; Out: NC=>ok
     114:  00:DCDF  AF                  send_0:		xor	a
     115:  00:DCE0  FD CB 00 4E         send:		bit	vars.trace.socket,(iy+vars._trace)
     116:  00:DCE4  28 2E               		jr	z,.notrace
     117:  00:DCE6                      ;
     118:  00:DCE6  F5                  		push	af		; Save socket no
     119:  00:DCE7  CD E5 DB            		 call	socket.trace
     120:  00:DCEA                      
     121:  00:DCEA  11 D4 D1            		 ld	de,trace.udp.tx
     122:  00:DCED  CD 3D CE            		 call	io.str
     123:  00:DCF0                      ;
     124:  00:DCF0  21 11 F0            		 ld	hl,vars.udp.ip
     125:  00:DCF3  ED 4B 15 F0         		 ld	bc,(vars.udp.port)
     126:  00:DCF7  CD A2 CD            		 call	io.ip_port	; Print dest ip address & port
     127:  00:DCFA  F1                  		pop	af		; A=socket number
     128:  00:DCFB                      ;
     129:  00:DCFB  F5                  		push	af		; Save socket number
     130:  00:DCFC                      		 SOCKET_GET_BASE
     130:  00:DCFC  11 00 01          >    ld de,0100h
     130:  00:DCFF  0F                >    rrca
     130:  00:DD00  CB 1B             >    rr e
     130:  00:DD02  0F                >    rrca
     130:  00:DD03  CB 1B             >    rr e
     130:  00:DD05  0F                >    rrca
     130:  00:DD06  CB 12             >    rl d
     131:  00:DD08  3E 07               		 ld	a,socket.vars.tx_size
     132:  00:DD0A  CD BF DB            		 call	socket.get_word
     133:  00:DD0D  CD 30 D0            		 call	trace.bytes
     134:  00:DD10  CD 3C D0            		 call	trace.dots
     135:  00:DD13  F1                  		pop	af		; A=socket no
     136:  00:DD14                      ;
     137:  00:DD14                      .notrace:
     138:  00:DD14  21 11 F0            		ld	hl,vars.udp.ip		; Set up dest IP address
     139:  00:DD17  CD BD D9            		call	socket.write_DIPR	; Sets DE=base reg
     140:  00:DD1A                      ;
     141:  00:DD1A  2A 15 F0            		ld	hl,(vars.udp.port)	
     142:  00:DD1D  CD DC D9            		call	socket.write_DPORTR	; Set up dest port #
     143:  00:DD20                      ;
     144:  00:DD20  C3 14 DA            		jp	socket._send		; Do the send
     145:  00:DD23                      ;
     146:  00:DD23                      ;
     147:  00:DD23                      		endmodule
     106.  00:DD23                      	include	tcp.asm
       1:  00:DD23                      ; TCP
       2:  00:DD23                      ;
       3:  00:DD23                      ; Implements an interface to the sockets of the WIZ chip in TCP mode
       4:  00:DD23                      ;
       5:  00:DD23                      		module tcp
       6:  00:DD23                      ;
       7:  00:DD23                      ;==============================================================================
       8:  00:DD23                      ;
       9:  00:DD23                      ; This file is part of the EPNET software
      10:  00:DD23                      ;
      11:  00:DD23                      ; Copyright (C) 2015  Bruce Tanner
      12:  00:DD23                      ;
      13:  00:DD23                      ;    This program is free software: you can redistribute it and/or modify
      14:  00:DD23                      ;    it under the terms of the GNU General Public License as published by
      15:  00:DD23                      ;    the Free Software Foundation, either version 3 of the License, or
      16:  00:DD23                      ;    (at your option) any later version.
      17:  00:DD23                      ;
      18:  00:DD23                      ;    This program is distributed in the hope that it will be useful,
      19:  00:DD23                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      20:  00:DD23                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      21:  00:DD23                      ;    GNU General Public License for more details.
      22:  00:DD23                      ;
      23:  00:DD23                      ;    You should have received a copy of the GNU General Public License
      24:  00:DD23                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      25:  00:DD23                      ;
      26:  00:DD23                      ; If you do use or modify this file, either for its original purpose or for
      27:  00:DD23                      ; something new, I'd love to hear about it! I can be contacted by email at:
      28:  00:DD23                      ;
      29:  00:DD23                      ; brucetanner@btopenworld.com
      30:  00:DD23                      ;
      31:  00:DD23                      ;==============================================================================
      32:  00:DD23                      ; open
      33:  00:DD23                      ;
      34:  00:DD23                      ; Opens a WIZ socket in TCP client mode
      35:  00:DD23                      ;
      36:  00:DD23                      ; In:  A=socket number
      37:  00:DD23                      ;     HL=our port number
      38:  00:DD23                      ;     DE->owner string
      39:  00:DD23                      ; Out: Carry set if error
      40:  00:DD23                      ;
      41:  00:DD23                      open:
      42:  00:DD23  01 13 21            		ld	bc,(w5300.Sn_MR_TCP or w5300.Sn_MR_ND)*256+                                                              w5300.Sn_SSR_INIT
      43:  00:DD26  C3 50 D7            		jp	socket.open		; Open socket in TCP client mode
      44:  00:DD29                      ;
      45:  00:DD29                      ;
      46:  00:DD29                      ;------------------------------------------------------------------------------
      47:  00:DD29                      ; header
      48:  00:DD29                      ;
      49:  00:DD29                      ; Starts reading a packet from an open socket
      50:  00:DD29                      ;
      51:  00:DD29                      ; In:  A=socket number
      52:  00:DD29                      ; Out: NC=>no error
      53:  00:DD29                      ;       Z=>nothing to read
      54:  00:DD29                      ;      HL=no bytes in packet (0 if nothing read)
      55:  00:DD29                      ;      DE=socket base register
      56:  00:DD29                      header:		SOCKET_GET_BASE
      56:  00:DD29  11 00 01          >    ld de,0100h
      56:  00:DD2C  0F                >    rrca
      56:  00:DD2D  CB 1B             >    rr e
      56:  00:DD2F  0F                >    rrca
      56:  00:DD30  CB 1B             >    rr e
      56:  00:DD32  0F                >    rrca
      56:  00:DD33  CB 12             >    rl d
      57:  00:DD35  CD 82 D8            _header:	call	socket._available; See if any bytes available to read
      58:  00:DD38  C8                  		ret	z		; Z=>nope
      59:  00:DD39                      ;
      60:  00:DD39                      ; A packet has been received. First 2 bytes are PACKET_INFO: just 
      61:  00:DD39                      ; packet size for TCP mode
      62:  00:DD39                      ;
      63:  00:DD39                      		; We rely on the w5300 behaving here - if there's some data
      64:  00:DD39                      		; there must be at least a PACKET_INFO header here
      65:  00:DD39  01 02 00            		ld	bc,vars.tcp.header_size	; Header 1 word for TCP mode
      66:  00:DD3C  21 17 F0            		ld	hl,vars.tcp.header
      67:  00:DD3F  D5                  		push	de
      68:  00:DD40  CD A6 D6            		 call	socket.read_header	; Read header
      69:  00:DD43  D1                  		pop	de			; DE=base reg
      70:  00:DD44                      ;
      71:  00:DD44  21 17 F0            		ld	hl,vars.tcp.size
      72:  00:DD47  CD 96 DB            		call	socket.byteswapword
      73:  00:DD4A                      ;
      74:  00:DD4A  3E 03               		ld	a,socket.vars.rx_size
      75:  00:DD4C  CD 9F DB            		call	socket.set_word		; Set up per-socket vars
      76:  00:DD4F                      ;
      77:  00:DD4F  FD CB 00 4E          		bit	vars.trace.socket,(iy+vars._trace)
      78:  00:DD53  28 14               		jr	z,.ret
      79:  00:DD55                      ;
      80:  00:DD55  D5                  		push	de			; Save socket base reg
      81:  00:DD56  CD F1 DB            		 call	socket._trace
      82:  00:DD59                      ;
      83:  00:DD59  11 EB D1            		 ld	de,trace.tcp.rx
      84:  00:DD5C  CD 3D CE            		 call	io.str
      85:  00:DD5F                      ;
      86:  00:DD5F  2A 17 F0            		 ld	hl,(vars.tcp.size)
      87:  00:DD62  CD 30 D0            		 call	trace.bytes
      88:  00:DD65  CD 31 CE            		 call	io.space
      89:  00:DD68  D1                  		pop	de			; DE=socket base reg
      90:  00:DD69                      ;
      91:  00:DD69  2A 17 F0            .ret:		ld	hl,(vars.tcp.size)
      92:  00:DD6C  7C                  		ld	a,h
      93:  00:DD6D  B5                  		or	l			; NC=>no error, NZ=>bytes ready
      94:  00:DD6E  C9                  		ret
      95:  00:DD6F                      ;
      96:  00:DD6F                      ;
      97:  00:DD6F                      ;------------------------------------------------------------------------------
      98:  00:DD6F                      ; read_block
      99:  00:DD6F                      ;
     100:  00:DD6F                      ; This is called from the EXOS device to read a block of data into the user's
     101:  00:DD6F                      ; buffer. It must cope with odd-length reads and multiple TCP packets.
     102:  00:DD6F                      ;
     103:  00:DD6F                      ; In:  A=socket number
     104:  00:DD6F                      ;     DE->buffer
     105:  00:DD6F                      ;     BC=total number of bytes to read, >0
     106:  00:DD6F                      ; Out: NC & A=0 if no error
     107:  00:DD6F                      ;      Cy=>error, A=1 => socket closed, A=2 => STOP pressed, A=3 => timeout
     108:  00:DD6F                      ;
     109:  00:DD6F                      read_block:
     110:  00:DD6F  EB                  		ex	de,hl		; HL->user's buffer
     111:  00:DD70                      		SOCKET_GET_BASE		; DE=socket base register
     111:  00:DD70  11 00 01          >    ld de,0100h
     111:  00:DD73  0F                >    rrca
     111:  00:DD74  CB 1B             >    rr e
     111:  00:DD76  0F                >    rrca
     111:  00:DD77  CB 1B             >    rr e
     111:  00:DD79  0F                >    rrca
     111:  00:DD7A  CB 12             >    rl d
     112:  00:DD7C                      ;
     113:  00:DD7C                      .loop:
     114:  00:DD7C  78                  		ld	a,b		; See if byte count == 0
     115:  00:DD7D  B1                  		or	c
     116:  00:DD7E  C8                  		ret	z		; All done
     117:  00:DD7F                      ;		
     118:  00:DD7F                      		; First we look to see if we have an odd byte buffered and,
     119:  00:DD7F                      		; if we have, put this in the user's buffer
     120:  00:DD7F  E5                  		push	hl		; Save ->buffer
     121:  00:DD80                      		 SOCKET_GET_VAR socket.vars.rx_inhand
     121:  00:DD80                    >    if (var)=0
     121:  00:DD80                    ~     ld a,e
     121:  00:DD80                    ~    else
     121:  00:DD80  3E 0A             >     ld a,(var)*2
     121:  00:DD82  B3                >     or e
     121:  00:DD83                    >    endif
     121:  00:DD83  6F                >    ld l,a
     121:  00:DD84  7A                >    ld a,d
     121:  00:DD85  0F                >    rrca
     121:  00:DD86  CB 1D             >    rr l
     121:  00:DD88  26 F2             >    ld h,high vars.sockets
     122:  00:DD8A  7E                  		 ld	a,(hl)		; FF=>buffered byte, 0=>none
     123:  00:DD8B  3C                  		 inc	a
     124:  00:DD8C  20 09               		 jr	nz,.no_inhand	; Go if no byte inhand
     125:  00:DD8E                      ;
     126:  00:DD8E  77                  		 ld	(hl),a		; No byte buffered now
     127:  00:DD8F  23                  		 inc	hl
     128:  00:DD90  7E                  		 ld	a,(hl)		; Get buffered byte
     129:  00:DD91  E1                  		pop	hl		; HL->user's buffer
     130:  00:DD92                      ;
     131:  00:DD92  77                  .putbyte:	ld	(hl),a		; Put byte into user's buffer
     132:  00:DD93  23                  		inc	hl		; Adjust ->user's buffer
     133:  00:DD94  0B                  		dec	bc		; Adjust total byte count
     134:  00:DD95  18 E5               		jr	.loop		; Repeat but now we know no byte buffered
     135:  00:DD97                      ;
     136:  00:DD97  E1                  .no_inhand:	pop	hl		; HL->user's buffer
     137:  00:DD98                      ;
     138:  00:DD98                      		; Now we definitely need one or more bytes from a packet, so
     139:  00:DD98                      		; see if we have started reading from one
     140:  00:DD98  E5                  		push	hl
     141:  00:DD99  C5                  		push	bc
     142:  00:DD9A                      		 SOCKET_GET_VAR socket.vars.rx_size
     142:  00:DD9A                    >    if (var)=0
     142:  00:DD9A                    ~     ld a,e
     142:  00:DD9A                    ~    else
     142:  00:DD9A  3E 06             >     ld a,(var)*2
     142:  00:DD9C  B3                >     or e
     142:  00:DD9D                    >    endif
     142:  00:DD9D  6F                >    ld l,a
     142:  00:DD9E  7A                >    ld a,d
     142:  00:DD9F  0F                >    rrca
     142:  00:DDA0  CB 1D             >    rr l
     142:  00:DDA2  26 F2             >    ld h,high vars.sockets
     143:  00:DDA4  4E                  		 ld	c,(hl)
     144:  00:DDA5  23                  		 inc	hl
     145:  00:DDA6  46                  		 ld	b,(hl)		; BC=amount available
     146:  00:DDA7  78                  		 ld	a,b
     147:  00:DDA8  B1                  		 or	c
     148:  00:DDA9  20 36               		 jr	nz,.got_packet	; Go if packet waiting
     149:  00:DDAB                      ;
     150:  00:DDAB                      		 ; Here we need to read more but we have exhausted the current
     151:  00:DDAB                      		 ; packet, so we need to wait until RSR indicates that there
     152:  00:DDAB                      		 ; is something available and then read the PACKET_INFO of
     153:  00:DDAB                      		 ; the next packet (if there is one)
     154:  00:DDAB                      		 ;
     155:  00:DDAB                      		 ; We need to check for a packet ready *before* checking to
     156:  00:DDAB                      		 ; see if the socket is closed, as the other end may well
     157:  00:DDAB                      		 ; send lots of packets then close the link before we have
     158:  00:DDAB                      		 ; read them all
     159:  00:DDAB                      ;
     160:  00:DDAB  2A 06 F0            		 ld	hl,(vars.ticks)	; Setup timout timer
     161:  00:DDAE  22 0F F0            		 ld	(vars.tcp.start),hl
     162:  00:DDB1                      ;
     163:  00:DDB1  CD 35 DD            .wait:		 call	_header		; See if packet arrived
     164:  00:DDB4  20 2B               		 jr	nz,.got_packet	; Go and read it if yes
     165:  00:DDB6                      ;
     166:  00:DDB6  CD 96 D8            		 call	socket._is_closed; Other end closed connection
     167:  00:DDB9  3E 01               		 ld	a,1
     168:  00:DDBB  28 20               		 jr	z,.ret		; Return with A=1 if yes
     169:  00:DDBD                      ;
     170:  00:DDBD  CD CA CE            		 call	status.waiting	; Flash waiting indicator
     171:  00:DDC0                      ;
     172:  00:DDC0  CD 10 DF            		 call	_send		; Send 0 bytes to update TCP/IP window
     173:  00:DDC3                      ;
     174:  00:DDC3  CD 94 C9            		 call	exos.is_stop	; Stop key pressed?
     175:  00:DDC6  3E 02               		 ld	a,2
     176:  00:DDC8  38 13               		 jr	c,.ret		; Return with A=2 if yes
     177:  00:DDCA                      ;
     178:  00:DDCA  ED 4B 0F F0         		 ld	bc,(vars.tcp.start)
     179:  00:DDCE  2A 06 F0            		 ld	hl,(vars.ticks)
     180:  00:DDD1  B7                  		 or	a
     181:  00:DDD2  ED 42               		 sbc	hl,bc		; HL=duraction in ticks
     182:  00:DDD4  01 B8 0B            		 ld	bc,TICKS_1m
     183:  00:DDD7  ED 42               		 sbc	hl,bc		; See if timed out (1 S)
     184:  00:DDD9  38 D6               		 jr	c,.wait		; Keep waiting if not
     185:  00:DDDB                      ;
     186:  00:DDDB  3E 03               		 ld	a,3		; Return with A=3 if timed out
     187:  00:DDDD                      ;
     188:  00:DDDD  C1                  .ret:		pop	bc
     189:  00:DDDE  E1                  		pop	hl
     190:  00:DDDF  37                  		scf			; Cy=>error
     191:  00:DDE0  C9                  		ret
     192:  00:DDE1                      ;
     193:  00:DDE1  C1                  .got_packet:	pop	bc
     194:  00:DDE2  E1                  		pop	hl
     195:  00:DDE3                      ;
     196:  00:DDE3                      		; Here there is a packet buffered and we need one or more
     197:  00:DDE3                      		; bytes from it
     198:  00:DDE3                      		; HL->user's buffer
     199:  00:DDE3                      		; BC=total bytes needed
     200:  00:DDE3                      		; DE=socket base
     201:  00:DDE3                      ;
     202:  00:DDE3                      		; First we read as many even bytes as we can from the packet
     203:  00:DDE3  C5                  		push	bc	; Save total byte count
     204:  00:DDE4  E5                  		 push	hl	; Save->user's buffer
     205:  00:DDE5  CB 81               		  res	0,c	; Only doing even bytes (could == 0!)
     206:  00:DDE7  C5                  		  push	bc	; Save # even bytes required
     207:  00:DDE8                      		   SOCKET_GET_VAR socket.vars.rx_size
     207:  00:DDE8                    >    if (var)=0
     207:  00:DDE8                    ~     ld a,e
     207:  00:DDE8                    ~    else
     207:  00:DDE8  3E 06             >     ld a,(var)*2
     207:  00:DDEA  B3                >     or e
     207:  00:DDEB                    >    endif
     207:  00:DDEB  6F                >    ld l,a
     207:  00:DDEC  7A                >    ld a,d
     207:  00:DDED  0F                >    rrca
     207:  00:DDEE  CB 1D             >    rr l
     207:  00:DDF0  26 F2             >    ld h,high vars.sockets
     208:  00:DDF2  4E                  		   ld	c,(hl)
     209:  00:DDF3  23                  		   inc	hl
     210:  00:DDF4  46                  		   ld	b,(hl)	; BC=amount available
     211:  00:DDF5  CB 81               		   res	0,c	; Only doing even bytes (could == 0!)
     212:  00:DDF7  E1                  		  pop	hl	; HL=#even bytes required
     213:  00:DDF8  B7                  		  or	a
     214:  00:DDF9  ED 42               		  sbc	hl,bc	; HL=remainder after read
     215:  00:DDFB  30 03               		  jr	nc,.all	; Go if amount in packet < required
     216:  00:DDFD                      ;
     217:  00:DDFD  09                  		  add	hl,bc	; HL=amount to read from packet
     218:  00:DDFE  4D                  		  ld	c,l
     219:  00:DDFF  44                  		  ld	b,h	; BC=amount for this read
     220:  00:DE00                      ;
     221:  00:DE00  E1                  .all:		 pop	hl	; HL->user's buffer
     222:  00:DE01                      
     223:  00:DE01                      		 ; Now BC   = number of even bytes to read from packet
     224:  00:DE01                      		 ;     HL   ->user's buffer
     225:  00:DE01                      		 ;     (SP) = total bytes required
     226:  00:DE01                      ;
     227:  00:DE01  78                  		 ld	a,b
     228:  00:DE02  B1                  		 or	c	; A=0 => no even bytes to read
     229:  00:DE03  28 19               		 jr	z,.odd
     230:  00:DE05                      ;
     231:  00:DE05  E5                  		 push	hl	; Save ->user's buffer
     232:  00:DE06  09                  		  add	hl,bc	; HL->user's buffer updated
     233:  00:DE07  E3                  		 ex	(sp),hl	; HL->user's buffer, (SP)->buffer updated
     234:  00:DE08  C5                  		  push	bc	; Save amount to read
     235:  00:DE09  CD B8 D8            		   call	socket._read	; Read the bytes; HL->rx_size
     236:  00:DE0C                      ;
     237:  00:DE0C  7E                  		   ld	a,(hl)
     238:  00:DE0D  23                  		   inc	hl
     239:  00:DE0E  B6                  		   or	(hl)	; See if we've read everything
     240:  00:DE0F  CC 83 D9            		   call	z,socket._send_end	; Indicate end of read if we have
     241:  00:DE12  C1                  		  pop	bc	; BC=amount just read
     242:  00:DE13  E1                  		 pop	hl	; HL->user's buffer updated
     243:  00:DE14  E3                  		ex	(sp),hl	; HL=total byte count, (SP)=buffer updated
     244:  00:DE15  B7                  		 or	a
     245:  00:DE16  ED 42               		 sbc	hl,bc	; Total bytes required -= amount just read
     246:  00:DE18  4D                  		 ld	c,l
     247:  00:DE19  44                  		 ld	b,h	; BC=new total byte count
     248:  00:DE1A  E1                  		pop	hl	; HL->new user's buffer
     249:  00:DE1B                      ;
     250:  00:DE1B  C3 7C DD            		jp	.loop
     251:  00:DE1E                      ;
     252:  00:DE1E  C1                  .odd:		pop	bc	; BC=total byte count
     253:  00:DE1F                      ;
     254:  00:DE1F                      		; We now have a packet and have read as many even bytes as we
     255:  00:DE1F                      		; can from it. If we end up here either a) it's an odd-length
     256:  00:DE1F                      		; read and we need the last odd byte, or b) we have an
     257:  00:DE1F                      		; odd-length packet and we need to read the last byte from it
     258:  00:DE1F                      ;
     259:  00:DE1F                      		; HL->user's buffer
     260:  00:DE1F                      		; BC=bytes still required
     261:  00:DE1F                      ;
     262:  00:DE1F                      		; When doing a byte read we normally read a word and buffer
     263:  00:DE1F                      		; the second byte in rx_inhand. But if it's the last byte of
     264:  00:DE1F                      		; an odd-length packet we have to discard the second byte as
     265:  00:DE1F                      		; it's a dummy!
     266:  00:DE1F                      ;
     267:  00:DE1F  E5                  		push	hl
     268:  00:DE20  C5                  		push	bc
     269:  00:DE21                      		 SOCKET_GET_VAR socket.vars.rx_inhand	; Read 2 bytes to here
     269:  00:DE21                    >    if (var)=0
     269:  00:DE21                    ~     ld a,e
     269:  00:DE21                    ~    else
     269:  00:DE21  3E 0A             >     ld a,(var)*2
     269:  00:DE23  B3                >     or e
     269:  00:DE24                    >    endif
     269:  00:DE24  6F                >    ld l,a
     269:  00:DE25  7A                >    ld a,d
     269:  00:DE26  0F                >    rrca
     269:  00:DE27  CB 1D             >    rr l
     269:  00:DE29  26 F2             >    ld h,high vars.sockets
     270:  00:DE2B  01 02 00            		 ld	bc,2	; Read 2 bytes
     271:  00:DE2E  E5                  		 push	hl	; Save->rx_inhand
     272:  00:DE2F  CD B8 D8            		  call	socket._read	; Read 1 word; Cy=>past last byte
     273:  00:DE32  F5                  		  push	af	; Save last byte flag
     274:  00:DE33  7E                  		   ld	a,(hl)	; Check rx_size to see if we've read everything
     275:  00:DE34  23                  		   inc	hl
     276:  00:DE35  B6                  		   or	(hl)	; See if we've read everything
     277:  00:DE36  CC 83 D9            		   call	z,socket._send_end ; Indicate end of read if we have
     278:  00:DE39  F1                  		  pop	af	; Cy=>read past last byte
     279:  00:DE3A  E1                  		 pop	hl	; HL->rx_inhand
     280:  00:DE3B  3F                  		 ccf		; NC=>last byte, Cy=>not last byte
     281:  00:DE3C  9F                  		 sbc	a,a	; A= 0=>last byte, ff=>not last byte
     282:  00:DE3D  46                  		 ld	b,(hl)	; B=first of the two bytes
     283:  00:DE3E  77                  		 ld	(hl),a	; FF=>buffered byte, 0=>no buffered byte
     284:  00:DE3F  78                  		 ld	a,b	; A=byte to put in user's buffer
     285:  00:DE40  C1                  		pop	bc	; BC=total byte count
     286:  00:DE41  E1                  		pop	hl	; HL->user's buffer
     287:  00:DE42  C3 92 DD            		jp	.putbyte; Put byte in user's buffer & update HL & BC
     288:  00:DE45                      ;
     289:  00:DE45                      ;
     290:  00:DE45                      ;------------------------------------------------------------------------------
     291:  00:DE45                      ; write_block
     292:  00:DE45                      ;
     293:  00:DE45                      ; This is called from the EXOS device to write a block of data from the user's
     294:  00:DE45                      ; buffer. It must cope with odd-length writes and splitting large blocks into
     295:  00:DE45                      ; multiple TCP packets.
     296:  00:DE45                      ;
     297:  00:DE45                      ; In:  A=socket number
     298:  00:DE45                      ;     DE->buffer
     299:  00:DE45                      ;     BC=total number of bytes to read, >0
     300:  00:DE45                      ; Out: Cy=>error
     301:  00:DE45                      ;
     302:  00:DE45                      write_block:
     303:  00:DE45  EB                  		ex	de,hl		; HL->user's buffer
     304:  00:DE46                      		SOCKET_GET_BASE		; DE=socket base register
     304:  00:DE46  11 00 01          >    ld de,0100h
     304:  00:DE49  0F                >    rrca
     304:  00:DE4A  CB 1B             >    rr e
     304:  00:DE4C  0F                >    rrca
     304:  00:DE4D  CB 1B             >    rr e
     304:  00:DE4F  0F                >    rrca
     304:  00:DE50  CB 12             >    rl d
     305:  00:DE52                      ;
     306:  00:DE52                      		; First we look to see if we have an odd byte buffered from
     307:  00:DE52                      		; the previous write and, if we have, take first byte from
     308:  00:DE52                      		; the current write to form a word with it, and write it
     309:  00:DE52  E5                  		push	hl		; Save ->buffer
     310:  00:DE53                      		 SOCKET_GET_VAR socket.vars.tx_inhand+1
     310:  00:DE53                    >    if (var)=0
     310:  00:DE53                    ~     ld a,e
     310:  00:DE53                    ~    else
     310:  00:DE53  3E 14             >     ld a,(var)*2
     310:  00:DE55  B3                >     or e
     310:  00:DE56                    >    endif
     310:  00:DE56  6F                >    ld l,a
     310:  00:DE57  7A                >    ld a,d
     310:  00:DE58  0F                >    rrca
     310:  00:DE59  CB 1D             >    rr l
     310:  00:DE5B  26 F2             >    ld h,high vars.sockets
     311:  00:DE5D  7E                  		 ld	a,(hl)		; FF=>buffered byte, 0=>none
     312:  00:DE5E  B7                  		 or	a		; NC
     313:  00:DE5F  3C                  		 inc	a
     314:  00:DE60  20 14               		 jr	nz,.nobuf	; Go with NC if no byte inhand
     315:  00:DE62                      ;
     316:  00:DE62  E3                  		 ex	(sp),hl		; (SP)->tx_inhand+1, HL->user's buffer
     317:  00:DE63  7E                  		 ld	a,(hl)		; Get user's first data byte
     318:  00:DE64  23                  		 inc	hl
     319:  00:DE65  E3                  		 ex	(sp),hl		; (SP)->user's data, HL->tx_inhand+1
     320:  00:DE66  77                  		 ld	(hl),a		; tx_inhand now = next word to write
     321:  00:DE67  2B                  		 dec	hl		; HL->tx_inhand
     322:  00:DE68  0B                  		 dec	bc		; User's byte count now 1 less
     323:  00:DE69  C5                  		 push	bc
     324:  00:DE6A  E5                  		  push	hl		; Save ->tx_inhand
     325:  00:DE6B  01 02 00            		   ld	bc,2		; Write 1 word
     326:  00:DE6E  CD 9C DE            		   call	_write_block
     327:  00:DE71  E1                  		  pop	hl		; HL->tx_inhand
     328:  00:DE72  23                  		  inc	hl
     329:  00:DE73  36 00               		  ld	(hl),0		; 0 => no buffered byte
     330:  00:DE75  C1                  		 pop	bc		; BC=remaining bytes to write
     331:  00:DE76  E1                  .nobuf:		pop	hl		; HL->user's data
     332:  00:DE77  D8                  		ret	c		; Error
     333:  00:DE78                      ;
     334:  00:DE78                      		; Now we write the even words
     335:  00:DE78                      		; HL->user's buffer
     336:  00:DE78                      		; BC=byte count (could now be 0, could still be odd)
     337:  00:DE78                      		; DE=socket base
     338:  00:DE78  E5                  		push	hl		; Save ->user's buffer
     339:  00:DE79  C5                  		 push	bc		; Save byte count
     340:  00:DE7A  CB 81               		  res	0,c		; We'll do odd bytes l8r
     341:  00:DE7C  78                  		  ld	a,b
     342:  00:DE7D  B1                  		  or	c		; NC as well as testing BC
     343:  00:DE7E  C4 9C DE            		  call	nz,_write_block
     344:  00:DE81  C1                  		 pop	bc		; BC=byte count jusrt written
     345:  00:DE82  E1                  		pop	hl		; HL->user's buffer
     346:  00:DE83                      ;
     347:  00:DE83  D8                  		ret	c		; Error from _write_block
     348:  00:DE84                      ;
     349:  00:DE84  CB 41               		bit	0,c		; An odd #bytes?
     350:  00:DE86  C8                  		ret	z		; We're done if not
     351:  00:DE87                      ;
     352:  00:DE87                      		; If there's an odd byte at the end, save it in tx_inhand for
     353:  00:DE87                      		; the next write
     354:  00:DE87  09                  		add	hl,bc		; Adjust ->buffer for write
     355:  00:DE88  2B                  		dec	hl		; ->last odd byte
     356:  00:DE89  7E                  		ld	a,(hl)
     357:  00:DE8A  F5                  		push	af		; Save odd byte
     358:  00:DE8B                      		 SOCKET_GET_VAR socket.vars.tx_inhand
     358:  00:DE8B                    >    if (var)=0
     358:  00:DE8B                    ~     ld a,e
     358:  00:DE8B                    ~    else
     358:  00:DE8B  3E 12             >     ld a,(var)*2
     358:  00:DE8D  B3                >     or e
     358:  00:DE8E                    >    endif
     358:  00:DE8E  6F                >    ld l,a
     358:  00:DE8F  7A                >    ld a,d
     358:  00:DE90  0F                >    rrca
     358:  00:DE91  CB 1D             >    rr l
     358:  00:DE93  26 F2             >    ld h,high vars.sockets
     359:  00:DE95  F1                  		pop	af		; A=last odd byte
     360:  00:DE96  77                  		ld	(hl),a		; Save last byte in tx_inhand
     361:  00:DE97  23                  		inc	hl
     362:  00:DE98  36 FF               		ld	(hl),0ffh	; FF->got a buffered byte in hand
     363:  00:DE9A  B7                  		or	a		; NC=>no error
     364:  00:DE9B  C9                  		ret
     365:  00:DE9C                      ;
     366:  00:DE9C                      ;
     367:  00:DE9C                      ; _write_block
     368:  00:DE9C                      ;
     369:  00:DE9C                      ; write_block (above) deals with odd bytes, so here we just write a block given
     370:  00:DE9C                      ; an even byte count. However it could be a large block so we might have to
     371:  00:DE9C                      ; split it up into separate WIZ sends ( ie. separate TCP packets)
     372:  00:DE9C                      ;
     373:  00:DE9C                      ; In:  HL->bufer
     374:  00:DE9C                      ;      BC=word byte, >0
     375:  00:DE9C                      ;      DE=socket register base
     376:  00:DE9C                      ; Out: DE preserved
     377:  00:DE9C                      ;      Cy=>error
     378:  00:DE9C                      ;
     379:  00:DE9C                      _write_block:
     380:  00:DE9C                      ;
     381:  00:DE9C                      		; First see if it's time to send a packet
     382:  00:DE9C  E5                  		push	hl		; Save ->data
     383:  00:DE9D  C5                  		 push	bc		; Save byte count
     384:  00:DE9E  CD 0C DA            .loop:		  call	socket.read_FSR	; HL=space available (in bytes)
     385:  00:DEA1  7C                  		  ld	a,h
     386:  00:DEA2  B5                  		  or	l
     387:  00:DEA3  20 08               		  jr	nz,.donesend
     388:  00:DEA5                      ;
     389:  00:DEA5  CD 10 DF            		  call	tcp._send	; Send if WIZ buffer full
     390:  00:DEA8  30 F4               		  jr	nc,.loop
     391:  00:DEAA                      ;
     392:  00:DEAA  C1                  		 pop	bc
     393:  00:DEAB  E1                  		pop	hl
     394:  00:DEAC  C9                  		ret
     395:  00:DEAD                      
     396:  00:DEAD                      ;
     397:  00:DEAD  4D                  .donesend:	  ld	c,l
     398:  00:DEAE  44                  		  ld	b,h		; BC=no bytes to write this time
     399:  00:DEAF  E1                  		 pop	hl		; HL=total byte count to write
     400:  00:DEB0  B7                  		 or	a
     401:  00:DEB1  ED 42               		 sbc	hl,bc		; HL=remainder after this write
     402:  00:DEB3  30 06               		 jr	nc,.notlast
     403:  00:DEB5                      ;
     404:  00:DEB5  09                  		 add	hl,bc		; HL=amount to write this time
     405:  00:DEB6  4D                  		 ld	c,l
     406:  00:DEB7  44                  		 ld	b,h		; BC=#bytes to write this time
     407:  00:DEB8                      
     408:  00:DEB8  B7                  		 or	a
     409:  00:DEB9  ED 62               		 sbc	hl,hl		; HL=0, #bytes to write next time
     410:  00:DEBB                      ;
     411:  00:DEBB                      .notlast:
     412:  00:DEBB                      		 ; HL=remaining byte count
     413:  00:DEBB                      		 ; BC=byte count this time
     414:  00:DEBB                      		 ; (SP)->data
     415:  00:DEBB  E3                  		ex	(sp),hl		; (SP)=remaining bytes, HL->data
     416:  00:DEBC  C5                  		 push	bc		; Save # byte about to be written
     417:  00:DEBD  D5                  		  push	de		; Save socket base register
     418:  00:DEBE  CD 32 D7            		   call	socket.write_FIFO; Write data; HL=updated ->data
     419:  00:DEC1  D1                  		  pop	de		; DE=socket register base
     420:  00:DEC2  E3                  		 ex	(sp),hl		; (SP)->data, HL=#bytes just written
     421:  00:DEC3  4D                  		  ld	c,l
     422:  00:DEC4  44                  		  ld	b,h
     423:  00:DEC5  CD A9 D9            		  call	socket.add_tx_size	; Add on to tx_size
     424:  00:DEC8  E1                  		 pop	hl		; HL->data
     425:  00:DEC9  C1                  		pop	bc		; BC=#bytes remaining
     426:  00:DECA  78                  		ld	a,b
     427:  00:DECB  B1                  		or	c
     428:  00:DECC  20 CE               		jr	nz,_write_block	; Do it again if more to write
     429:  00:DECE                      ;
     430:  00:DECE  C9                  		ret			; NC =>no error
     431:  00:DECF                      ;
     432:  00:DECF                      ;
     433:  00:DECF                      ;------------------------------------------------------------------------------
     434:  00:DECF                      ; status
     435:  00:DECF                      ;
     436:  00:DECF                      ; This is called from EXOS devices to determine whether there is a byte
     437:  00:DECF                      ; ready to be read or not.
     438:  00:DECF                      ;
     439:  00:DECF                      ; In:  A=socket number
     440:  00:DECF                      ; Out: A=0=>byte ready, FF=>end of file, 1 otherwise
     441:  00:DECF                      ;      Note: flags may not be set according to A!
     442:  00:DECF                      ;
     443:  00:DECF                      status:	
     444:  00:DECF                      		SOCKET_GET_BASE		; DE=socket base register
     444:  00:DECF  11 00 01          >    ld de,0100h
     444:  00:DED2  0F                >    rrca
     444:  00:DED3  CB 1B             >    rr e
     444:  00:DED5  0F                >    rrca
     444:  00:DED6  CB 1B             >    rr e
     444:  00:DED8  0F                >    rrca
     444:  00:DED9  CB 12             >    rl d
     445:  00:DEDB                      ;
     446:  00:DEDB                      		; First see if we have a byte buffered
     447:  00:DEDB                      		SOCKET_GET_VAR socket.vars.rx_inhand
     447:  00:DEDB                    >    if (var)=0
     447:  00:DEDB                    ~     ld a,e
     447:  00:DEDB                    ~    else
     447:  00:DEDB  3E 0A             >     ld a,(var)*2
     447:  00:DEDD  B3                >     or e
     447:  00:DEDE                    >    endif
     447:  00:DEDE  6F                >    ld l,a
     447:  00:DEDF  7A                >    ld a,d
     447:  00:DEE0  0F                >    rrca
     447:  00:DEE1  CB 1D             >    rr l
     447:  00:DEE3  26 F2             >    ld h,high vars.sockets
     448:  00:DEE5  7E                  		ld	a,(hl)		; FF=>buffered byte, 0=>none
     449:  00:DEE6  3C                  		inc	a
     450:  00:DEE7  C8                  		ret	z		; Return with A=0 if byte buffered
     451:  00:DEE8                      ;
     452:  00:DEE8                      		SOCKET_GET_VAR socket.vars.rx_size
     452:  00:DEE8                    >    if (var)=0
     452:  00:DEE8                    ~     ld a,e
     452:  00:DEE8                    ~    else
     452:  00:DEE8  3E 06             >     ld a,(var)*2
     452:  00:DEEA  B3                >     or e
     452:  00:DEEB                    >    endif
     452:  00:DEEB  6F                >    ld l,a
     452:  00:DEEC  7A                >    ld a,d
     452:  00:DEED  0F                >    rrca
     452:  00:DEEE  CB 1D             >    rr l
     452:  00:DEF0  26 F2             >    ld h,high vars.sockets
     453:  00:DEF2  7E                  		ld	a,(hl)		; See if any packet read started
     454:  00:DEF3  23                  		inc	hl
     455:  00:DEF4  B6                  		or	(hl)
     456:  00:DEF5  CC 82 D8            		call	z,socket._available; Or any packet waiting
     457:  00:DEF8  3E 00               		ld	a,0
     458:  00:DEFA  C0                  		ret	nz		; Return with A=0 if yes
     459:  00:DEFB                      ;
     460:  00:DEFB  CD 96 D8            		call	socket._is_closed
     461:  00:DEFE  3E FF               		ld	a,0ffh
     462:  00:DF00  C8                  		ret	z		; FF=>EOF if socket closed (or closing)
     463:  00:DF01                      ;
     464:  00:DF01  3E 01               		ld	a,1
     465:  00:DF03  C9                  		ret
     466:  00:DF04                      ;
     467:  00:DF04                      ;
     468:  00:DF04                      ;------------------------------------------------------------------------------
     469:  00:DF04                      ; keepalive
     470:  00:DF04                      ;
     471:  00:DF04                      ; Sets the Keep Alive timer so the session does not time out
     472:  00:DF04                      ;
     473:  00:DF04                      ;keepalive:	SOCKET_GET_BASE		; DE=socket base register
     474:  00:DF04                      ;
     475:  00:DF04                      ;		ld	a,w5300.Sn_PORTOR	; Timer is in Port Options Reg
     476:  00:DF04                      ;		ld	hl,(60/5)*256+0	; H=1 min, L=0 not used in TCP mode
     477:  00:DF04                      ;		jp	socket.write_reg
     478:  00:DF04                      ;
     479:  00:DF04                      ;
     480:  00:DF04                      ;------------------------------------------------------------------------------
     481:  00:DF04                      ; send
     482:  00:DF04                      ;
     483:  00:DF04                      ; Sends data that has already been written to the tx FIFO.
     484:  00:DF04                      ;
     485:  00:DF04                      ; In:  A=socket number
     486:  00:DF04                      ;
     487:  00:DF04                      send:		SOCKET_GET_BASE
     487:  00:DF04  11 00 01          >    ld de,0100h
     487:  00:DF07  0F                >    rrca
     487:  00:DF08  CB 1B             >    rr e
     487:  00:DF0A  0F                >    rrca
     487:  00:DF0B  CB 1B             >    rr e
     487:  00:DF0D  0F                >    rrca
     487:  00:DF0E  CB 12             >    rl d
     488:  00:DF10                      _send:
     489:  00:DF10  FD CB 00 4E         		bit	vars.trace.socket,(iy+vars._trace)
     490:  00:DF14  CA 14 DA            		jp	z,socket._send
     491:  00:DF17                      ;
     492:  00:DF17  CD F1 DB            		call	socket._trace
     493:  00:DF1A                      ;
     494:  00:DF1A  D5                  		push	de
     495:  00:DF1B  11 F2 D1            		 ld	de,trace.tcp.tx
     496:  00:DF1E  CD 3D CE            		 call	io.str
     497:  00:DF21  D1                  		pop	de
     498:  00:DF22                      ;
     499:  00:DF22  D5                  		push	de
     500:  00:DF23  3E 07               		 ld	a,socket.vars.tx_size
     501:  00:DF25  CD BF DB            		 call	socket.get_word
     502:  00:DF28  CD 30 D0            		 call	trace.bytes
     503:  00:DF2B  CD 3C D0            		 call	trace.dots
     504:  00:DF2E  D1                  		pop	de
     505:  00:DF2F                      ;
     506:  00:DF2F  C3 14 DA            		jp	socket._send	; Do the send
     507:  00:DF32                      ;
     508:  00:DF32                      ;
     509:  00:DF32                      ;------------------------------------------------------------------------------
     510:  00:DF32                      ; connect
     511:  00:DF32                      ;
     512:  00:DF32                      ; Attempts to open a socket in client TCP mode ie attempts to open a TCP/IP
     513:  00:DF32                      ; link with a remote server
     514:  00:DF32                      ;
     515:  00:DF32                      ; In:   A=socket number
     516:  00:DF32                      ; Out: NC=>no error
     517:  00:DF32  CD F0 D7            connect:	call	socket.connect	; Attempt t connect
     518:  00:DF35  D8                  		ret	c		; Error occured
     519:  00:DF36                      ;
     520:  00:DF36                      		SOCKET_GET_VAR socket.vars.tcp_connected; HL->tcp.connected
     520:  00:DF36                    >    if (var)=0
     520:  00:DF36                    ~     ld a,e
     520:  00:DF36                    ~    else
     520:  00:DF36  3E 04             >     ld a,(var)*2
     520:  00:DF38  B3                >     or e
     520:  00:DF39                    >    endif
     520:  00:DF39  6F                >    ld l,a
     520:  00:DF3A  7A                >    ld a,d
     520:  00:DF3B  0F                >    rrca
     520:  00:DF3C  CB 1D             >    rr l
     520:  00:DF3E  26 F2             >    ld h,high vars.sockets
     521:  00:DF40  36 FF               		ld	(hl),0ffh	; NZ=>we are connected
     522:  00:DF42  B7                  		or	a		; NC=>no error
     523:  00:DF43  C9                  		ret
     524:  00:DF44                      ;
     525:  00:DF44                      ;
     526:  00:DF44                      ;------------------------------------------------------------------------------
     527:  00:DF44                      ; disconnect
     528:  00:DF44                      ;
     529:  00:DF44                      ; Attempts to disconnect a TCP/IP link.
     530:  00:DF44                      ;
     531:  00:DF44                      ; In:  A=socket number
     532:  00:DF44                      ; Out: NC=>no error
     533:  00:DF44                      ;
     534:  00:DF44                      disconnect:	SOCKET_GET_BASE
     534:  00:DF44  11 00 01          >    ld de,0100h
     534:  00:DF47  0F                >    rrca
     534:  00:DF48  CB 1B             >    rr e
     534:  00:DF4A  0F                >    rrca
     534:  00:DF4B  CB 1B             >    rr e
     534:  00:DF4D  0F                >    rrca
     534:  00:DF4E  CB 12             >    rl d
     535:  00:DF50                      _disconnect:
     536:  00:DF50  CD 62 DF            		call	.readall	; Make we have a rx window<>0
     537:  00:DF53                      ;
     538:  00:DF53                      		SOCKET_GET_VAR socket.vars.tcp_connected
     538:  00:DF53                    >    if (var)=0
     538:  00:DF53                    ~     ld a,e
     538:  00:DF53                    ~    else
     538:  00:DF53  3E 04             >     ld a,(var)*2
     538:  00:DF55  B3                >     or e
     538:  00:DF56                    >    endif
     538:  00:DF56  6F                >    ld l,a
     538:  00:DF57  7A                >    ld a,d
     538:  00:DF58  0F                >    rrca
     538:  00:DF59  CB 1D             >    rr l
     538:  00:DF5B  26 F2             >    ld h,high vars.sockets
     539:  00:DF5D  36 00               		ld	(hl),0		; 0=>not connected any more
     540:  00:DF5F                      ;
     541:  00:DF5F  CD 36 D8            		call	socket._disconnect	; Send disconnect
     542:  00:DF62                      ;
     543:  00:DF62  3E 03               .readall:	ld	a,socket.vars.rx_size
     544:  00:DF64  CD BF DB            		call	socket.get_word	; HL=no. bytes left to read
     545:  00:DF67  7C                  		ld	a,h
     546:  00:DF68  B5                  		or	l		; See if we've started a read
     547:  00:DF69  C4 80 D9            		call	nz,socket._read_end	; Flush & finish if yes
     548:  00:DF6C                      ;
     549:  00:DF6C  CD 35 DD            		call	_header		; See if more packets waiting
     550:  00:DF6F  20 F1               		jr	nz,.readall	; Read them if yes
     551:  00:DF71                      ;
     552:  00:DF71  B7                  		or	a		; No error
     553:  00:DF72  C9                  		ret
     554:  00:DF73                      ;
     555:  00:DF73                      ;
     556:  00:DF73                      ;------------------------------------------------------------------------------
     557:  00:DF73                      ; close
     558:  00:DF73                      ;
     559:  00:DF73                      ; Closes the socket
     560:  00:DF73                      ;
     561:  00:DF73                      ; In:  A=socket number
     562:  00:DF73                      close:
     563:  00:DF73  F5                  		push	af
     564:  00:DF74                      		 SOCKET_GET_BASE
     564:  00:DF74  11 00 01          >    ld de,0100h
     564:  00:DF77  0F                >    rrca
     564:  00:DF78  CB 1B             >    rr e
     564:  00:DF7A  0F                >    rrca
     564:  00:DF7B  CB 1B             >    rr e
     564:  00:DF7D  0F                >    rrca
     564:  00:DF7E  CB 12             >    rl d
     565:  00:DF80                      ;
     566:  00:DF80                      		 ; If there's an odd byte waiting to be written it needs to
     567:  00:DF80                      		 ; be flushed, so we write a final dummy byte but decrement
     568:  00:DF80                      		 ; the byte count after so it doesn't actually get sent
     569:  00:DF80                      		 SOCKET_GET_VAR socket.vars.tx_inhand+1
     569:  00:DF80                    >    if (var)=0
     569:  00:DF80                    ~     ld a,e
     569:  00:DF80                    ~    else
     569:  00:DF80  3E 14             >     ld a,(var)*2
     569:  00:DF82  B3                >     or e
     569:  00:DF83                    >    endif
     569:  00:DF83  6F                >    ld l,a
     569:  00:DF84  7A                >    ld a,d
     569:  00:DF85  0F                >    rrca
     569:  00:DF86  CB 1D             >    rr l
     569:  00:DF88  26 F2             >    ld h,high vars.sockets
     570:  00:DF8A  7E                  		 ld	a,(hl)		; FF=>bufered byte
     571:  00:DF8B  3C                  		 inc	a
     572:  00:DF8C  20 19               		 jr	nz,.doneinhand
     573:  00:DF8E                      ;
     574:  00:DF8E  77                  		 ld	(hl),a		; Final dummy byte, 0 =>nothing inhand
     575:  00:DF8F  2B                  		 dec	hl		; Point to last user byte
     576:  00:DF90  01 02 00            		 ld	bc,2
     577:  00:DF93  CD 9C DE            		 call	_write_block	; Write final byte+dummy
     578:  00:DF96                      ;		
     579:  00:DF96                      		 SOCKET_GET_VAR socket.vars.tx_size
     579:  00:DF96                    >    if (var)=0
     579:  00:DF96                    ~     ld a,e
     579:  00:DF96                    ~    else
     579:  00:DF96  3E 0E             >     ld a,(var)*2
     579:  00:DF98  B3                >     or e
     579:  00:DF99                    >    endif
     579:  00:DF99  6F                >    ld l,a
     579:  00:DF9A  7A                >    ld a,d
     579:  00:DF9B  0F                >    rrca
     579:  00:DF9C  CB 1D             >    rr l
     579:  00:DF9E  26 F2             >    ld h,high vars.sockets
     580:  00:DFA0  7E                  		 ld	a,(hl)
     581:  00:DFA1  35                  		 dec	(hl)		; Dec tx_size so dummy isn't written
     582:  00:DFA2  B7                  		 or	a
     583:  00:DFA3  20 02               		 jr	nz,.doneinhand	; If LSB was 0 then must dec MSB
     584:  00:DFA5                      ;
     585:  00:DFA5  23                  		 inc	hl
     586:  00:DFA6  35                  		 dec	(hl)
     587:  00:DFA7                      .doneinhand:
     588:  00:DFA7                      		 ; Any odd byte at the end that was buffered in tx_inhand has
     589:  00:DFA7                      		 ; now been dealt with. Now need to actually send any bytes
     590:  00:DFA7                      		 ; that have been written to the WIZ chip but not yet sent
     591:  00:DFA7                      		 SOCKET_GET_VAR socket.vars.tx_size
     591:  00:DFA7                    >    if (var)=0
     591:  00:DFA7                    ~     ld a,e
     591:  00:DFA7                    ~    else
     591:  00:DFA7  3E 0E             >     ld a,(var)*2
     591:  00:DFA9  B3                >     or e
     591:  00:DFAA                    >    endif
     591:  00:DFAA  6F                >    ld l,a
     591:  00:DFAB  7A                >    ld a,d
     591:  00:DFAC  0F                >    rrca
     591:  00:DFAD  CB 1D             >    rr l
     591:  00:DFAF  26 F2             >    ld h,high vars.sockets
     592:  00:DFB1  7E                  		 ld	a,(hl)
     593:  00:DFB2  23                  		 inc	hl
     594:  00:DFB3  B6                  		 or	(hl)
     595:  00:DFB4  C4 10 DF            		 call	nz,_send	; Ignore errors 'cos we're closing
     596:  00:DFB7                      ;
     597:  00:DFB7                      		 SOCKET_GET_VAR socket.vars.tcp_connected; Currently connected?
     597:  00:DFB7                    >    if (var)=0
     597:  00:DFB7                    ~     ld a,e
     597:  00:DFB7                    ~    else
     597:  00:DFB7  3E 04             >     ld a,(var)*2
     597:  00:DFB9  B3                >     or e
     597:  00:DFBA                    >    endif
     597:  00:DFBA  6F                >    ld l,a
     597:  00:DFBB  7A                >    ld a,d
     597:  00:DFBC  0F                >    rrca
     597:  00:DFBD  CB 1D             >    rr l
     597:  00:DFBF  26 F2             >    ld h,high vars.sockets
     598:  00:DFC1  7E                  		 ld	a,(hl)		; NZ=>connected
     599:  00:DFC2  B7                  		 or	a
     600:  00:DFC3  D5                  		 push	de
     601:  00:DFC4  C4 50 DF            		  call	nz,_disconnect	; Disconnect before closing if yes
     602:  00:DFC7  D1                  		 pop	de
     603:  00:DFC8  F1                  		pop	af
     604:  00:DFC9                      ;
     605:  00:DFC9  CD 72 DA            		call	socket.close
     606:  00:DFCC                      ;
     607:  00:DFCC  FD CB 00 4E         		bit	vars.trace.socket,(iy+vars._trace)
     608:  00:DFD0  C8                  		ret	z
     609:  00:DFD1                      ;
     610:  00:DFD1  C3 46 D0            		jp	trace.ok
     611:  00:DFD4                      ;
     612:  00:DFD4                      ;
     613:  00:DFD4                      		endmodule
     107.  00:DFD4                      	include dhcp.asm
       1:  00:DFD4                      ; DHCP
       2:  00:DFD4                      ;
       3:  00:DFD4                      ; Attempts to get IP address, subnet mask etc using the DHCP protocol.
       4:  00:DFD4                      ;
       5:  00:DFD4                      ;
       6:  00:DFD4                      		module	dhcp
       7:  00:DFD4                      ;
       8:  00:DFD4                      ;==============================================================================
       9:  00:DFD4                      ;
      10:  00:DFD4                      ; This file is part of the EPNET software
      11:  00:DFD4                      ;
      12:  00:DFD4                      ; Copyright (C) 2015  Bruce Tanner
      13:  00:DFD4                      ;
      14:  00:DFD4                      ;    This program is free software: you can redistribute it and/or modify
      15:  00:DFD4                      ;    it under the terms of the GNU General Public License as published by
      16:  00:DFD4                      ;    the Free Software Foundation, either version 3 of the License, or
      17:  00:DFD4                      ;    (at your option) any later version.
      18:  00:DFD4                      ;
      19:  00:DFD4                      ;    This program is distributed in the hope that it will be useful,
      20:  00:DFD4                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      21:  00:DFD4                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      22:  00:DFD4                      ;    GNU General Public License for more details.
      23:  00:DFD4                      ;
      24:  00:DFD4                      ;    You should have received a copy of the GNU General Public License
      25:  00:DFD4                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      26:  00:DFD4                      ;
      27:  00:DFD4                      ; If you do use or modify this file, either for its original purpose or for
      28:  00:DFD4                      ; something new, I'd love to hear about it! I can be contacted by email at:
      29:  00:DFD4                      ;
      30:  00:DFD4                      ; brucetanner@btopenworld.com
      31:  00:DFD4                      ;
      32:  00:DFD4                      ;==============================================================================
      33:  00:DFD4                      ;
      34:  00:DFD4                      ; For reference, this is the format of a DHCP packet (from RFC 2131):
      35:  00:DFD4                      ;
      36:  00:DFD4                      ;   0                   1                   2                   3
      37:  00:DFD4                      ;   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      38:  00:DFD4                      ;   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      39:  00:DFD4                      ;   |     op (1)    |   htype (1)   |   hlen (1)    |   hops (1)    |
      40:  00:DFD4                      ;   +---------------+---------------+---------------+---------------+
      41:  00:DFD4                      ;   |                            xid (4)                            |
      42:  00:DFD4                      ;   +-------------------------------+-------------------------------+
      43:  00:DFD4                      ;   |           secs (2)            |           flags (2)           |
      44:  00:DFD4                      ;   +-------------------------------+-------------------------------+
      45:  00:DFD4                      ;   |                          ciaddr  (4)                          |
      46:  00:DFD4                      ;   +---------------------------------------------------------------+
      47:  00:DFD4                      ;   |                          yiaddr  (4)                          |
      48:  00:DFD4                      ;   +---------------------------------------------------------------+
      49:  00:DFD4                      ;   |                          siaddr  (4)                          |
      50:  00:DFD4                      ;   +---------------------------------------------------------------+
      51:  00:DFD4                      ;   |                          giaddr  (4)                          |
      52:  00:DFD4                      ;   +---------------------------------------------------------------+
      53:  00:DFD4                      ;   |                          chaddr  (16)                         |
      54:  00:DFD4                      ;   +---------------------------------------------------------------+
      55:  00:DFD4                      ;   |                          sname   (64)                         |
      56:  00:DFD4                      ;   +---------------------------------------------------------------+
      57:  00:DFD4                      ;   |                          file    (128)                        |
      58:  00:DFD4                      ;   +---------------------------------------------------------------+
      59:  00:DFD4                      ;   |                          options (variable)                   |
      60:  00:DFD4                      ;   +---------------------------------------------------------------+
      61:  00:DFD4                      ;
      62:  00:DFD4                      ;   FIELD      OCTETS       DESCRIPTION
      63:  00:DFD4                      ;   -----      ------       -----------
      64:  00:DFD4                      ;
      65:  00:DFD4                      ;   op            1  Message op code / message type.
      66:  00:DFD4                      ;                    1 = BOOTREQUEST, 2 = BOOTREPLY
      67:  00:DFD4                      ;   htype         1  Hardware address type, see ARP section in "Assigned
      68:  00:DFD4                      ;                    Numbers" RFC; e.g., '1' = 10mb ethernet.
      69:  00:DFD4                      ;   hlen          1  Hardware address length (e.g.  '6' for 10mb
      70:  00:DFD4                      ;                    ethernet).
      71:  00:DFD4                      ;   hops          1  Client sets to zero, optionally used by relay agents
      72:  00:DFD4                      ;                    when booting via a relay agent.
      73:  00:DFD4                      ;   xid           4  Transaction ID, a random number chosen by the
      74:  00:DFD4                      ;                    client, used by the client and server to associate
      75:  00:DFD4                      ;                    messages and responses between a client and a
      76:  00:DFD4                      ;                    server.
      77:  00:DFD4                      ;   secs          2  Filled in by client, seconds elapsed since client
      78:  00:DFD4                      ;                    began address acquisition or renewal process.
      79:  00:DFD4                      ;   flags         2  Flags (see figure 2).
      80:  00:DFD4                      ;   ciaddr        4  Client IP address; only filled in if client is in
      81:  00:DFD4                      ;                    BOUND, RENEW or REBINDING state and can respond
      82:  00:DFD4                      ;                    to ARP requests.
      83:  00:DFD4                      ;   yiaddr        4  'your' (client) IP address.
      84:  00:DFD4                      ;   siaddr        4  IP address of next server to use in bootstrap;
      85:  00:DFD4                      ;                    returned in DHCPOFFER, DHCPACK by server.
      86:  00:DFD4                      ;   giaddr        4  Relay agent IP address, used in booting via a
      87:  00:DFD4                      ;                    relay agent.
      88:  00:DFD4                      ;   chaddr       16  Client hardware address.
      89:  00:DFD4                      ;   sname        64  Optional server host name, null terminated string.
      90:  00:DFD4                      ;   file        128  Boot file name, null terminated string; "generic"
      91:  00:DFD4                      ;                    name or null in DHCPDISCOVER, fully qualified
      92:  00:DFD4                      ;                    directory-path name in DHCPOFFER.
      93:  00:DFD4                      ;   options     var  Optional parameters field.  See the options
      94:  00:DFD4                      ;                    documents for a list of defined options.
      95:  00:DFD4                      ;
      96:  00:DFD4  (00:0001)           DHCP_OP.BOOTREQUEST	equ	1
      97:  00:DFD4  (00:0002)           DHCP_OP.BOOTREPLY	equ	2
      98:  00:DFD4                      ;
      99:  00:DFD4  (00:0001)           DHCP_HTYPE.10MB		equ	1
     100:  00:DFD4  (00:0002)           DHCP_HTYPE.100MB	equ	2
     101:  00:DFD4                      ;
     102:  00:DFD4  (00:0006)           DHCP_HLEN.ETHERNET	equ	6
     103:  00:DFD4  (00:0000)           DHCP.HOPS		equ	0
     104:  00:DFD4  (00:8000)           DHCP_FLAGS.BROADCAST	equ	8000h
     105:  00:DFD4                      ;
     106:  00:DFD4                      ;
     107:  00:DFD4                      ; The "options" field is variable length and consists of zero or more options
     108:  00:DFD4                      ; (from RFC 2132, options we don't use omitted):
     109:  00:DFD4                      ;
     110:  00:DFD4                      ; 3.1. Pad Option
     111:  00:DFD4                      ;
     112:  00:DFD4                      ; The pad option can be used to cause subsequent fields to align on
     113:  00:DFD4                      ; word boundaries.
     114:  00:DFD4                      ;
     115:  00:DFD4                      ;   The code for the pad option is 0, and its length is 1 octet.
     116:  00:DFD4                      ;
     117:  00:DFD4                      ;    Code
     118:  00:DFD4                      ;   +-----+
     119:  00:DFD4                      ;   |  0  |
     120:  00:DFD4                      ;   +-----+
     121:  00:DFD4                      ;
     122:  00:DFD4  (00:0000)           DHCP_OPT.PAD		equ	0
     123:  00:DFD4                      ;
     124:  00:DFD4                      ;
     125:  00:DFD4                      ; 3.2. End Option
     126:  00:DFD4                      ;
     127:  00:DFD4                      ;   The end option marks the end of valid information in the vendor
     128:  00:DFD4                      ;   field.  Subsequent octets should be filled with pad options.
     129:  00:DFD4                      ;
     130:  00:DFD4                      ;   The code for the end option is 255, and its length is 1 octet.
     131:  00:DFD4                      ;
     132:  00:DFD4                      ;    Code
     133:  00:DFD4                      ;   +-----+
     134:  00:DFD4                      ;   | 255 |
     135:  00:DFD4                      ;   +-----+
     136:  00:DFD4                      ;
     137:  00:DFD4  (00:00FF)           DHCP_OPT.END		equ	255
     138:  00:DFD4                      ;
     139:  00:DFD4                      ;
     140:  00:DFD4                      ; 3.3. Subnet Mask
     141:  00:DFD4                      ;
     142:  00:DFD4                      ;   The subnet mask option specifies the client's subnet mask as per RFC
     143:  00:DFD4                      ;   950 [5].
     144:  00:DFD4                      ;
     145:  00:DFD4                      ;   If both the subnet mask and the router option are specified in a DHCP
     146:  00:DFD4                      ;   reply, the subnet mask option MUST be first.
     147:  00:DFD4                      ;
     148:  00:DFD4                      ;   The code for the subnet mask option is 1, and its length is 4 octets.
     149:  00:DFD4                      ;
     150:  00:DFD4                      ;    Code   Len        Subnet Mask
     151:  00:DFD4                      ;   +-----+-----+-----+-----+-----+-----+
     152:  00:DFD4                      ;   |  1  |  4  |  m1 |  m2 |  m3 |  m4 |
     153:  00:DFD4                      ;   +-----+-----+-----+-----+-----+-----+
     154:  00:DFD4                      ;
     155:  00:DFD4  (00:0001)           DHCP_OPT.SUBNET		equ	1
     156:  00:DFD4                      ;
     157:  00:DFD4                      ;
     158:  00:DFD4                      ; 3.4. Time Offset
     159:  00:DFD4                      ;
     160:  00:DFD4                      ;   The time offset field specifies the offset of the client's subnet in
     161:  00:DFD4                      ;   seconds from Coordinated Universal Time (UTC).  The offset is
     162:  00:DFD4                      ;   expressed as a two's complement 32-bit integer.  A positive offset
     163:  00:DFD4                      ;   indicates a location east of the zero meridian and a negative offset
     164:  00:DFD4                      ;   indicates a location west of the zero meridian.
     165:  00:DFD4                      ;
     166:  00:DFD4                      ;   The code for the time offset option is 2, and its length is 4 octets.
     167:  00:DFD4                      ;
     168:  00:DFD4                      ;    Code   Len        Time Offset
     169:  00:DFD4                      ;   +-----+-----+-----+-----+-----+-----+
     170:  00:DFD4                      ;   |  2  |  4  |  n1 |  n2 |  n3 |  n4 |
     171:  00:DFD4                      ;   +-----+-----+-----+-----+-----+-----+
     172:  00:DFD4                      ;
     173:  00:DFD4                      ; 3.5. Router Option
     174:  00:DFD4                      ;
     175:  00:DFD4                      ;   The router option specifies a list of IP addresses for routers on the
     176:  00:DFD4                      ;   client's subnet.  Routers SHOULD be listed in order of preference.
     177:  00:DFD4                      ;
     178:  00:DFD4                      ;   The code for the router option is 3.  The minimum length for the
     179:  00:DFD4                      ;   router option is 4 octets, and the length MUST always be a multiple
     180:  00:DFD4                      ;   of 4.
     181:  00:DFD4                      ;
     182:  00:DFD4                      ;    Code   Len         Address 1               Address 2
     183:  00:DFD4                      ;   +-----+-----+-----+-----+-----+-----+-----+-----+--
     184:  00:DFD4                      ;   |  3  |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
     185:  00:DFD4                      ;   +-----+-----+-----+-----+-----+-----+-----+-----+--
     186:  00:DFD4                      ;
     187:  00:DFD4  (00:0003)           DHCP_OPT.ROUTER		equ	3
     188:  00:DFD4                      ;
     189:  00:DFD4                      ;
     190:  00:DFD4                      ; 3.6. Time Server Option
     191:  00:DFD4                      ;
     192:  00:DFD4                      ;   The time server option specifies a list of RFC 868 [6] time servers
     193:  00:DFD4                      ;   available to the client.  Servers SHOULD be listed in order of
     194:  00:DFD4                      ;   preference.
     195:  00:DFD4                      ;
     196:  00:DFD4                      ;   The code for the time server option is 4.  The minimum length for
     197:  00:DFD4                      ;   this option is 4 octets, and the length MUST always be a multiple of
     198:  00:DFD4                      ;   4.
     199:  00:DFD4                      ;
     200:  00:DFD4                      ;    Code   Len         Address 1               Address 2
     201:  00:DFD4                      ;   +-----+-----+-----+-----+-----+-----+-----+-----+--
     202:  00:DFD4                      ;   |  4  |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
     203:  00:DFD4                      ;   +-----+-----+-----+-----+-----+-----+-----+-----+--
     204:  00:DFD4                      ;
     205:  00:DFD4                      ;
     206:  00:DFD4                      ; 3.7. Name Server Option
     207:  00:DFD4                      ;
     208:  00:DFD4                      ;   The name server option specifies a list of IEN 116 [7] name servers
     209:  00:DFD4                      ;   available to the client.  Servers SHOULD be listed in order of
     210:  00:DFD4                      ;   preference.
     211:  00:DFD4                      ;
     212:  00:DFD4                      ;   The code for the name server option is 5.  The minimum length for
     213:  00:DFD4                      ;   this option is 4 octets, and the length MUST always be a multiple of
     214:  00:DFD4                      ;   4.
     215:  00:DFD4                      ;
     216:  00:DFD4                      ;    Code   Len         Address 1               Address 2
     217:  00:DFD4                      ;   +-----+-----+-----+-----+-----+-----+-----+-----+--
     218:  00:DFD4                      ;   |  5  |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
     219:  00:DFD4                      ;   +-----+-----+-----+-----+-----+-----+-----+-----+--
     220:  00:DFD4                      ;
     221:  00:DFD4                      ;
     222:  00:DFD4                      ; 3.8. Domain Name Server Option
     223:  00:DFD4                      ;
     224:  00:DFD4                      ;   The domain name server option specifies a list of Domain Name System
     225:  00:DFD4                      ;   (STD 13, RFC 1035 [8]) name servers available to the client.  Servers
     226:  00:DFD4                      ;   SHOULD be listed in order of preference.
     227:  00:DFD4                      ;
     228:  00:DFD4                      ;   The code for the domain name server option is 6.  The minimum length
     229:  00:DFD4                      ;   for this option is 4 octets, and the length MUST always be a multiple
     230:  00:DFD4                      ;   of 4.
     231:  00:DFD4                      ;
     232:  00:DFD4                      ;    Code   Len         Address 1               Address 2
     233:  00:DFD4                      ;   +-----+-----+-----+-----+-----+-----+-----+-----+--
     234:  00:DFD4                      ;   |  6  |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
     235:  00:DFD4                      ;   +-----+-----+-----+-----+-----+-----+-----+-----+--
     236:  00:DFD4                      ;
     237:  00:DFD4  (00:0006)           DHCP_OPT.DNS		equ	6
     238:  00:DFD4                      ;
     239:  00:DFD4                      ;
     240:  00:DFD4                      ; 3.14. Host Name Option
     241:  00:DFD4                      ;
     242:  00:DFD4                      ;   This option specifies the name of the client.  The name may or may
     243:  00:DFD4                      ;   not be qualified with the local domain name (see section 3.17 for the
     244:  00:DFD4                      ;   preferred way to retrieve the domain name).  See RFC 1035 for
     245:  00:DFD4                      ;   character set restrictions.
     246:  00:DFD4                      ;
     247:  00:DFD4                      ;   The code for this option is 12, and its minimum length is 1.
     248:  00:DFD4                      ;
     249:  00:DFD4                      ;    Code   Len                 Host Name
     250:  00:DFD4                      ;   +-----+-----+-----+-----+-----+-----+-----+-----+--
     251:  00:DFD4                      ;   |  12 |  n  |  h1 |  h2 |  h3 |  h4 |  h5 |  h6 |  ...
     252:  00:DFD4                      ;   +-----+-----+-----+-----+-----+-----+-----+-----+--
     253:  00:DFD4                      ;
     254:  00:DFD4  (00:000C)           DHCP_OPT.HOST		equ	12
     255:  00:DFD4                      ;
     256:  00:DFD4                      ;
     257:  00:DFD4                      ; 3.17. Domain Name
     258:  00:DFD4                      ;
     259:  00:DFD4                      ;   This option specifies the domain name that client should use when
     260:  00:DFD4                      ;   resolving hostnames via the Domain Name System.
     261:  00:DFD4                      ;
     262:  00:DFD4                      ;   The code for this option is 15.  Its minimum length is 1.
     263:  00:DFD4                      ;
     264:  00:DFD4                      ;    Code   Len        Domain Name
     265:  00:DFD4                      ;   +-----+-----+-----+-----+-----+-----+--
     266:  00:DFD4                      ;   |  15 |  n  |  d1 |  d2 |  d3 |  d4 |  ...
     267:  00:DFD4                      ;   +-----+-----+-----+-----+-----+-----+--
     268:  00:DFD4                      ;
     269:  00:DFD4  (00:000F)           DHCP_OPT.DOMAIN		equ	15
     270:  00:DFD4                      ;
     271:  00:DFD4                      ;
     272:  00:DFD4                      ; 8.3. Network Time Protocol Servers Option
     273:  00:DFD4                      ;
     274:  00:DFD4                      ;   This option specifies a list of IP addresses indicating NTP [18]
     275:  00:DFD4                      ;   servers available to the client.  Servers SHOULD be listed in order
     276:  00:DFD4                      ;   of preference.
     277:  00:DFD4                      ;
     278:  00:DFD4                      ;   The code for this option is 42.  Its minimum length is 4, and the
     279:  00:DFD4                      ;   length MUST be a multiple of 4.
     280:  00:DFD4                      ;
     281:  00:DFD4                      ;    Code   Len         Address 1               Address 2
     282:  00:DFD4                      ;   +-----+-----+-----+-----+-----+-----+-----+-----+--
     283:  00:DFD4                      ;   |  42 |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
     284:  00:DFD4                      ;   +-----+-----+-----+-----+-----+-----+-----+-----+--
     285:  00:DFD4                      ;
     286:  00:DFD4  (00:002A)           DHCP_OPT.NTP		equ	42
     287:  00:DFD4                      ;
     288:  00:DFD4                      ;
     289:  00:DFD4                      ; 9.1. Requested IP Address
     290:  00:DFD4                      ;
     291:  00:DFD4                      ;   This option is used in a client request (DHCPDISCOVER) to allow the
     292:  00:DFD4                      ;   client to request that a particular IP address be assigned.
     293:  00:DFD4                      ;
     294:  00:DFD4                      ;   The code for this option is 50, and its length is 4.
     295:  00:DFD4                      ;
     296:  00:DFD4                      ;    Code   Len          Address
     297:  00:DFD4                      ;   +-----+-----+-----+-----+-----+-----+
     298:  00:DFD4                      ;   |  50 |  4  |  a1 |  a2 |  a3 |  a4 |
     299:  00:DFD4                      ;   +-----+-----+-----+-----+-----+-----+
     300:  00:DFD4                      ;
     301:  00:DFD4  (00:0032)           DHCP_OPT.IP		equ	50
     302:  00:DFD4                      ;
     303:  00:DFD4                      ;
     304:  00:DFD4                      ; 9.2. IP Address Lease Time
     305:  00:DFD4                      ;
     306:  00:DFD4                      ;   This option is used in a client request (DHCPDISCOVER or DHCPREQUEST)
     307:  00:DFD4                      ;   to allow the client to request a lease time for the IP address.  In a
     308:  00:DFD4                      ;   server reply (DHCPOFFER), a DHCP server uses this option to specify
     309:  00:DFD4                      ;   the lease time it is willing to offer.
     310:  00:DFD4                      ;
     311:  00:DFD4                      ;   The time is in units of seconds, and is specified as a 32-bit
     312:  00:DFD4                      ;   unsigned integer.
     313:  00:DFD4                      ;
     314:  00:DFD4                      ;   The code for this option is 51, and its length is 4.
     315:  00:DFD4                      ;
     316:  00:DFD4                      ;    Code   Len         Lease Time
     317:  00:DFD4                      ;   +-----+-----+-----+-----+-----+-----+
     318:  00:DFD4                      ;   |  51 |  4  |  t1 |  t2 |  t3 |  t4 |
     319:  00:DFD4                      ;   +-----+-----+-----+-----+-----+-----+
     320:  00:DFD4                      ;
     321:  00:DFD4  (00:0033)           DHCP_OPT.LEASE		equ	51
     322:  00:DFD4                      ;
     323:  00:DFD4                      ;
     324:  00:DFD4                      ; 9.6. DHCP Message Type
     325:  00:DFD4                      ;
     326:  00:DFD4                      ;   This option is used to convey the type of the DHCP message.  The code
     327:  00:DFD4                      ;   for this option is 53, and its length is 1.  Legal values for this
     328:  00:DFD4                      ;   option are:
     329:  00:DFD4                      ;
     330:  00:DFD4                      ;           Value   Message Type
     331:  00:DFD4                      ;           -----   ------------
     332:  00:DFD4                      ;             1     DHCPDISCOVER
     333:  00:DFD4                      ;             2     DHCPOFFER
     334:  00:DFD4                      ;             3     DHCPREQUEST
     335:  00:DFD4                      ;             4     DHCPDECLINE
     336:  00:DFD4                      ;             5     DHCPACK
     337:  00:DFD4                      ;             6     DHCPNAK
     338:  00:DFD4                      ;             7     DHCPRELEASE
     339:  00:DFD4                      ;             8     DHCPINFORM
     340:  00:DFD4                      ;
     341:  00:DFD4                      ;    Code   Len  Type
     342:  00:DFD4                      ;   +-----+-----+-----+
     343:  00:DFD4                      ;   |  53 |  1  | 1-9 |
     344:  00:DFD4                      ;   +-----+-----+-----+
     345:  00:DFD4                      ;
     346:  00:DFD4  (00:0035)           DHCP_OPT.TYPE		equ	53
     347:  00:DFD4                      ;
     348:  00:DFD4  (00:0001)           DHCP_TYPE.DISCOVER	equ	1
     349:  00:DFD4  (00:0002)           DHCP_TYPE.OFFER		equ	2
     350:  00:DFD4  (00:0003)           DHCP_TYPE.REQUEST	equ	3
     351:  00:DFD4  (00:0004)           DHCP_TYPE.DECLINE	equ	4
     352:  00:DFD4  (00:0005)           DHCP_TYPE.ACK		equ	5
     353:  00:DFD4  (00:0006)           DHCP_TYPE.NAK		equ	6
     354:  00:DFD4  (00:0007)           DHCP_TYPE.RELEASE	equ	7
     355:  00:DFD4  (00:0008)           DHCP_TYPE.INFORM	equ	8
     356:  00:DFD4                      ;
     357:  00:DFD4                      ;
     358:  00:DFD4                      ; 9.7. Server Identifier
     359:  00:DFD4                      ;
     360:  00:DFD4                      ;   This option is used in DHCPOFFER and DHCPREQUEST messages, and may
     361:  00:DFD4                      ;   optionally be included in the DHCPACK and DHCPNAK messages.  DHCP
     362:  00:DFD4                      ;   servers include this option in the DHCPOFFER in order to allow the
     363:  00:DFD4                      ;   client to distinguish between lease offers.  DHCP clients use the
     364:  00:DFD4                      ;   contents of the 'server identifier' field as the destination address
     365:  00:DFD4                      ;   for any DHCP messages unicast to the DHCP server.  DHCP clients also
     366:  00:DFD4                      ;   indicate which of several lease offers is being accepted by including
     367:  00:DFD4                      ;   this option in a DHCPREQUEST message.
     368:  00:DFD4                      ;
     369:  00:DFD4                      ;   The identifier is the IP address of the selected server.
     370:  00:DFD4                      ;
     371:  00:DFD4                      ;   The code for this option is 54, and its length is 4.
     372:  00:DFD4                      ;
     373:  00:DFD4                      ;    Code   Len            Address
     374:  00:DFD4                      ;   +-----+-----+-----+-----+-----+-----+
     375:  00:DFD4                      ;   |  54 |  4  |  a1 |  a2 |  a3 |  a4 |
     376:  00:DFD4                      ;   +-----+-----+-----+-----+-----+-----+
     377:  00:DFD4                      ;
     378:  00:DFD4  (00:0036)           DHCP_OPT.SERVER		equ	54
     379:  00:DFD4                      ;
     380:  00:DFD4                      ;
     381:  00:DFD4                      ; 9.8. Parameter Request List
     382:  00:DFD4                      ;
     383:  00:DFD4                      ;   This option is used by a DHCP client to request values for specified
     384:  00:DFD4                      ;   configuration parameters.  The list of requested parameters is
     385:  00:DFD4                      ;   specified as n octets, where each octet is a valid DHCP option code
     386:  00:DFD4                      ;   as defined in this document.
     387:  00:DFD4                      ;
     388:  00:DFD4                      ;   The client MAY list the options in order of preference.  The DHCP
     389:  00:DFD4                      ;   server is not required to return the options in the requested order,
     390:  00:DFD4                      ;   but MUST try to insert the requested options in the order requested
     391:  00:DFD4                      ;   by the client.
     392:  00:DFD4                      ;
     393:  00:DFD4                      ;   The code for this option is 55.  Its minimum length is 1.
     394:  00:DFD4                      ;
     395:  00:DFD4                      ;    Code   Len   Option Codes
     396:  00:DFD4                      ;   +-----+-----+-----+-----+---
     397:  00:DFD4                      ;   |  55 |  n  |  c1 |  c2 | ...
     398:  00:DFD4                      ;   +-----+-----+-----+-----+---
     399:  00:DFD4                      ;
     400:  00:DFD4  (00:0037)           DHCP_OPT.PARAM		equ	55
     401:  00:DFD4                      ;
     402:  00:DFD4                      ;
     403:  00:DFD4                      ; 9.9. Message
     404:  00:DFD4                      ;
     405:  00:DFD4                      ;   This option is used by a DHCP server to provide an error message to a
     406:  00:DFD4                      ;   DHCP client in a DHCPNAK message in the event of a failure. A client
     407:  00:DFD4                      ;   may use this option in a DHCPDECLINE message to indicate the why the
     408:  00:DFD4                      ;   client declined the offered parameters.  The message consists of n
     409:  00:DFD4                      ;   octets of NVT ASCII text, which the client may display on an
     410:  00:DFD4                      ;   available output device.
     411:  00:DFD4                      ;
     412:  00:DFD4                      ;   The code for this option is 56 and its minimum length is 1.
     413:  00:DFD4                      ;
     414:  00:DFD4                      ;    Code   Len     Text
     415:  00:DFD4                      ;   +-----+-----+-----+-----+---
     416:  00:DFD4                      ;   |  56 |  n  |  c1 |  c2 | ...
     417:  00:DFD4                      ;   +-----+-----+-----+-----+---
     418:  00:DFD4                      ;
     419:  00:DFD4                      ;
     420:  00:DFD4                      ; 9.11. Renewal (T1) Time Value
     421:  00:DFD4                      ;
     422:  00:DFD4                      ;   This option specifies the time interval from address assignment until
     423:  00:DFD4                      ;   the client transitions to the RENEWING state.
     424:  00:DFD4                      ;
     425:  00:DFD4                      ;   The value is in units of seconds, and is specified as a 32-bit
     426:  00:DFD4                      ;   unsigned integer.
     427:  00:DFD4                      ;
     428:  00:DFD4                      ;   The code for this option is 58, and its length is 4.
     429:  00:DFD4                      ;
     430:  00:DFD4                      ;    Code   Len         T1 Interval
     431:  00:DFD4                      ;   +-----+-----+-----+-----+-----+-----+
     432:  00:DFD4                      ;   |  58 |  4  |  t1 |  t2 |  t3 |  t4 |
     433:  00:DFD4                      ;   +-----+-----+-----+-----+-----+-----+
     434:  00:DFD4                      ;
     435:  00:DFD4  (00:003A)           DHCP_OPT.T1		equ	58
     436:  00:DFD4                      ;
     437:  00:DFD4                      ;
     438:  00:DFD4                      ; 9.12. Rebinding (T2) Time Value
     439:  00:DFD4                      ;
     440:  00:DFD4                      ;   This option specifies the time interval from address assignment until
     441:  00:DFD4                      ;   the client transitions to the REBINDING state.
     442:  00:DFD4                      ;
     443:  00:DFD4                      ;   The value is in units of seconds, and is specified as a 32-bit
     444:  00:DFD4                      ;   unsigned integer.
     445:  00:DFD4                      ;
     446:  00:DFD4                      ;   The code for this option is 59, and its length is 4.
     447:  00:DFD4                      ;
     448:  00:DFD4                      ;    Code   Len         T2 Interval
     449:  00:DFD4                      ;   +-----+-----+-----+-----+-----+-----+
     450:  00:DFD4                      ;   |  59 |  4  |  t1 |  t2 |  t3 |  t4 |
     451:  00:DFD4                      ;   +-----+-----+-----+-----+-----+-----+
     452:  00:DFD4                      ;
     453:  00:DFD4  (00:003B)           DHCP_OPT.T2		equ	59
     454:  00:DFD4                      ;
     455:  00:DFD4                      ;
     456:  00:DFD4                      ; 9.14. Client-identifier
     457:  00:DFD4                      ;
     458:  00:DFD4                      ;   This option is used by DHCP clients to specify their unique
     459:  00:DFD4                      ;   identifier.  DHCP servers use this value to index their database of
     460:  00:DFD4                      ;   address bindings.  This value is expected to be unique for all
     461:  00:DFD4                      ;   clients in an administrative domain.
     462:  00:DFD4                      ;
     463:  00:DFD4                      ;   Identifiers SHOULD be treated as opaque objects by DHCP servers.
     464:  00:DFD4                      ;
     465:  00:DFD4                      ;   The client identifier MAY consist of type-value pairs similar to the
     466:  00:DFD4                      ;   'htype'/'chaddr' fields defined in [3]. For instance, it MAY consist
     467:  00:DFD4                      ;   of a hardware type and hardware address. In this case the type field
     468:  00:DFD4                      ;   SHOULD be one of the ARP hardware types defined in STD2 [22].  A
     469:  00:DFD4                      ;   hardware type of 0 (zero) should be used when the value field
     470:  00:DFD4                      ;   contains an identifier other than a hardware address (e.g. a fully
     471:  00:DFD4                      ;   qualified domain name).
     472:  00:DFD4                      ;
     473:  00:DFD4                      ;   For correct identification of clients, each client's client-
     474:  00:DFD4                      ;   identifier MUST be unique among the client-identifiers used on the
     475:  00:DFD4                      ;   subnet to which the client is attached.  Vendors and system
     476:  00:DFD4                      ;   administrators are responsible for choosing client-identifiers that
     477:  00:DFD4                      ;   meet this requirement for uniqueness.
     478:  00:DFD4                      ;
     479:  00:DFD4                      ;   The code for this option is 61, and its minimum length is 2.
     480:  00:DFD4                      ;
     481:  00:DFD4                      ;   Code   Len   Type  Client-Identifier
     482:  00:DFD4                      ;   +-----+-----+-----+-----+-----+---
     483:  00:DFD4                      ;   |  61 |  n  |  t1 |  i1 |  i2 | ...
     484:  00:DFD4                      ;   +-----+-----+-----+-----+-----+---
     485:  00:DFD4                      ;
     486:  00:DFD4  (00:003D)           DHCP_OPT.CLIENT		equ	61
     487:  00:DFD4                      ;
     488:  00:DFD4                      ;==============================================================================
     489:  00:DFD4                      ;
     490:  00:DFD4  (00:0043)           DHCP_SERVER_PORT	equ	67	; Standard fixed port numbers used
     491:  00:DFD4  (00:0044)           DHCP_CLIENT_PORT	equ	68	;   for DHCP
     492:  00:DFD4                      ;
     493:  00:DFD4                      ;
     494:  00:DFD4                      ;
     495:  00:DFD4                      ; init
     496:  00:DFD4                      ;
     497:  00:DFD4                      ; Starts the whole DHCP process. If we have not yet been initialized, we do
     498:  00:DFD4                      ; the DHCP process. If we have been initialized, we check whether the lease
     499:  00:DFD4                      ; time has expired.
     500:  00:DFD4                      ;
     501:  00:DFD4                      ; Out: NC=>ok
     502:  00:DFD4                      init:
     503:  00:DFD4  FD CB 03 4E         		bit	vars.init.dhcp,(iy+vars._init)	; Initialized?
     504:  00:DFD8  28 11               		jr	z,.do_dhcp			; Go if not
     505:  00:DFDA                      ;
     506:  00:DFDA  B7                  		or	a
     507:  00:DFDB  FD CB 03 56         		bit	vars.init.lease,(iy+vars._init)	; Got a lease?
     508:  00:DFDF  C8                  		ret	z				; Just return NC if not
     509:  00:DFE0                      ;
     510:  00:DFE0  21 34 F0            		ld	hl,vars.dhcp.lease	; See if lease has expired
     511:  00:DFE3  06 04               		ld	b,4
     512:  00:DFE5  AF                  		xor	a
     513:  00:DFE6  B6                  .loop:		or	(hl)
     514:  00:DFE7  C0                  		ret	nz
     515:  00:DFE8                      ;
     516:  00:DFE8  23                  		inc	hl
     517:  00:DFE9  10 FB               		djnz	.loop
     518:  00:DFEB                      ;
     519:  00:DFEB                      		; Lease count has gone to 0 so renew DHCP params
     520:  00:DFEB                      ;
     521:  00:DFEB  FD CB 03 8E         .do_dhcp:	res	vars.init.dhcp,(iy+vars._init)	; Not initialized
     522:  00:DFEF  FD CB 03 96         		res	vars.init.lease,(iy+vars._init)	; No lease time
     523:  00:DFF3                      
     524:  00:DFF3  11 41 D1            		ld	de,trace.diag.dhcp
     525:  00:DFF6  CD EF CF            		call	trace.diag.str
     526:  00:DFF9                      ;
     527:  00:DFF9  FD CB 00 56         		bit	vars.trace.dhcp,(iy+vars._trace)
     528:  00:DFFD  28 09               		jr	z,.donetrace
     529:  00:DFFF                      ;		
     530:  00:DFFF  CD 23 CE            		call	io.start
     531:  00:E002  11 15 D2            		ld	de,trace.dhcp.start
     532:  00:E005  CD 3D CE            		call	io.str
     533:  00:E008                      .donetrace:
     534:  00:E008                      ;
     535:  00:E008  CD B5 CE            		call	status.start		; Start status line blob
     536:  00:E00B                      ;		
     537:  00:E00B  AF                  		xor	a			; We always start with xid=0
     538:  00:E00C  ED 62               		sbc	hl,hl
     539:  00:E00E  22 3C F0            		ld	(vars.dhcp.xid),hl
     540:  00:E011  22 3E F0            		ld	(vars.dhcp.xid+2),hl
     541:  00:E014                      ;
     542:  00:E014  22 40 F0            		ld	(vars.dhcp.secs),hl
     543:  00:E017                      ;
     544:  00:E017  32 1B F0            		ld	(vars.dhcp.retries),a
     545:  00:E01A  18 05               		jr	donetrace
     546:  00:E01C                      
     547:  00:E01C  CD 71 DA            restart:	call	socket.close_0
     548:  00:E01F  38 14               		jr	c,init.error
     549:  00:E021                      
     550:  00:E021  21 1C F0            donetrace:	ld	hl,vars.dhcp.values	; Clear DHCP values
     551:  00:E024  01 20 00            		ld	bc,vars.dhcp.values_size
     552:  00:E027  CD 27 CF            		call	util.memzero
     553:  00:E02A                      ;
     554:  00:E02A  11 8D E4            		ld	de,owner_str		; Our name
     555:  00:E02D  21 44 00            		ld	hl,DHCP_CLIENT_PORT	; Always use this port
     556:  00:E030  CD 8F DC            		call	udp.open_0		; Open socket
     557:  00:E033  30 0F               		jr	nc,init.startok
     558:  00:E035                      ;
     559:  00:E035  FD CB 00 56         init.error:	bit	vars.trace.dhcp,(iy+vars._trace)
     560:  00:E039  C4 53 D0            		call	nz,trace.error
     561:  00:E03C                      ;
     562:  00:E03C  CD 71 DA            init.abort:	call	socket.close_0
     563:  00:E03F  CD A9 CE            		call	status.stop		; Restore status line
     564:  00:E042  37                  		scf
     565:  00:E043  C9                  		ret
     566:  00:E044                      ;
     567:  00:E044  FD CB 00 56         init.startok:	bit	vars.trace.dhcp,(iy+vars._trace)
     568:  00:E048  C4 46 D0            		call	nz,trace.ok
     569:  00:E04B                      ;
     570:  00:E04B                      start:		; Inc the current transaction id. But for simplicity we just
     571:  00:E04B                      		; always use top word = 0
     572:  00:E04B  2A 3C F0            		ld	hl,(vars.dhcp.xid)	; We don't bother with the top
     573:  00:E04E  23                  		inc	hl			;   word of 32-bit xid, always
     574:  00:E04F  22 3C F0            		ld	(vars.dhcp.xid),hl	;   0
     575:  00:E052  B7                  		or	a
     576:  00:E053  ED 62               		sbc	hl,hl
     577:  00:E055  22 3E F0            		ld	(vars.dhcp.xid+2),hl
     578:  00:E058                      ;
     579:  00:E058  FD CB 00 56         		bit	vars.trace.dhcp,(iy+vars._trace)
     580:  00:E05C  28 12               		jr	z,.donetrace
     581:  00:E05E                      ;
     582:  00:E05E  CD 23 CE            		call	io.start
     583:  00:E061  11 23 D2            		ld	de,trace.dhcp.discover
     584:  00:E064  CD 3D CE            		call	io.str
     585:  00:E067  2A 3C F0            		ld	hl,(vars.dhcp.xid)
     586:  00:E06A  CD B1 CD            		call	io.int
     587:  00:E06D  CD 3C D0            		call	trace.dots
     588:  00:E070                      .donetrace:
     589:  00:E070                      ;
     590:  00:E070  3A 1B F0            		ld	a,(vars.dhcp.retries)
     591:  00:E073  3C                  		inc	a
     592:  00:E074  32 1B F0            		ld	(vars.dhcp.retries),a
     593:  00:E077  FE 0A               		cp	10
     594:  00:E079  30 BA               		jr	nc,init.error		; Try 10 times, then give up
     595:  00:E07B                      ;
     596:  00:E07B  3E 01               		ld	a,DHCP_TYPE.DISCOVER
     597:  00:E07D  CD EA E0            		call	send
     598:  00:E080  38 B3               		jr	c,init.error
     599:  00:E082                      ;
     600:  00:E082  CD E3 E1            		call	read
     601:  00:E085  38 B5               		jr	c,init.abort
     602:  00:E087                      ;
     603:  00:E087  FE 02               		cp	DHCP_TYPE.OFFER
     604:  00:E089  20 91               		jr	nz,restart
     605:  00:E08B                      ;
     606:  00:E08B  2A 42 F0            		ld	hl,(vars.dhcp.packet_xid)
     607:  00:E08E  22 3C F0            		ld	(vars.dhcp.xid),hl
     608:  00:E091  2A 44 F0            		ld	hl,(vars.dhcp.packet_xid+2); Use offer's xid
     609:  00:E094  22 3E F0            		ld	(vars.dhcp.xid+2),hl
     610:  00:E097                      ;
     611:  00:E097  FD CB 00 56         		bit	vars.trace.dhcp,(iy+vars._trace)
     612:  00:E09B  28 12               		jr	z,.dontr2
     613:  00:E09D                      
     614:  00:E09D  CD 23 CE            		call	io.start
     615:  00:E0A0  11 35 D2            		ld	de,trace.dhcp.request
     616:  00:E0A3  CD 3D CE            		call	io.str
     617:  00:E0A6  2A 3C F0            		ld	hl,(vars.dhcp.xid)
     618:  00:E0A9  CD B1 CD            		call	io.int
     619:  00:E0AC  CD 3C D0            		call	trace.dots
     620:  00:E0AF                      .dontr2:
     621:  00:E0AF                      ;
     622:  00:E0AF  3E 03               		ld	a,DHCP_TYPE.REQUEST
     623:  00:E0B1  CD EA E0            		call	send
     624:  00:E0B4  DA 35 E0            		jp	c,init.error
     625:  00:E0B7                      ;
     626:  00:E0B7  CD E3 E1            		call	read
     627:  00:E0BA  DA 3C E0            		jp	c,init.abort
     628:  00:E0BD                      ;
     629:  00:E0BD  FE 05               		cp	DHCP_TYPE.ACK
     630:  00:E0BF  C2 1C E0            		jp	nz,restart
     631:  00:E0C2                      ;
     632:  00:E0C2  11 A9 D2            		ld	de,trace.dhcp.end
     633:  00:E0C5  FD CB 00 56         		bit	vars.trace.dhcp,(iy+vars._trace)
     634:  00:E0C9  C4 3D CE            		call	nz,io.str
     635:  00:E0CC                      ;
     636:  00:E0CC  21 1C F0            		ld	hl,vars.dhcp.ip
     637:  00:E0CF  CD D2 D5            		call	wiz.set_ip
     638:  00:E0D2                      ;
     639:  00:E0D2  21 20 F0            		ld	hl,vars.dhcp.subnet
     640:  00:E0D5  D4 E9 D5            		call	nc,wiz.set_subnet
     641:  00:E0D8                      ;
     642:  00:E0D8  21 24 F0            		ld	hl,vars.dhcp.gateway
     643:  00:E0DB  D4 F9 D5            		call	nc,wiz.set_gateway
     644:  00:E0DE                      ;
     645:  00:E0DE  CD 71 DA            		call	socket.close_0
     646:  00:E0E1                      ;
     647:  00:E0E1  CD A9 CE            		call	status.stop		; Restore status line
     648:  00:E0E4                      ;		
     649:  00:E0E4  FD CB 03 CE         		set	vars.init.dhcp,(iy+vars._init)	; Initialised!
     650:  00:E0E8                      ;
     651:  00:E0E8  B7                  		or	a
     652:  00:E0E9  C9                  		ret
     653:  00:E0EA                      ;
     654:  00:E0EA                      ;
     655:  00:E0EA                      ;------------------------------------------------------------------------------
     656:  00:E0EA                      ; send
     657:  00:E0EA                      ;
     658:  00:E0EA                      ; Sends a DHCP packet
     659:  00:E0EA                      ;
     660:  00:E0EA                      ; In:  A=DHCP_TYPE.xxx
     661:  00:E0EA                      ; Out: NC=>ok
     662:  00:E0EA  08                  send:		ex	af,af			; Save DHCP type in A'
     663:  00:E0EB                      ;
     664:  00:E0EB                      		; Set up udp header with dest ip address & port
     665:  00:E0EB  21 11 F0            		ld	hl,vars.udp.ip
     666:  00:E0EE  06 04               		ld	b,4
     667:  00:E0F0  36 FF               .loop:		ld	(hl),0xff		; Broadcast
     668:  00:E0F2  23                  		inc	hl
     669:  00:E0F3  10 FB               		djnz	.loop
     670:  00:E0F5                      ;
     671:  00:E0F5  21 43 00            		ld	hl,DHCP_SERVER_PORT	; Standard DHCP port
     672:  00:E0F8  22 15 F0            		ld	(vars.udp.port),hl
     673:  00:E0FB                      ;
     674:  00:E0FB                      		; Construct a DHCP packet
     675:  00:E0FB  CD 25 E4            		call	packet_init		; Zero packet buffer
     676:  00:E0FE                      ;
     677:  00:E0FE  36 01               		ld	(hl),DHCP_OP.BOOTREQUEST;
     678:  00:E100  23                  		inc	hl			; HL->packet.htype
     679:  00:E101  36 01               		ld	(hl),DHCP_HTYPE.10MB;
     680:  00:E103  23                  		inc	hl			; HL->packet.hlen
     681:  00:E104  36 06               		ld	(hl),DHCP_HLEN.ETHERNET
     682:  00:E106  23                  		inc	hl			; HL->packet.hops
     683:  00:E107  36 00               		ld	(hl),DHCP.HOPS
     684:  00:E109  23                  		inc	hl			; HL->packet.xid
     685:  00:E10A                      ;
     686:  00:E10A                      		; Copy in transaction id, byte swapping
     687:  00:E10A  ED 5B 3E F0         		ld	de,(vars.dhcp.xid+2)
     688:  00:E10E  72                  		ld	(hl),d
     689:  00:E10F  23                  		inc	hl
     690:  00:E110  73                  		ld	(hl),e
     691:  00:E111  23                  		inc	hl
     692:  00:E112  ED 5B 3C F0         		ld	de,(vars.dhcp.xid)
     693:  00:E116  72                  		ld	(hl),d
     694:  00:E117  23                  		inc	hl
     695:  00:E118  73                  		ld	(hl),e
     696:  00:E119  23                  		inc	hl
     697:  00:E11A                      ;
     698:  00:E11A                      		; secs has to be byte swapped too
     699:  00:E11A  ED 5B 40 F0         		ld	de,(vars.dhcp.secs)
     700:  00:E11E  72                  		ld	(hl),d
     701:  00:E11F  23                  		inc	hl
     702:  00:E120  73                  		ld	(hl),e
     703:  00:E121  23                  		inc	hl
     704:  00:E122                      ;
     705:  00:E122  36 80               		ld	(hl),HIGH DHCP_FLAGS.BROADCAST
     706:  00:E124  23                  		inc	hl
     707:  00:E125  36 00               		ld	(hl),LOW DHCP_FLAGS.BROADCAST
     708:  00:E127                      ;
     709:  00:E127                      		; ciaddr, yiaddr, siaddr & giaddr already zeroed
     710:  00:E127                      ;
     711:  00:E127  21 1C F3            		ld	hl,vars.dhcp.packet.chaddr	; Copy MAC adrdess to chaddr
     712:  00:E12A  CD 2E E4            		call	packet_mac	; Rest of packet.chaddr already 0
     713:  00:E12D                      ;
     714:  00:E12D                      		ASSERT	(vars.dhcp.packet_size & 1) = 0
     715:  00:E12D                      ;
     716:  00:E12D  01 2C 00            		ld	bc,vars.dhcp.packet_size
     717:  00:E130  CD 1C E4            		call	packet_write	; Write packet upto & including chaddr
     718:  00:E133  38 55               		jr	c,.error
     719:  00:E135                      ;
     720:  00:E135  CD 25 E4            		call	packet_init	; Zero packet buffer again
     721:  00:E138                      ;
     722:  00:E138                      		; Write 32 bytes from zerod buffer for sname & file
     723:  00:E138  06 06               		ld	b,6		; 6x32 bytes = 192
     724:  00:E13A  C5                  .writezeros:	push	bc
     725:  00:E13B  01 20 00            		ld	bc,32
     726:  00:E13E  CD 1C E4            		call	packet_write
     727:  00:E141  C1                  		pop	bc
     728:  00:E142  38 46               		jr	c,.error
     729:  00:E144                      ;
     730:  00:E144  10 F4               		djnz	.writezeros
     731:  00:E146                      ;
     732:  00:E146                      		; OPT - Magic cookie
     733:  00:E146  36 63               		ld	(hl),99
     734:  00:E148  23                  		inc	hl
     735:  00:E149  36 82               		ld	(hl),130
     736:  00:E14B  23                  		inc	hl
     737:  00:E14C  36 53               		ld	(hl),83
     738:  00:E14E  23                  		inc	hl
     739:  00:E14F  36 63               		ld	(hl),99
     740:  00:E151  23                  		inc	hl
     741:  00:E152  (00:0004)           .LEN_COOKIE	equ	4
     742:  00:E152                      ;
     743:  00:E152                      		; OPT - Message type
     744:  00:E152  36 35               		ld	(hl),DHCP_OPT.TYPE; Message type
     745:  00:E154  23                  		inc	hl
     746:  00:E155  36 01               		ld	(hl),1		; One byte
     747:  00:E157  23                  		inc	hl
     748:  00:E158  08                  		ex	af,af		; Get back our message type
     749:  00:E159  77                  		ld	(hl),a
     750:  00:E15A  23                  		inc	hl
     751:  00:E15B  08                  		ex	af,af		; Save type again
     752:  00:E15C  (00:0003)           .LEN_TYPE	equ	3
     753:  00:E15C                      ;
     754:  00:E15C                      		; OPT - Client identifier
     755:  00:E15C  36 3D               		ld	(hl),DHCP_OPT.CLIENT	; Client identifier
     756:  00:E15E  23                  		inc	hl
     757:  00:E15F  36 07               		ld	(hl),7		; Length
     758:  00:E161  23                  		inc	hl
     759:  00:E162  36 01               		ld	(hl),1		; Type 1 (hardware)
     760:  00:E164  23                  		inc	hl
     761:  00:E165  CD 2E E4            		call	packet_mac
     762:  00:E168  (00:0009)           .LEN_CLIENT	equ	9
     763:  00:E168                      ;
     764:  00:E168  E5                  		push	hl		; Save ptr to end of mac
     765:  00:E169                      		 ; OPT - host name
     766:  00:E169  36 0C               		 ld	(hl),DHCP_OPT.HOST	; Host name
     767:  00:E16B  23                  		 inc	hl
     768:  00:E16C  36 08               		 ld	(hl),2+(2*3)	; "EP" + 3 bytes from mac
     769:  00:E16E  23                  		 inc	hl
     770:  00:E16F  36 45               		 ld	(hl),'E'
     771:  00:E171  23                  		 inc	hl
     772:  00:E172  36 50               		 ld	(hl),'P'
     773:  00:E174  23                  		 inc	hl
     774:  00:E175                      ;		 ld	(hl),'-'
     775:  00:E175                      ;		 inc	hl
     776:  00:E175  D1                  		pop	de		; DE->end of mac address
     777:  00:E176  1B                  		dec	de		; Point to ;last 3 bytes of MAC address
     778:  00:E177  1B                  		dec	de
     779:  00:E178  1B                  		dec	de
     780:  00:E179  CD 44 E4            		call	packet_byte
     781:  00:E17C  CD 44 E4            		call	packet_byte
     782:  00:E17F  CD 44 E4            		call	packet_byte
     783:  00:E182  (00:000A)           .LEN_HOST	equ	10
     784:  00:E182                      ;
     785:  00:E182                      		; Write above OPTs
     786:  00:E182  (00:001A)           .packet_size	equ	.LEN_COOKIE+.LEN_TYPE+.LEN_CLIENT+.LEN_HOST
     787:  00:E182                      		ASSERT	(.packet_size & 1) = 0
     788:  00:E182                      ;
     789:  00:E182  01 1A 00            		ld	bc,.packet_size
     790:  00:E185  CD 1C E4            		call	packet_write
     791:  00:E188  30 08               		jr	nc,.noerror
     792:  00:E18A                      ;
     793:  00:E18A                      .error:
     794:  00:E18A  FD CB 00 56         		bit	vars.trace.dhcp,(iy+vars._trace)
     795:  00:E18E  C8                  		ret	z
     796:  00:E18F                      ;
     797:  00:E18F  C3 53 D0            		jp	trace.error
     798:  00:E192                      ;
     799:  00:E192  08                  .noerror:	ex	af,af		; Get back message type
     800:  00:E193  FE 03               		cp	DHCP_TYPE.REQUEST
     801:  00:E195  20 1A               		jr	nz,.notreq
     802:  00:E197                      ;
     803:  00:E197  36 32               		ld	(hl),DHCP_OPT.IP; Requested ip address
     804:  00:E199  23                  		inc	hl
     805:  00:E19A  11 1C F0            		ld	de,vars.dhcp.ip
     806:  00:E19D  CD 39 E4            		call	packet_ip
     807:  00:E1A0                      ;
     808:  00:E1A0  36 36               		ld	(hl),DHCP_OPT.SERVER	; Server identifier
     809:  00:E1A2  23                  		inc	hl
     810:  00:E1A3  11 28 F0            		ld	de,vars.dhcp.server
     811:  00:E1A6  CD 39 E4            		call	packet_ip
     812:  00:E1A9                      ;
     813:  00:E1A9  01 0C 00            		ld	bc,2*(2+4)	; 2 lots of (type+length+ip)
     814:  00:E1AC  CD 1C E4            		call	packet_write
     815:  00:E1AF  38 D9               		jr	c,.error
     816:  00:E1B1                      ;
     817:  00:E1B1                      .notreq:
     818:  00:E1B1  36 37               		ld	(hl),DHCP_OPT.PARAM	; Param Request
     819:  00:E1B3  23                  		inc	hl
     820:  00:E1B4  36 07               		ld	(hl),7		; Number of params
     821:  00:E1B6  23                  		inc	hl
     822:  00:E1B7  36 01               		ld	(hl),DHCP_OPT.SUBNET	; subnet mask
     823:  00:E1B9  23                  		inc	hl
     824:  00:E1BA  36 03               		ld	(hl),DHCP_OPT.ROUTER	; routers on subnet
     825:  00:E1BC  23                  		inc	hl
     826:  00:E1BD  36 06               		ld	(hl),DHCP_OPT.DNS	; DNS server
     827:  00:E1BF  23                  		inc	hl
     828:  00:E1C0  36 0F               		ld	(hl),DHCP_OPT.DOMAIN	; domain name
     829:  00:E1C2  23                  		inc	hl
     830:  00:E1C3  36 2A               		ld	(hl),DHCP_OPT.NTP	; Time server
     831:  00:E1C5  23                  		inc	hl
     832:  00:E1C6  36 3A               		ld	(hl),DHCP_OPT.T1
     833:  00:E1C8  23                  		inc	hl
     834:  00:E1C9  36 3B               		ld	(hl),DHCP_OPT.T2
     835:  00:E1CB  23                  		inc	hl
     836:  00:E1CC  36 FF               		ld	(hl),DHCP_OPT.END	; End option
     837:  00:E1CE  01 0A 00            		ld	bc,10		; #bytes written above
     838:  00:E1D1  CD 1C E4            		call	packet_write
     839:  00:E1D4  38 B4               		jr	c,.error
     840:  00:E1D6                      ;
     841:  00:E1D6  CD DF DC            		call	udp.send_0
     842:  00:E1D9  38 AF               		jr	c,.error
     843:  00:E1DB                      ;
     844:  00:E1DB  FD CB 00 56         		bit	vars.trace.dhcp,(iy+vars._trace)
     845:  00:E1DF  C8                  		ret	z
     846:  00:E1E0                      ;
     847:  00:E1E0  C3 46 D0            		jp	trace.ok
     848:  00:E1E3                      ;
     849:  00:E1E3                      ;
     850:  00:E1E3                      ;------------------------------------------------------------------------------
     851:  00:E1E3                      ; read
     852:  00:E1E3                      ;
     853:  00:E1E3                      ; Receives and parses a DHCP response
     854:  00:E1E3                      ;
     855:  00:E1E3                      ; Out: A=DHCP_TYPE.xx if valid response, else 0 or ff
     856:  00:E1E3                      ;      Cy=>error
     857:  00:E1E3                      read:
     858:  00:E1E3  2A 06 F0            		ld	hl,(vars.ticks)
     859:  00:E1E6  22 19 F0            		ld	(vars.dhcp.timeout),hl
     860:  00:E1E9  18 0D               		jr	.loop
     861:  00:E1EB                      ;
     862:  00:E1EB  11 FA D2            .eop:		ld	de,trace.dhcp.eop
     863:  00:E1EE  FD CB 00 56         .badpacket:	bit	vars.trace.dhcp,(iy+vars._trace)
     864:  00:E1F2  C4 3D CE            		call	nz,io.str
     865:  00:E1F5  CD 73 D9            .retry:		call	socket.read_end_0
     866:  00:E1F8                      ;
     867:  00:E1F8  CD 96 DC            .loop:		call	udp.header_0
     868:  00:E1FB  20 20               		jr	nz,.gotpacket
     869:  00:E1FD                      ;
     870:  00:E1FD  CD CA CE            		call	status.waiting	; Flash status line blob
     871:  00:E200                      ;
     872:  00:E200  CD 94 C9            		call	exos.is_stop
     873:  00:E203  38 11               		jr	c,.errret
     874:  00:E205                      ;
     875:  00:E205  ED 5B 19 F0         		ld	de,(vars.dhcp.timeout)	; Start tick count
     876:  00:E209  2A 06 F0            		ld	hl,(vars.ticks)		; Current tick count
     877:  00:E20C  B7                  		or	a
     878:  00:E20D  ED 52               		sbc	hl,de		; HL=duration in ticks
     879:  00:E20F  11 32 00            		ld	de,TICKS_1s	; 1S timeout in ticks
     880:  00:E212  ED 52               		sbc	hl,de
     881:  00:E214  38 E2               		jr	c,.loop		; Not timed out yet
     882:  00:E216                      ;
     883:  00:E216                      .errret:				; Cy=>error, or NC=>timeout
     884:  00:E216  F5                  		push	af
     885:  00:E217  CD 73 D9            		 call	socket.read_end_0
     886:  00:E21A  F1                  		pop	af
     887:  00:E21B  9F                  		sbc	a,a		; FF and carry or 0 and NC
     888:  00:E21C  C9                  		ret
     889:  00:E21D                      ;
     890:  00:E21D                      ;
     891:  00:E21D                      .gotpacket:		; Got something - must be at least DHCP header long
     892:  00:E21D  FD CB 00 56         		bit	vars.trace.dhcp,(iy+vars._trace)
     893:  00:E221  28 09               		jr	z,.donetrace
     894:  00:E223                      ;
     895:  00:E223  CD 23 CE            		call	io.start
     896:  00:E226  11 46 D2            		ld	de,trace.dhcp.rx
     897:  00:E229  CD 3D CE            		call	io.str
     898:  00:E22C                      .donetrace:
     899:  00:E22C                      ;
     900:  00:E22C  B7                  		or	a
     901:  00:E22D  01 2C 00            		ld	bc,vars.dhcp.packet_size
     902:  00:E230  ED 42               		sbc	hl,bc
     903:  00:E232  11 C4 D2            		ld	de,trace.dhcp.small
     904:  00:E235  38 B7               		jr	c,.badpacket	; Too small - ignore
     905:  00:E237                      ;
     906:  00:E237  21 00 F3            		ld	hl,vars.dhcp.packet
     907:  00:E23A  01 2C 00            		ld	bc,vars.dhcp.packet_size
     908:  00:E23D  CD AB D8            		call	socket.read_0		; Read start of DHCP packet
     909:  00:E240                      ;
     910:  00:E240                      		; Check packet has come from the right port
     911:  00:E240  2A 15 F0            		ld	hl,(vars.udp.port)
     912:  00:E243  01 43 00            		ld	bc,DHCP_SERVER_PORT	; Standard server port
     913:  00:E246  B7                  		or	a
     914:  00:E247  ED 42               		sbc	hl,bc
     915:  00:E249  11 CE D2            		ld	de,trace.dhcp.port
     916:  00:E24C  C2 EE E1             jp	nz,.badpacket
     917:  00:E24F                      ;		jr	nz,.badpacket
     918:  00:E24F                      ;
     919:  00:E24F                      		; Check it's the right sort of DHCP reply
     920:  00:E24F  3A 00 F3            		ld	a,(vars.dhcp.packet.op)
     921:  00:E252  FE 02               		cp	2		; BOOTREPLY
     922:  00:E254  11 D7 D2            		ld	de,trace.dhcp.op
     923:  00:E257  C2 EE E1            		jp	nz,.badpacket
     924:  00:E25A                      ;
     925:  00:E25A                      		; Check chaddr has our mac address
     926:  00:E25A  21 1C F3            		ld	hl,vars.dhcp.packet.chaddr
     927:  00:E25D  11 0E C0            		ld	de,mac
     928:  00:E260  06 06               		ld	b,6
     929:  00:E262  CD 34 CF            		call	util.memcmp
     930:  00:E265  11 DE D2            		ld	de,trace.dhcp.addr
     931:  00:E268  C2 EE E1            		jp	nz,.badpacket
     932:  00:E26B                      ;
     933:  00:E26B                      		; Check xid. Top word MBZ as we always send it 0
     934:  00:E26B  2A 04 F3            		ld	hl,(vars.dhcp.packet.xid)
     935:  00:E26E  7C                  		ld	a,h
     936:  00:E26F  B5                  		or	l
     937:  00:E270  11 E7 D2            .xiderrnz:	ld	de,trace.dhcp.xid
     938:  00:E273  C2 EE E1            		jp	nz,.badpacket
     939:  00:E276                      ;
     940:  00:E276                      		; Save packet's xid in vars.dhcp.packet_xid because we
     941:  00:E276                      		; reuse the packet buffer later
     942:  00:E276  7C                  		ld	a,h		; Get it in Z80 order
     943:  00:E277  65                  		ld	h,l
     944:  00:E278  6F                  		ld	l,a
     945:  00:E279  22 44 F0            		ld	(vars.dhcp.packet_xid+2),hl
     946:  00:E27C                      ;
     947:  00:E27C  2A 06 F3            		ld	hl,(vars.dhcp.packet.xid+2)
     948:  00:E27F  7C                  		ld	a,h		; Get it in Z80 order
     949:  00:E280  65                  		ld	h,l
     950:  00:E281  6F                  		ld	l,a
     951:  00:E282  22 42 F0            		ld	(vars.dhcp.packet_xid),hl
     952:  00:E285  ED 5B 3C F0         		ld	de,(vars.dhcp.xid)
     953:  00:E289  EB                  		ex	de,hl		; HL=our xid, DE=packet xid
     954:  00:E28A  B7                  		or	a
     955:  00:E28B  ED 52               		sbc	hl,de		; Make sure it's <= current xid
     956:  00:E28D  38 E1               		jr	c,.xiderrnz	; Also NZ if Cy
     957:  00:E28F                      .xidok:	
     958:  00:E28F                      ;
     959:  00:E28F  11 1C F0            		ld	de,vars.dhcp.ip	; Get the IP address
     960:  00:E292  21 10 F3            		ld	hl,vars.dhcp.packet.yiaddr
     961:  00:E295  01 04 00            		ld	bc,4
     962:  00:E298  ED B0               		ldir
     963:  00:E29A                      ;
     964:  00:E29A                      		; Now we need to skip to the options part
     965:  00:E29A                      		; so read 6x32 bytes
     966:  00:E29A                      		; This will trash the DHCP header!!
     967:  00:E29A  06 06               		ld	b,6
     968:  00:E29C  21 00 F3            .readlots:	ld	hl,vars.dhcp.packet
     969:  00:E29F  C5                  		push	bc
     970:  00:E2A0  01 20 00            		 ld	bc,32
     971:  00:E2A3  CD AB D8            		 call	socket.read_0
     972:  00:E2A6  C1                  		pop	bc
     973:  00:E2A7  10 F3               		djnz	.readlots
     974:  00:E2A9                      ;
     975:  00:E2A9                      		; Read the magic cookie
     976:  00:E2A9  21 00 F3            		ld	hl,vars.dhcp.packet
     977:  00:E2AC  01 04 00            		ld	bc,4		; Read the magic cookie
     978:  00:E2AF  CD AB D8            		call	socket.read_0
     979:  00:E2B2                      ;
     980:  00:E2B2  2A 00 F3            		ld	hl,(vars.dhcp.packet+0)
     981:  00:E2B5  11 63 82            		ld	de,130*256+99
     982:  00:E2B8  B7                  		or	a
     983:  00:E2B9  ED 52               		sbc	hl,de
     984:  00:E2BB  20 0B               		jr	nz,.cookiebad
     985:  00:E2BD                      ;
     986:  00:E2BD  2A 02 F3            		ld	hl,(vars.dhcp.packet+2)
     987:  00:E2C0  11 53 63            		ld	de,99*256+83
     988:  00:E2C3  B7                  		or	a
     989:  00:E2C4  ED 52               		sbc	hl,de
     990:  00:E2C6  28 06               		jr	z,.cookieok
     991:  00:E2C8                      ;
     992:  00:E2C8  11 EF D2            .cookiebad:	ld	de,trace.dhcp.cookie
     993:  00:E2CB  C3 EE E1            		jp	.badpacket
     994:  00:E2CE                      
     995:  00:E2CE                      .cookieok:
     996:  00:E2CE                      		; Now read the variable-sized options
     997:  00:E2CE  AF                  		xor	a		; Initialise DHCP type
     998:  00:E2CF  08                  		ex	af,af		; Save in AF'
     999:  00:E2D0                      ;
    1000:  00:E2D0  18 0D               		jr	.nextopt
    1001:  00:E2D2                      ;
    1002:  00:E2D2  CD 73 D9            .ret:		call	socket.read_end_0
    1003:  00:E2D5  FD CB 00 56         		bit	vars.trace.dhcp,(iy+vars._trace)
    1004:  00:E2D9  C4 46 D0            		call	nz,trace.ok
    1005:  00:E2DC  08                  		ex	af,af		; Get back saved DHCP type
    1006:  00:E2DD  B7                  		or	a		; NC=>no error
    1007:  00:E2DE  C9                  		ret
    1008:  00:E2DF                      ;
    1009:  00:E2DF                      .nextopt:
    1010:  00:E2DF  CD DF D8            		call	socket.read_byte_0
    1011:  00:E2E2  DA EB E1            		jp	c,.eop		; Nothing left to read but no end opt
    1012:  00:E2E5                      ;
    1013:  00:E2E5                      		; FF is the end of options
    1014:  00:E2E5                      		; 00 is just padding
    1015:  00:E2E5                      		; All others are (should be!) followed by a length byte
    1016:  00:E2E5                      
    1017:  00:E2E5  FE FF               		cp	0ffh		; End option?
    1018:  00:E2E7  28 E9               		jr	z,.ret
    1019:  00:E2E9                      ;
    1020:  00:E2E9  B7                  		or	a		; Padding?
    1021:  00:E2EA  28 F3               		jr	z,.nextopt
    1022:  00:E2EC                      
    1023:  00:E2EC  4F                  		ld	c,a		; Save opt code
    1024:  00:E2ED                      ;
    1025:  00:E2ED  CD DF D8            		call	socket.read_byte_0; Get length byte
    1026:  00:E2F0  DA EB E1            		jp	c,.eop
    1027:  00:E2F3                      ;
    1028:  00:E2F3  47                  		ld	b,a		; Save length
    1029:  00:E2F4  79                  		ld	a,c		; Get back opt code
    1030:  00:E2F5                      ;
    1031:  00:E2F5  FE 35               		cp	DHCP_OPT.TYPE	; Message type?
    1032:  00:E2F7  20 48               		jr	nz,.not53
    1033:  00:E2F9                      ;
    1034:  00:E2F9  CD DF D8            		call	socket.read_byte_0; Get DHCP message type
    1035:  00:E2FC  DA EB E1            		jp	c,.eop
    1036:  00:E2FF                      ;
    1037:  00:E2FF  47                  		ld	b,a
    1038:  00:E300  08                  		ex	af,af		; Save in AF for returning type
    1039:  00:E301                      ;
    1040:  00:E301  FD CB 00 56         		bit	vars.trace.dhcp,(iy+vars._trace)
    1041:  00:E305  28 D8               		jr	z,.nextopt
    1042:  00:E307                      ;
    1043:  00:E307  78                  		ld	a,b		; Retrieve message type
    1044:  00:E308  11 84 D2            		ld	de,trace.dhcp.offer
    1045:  00:E30B  FE 02               		cp	DHCP_TYPE.OFFER
    1046:  00:E30D  28 1B               		jr	z,.tracetype
    1047:  00:E30F                      ;
    1048:  00:E30F  11 8B D2            		ld	de,trace.dhcp.decline
    1049:  00:E312  FE 04               		cp	DHCP_TYPE.DECLINE
    1050:  00:E314  28 14               		jr	z,.tracetype
    1051:  00:E316                      ;
    1052:  00:E316  11 94 D2            		ld	de,trace.dhcp.ack
    1053:  00:E319  FE 05               		cp	DHCP_TYPE.ACK
    1054:  00:E31B  28 0D               		jr	z,.tracetype
    1055:  00:E31D                      ;
    1056:  00:E31D  11 99 D2            		ld	de,trace.dhcp.nak
    1057:  00:E320  FE 06               		cp	DHCP_TYPE.NAK
    1058:  00:E322  28 06               		jr	z,.tracetype
    1059:  00:E324                      ;
    1060:  00:E324  CD AE CD            		call	io.short
    1061:  00:E327  11 9E D2            		ld	de,trace.dhcp.type
    1062:  00:E32A  CD 3D CE            .tracetype:	call	io.str		; Print message type
    1063:  00:E32D                      ;
    1064:  00:E32D  2A 42 F0            		ld	hl,(vars.dhcp.packet_xid)
    1065:  00:E330  CD B1 CD            		call	io.int		; Followed by xid...
    1066:  00:E333  CD 3C D0            		call	trace.dots
    1067:  00:E336                      ;
    1068:  00:E336  01 1C F0            		ld	bc,vars.dhcp.ip
    1069:  00:E339  11 4F D2            		ld	de,trace.dhcp.gotip
    1070:  00:E33C  CD 07 E4            		call	traceip		; And the IP we received
    1071:  00:E33F                      ;
    1072:  00:E33F  18 9E               		jr	.nextopt
    1073:  00:E341                      .not53:
    1074:  00:E341                      ;
    1075:  00:E341  FE 01               		cp	DHCP_OPT.SUBNET		; Subnet mask?
    1076:  00:E343  20 14               		jr	nz,.not1
    1077:  00:E345                      ;
    1078:  00:E345  21 20 F0            		ld	hl,vars.dhcp.subnet
    1079:  00:E348  CD F8 E3            		call	read_ip
    1080:  00:E34B  DA EB E1            		jp	c,.eop
    1081:  00:E34E                      ;
    1082:  00:E34E  11 54 D2            		ld	de,trace.dhcp.gotsubnet
    1083:  00:E351  01 20 F0            		ld	bc,vars.dhcp.subnet
    1084:  00:E354  CD 07 E4            		call	traceip
    1085:  00:E357                      ;
    1086:  00:E357  18 86               		jr	.nextopt
    1087:  00:E359                      .not1:		
    1088:  00:E359                      ;
    1089:  00:E359  FE 03               		cp	DHCP_OPT.ROUTER		; Routers on subnet?
    1090:  00:E35B  20 18               		jr	nz,.not3
    1091:  00:E35D                      ;
    1092:  00:E35D  C5                  		push	bc		; Save length
    1093:  00:E35E  21 24 F0            		 ld	hl,vars.dhcp.gateway
    1094:  00:E361  CD F8 E3            		 call	read_ip
    1095:  00:E364  C1                  		pop	bc
    1096:  00:E365  DA EB E1            		jp	c,.eop
    1097:  00:E368                      ;
    1098:  00:E368  C5                  		push	bc
    1099:  00:E369  11 5D D2            		 ld	de,trace.dhcp.gotgateway
    1100:  00:E36C  01 24 F0            		 ld	bc,vars.dhcp.gateway
    1101:  00:E36F  CD 07 E4            		 call	traceip
    1102:  00:E372  C1                  		pop	bc
    1103:  00:E373                      ;
    1104:  00:E373  18 1A               		jr	.skip4
    1105:  00:E375                      .not3:
    1106:  00:E375                      ;
    1107:  00:E375  FE 06               		cp	DHCP_OPT.DNS	; DNS server?
    1108:  00:E377  20 1C               		jr	nz,.not6
    1109:  00:E379                      ;
    1110:  00:E379  C5                  		push	bc		; Save length
    1111:  00:E37A  21 2C F0            		 ld	hl,vars.dhcp.dns
    1112:  00:E37D  CD F8 E3            		 call	read_ip
    1113:  00:E380  C1                  		pop	bc
    1114:  00:E381  DA EB E1            		jp	c,.eop
    1115:  00:E384                      ;
    1116:  00:E384  C5                  		push	bc
    1117:  00:E385  11 78 D2            		 ld	de,trace.dhcp.gotdns
    1118:  00:E388  01 2C F0            		 ld	bc,vars.dhcp.dns
    1119:  00:E38B  CD 07 E4            .traceip:	 call	traceip
    1120:  00:E38E  C1                  		pop	bc
    1121:  00:E38F                      ;
    1122:  00:E38F  78                  .skip4:		ld	a,b
    1123:  00:E390  D6 04               		sub	4		; Allow for bytes just read
    1124:  00:E392  47                  		ld	b,a
    1125:  00:E393  18 54               		jr	.skipopt	; Skip rest of option
    1126:  00:E395                      .not6:
    1127:  00:E395                      ;
    1128:  00:E395  FE 2A               		cp	DHCP_OPT.NTP	; NTP server?
    1129:  00:E397  20 14               		jr	nz,.not42
    1130:  00:E399                      ;
    1131:  00:E399  C5                  		push	bc		; Save length
    1132:  00:E39A  21 30 F0            		 ld	hl,vars.dhcp.ntp
    1133:  00:E39D  CD F8 E3            		 call	read_ip
    1134:  00:E3A0  C1                  		pop	bc
    1135:  00:E3A1  DA EB E1            		jp	c,.eop
    1136:  00:E3A4                      ;
    1137:  00:E3A4  C5                  		push	bc
    1138:  00:E3A5  11 7E D2            		 ld	de,trace.dhcp.gotntp
    1139:  00:E3A8  01 30 F0            		 ld	bc,vars.dhcp.ntp
    1140:  00:E3AB  18 DE               		jr	.traceip
    1141:  00:E3AD                      .not42:
    1142:  00:E3AD                      ;
    1143:  00:E3AD  FE 36               		cp	DHCP_OPT.SERVER	; Server identifier?
    1144:  00:E3AF  20 15               		jr	nz,.not54
    1145:  00:E3B1                      ;
    1146:  00:E3B1  21 28 F0            		ld	hl,vars.dhcp.server
    1147:  00:E3B4  CD F8 E3            		call	read_ip
    1148:  00:E3B7  DA EB E1            		jp	c,.eop
    1149:  00:E3BA                      ;
    1150:  00:E3BA  11 67 D2            		ld	de,trace.dhcp.gotserver
    1151:  00:E3BD  01 28 F0            		ld	bc,vars.dhcp.server
    1152:  00:E3C0  CD 07 E4            		call	traceip
    1153:  00:E3C3                      ;
    1154:  00:E3C3  C3 DF E2            		jp	.nextopt
    1155:  00:E3C6                      .not54:
    1156:  00:E3C6                      ;
    1157:  00:E3C6  FE 33               		cp	DHCP_OPT.LEASE	; IP lease time?
    1158:  00:E3C8  20 1F               		jr	nz,.not51
    1159:  00:E3CA                      ;
    1160:  00:E3CA  21 34 F0            		ld	hl,vars.dhcp.lease
    1161:  00:E3CD  CD F8 E3            		call	read_ip		; It's not an IP addr, but it is 4 bytes!
    1162:  00:E3D0  DA EB E1            		jp	c,.eop
    1163:  00:E3D3                      ;
    1164:  00:E3D3  B7                  		or	a
    1165:  00:E3D4  ED 62               		sbc	hl,hl
    1166:  00:E3D6  22 08 F0            		ld	(vars.dhcp.ticks),hl		; Reset tick count
    1167:  00:E3D9  FD CB 03 D6         		set	vars.init.lease,(iy+vars._init)	; Got a lease time!
    1168:  00:E3DD                      ;
    1169:  00:E3DD  11 70 D2            		ld	de,trace.dhcp.gotlease
    1170:  00:E3E0  01 34 F0            		ld	bc,vars.dhcp.lease
    1171:  00:E3E3  CD 07 E4            		call	traceip
    1172:  00:E3E6                      ;
    1173:  00:E3E6  C3 DF E2            		jp	.nextopt
    1174:  00:E3E9                      		
    1175:  00:E3E9                      .not51:
    1176:  00:E3E9                      ;
    1177:  00:E3E9                      					; Unrecognised option - just skip
    1178:  00:E3E9  78                  .skipopt:	ld	a,b		; Get length byte
    1179:  00:E3EA  B7                  		or	a
    1180:  00:E3EB  28 08               		jr	z,.skipped
    1181:  00:E3ED                      ;
    1182:  00:E3ED  CD DF D8            .skiploop:	call	socket.read_byte_0
    1183:  00:E3F0  DA EB E1            		jp	c,.eop
    1184:  00:E3F3                      ;
    1185:  00:E3F3  10 F8               		djnz	.skiploop
    1186:  00:E3F5                      ;
    1187:  00:E3F5  C3 DF E2            .skipped:	jp	.nextopt
    1188:  00:E3F8                      ;
    1189:  00:E3F8                      ;
    1190:  00:E3F8                      ;
    1191:  00:E3F8                      ; read_ip
    1192:  00:E3F8                      ;
    1193:  00:E3F8                      ; Calls udp.read_byte() 4 times to read an IP address
    1194:  00:E3F8                      ;
    1195:  00:E3F8                      ; In:  HL->buffer
    1196:  00:E3F8                      ;       B=length of parameter in packet
    1197:  00:E3F8                      ; Out: Cy=>error
    1198:  00:E3F8  78                  read_ip:	ld	a,b		; Get #bytes to follow
    1199:  00:E3F9  FE 04               		cp	4
    1200:  00:E3FB  D8                  		ret	c		; Not enough for an IP address!
    1201:  00:E3FC                      ;
    1202:  00:E3FC  06 04               		ld	b,4
    1203:  00:E3FE  CD DF D8            .loop:		call	socket.read_byte_0
    1204:  00:E401  D8                  		ret	c
    1205:  00:E402                      ;
    1206:  00:E402  77                  		ld	(hl),a
    1207:  00:E403  23                  		inc	hl
    1208:  00:E404  10 F8               		djnz	.loop
    1209:  00:E406                      ;
    1210:  00:E406  C9                  		ret
    1211:  00:E407                      ;
    1212:  00:E407                      ;
    1213:  00:E407                      ; DE->string
    1214:  00:E407                      ; BC->IP
    1215:  00:E407                      ; HL preserved
    1216:  00:E407                      traceip:
    1217:  00:E407  FD CB 00 56         		bit	vars.trace.dhcp,(iy+vars._trace)
    1218:  00:E40B  C8                  		ret	z
    1219:  00:E40C                      ;
    1220:  00:E40C  E5                  		push	hl
    1221:  00:E40D  C5                  		 push	bc
    1222:  00:E40E  CD 3D CE            		  call	io.str
    1223:  00:E411  E1                  		 pop	hl		; HL->IP
    1224:  00:E412                      ;
    1225:  00:E412  CD 8C CD            		 call	io.ip
    1226:  00:E415  3E 2C               		 ld	a,','
    1227:  00:E417  CD 00 CE            		 call	io.char
    1228:  00:E41A  E1                  		pop	hl
    1229:  00:E41B  C9                  		ret
    1230:  00:E41C                      ;
    1231:  00:E41C                      ;
    1232:  00:E41C                      ; packet_write
    1233:  00:E41C                      ;
    1234:  00:E41C                      ; Writes the data built up in dhcp.packet
    1235:  00:E41C                      ;
    1236:  00:E41C                      ; In:  BC=no.bytes in packet buffer
    1237:  00:E41C                      ; Out: NC=>no error
    1238:  00:E41C                      ;      HL->start of packet
    1239:  00:E41C  21 00 F3            packet_write:	ld	hl,vars.dhcp.packet
    1240:  00:E41F  E5                  		push	hl
    1241:  00:E420  CD 8B D9            		 call	socket.write_0
    1242:  00:E423  E1                  		pop	hl
    1243:  00:E424  C9                  		ret
    1244:  00:E425                      ;
    1245:  00:E425                      ;
    1246:  00:E425                      ;
    1247:  00:E425  21 00 F3            packet_init:	ld	hl,vars.dhcp.packet
    1248:  00:E428  01 2C 00            		ld	bc,vars.dhcp.packet_size
    1249:  00:E42B  C3 27 CF            		jp	util.memzero
    1250:  00:E42E                      ;
    1251:  00:E42E                      ;
    1252:  00:E42E                      ; packet_mac
    1253:  00:E42E                      ;
    1254:  00:E42E                      ; Copies our MAC address into packet buffer
    1255:  00:E42E                      ;
    1256:  00:E42E                      ; In:  HL->packet buffer
    1257:  00:E42E                      ; Out: HL updated
    1258:  00:E42E  EB                  packet_mac:	ex	de,hl		; DE->buffer
    1259:  00:E42F  21 0E C0            		ld	hl,mac
    1260:  00:E432  01 06 00            		ld	bc,6
    1261:  00:E435  ED B0               		ldir
    1262:  00:E437  EB                  		ex	de,hl
    1263:  00:E438                      ;
    1264:  00:E438  C9                  		ret
    1265:  00:E439                      ;
    1266:  00:E439                      ; packet_ip
    1267:  00:E439                      ;
    1268:  00:E439                      ; Puts a length byte and copies an IP address into packet buffer
    1269:  00:E439                      ;
    1270:  00:E439                      ; In:  HL->packet buffer
    1271:  00:E439                      ;      DE->IP address (4 bytes)
    1272:  00:E439                      ; Out: HL updated
    1273:  00:E439  36 04               packet_ip:	ld	(hl),4		; Length byte
    1274:  00:E43B  23                  		inc	hl
    1275:  00:E43C  EB                  		ex	de,hl		; DE->buffer
    1276:  00:E43D  01 04 00            		ld	bc,4
    1277:  00:E440  ED B0               		ldir
    1278:  00:E442  EB                  		ex	de,hl
    1279:  00:E443                      ;
    1280:  00:E443  C9                  		ret
    1281:  00:E444                      ;
    1282:  00:E444                      ; packet_byte
    1283:  00:E444                      ;
    1284:  00:E444                      ; Puts a byte in ASCII into packet buffer
    1285:  00:E444                      ;
    1286:  00:E444                      ; In:  HL->packet buffer
    1287:  00:E444                      ;      DE->byte
    1288:  00:E444                      ; Out: HL and DE updated
    1289:  00:E444                      ;
    1290:  00:E444  1A                  packet_byte:	ld	a,(de)
    1291:  00:E445  0F                  		rrca
    1292:  00:E446  0F                  		rrca
    1293:  00:E447  0F                  		rrca
    1294:  00:E448  0F                  		rrca
    1295:  00:E449  CD 4E E4            		call	packet_nibble
    1296:  00:E44C  1A                  		ld	a,(de)
    1297:  00:E44D  13                  		inc	de
    1298:  00:E44E                      ;
    1299:  00:E44E  E6 0F               packet_nibble:	and	0fh
    1300:  00:E450  C6 30               		add	a,'0'
    1301:  00:E452  FE 3A               		cp	a,'9'+1
    1302:  00:E454  38 02               		jr	c,.done
    1303:  00:E456                      ;
    1304:  00:E456  C6 07               		add	a,'A'-'9'-1
    1305:  00:E458  77                  .done:		ld	(hl),a
    1306:  00:E459  23                  		inc	hl
    1307:  00:E45A  C9                  		ret
    1308:  00:E45B                      ;
    1309:  00:E45B                      ;
    1310:  00:E45B                      ;------------------------------------------------------------------------------
    1311:  00:E45B                      ; interrupt
    1312:  00:E45B                      ;
    1313:  00:E45B                      ; This is an interrupt routine that is called every tick (20mS). It divides
    1314:  00:E45B                      ; ticks down into seconds, and then every second decrements the 32-bit lease
    1315:  00:E45B                      ; time until it reaches 0.
    1316:  00:E45B                      ;
    1317:  00:E45B                      interrupt:	; Increment lease tick count
    1318:  00:E45B  2A 08 F0            		ld	hl,(vars.dhcp.ticks)
    1319:  00:E45E  23                  		inc	hl
    1320:  00:E45F  22 08 F0            		ld	(vars.dhcp.ticks),hl
    1321:  00:E462                      ;
    1322:  00:E462                      		; See if it's reached 1S
    1323:  00:E462  11 32 00            		ld	de,TICKS_1s
    1324:  00:E465  B7                  		or	a
    1325:  00:E466  ED 52               		sbc	hl,de
    1326:  00:E468  D8                  		ret	c
    1327:  00:E469                      ;
    1328:  00:E469                      		; Reset the tick count back to 0
    1329:  00:E469                      		; If it's just gone NC, HL should be 0!
    1330:  00:E469  22 08 F0            		ld	(vars.dhcp.ticks),hl
    1331:  00:E46C                      ;
    1332:  00:E46C  2A 40 F0            		ld	hl,(vars.dhcp.secs)		; Inc seconds count
    1333:  00:E46F  23                  		inc	hl
    1334:  00:E470  22 40 F0            		ld	(vars.dhcp.secs),hl
    1335:  00:E473                      
    1336:  00:E473  FD CB 03 56         		bit	vars.init.lease,(iy+vars._init)	; Got a lease time?
    1337:  00:E477  C8                  		ret	z				; Return if not
    1338:  00:E478                      ;
    1339:  00:E478                      		; Now decrement the 32-bit lease time a byte at a time,
    1340:  00:E478                      		; starting with the LSB. If the byte is 0 before we decrement
    1341:  00:E478                      		; it, it will decrement below 0 so we go on to do the next
    1342:  00:E478                      		; byte. If this happens to the last byte, it's gone below 0
    1343:  00:E478                      		; so the lease has expired
    1344:  00:E478  21 37 F0            		ld	hl,vars.dhcp.lease+3
    1345:  00:E47B  06 04               		ld	b,4
    1346:  00:E47D  7E                  .loop:		ld	a,(hl)
    1347:  00:E47E  35                  		dec	(hl)
    1348:  00:E47F  B7                  		or	a
    1349:  00:E480  C0                  		ret	nz
    1350:  00:E481                      ;
    1351:  00:E481  2B                  		dec	hl
    1352:  00:E482  10 F9               		djnz	.loop
    1353:  00:E484                      ;
    1354:  00:E484                      		; If we get here, it's gone -ve so set back to 0
    1355:  00:E484  ED 62               		sbc	hl,hl
    1356:  00:E486  22 34 F0            		ld	(vars.dhcp.lease),hl
    1357:  00:E489  22 36 F0            		ld	(vars.dhcp.lease+2),hl
    1358:  00:E48C                      ;
    1359:  00:E48C  C9                  		ret
    1360:  00:E48D                      ;
    1361:  00:E48D                      ;
    1362:  00:E48D  44 48 43 50 00      owner_str:	db	"DHCP",0
    1363:  00:E492                      ;
    1364:  00:E492                      ;
    1365:  00:E492                      ;
    1366:  00:E492                      		endmodule
     108.  00:E492                      	include ping.asm
       1:  00:E492                      ; PING
       2:  00:E492                      ;
       3:  00:E492                      ; This module implements an interface to the WIZ W5300 that provides a
       4:  00:E492                      ; 'ping' command.
       5:  00:E492                      ;
       6:  00:E492                      		module	ping
       7:  00:E492                      ;
       8:  00:E492                      ;==============================================================================
       9:  00:E492                      ;
      10:  00:E492                      ; This file is part of the EPNET software
      11:  00:E492                      ;
      12:  00:E492                      ; Copyright (C) 2015  Bruce Tanner
      13:  00:E492                      ;
      14:  00:E492                      ;    This program is free software: you can redistribute it and/or modify
      15:  00:E492                      ;    it under the terms of the GNU General Public License as published by
      16:  00:E492                      ;    the Free Software Foundation, either version 3 of the License, or
      17:  00:E492                      ;    (at your option) any later version.
      18:  00:E492                      ;
      19:  00:E492                      ;    This program is distributed in the hope that it will be useful,
      20:  00:E492                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      21:  00:E492                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      22:  00:E492                      ;    GNU General Public License for more details.
      23:  00:E492                      ;
      24:  00:E492                      ;    You should have received a copy of the GNU General Public License
      25:  00:E492                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      26:  00:E492                      ;
      27:  00:E492                      ; If you do use or modify this file, either for its original purpose or for
      28:  00:E492                      ; something new, I'd love to hear about it! I can be contacted by email at:
      29:  00:E492                      ;
      30:  00:E492                      ; brucetanner@btopenworld.com
      31:  00:E492                      ;
      32:  00:E492                      ;==============================================================================
      33:  00:E492                      ;
      34:  00:E492                      ; You would think they would make it easy to implement this most basic of
      35:  00:E492                      ; commands but unfortunately it is necessary to open a WIZ socket in "IP raw"
      36:  00:E492                      ; mode and construct ICMP packets to do this.
      37:  00:E492                      ;
      38:  00:E492                      ; The ping ICMP packet format (from RFC 792) is:
      39:  00:E492                      ;
      40:  00:E492                      ; Echo or Echo Reply Message
      41:  00:E492                      ;
      42:  00:E492                      ;    0                   1                   2                   3
      43:  00:E492                      ;    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      44:  00:E492                      ;   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      45:  00:E492                      ;   |     Type      |     Code      |          Checksum             |
      46:  00:E492                      ;   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      47:  00:E492                      ;   |           Identifier          |        Sequence Number        |
      48:  00:E492                      ;   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      49:  00:E492                      ;   |     Data ...
      50:  00:E492                      ;   +-+-+-+-+-
      51:  00:E492                      ;
      52:  00:E492                      ;   IP Fields:
      53:  00:E492                      ;
      54:  00:E492                      ;   Addresses
      55:  00:E492                      ;
      56:  00:E492                      ;      The address of the source in an echo message will be the
      57:  00:E492                      ;      destination of the echo reply message.  To form an echo reply
      58:  00:E492                      ;      message, the source and destination addresses are simply reversed,
      59:  00:E492                      ;      the type code changed to 0, and the checksum recomputed.
      60:  00:E492                      ;
      61:  00:E492                      ;   IP Fields:
      62:  00:E492                      ;
      63:  00:E492                      ;   Type
      64:  00:E492                      ;
      65:  00:E492                      ;      8 for echo message;
      66:  00:E492                      ;
      67:  00:E492                      ;      0 for echo reply message.
      68:  00:E492                      ;
      69:  00:E492                      ;   Code
      70:  00:E492                      ;
      71:  00:E492                      ;      0
      72:  00:E492                      ;
      73:  00:E492                      ;   Checksum
      74:  00:E492                      ;
      75:  00:E492                      ;      The checksum is the 16-bit ones's complement of the one's
      76:  00:E492                      ;      complement sum of the ICMP message starting with the ICMP Type.
      77:  00:E492                      ;      For computing the checksum , the checksum field should be zero.
      78:  00:E492                      ;      If the total length is odd, the received data is padded with one
      79:  00:E492                      ;      octet of zeros for computing the checksum.  This checksum may be
      80:  00:E492                      ;      replaced in the future.
      81:  00:E492                      ;
      82:  00:E492                      ;   Identifier
      83:  00:E492                      ;
      84:  00:E492                      ;      If code = 0, an identifier to aid in matching echos and replies,
      85:  00:E492                      ;      may be zero.
      86:  00:E492                      ;
      87:  00:E492  (00:4242)           OUR_ID		equ	4242h
      88:  00:E492                      ;
      89:  00:E492                      ;   Sequence Number
      90:  00:E492                      ;
      91:  00:E492                      ;      If code = 0, a sequence number to aid in matching echos and
      92:  00:E492                      ;      replies, may be zero.
      93:  00:E492                      ;
      94:  00:E492                      ;   Description
      95:  00:E492                      ;
      96:  00:E492                      ;      The data received in the echo message must be returned in the echo
      97:  00:E492                      ;      reply message.
      98:  00:E492                      ;
      99:  00:E492                      ;      The identifier and sequence number may be used by the echo sender
     100:  00:E492                      ;      to aid in matching the replies with the echo requests.  For
     101:  00:E492                      ;      example, the identifier might be used like a port in TCP or UDP to
     102:  00:E492                      ;      identify a session, and the sequence number might be incremented
     103:  00:E492                      ;      on each echo request sent.  The echoer returns these same values
     104:  00:E492                      ;      in the echo reply.
     105:  00:E492                      ;
     106:  00:E492                      ;      Code 0 may be received from a gateway or a host.
     107:  00:E492                      ;
     108:  00:E492                      ;==============================================================================
     109:  00:E492                      ; init
     110:  00:E492                      ;
     111:  00:E492                      ; In:  vars.ping.ip contains IP address
     112:  00:E492                      ; Out: Cy=>error occured
     113:  00:E492  AF                  init:		xor	a		; Always use socket 0
     114:  00:E493                      		SOCKET_GET_BASE
     114:  00:E493  11 00 01          >    ld de,0100h
     114:  00:E496  0F                >    rrca
     114:  00:E497  CB 1B             >    rr e
     114:  00:E499  0F                >    rrca
     114:  00:E49A  CB 1B             >    rr e
     114:  00:E49C  0F                >    rrca
     114:  00:E49D  CB 12             >    rl d
     115:  00:E49F                      ;
     116:  00:E49F                      		; We have to set SnPROTOR to the IP protocol number
     117:  00:E49F                      		; 01 (ICMP). SnPROTOR is a byte register that is half of
     118:  00:E49F                      		; 16-bit SnPORTOR (look carefully, one is PROT and one is PORT!) 
     119:  00:E49F                      		; The other half of SnPORTOR is SnKPALVTR and it is not clear
     120:  00:E49F                      		; if we have to preserve this for when this socket is re-used in
     121:  00:E49F                      		; TCP mode. So just in case we read SnKPALVTR first and write
     122:  00:E49F                      		; it back along with our new value for SnPROTOR.
     123:  00:E49F  3E 1A               		ld	a,w5300.Sn_PORTOR
     124:  00:E4A1  CD 39 D6            		call	socket.read_reg	; H=SnKPALVTR, L=SnPROT
     125:  00:E4A4  2E 01               		ld	l,1		; 1=>ICMP
     126:  00:E4A6  3E 1A               		ld	a,w5300.Sn_PORTOR
     127:  00:E4A8  CD 49 D6            		call	socket.write_reg
     128:  00:E4AB                      ;
     129:  00:E4AB  11 00 E6            		ld	de,owner_str	; Our name
     130:  00:E4AE  32 40 F0            		ld	(vars.ping.seq),a
     131:  00:E4B1  CD 09 DC            		call	ipraw.open_0	; Open socket in IP RAW mode
     132:  00:E4B4  38 0B               		jr	c,.end
     133:  00:E4B6                      ;
     134:  00:E4B6  06 05               		ld	b,5		; Do 5 pings/attempts
     135:  00:E4B8  C5                  .loop		push	bc
     136:  00:E4B9  CD C7 E4            		 call	do_ping
     137:  00:E4BC  C1                  		pop	bc
     138:  00:E4BD  38 02               		jr	c,.end
     139:  00:E4BF                      ;
     140:  00:E4BF  10 F7               		djnz	.loop
     141:  00:E4C1                      ;
     142:  00:E4C1  F5                  .end:		push	af		; Save error indication in Cy
     143:  00:E4C2  CD 71 DA            		 call	socket.close_0
     144:  00:E4C5  F1                  		pop	af
     145:  00:E4C6                      ;
     146:  00:E4C6  C9                  		ret
     147:  00:E4C7                      ;
     148:  00:E4C7                      ;
     149:  00:E4C7                      ;
     150:  00:E4C7                      ; Out: Cy=>error or STOP key
     151:  00:E4C7                      do_ping:
     152:  00:E4C7  11 05 D3            		ld	de,trace.ping.pinging
     153:  00:E4CA  CD 3D CE            		call	io.str		; "Pinging a.b.c.d..."
     154:  00:E4CD  21 3C F0            		ld	hl,vars.ping.ip
     155:  00:E4D0  CD 8C CD            		call	io.ip
     156:  00:E4D3  CD 3C D0            		call	trace.dots
     157:  00:E4D6                      ;
     158:  00:E4D6                      		; Normally send would return an error (Cy) if the IP address
     159:  00:E4D6                      		; does not exist (the WIZ chip does ARP stuff) but here we
     160:  00:E4D6                      		; just ignore an error return and let the timeout/retry
     161:  00:E4D6                      		; mechanism retry it
     162:  00:E4D6  CD B2 E5            		call	build		; Build ping packet
     163:  00:E4D9                      ;
     164:  00:E4D9  CD B5 CE            		call	status.start	; Start waiting indicator
     165:  00:E4DC                      ;
     166:  00:E4DC  ED 4B 06 F0         		ld	bc,(vars.ticks)	; Wait for start of tick
     167:  00:E4E0  2A 06 F0            .wait:		ld	hl,(vars.ticks)
     168:  00:E4E3  B7                  		or	a
     169:  00:E4E4  ED 42               		sbc	hl,bc
     170:  00:E4E6  28 F8               		jr	z,.wait
     171:  00:E4E8                      ;
     172:  00:E4E8  09                  		add	hl,bc
     173:  00:E4E9  22 19 F0            		ld	(vars.ping.start_ticks),hl	; Save ticks at start
     174:  00:E4EC                      ;
     175:  00:E4EC  21 3C F0            		ld	hl,vars.ping.ip	; HL->ip address
     176:  00:E4EF  CD 55 DC            		call	ipraw.send_0	; Send packet on socket 0
     177:  00:E4F2  30 07               		jr	nc,.loop	; Go if no error
     178:  00:E4F4                      ;
     179:  00:E4F4  CD 94 C9            		call	exos.is_stop	; See if it was due to stop key
     180:  00:E4F7  38 28               		jr	c,.ret		; Return with Cy if yes
     181:  00:E4F9                      ;
     182:  00:E4F9  18 1F               		jr	.timeout	; Else print timeout & continue
     183:  00:E4FB                      ;
     184:  00:E4FB                      		; Now wait for a reply for up to a second
     185:  00:E4FB  CD 75 D8            .loop:		call	socket.available_0; Packet received?
     186:  00:E4FE  20 27               		jr	nz,.gotreply
     187:  00:E500                      ;
     188:  00:E500  CD CA CE            		call	status.waiting	; Show waiting indicator
     189:  00:E503                      ;
     190:  00:E503  CD 94 C9            		call	exos.is_stop	; STOP key?
     191:  00:E506  38 19               		jr	c,.ret		; Go with C if yes
     192:  00:E508                      ;
     193:  00:E508  2A 06 F0            		ld	hl,(vars.ticks)		; HL=current ticks
     194:  00:E50B  ED 5B 19 F0         		ld	de,(vars.ping.start_ticks); DE=start ticks
     195:  00:E50F  B7                  		or	a
     196:  00:E510  ED 52               		sbc	hl,de		; HL=elapsed time in ticks
     197:  00:E512  11 32 00            		ld	de,TICKS_1s	; See if >= 1s timeout
     198:  00:E515  B7                  		or	a
     199:  00:E516  ED 52               		sbc	hl,de
     200:  00:E518  38 E1               		jr	c,.loop		; Keep waiting if no timeout
     201:  00:E51A                      ;
     202:  00:E51A  11 89 D3            .timeout:	ld	de,trace.timeout_str
     203:  00:E51D  CD 3D CE            .okret:		call	io.str		; Print ok or timeout
     204:  00:E520  B7                  		or	a		; NC cos not a fatal error
     205:  00:E521  F5                  .ret:		push	af		; Save Cy
     206:  00:E522  CD A9 CE            		call	status.stop	; Turn off waiting indicator
     207:  00:E525  F1                  		pop	af		; Restore Cy error indicator
     208:  00:E526  C9                  		ret
     209:  00:E527                      ;
     210:  00:E527  2A 06 F0            .gotreply:	ld	hl,(vars.ticks)
     211:  00:E52A  22 1B F0            		ld	(vars.ping.end_ticks),hl
     212:  00:E52D                      ;
     213:  00:E52D  CD 10 DC            		call	ipraw.header_0	; Read header
     214:  00:E530                      ;
     215:  00:E530  21 11 F0            		ld	hl,vars.icmp.ip
     216:  00:E533  11 3C F0            		ld	de,vars.ping.ip
     217:  00:E536  CD 32 CF            		call	util.ipcmp
     218:  00:E539  37                  		scf
     219:  00:E53A  20 1D               		jr	nz,.rejectheader
     220:  00:E53C                      
     221:  00:E53C  2A 15 F0            		ld	hl,(vars.icmp.size); Make sure enough bytes received
     222:  00:E53F  01 08 00            		ld	bc,vars.ping.packet_size
     223:  00:E542  B7                  		or	a
     224:  00:E543  ED 42               		sbc	hl,bc
     225:  00:E545  38 12               		jr	c,.rejectheader		; Go with Cy if not enough
     226:  00:E547                      ;
     227:  00:E547  21 00 F3            		ld	hl,vars.ping.packet	; Read packet start
     228:  00:E54A  01 08 00            		ld	bc,vars.ping.packet_size
     229:  00:E54D                      ;
     230:  00:E54D  CD AB D8            		call	socket.read_0		; Read packet
     231:  00:E550                      ;
     232:  00:E550  2A 15 F0            		ld	hl,(vars.icmp.size)
     233:  00:E553  01 08 00            		ld	bc,vars.ping.packet_size
     234:  00:E556  B7                  		or	a
     235:  00:E557  ED 42               		sbc	hl,bc			; HL=amount left to read
     236:  00:E559                      ;
     237:  00:E559                      .rejectheader:
     238:  00:E559  F5                  .readrest:	push	af
     239:  00:E55A  CD 28 D9            		 call	socket.read_flush_0	; Read remainder of packet
     240:  00:E55D  F1                  		pop	af
     241:  00:E55E  DA FB E4            		jp	c,.loop			; Reject header
     242:  00:E561                      ;
     243:  00:E561  21 00 F3            		ld	hl,vars.ping.packet
     244:  00:E564  01 08 00            		ld	bc,vars.ping.packet_size
     245:  00:E567  CD E5 E5            		call	checksum
     246:  00:E56A  7C                  		ld	a,h
     247:  00:E56B  B5                  		or	l
     248:  00:E56C  C2 FB E4            		jp	nz,.loop		; Ignore packet
     249:  00:E56F                       
     250:  00:E56F  3A 00 F3            		ld	a,(vars.ping.packet.type)
     251:  00:E572  B7                  		or	a			; Type should be 0 for reply
     252:  00:E573  C2 FB E4            		jp	nz,.loop		; Ignore packet
     253:  00:E576                      ;
     254:  00:E576  3A 01 F3            		ld	a,(vars.ping.packet.code)
     255:  00:E579  B7                  		or	a			; Code should be 0 for reply
     256:  00:E57A  C2 FB E4            		jp	nz,.loop		; Ignore packet
     257:  00:E57D                      ;
     258:  00:E57D  2A 04 F3            		ld	hl,(vars.ping.packet.id); Check it's our id
     259:  00:E580  11 42 42            		ld	de,OUR_ID
     260:  00:E583  ED 52               		sbc	hl,de
     261:  00:E585  7C                  		ld	a,h
     262:  00:E586  B5                  		or	l
     263:  00:E587  C2 FB E4            		jp	nz,.loop
     264:  00:E58A                      ;
     265:  00:E58A  ED 4B 19 F0         		ld	bc,(vars.ping.start_ticks)
     266:  00:E58E  2A 1B F0            		ld	hl,(vars.ping.end_ticks)
     267:  00:E591  B7                  		or	a
     268:  00:E592  ED 42               		sbc	hl,bc			; HL=# ticks elapsed
     269:  00:E594  11 AA E5            		ld	de,lt20mS_str
     270:  00:E597  28 0E               		jr	z,.printmS		; Print "<20mS" if ticks=0
     271:  00:E599                      ;
     272:  00:E599  23                  		inc	hl			; x20 to get mS, 1=>40, 2=>80 etc
     273:  00:E59A  29                  		add	hl,hl			; ticks*2
     274:  00:E59B  4D                  		ld	c,l
     275:  00:E59C  44                  		ld	b,h			; BC=ticks*2
     276:  00:E59D  29                  		add	hl,hl			; ticks*4
     277:  00:E59E  29                  		add	hl,hl			; ticks*8
     278:  00:E59F  09                  		add	hl,bc			; ticks*10
     279:  00:E5A0  29                  		add	hl,hl			; ticks*20
     280:  00:E5A1  CD B1 CD            		call	io.int			; Print it
     281:  00:E5A4  11 AD E5            		ld	de,mS_str
     282:  00:E5A7  C3 1D E5            .printmS:	jp	.okret
     283:  00:E5AA                      ;
     284:  00:E5AA  3C 32 30            lt20mS_str:	db	"<20"		; No null as includes next string
     285:  00:E5AD  6D 53 0D 0A 00      mS_str:		db	"mS",CR,LF,0
     286:  00:E5B2                      
     287:  00:E5B2                      ;
     288:  00:E5B2                      ;------------------------------------------------------------------------------
     289:  00:E5B2  11 00 F3            build:		ld	de,vars.ping.packet
     290:  00:E5B5  D5                  		push	de
     291:  00:E5B6  21 DD E5            		 ld	hl,packet
     292:  00:E5B9  01 08 00            		 ld	bc,packet_size
     293:  00:E5BC  ED B0               		 ldir				; Copy fixed packet to buffer
     294:  00:E5BE                      ;
     295:  00:E5BE  21 40 F0            		 ld	hl,vars.ping.seq	; Put sequence # in packet
     296:  00:E5C1  34                  		 inc	(hl)
     297:  00:E5C2  7E                  		 ld	a,(hl)
     298:  00:E5C3  32 07 F3            		 ld	(vars.ping.packet.seq+1),a; Use network byte order!
     299:  00:E5C6                      ;
     300:  00:E5C6  E1                  		pop	hl			; HL->packet
     301:  00:E5C7  E5                  		push	hl
     302:  00:E5C8                      ;
     303:  00:E5C8  01 08 00            		 ld	bc,vars.ping.packet_size
     304:  00:E5CB  C5                  		 push	bc
     305:  00:E5CC  CD E5 E5            		  call	checksum
     306:  00:E5CF  7C                  		  ld	a,h
     307:  00:E5D0  65                  		  ld	h,l
     308:  00:E5D1  6F                  		  ld	l,a
     309:  00:E5D2  22 02 F3            		  ld	(vars.ping.packet.csum),hl
     310:  00:E5D5  C1                  		 pop	bc			; BC=byte count
     311:  00:E5D6                      ;
     312:  00:E5D6  E1                  		pop	hl			; HL->data
     313:  00:E5D7                      ;
     314:  00:E5D7  C5                  		push	bc
     315:  00:E5D8  CD 8B D9            		 call	socket.write_0
     316:  00:E5DB  E1                  		pop	hl			; HL=bytes sent
     317:  00:E5DC                      ;
     318:  00:E5DC  C9                  		ret
     319:  00:E5DD                      ;
     320:  00:E5DD  08                  packet:		db	8			; Type 8 = echo
     321:  00:E5DE  00                  		db	0			; Code always 0
     322:  00:E5DF  00 00               		dw	0			; Checksum 0 for now
     323:  00:E5E1  42 42               		dw	OUR_ID			; Identifier
     324:  00:E5E3  00 00               		db	0, 0			; Sequence 0
     325:  00:E5E5  (00:0008)           packet_size	equ	$-packet
     326:  00:E5E5                      ;
     327:  00:E5E5                      ;------------------------------------------------------------------------------
     328:  00:E5E5                      ; checksum
     329:  00:E5E5                      ;
     330:  00:E5E5                      ; Calculates a checksum for a ICMP packet.
     331:  00:E5E5                      ;
     332:  00:E5E5                      ; "The checksum is the 16-bit one's complement of the one's complement sum of
     333:  00:E5E5                      ; the ICMP message starting with the ICMP type".
     334:  00:E5E5                      ;
     335:  00:E5E5                      ; In:  HL->data
     336:  00:E5E5                      ;      BC=byte count but must be even
     337:  00:E5E5  EB                  checksum:	ex	de,hl		; DE->data
     338:  00:E5E6  B7                  		or	a
     339:  00:E5E7  ED 62               		sbc	hl,hl		; Initial checksum
     340:  00:E5E9  13                  .loop:		inc	de		; Do low byte first
     341:  00:E5EA  1A                  		ld	a,(de)
     342:  00:E5EB  85                  		add	a,l
     343:  00:E5EC  6F                  		ld	l,a
     344:  00:E5ED                      ;
     345:  00:E5ED  1B                  		dec	de		; Then high byte
     346:  00:E5EE  1A                  		ld	a,(de)
     347:  00:E5EF  8C                  		adc	a,h
     348:  00:E5F0  67                  		ld	h,a
     349:  00:E5F1                      ;
     350:  00:E5F1  13                  		inc	de		; Move on to next word
     351:  00:E5F2  13                  		inc	de
     352:  00:E5F3                      ;
     353:  00:E5F3  0B                  		dec	bc
     354:  00:E5F4  0B                  		dec	bc
     355:  00:E5F5  78                  		ld	a,b
     356:  00:E5F6  B1                  		or	c
     357:  00:E5F7  20 F0               		jr	nz,.loop
     358:  00:E5F9                      ;
     359:  00:E5F9  EB                  		ex	de,hl		; DE=checksum
     360:  00:E5FA  ED 62               		sbc	hl,hl		; HL=0
     361:  00:E5FC  ED 52               		sbc	hl,de		; HL=2s complement
     362:  00:E5FE  2B                  		dec	hl		; HL=1s complement
     363:  00:E5FF  C9                  		ret
     364:  00:E600                      ;
     365:  00:E600                      ;
     366:  00:E600  50 49 4E 47 00      owner_str:	db	"PING",0
     367:  00:E605                      ;
     368:  00:E605                      ;
     369:  00:E605                      ;
     370:  00:E605                      		endmodule
     109.  00:E605                      	include	ntp.asm
       1:  00:E605                      ; NTP
       2:  00:E605                      ;
       3:  00:E605                      ; Attempts to obtain the current date and time using the Simple Network Time
       4:  00:E605                      ; Protocol
       5:  00:E605                      ;
       6:  00:E605                      		module	ntp
       7:  00:E605                      ;
       8:  00:E605                      ;==============================================================================
       9:  00:E605                      ;
      10:  00:E605                      ; This file is part of the EPNET software
      11:  00:E605                      ;
      12:  00:E605                      ; Copyright (C) 2015  Bruce Tanner
      13:  00:E605                      ;
      14:  00:E605                      ;    This program is free software: you can redistribute it and/or modify
      15:  00:E605                      ;    it under the terms of the GNU General Public License as published by
      16:  00:E605                      ;    the Free Software Foundation, either version 3 of the License, or
      17:  00:E605                      ;    (at your option) any later version.
      18:  00:E605                      ;
      19:  00:E605                      ;    This program is distributed in the hope that it will be useful,
      20:  00:E605                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      21:  00:E605                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      22:  00:E605                      ;    GNU General Public License for more details.
      23:  00:E605                      ;
      24:  00:E605                      ;    You should have received a copy of the GNU General Public License
      25:  00:E605                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      26:  00:E605                      ;
      27:  00:E605                      ; If you do use or modify this file, either for its original purpose or for
      28:  00:E605                      ; something new, I'd love to hear about it! I can be contacted by email at:
      29:  00:E605                      ;
      30:  00:E605                      ; brucetanner@btopenworld.com
      31:  00:E605                      ;
      32:  00:E605                      ;==============================================================================
      33:  00:E605                      ;
      34:  00:E605                      ; For reference, this is the interesting bit of RFC 4330:
      35:  00:E605                      ;
      36:  00:E605                      ;3.  NTP Timestamp Format
      37:  00:E605                      ;
      38:  00:E605                      ;   SNTP uses the standard NTP timestamp format described in RFC 1305 and
      39:  00:E605                      ;   previous versions of that document.  In conformance with standard
      40:  00:E605                      ;   Internet practice, NTP data are specified as integer or fixed-point
      41:  00:E605                      ;   quantities, with bits numbered in big-endian fashion from 0 starting
      42:  00:E605                      ;   at the left or most significant end.  Unless specified otherwise, all
      43:  00:E605                      ;   quantities are unsigned and may occupy the full field width with an
      44:  00:E605                      ;   implied 0 preceding bit 0.
      45:  00:E605                      ;
      46:  00:E605                      ;   Because NTP timestamps are cherished data and, in fact, represent the
      47:  00:E605                      ;   main product of the protocol, a special timestamp format has been
      48:  00:E605                      ;   established.  NTP timestamps are represented as a 64-bit unsigned
      49:  00:E605                      ;   fixed-point number, in seconds relative to 0h on 1 January 1900.  The
      50:  00:E605                      ;   integer part is in the first 32 bits, and the fraction part in the
      51:  00:E605                      ;   last 32 bits.  In the fraction part, the non-significant low-order
      52:  00:E605                      ;   bits are not specified and are ordinarily set to 0.
      53:  00:E605                      ;
      54:  00:E605                      ;      It is advisable to fill the non-significant low-order bits of the
      55:  00:E605                      ;      timestamp with a random, unbiased bitstring, both to avoid
      56:  00:E605                      ;      systematic roundoff errors and to provide loop detection and
      57:  00:E605                      ;      replay detection (see below).  It is important that the bitstring
      58:  00:E605                      ;      be unpredictable by an intruder.  One way of doing this is to
      59:  00:E605                      ;      generate a random 128-bit bitstring at startup.  After that, each
      60:  00:E605                      ;      time the system clock is read, the string consisting of the
      61:  00:E605                      ;      timestamp and bitstring is hashed with the MD5 algorithm, then the
      62:  00:E605                      ;      non-significant bits of the timestamp are copied from the result.
      63:  00:E605                      ;
      64:  00:E605                      ;   The NTP format allows convenient multiple-precision arithmetic and
      65:  00:E605                      ;   conversion to UDP/TIME message (seconds), but does complicate the
      66:  00:E605                      ;   conversion to ICMP Timestamp message (milliseconds) and Unix time
      67:  00:E605                      ;   values (seconds and microseconds or seconds and nanoseconds).  The
      68:  00:E605                      ;   maximum number that can be represented is 4,294,967,295 seconds with
      69:  00:E605                      ;   a precision of about 232 picoseconds, which should be adequate for
      70:  00:E605                      ;   even the most exotic requirements.
      71:  00:E605                      ;
      72:  00:E605                      ;                           1                   2                   3
      73:  00:E605                      ;       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      74:  00:E605                      ;      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      75:  00:E605                      ;      |                           Seconds                             |
      76:  00:E605                      ;      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      77:  00:E605                      ;      |                  Seconds Fraction (0-padded)                  |
      78:  00:E605                      ;      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      79:  00:E605                      ;
      80:  00:E605                      ;   Note that since some time in 1968 (second 2,147,483,648), the most
      81:  00:E605                      ;   significant bit (bit 0 of the integer part) has been set and that the
      82:  00:E605                      ;   64-bit field will overflow some time in 2036 (second 4,294,967,296).
      83:  00:E605                      ;   There will exist a 232-picosecond interval, henceforth ignored, every
      84:  00:E605                      ;   136 years when the 64-bit field will be 0, which by convention is
      85:  00:E605                      ;   interpreted as an invalid or unavailable timestamp.
      86:  00:E605                      ;
      87:  00:E605                      ;      As the NTP timestamp format has been in use for over 20 years, it
      88:  00:E605                      ;      is possible that it will be in use 32 years from now, when the
      89:  00:E605                      ;      seconds field overflows.  As it is probably inappropriate to
      90:  00:E605                      ;      archive NTP timestamps before bit 0 was set in 1968, a convenient
      91:  00:E605                      ;      way to extend the useful life of NTP timestamps is the following
      92:  00:E605                      ;      convention: If bit 0 is set, the UTC time is in the range 1968-
      93:  00:E605                      ;      2036, and UTC time is reckoned from 0h 0m 0s UTC on 1 January
      94:  00:E605                      ;      1900.  If bit 0 is not set, the time is in the range 2036-2104 and
      95:  00:E605                      ;      UTC time is reckoned from 6h 28m 16s UTC on 7 February 2036.  Note
      96:  00:E605                      ;      that when calculating the correspondence, 2000 is a leap year, and
      97:  00:E605                      ;      leap seconds are not included in the reckoning.
      98:  00:E605                      ;
      99:  00:E605                      ;      The arithmetic calculations used by NTP to determine the clock
     100:  00:E605                      ;      offset and roundtrip delay require the client time to be within 34
     101:  00:E605                      ;      years of the server time before the client is launched.  As the
     102:  00:E605                      ;      time since the Unix base 1970 is now more than 34 years, means
     103:  00:E605                      ;      must be available to initialize the clock at a date closer to the
     104:  00:E605                      ;      present, either with a time-of-year (TOY) chip or from firmware.
     105:  00:E605                      ;
     106:  00:E605                      ; 4.  Message Format
     107:  00:E605                      ;
     108:  00:E605                      ;   Both NTP and SNTP are clients of the User Datagram Protocol (UDP)
     109:  00:E605                      ;   specified in RFC 768 [POS80].  The structures of the IP and UDP
     110:  00:E605                      ;   headers are described in the cited specification documents and will
     111:  00:E605                      ;   not be detailed further here.  The UDP port number assigned by the
     112:  00:E605                      ;   IANA to NTP is 123.  The SNTP client should use this value in the UDP
     113:  00:E605                      ;   Destination Port field for client request messages.  The Source Port
     114:  00:E605                      ;   field of these messages can be any nonzero value chosen for
     115:  00:E605                      ;   identification or multiplexing purposes.  The server interchanges
     116:  00:E605                      ;   these fields for the corresponding reply messages.
     117:  00:E605                      ;
     118:  00:E605                      ;      This differs from the RFC 2030 specifications, which required both
     119:  00:E605                      ;      the source and destination ports to be 123.  The intent of this
     120:  00:E605                      ;      change is to allow the identification of particular client
     121:  00:E605                      ;      implementations (which are now allowed to use unreserved port
     122:  00:E605                      ;      numbers, including ones of their choosing) and to attain
     123:  00:E605                      ;      compatibility with Network Address Port Translation (NAPT)
     124:  00:E605                      ;      described in RFC 2663 [SRI99] and RFC 3022 [SRI01].
     125:  00:E605                      ;
     126:  00:E605  (00:007B)           NTP_CLIENT_PORT		equ	123
     127:  00:E605  (00:007B)           NTP_SERVER_PORT		equ	123
     128:  00:E605                      ;
     129:  00:E605                      ;   Figure 1 is a description of the NTP and SNTP message format, which
     130:  00:E605                      ;   follows the IP and UDP headers in the message.  This format is
     131:  00:E605                      ;   identical to the NTP message format described in RFC 1305, with the
     132:  00:E605                      ;   exception of the Reference Identifier field described below.  For
     133:  00:E605                      ;   SNTP client messages, most of these fields are zero or initialized
     134:  00:E605                      ;   with pre-specified data.  For completeness, the function of each
     135:  00:E605                      ;   field is briefly summarized below.
     136:  00:E605                      ;
     137:  00:E605                      ;                           1                   2                   3
     138:  00:E605                      ;       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     139:  00:E605                      ;   0: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     140:  00:E605                      ;      |LI | VN  |Mode |    Stratum    |     Poll      |   Precision   |
     141:  00:E605                      ;   4: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     142:  00:E605                      ;      |                          Root  Delay                          |
     143:  00:E605                      ;   8: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     144:  00:E605                      ;      |                       Root  Dispersion                        |
     145:  00:E605                      ;  12: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     146:  00:E605                      ;      |                     Reference Identifier                      |
     147:  00:E605                      ;  16: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     148:  00:E605                      ;      |                                                               |
     149:  00:E605                      ;      |                    Reference Timestamp (64)                   |
     150:  00:E605                      ;      |                                                               |
     151:  00:E605                      ;  24: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     152:  00:E605                      ;      |                                                               |
     153:  00:E605                      ;      |                    Originate Timestamp (64)                   |
     154:  00:E605                      ;      |                                                               |
     155:  00:E605                      ;  32: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     156:  00:E605                      ;      |                                                               |
     157:  00:E605                      ;      |                     Receive Timestamp (64)                    |
     158:  00:E605                      ;      |                                                               |
     159:  00:E605                      ;  40: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     160:  00:E605                      ;      |                                                               |
     161:  00:E605                      ;      |                     Transmit Timestamp (64)                   |
     162:  00:E605                      ;      |                                                               |
     163:  00:E605                      ;  48: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     164:  00:E605                      ;      |                 Key Identifier (optional) (32)                |
     165:  00:E605                      ;      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     166:  00:E605                      ;      |                                                               |
     167:  00:E605                      ;      |                                                               |
     168:  00:E605                      ;      |                 Message Digest (optional) (128)               |
     169:  00:E605                      ;      |                                                               |
     170:  00:E605                      ;      |                                                               |
     171:  00:E605                      ;      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     172:  00:E605                      ;
     173:  00:E605                      ;                        Figure 1.  NTP Packet Header
     174:  00:E605                      ;
     175:  00:E605                      ;   Leap Indicator (LI): This is a two-bit code warning of an impending
     176:  00:E605                      ;   leap second to be inserted/deleted in the last minute of the current
     177:  00:E605                      ;   day.  This field is significant only in server messages, where the
     178:  00:E605                      ;   values are defined as follows:
     179:  00:E605                      ;
     180:  00:E605                      ;      LI       Meaning
     181:  00:E605                      ;      ---------------------------------------------
     182:  00:E605                      ;      0        no warning
     183:  00:E605                      ;      1        last minute has 61 seconds
     184:  00:E605                      ;      2        last minute has 59 seconds
     185:  00:E605                      ;      3        alarm condition (clock not synchronized)
     186:  00:E605                      ;
     187:  00:E605                      ;   On startup, servers set this field to 3 (clock not synchronized), and
     188:  00:E605                      ;   set this field to some other value when synchronized to the primary
     189:  00:E605                      ;   reference clock.  Once set to a value other than 3, the field is
     190:  00:E605                      ;   never set to that value again, even if all synchronization sources
     191:  00:E605                      ;   become unreachable or defective.
     192:  00:E605                      ;
     193:  00:E605                      ;   Version Number (VN): This is a three-bit integer indicating the
     194:  00:E605                      ;   NTP/SNTP version number, currently 4.  If necessary to distinguish
     195:  00:E605                      ;   between IPv4, IPv6, and OSI, the encapsulating context must be
     196:  00:E605                      ;   inspected.
     197:  00:E605                      ;
     198:  00:E605                      ;   Mode: This is a three-bit number indicating the protocol mode.  The
     199:  00:E605                      ;   values are defined as follows:
     200:  00:E605                      ;
     201:  00:E605                      ;      Mode     Meaning
     202:  00:E605                      ;      ------------------------------------
     203:  00:E605                      ;      0        reserved
     204:  00:E605                      ;      1        symmetric active
     205:  00:E605                      ;      2        symmetric passive
     206:  00:E605                      ;      3        client
     207:  00:E605                      ;      4        server
     208:  00:E605                      ;      5        broadcast
     209:  00:E605                      ;      6        reserved for NTP control message
     210:  00:E605                      ;      7        reserved for private use
     211:  00:E605                      ;
     212:  00:E605                      ;   In unicast and manycast modes, the client sets this field to 3
     213:  00:E605                      ;   (client) in the request, and the server sets it to 4 (server) in the
     214:  00:E605                      ;   reply.  In broadcast mode, the server sets this field to 5
     215:  00:E605                      ;   (broadcast).  The other modes are not used by SNTP servers and
     216:  00:E605                      ;   clients.
     217:  00:E605                      ;
     218:  00:E605                      ;   Stratum: This is an eight-bit unsigned integer indicating the
     219:  00:E605                      ;   stratum.  This field is significant only in SNTP server messages,
     220:  00:E605                      ;   where the values are defined as follows:
     221:  00:E605                      ;
     222:  00:E605                      ;      Stratum  Meaning
     223:  00:E605                      ;      ----------------------------------------------
     224:  00:E605                      ;      0        kiss-o'-death message (see below)
     225:  00:E605                      ;      1        primary reference (e.g., synchronized by radio clock)
     226:  00:E605                      ;      2-15     secondary reference (synchronized by NTP or SNTP)
     227:  00:E605                      ;      16-255   reserved
     228:  00:E605                      ;
     229:  00:E605                      ;   Poll Interval: This is an eight-bit unsigned integer used as an
     230:  00:E605                      ;   exponent of two, where the resulting value is the maximum interval
     231:  00:E605                      ;   between successive messages in seconds.  This field is significant
     232:  00:E605                      ;   only in SNTP server messages, where the values range from 4 (16 s) to
     233:  00:E605                      ;   17 (131,072 s -- about 36 h).
     234:  00:E605                      ;
     235:  00:E605                      ;   Precision: This is an eight-bit signed integer used as an exponent of
     236:  00:E605                      ;   two, where the resulting value is the precision of the system clock
     237:  00:E605                      ;   in seconds.  This field is significant only in server messages, where
     238:  00:E605                      ;   the values range from -6 for mains-frequency clocks to -20 for
     239:  00:E605                      ;   microsecond clocks found in some workstations.
     240:  00:E605                      ;
     241:  00:E605                      ;   Root Delay: This is a 32-bit signed fixed-point number indicating the
     242:  00:E605                      ;   total roundtrip delay to the primary reference source, in seconds
     243:  00:E605                      ;   with the fraction point between bits 15 and 16.  Note that this
     244:  00:E605                      ;   variable can take on both positive and negative values, depending on
     245:  00:E605                      ;   the relative time and frequency offsets.  This field is significant
     246:  00:E605                      ;   only in server messages, where the values range from negative values
     247:  00:E605                      ;   of a few milliseconds to positive values of several hundred
     248:  00:E605                      ;   milliseconds.
     249:  00:E605                      ;
     250:  00:E605                      ;      Code       External Reference Source
     251:  00:E605                      ;      ------------------------------------------------------------------
     252:  00:E605                      ;      LOCL       uncalibrated local clock
     253:  00:E605                      ;      CESM       calibrated Cesium clock
     254:  00:E605                      ;      RBDM       calibrated Rubidium clock
     255:  00:E605                      ;      PPS        calibrated quartz clock or other pulse-per-second
     256:  00:E605                      ;                 source
     257:  00:E605                      ;      IRIG       Inter-Range Instrumentation Group
     258:  00:E605                      ;      ACTS       NIST telephone modem service
     259:  00:E605                      ;      USNO       USNO telephone modem service
     260:  00:E605                      ;      PTB        PTB (Germany) telephone modem service
     261:  00:E605                      ;      TDF        Allouis (France) Radio 164 kHz
     262:  00:E605                      ;      DCF        Mainflingen (Germany) Radio 77.5 kHz
     263:  00:E605                      ;      MSF        Rugby (UK) Radio 60 kHz
     264:  00:E605                      ;      WWV        Ft. Collins (US) Radio 2.5, 5, 10, 15, 20 MHz
     265:  00:E605                      ;      WWVB       Boulder (US) Radio 60 kHz
     266:  00:E605                      ;      WWVH       Kauai Hawaii (US) Radio 2.5, 5, 10, 15 MHz
     267:  00:E605                      ;      CHU        Ottawa (Canada) Radio 3330, 7335, 14670 kHz
     268:  00:E605                      ;      LORC       LORAN-C radionavigation system
     269:  00:E605                      ;      OMEG       OMEGA radionavigation system
     270:  00:E605                      ;      GPS        Global Positioning Service
     271:  00:E605                      ;
     272:  00:E605                      ;                     Figure 2.  Reference Identifier Codes
     273:  00:E605                      ;
     274:  00:E605                      ;   Root Dispersion: This is a 32-bit unsigned fixed-point number
     275:  00:E605                      ;   indicating the maximum error due to the clock frequency tolerance, in
     276:  00:E605                      ;   seconds with the fraction point between bits 15 and 16.  This field
     277:  00:E605                      ;   is significant only in server messages, where the values range from
     278:  00:E605                      ;   zero to several hundred milliseconds.
     279:  00:E605                      ;
     280:  00:E605                      ;   Reference Identifier: This is a 32-bit bitstring identifying the
     281:  00:E605                      ;   particular reference source.  This field is significant only in
     282:  00:E605                      ;   server messages, where for stratum 0 (kiss-o'-death message) and 1
     283:  00:E605                      ;   (primary server), the value is a four-character ASCII string, left
     284:  00:E605                      ;   justified and zero padded to 32 bits.  For IPv4 secondary servers,
     285:  00:E605                      ;   the value is the 32-bit IPv4 address of the synchronization source.
     286:  00:E605                      ;   For IPv6 and OSI secondary servers, the value is the first 32 bits of
     287:  00:E605                      ;   the MD5 hash of the IPv6 or NSAP address of the synchronization
     288:  00:E605                      ;   source.
     289:  00:E605                      ;
     290:  00:E605                      ;   Primary (stratum 1) servers set this field to a code identifying the
     291:  00:E605                      ;   external reference source according to Figure 2.  If the external
     292:  00:E605                      ;   reference is one of those listed, the associated code should be used.
     293:  00:E605                      ;   Codes for sources not listed can be contrived, as appropriate.
     294:  00:E605                      ;
     295:  00:E605                      ;      In previous NTP and SNTP secondary servers and clients, this field
     296:  00:E605                      ;      was often used to walk-back the synchronization subnet to the root
     297:  00:E605                      ;      (primary server) for management purposes.  In SNTPv4 with IPv6 or
     298:  00:E605                      ;      OSI, this feature is not available, because the addresses are
     299:  00:E605                      ;      longer than 32 bits, and only a hash is available.  However, a
     300:  00:E605                      ;      walk-back can be accomplished using the NTP control message and
     301:  00:E605                      ;      the reference identifier field described in RFC 1305.
     302:  00:E605                      ;
     303:  00:E605                      ;   Reference Timestamp: This field is the time the system clock was last
     304:  00:E605                      ;   set or corrected, in 64-bit timestamp format.
     305:  00:E605                      ;
     306:  00:E605                      ;   Originate Timestamp: This is the time at which the request departed
     307:  00:E605                      ;   the client for the server, in 64-bit timestamp format.
     308:  00:E605                      ;
     309:  00:E605                      ;   Receive Timestamp: This is the time at which the request arrived at
     310:  00:E605                      ;   the server or the reply arrived at the client, in 64-bit timestamp
     311:  00:E605                      ;   format.
     312:  00:E605                      ;
     313:  00:E605                      ;   Transmit Timestamp: This is the time at which the request departed
     314:  00:E605                      ;   the client or the reply departed the server, in 64-bit timestamp
     315:  00:E605                      ;   format.
     316:  00:E605                      ;
     317:  00:E605                      ;   Authenticator (optional): When the NTP authentication scheme is
     318:  00:E605                      ;   implemented, the Key Identifier and Message Digest fields contain the
     319:  00:E605                      ;   message authentication code (MAC) information defined in Appendix C
     320:  00:E605                      ;   of RFC 1305.
     321:  00:E605                      ;
     322:  00:E605                      ;------------------------------------------------------------------------------
     323:  00:E605                      ; init
     324:  00:E605                      ;
     325:  00:E605                      ; Called to get the current time.
     326:  00:E605                      ;
     327:  00:E605                      ; dhcp.dns must contain the time server ip address.
     328:  00:E605                      ;
     329:  00:E605                      ; Out:  NC=>ok
     330:  00:E605                      ;
     331:  00:E605                      init:
     332:  00:E605  11 63 D1            		ld	de,trace.diag.ntp	; Diag mode trace
     333:  00:E608  CD EF CF            		call	trace.diag.str
     334:  00:E60B                      ;
     335:  00:E60B  AF                  		xor	a
     336:  00:E60C  32 1B F0            		ld	(vars.ntp.retries),a
     337:  00:E60F                      ;
     338:  00:E60F  CD B5 CE            		call	status.start	; Start waiting indicator
     339:  00:E612                      ;
     340:  00:E612  11 30 E7            		ld	de,owner_str	; Our name
     341:  00:E615  21 7B 00            		ld	hl,NTP_CLIENT_PORT	; Always use this port
     342:  00:E618  CD 8F DC            		call	udp.open_0	; Open socket
     343:  00:E61B  38 02               		jr	c,.error
     344:  00:E61D                      ;
     345:  00:E61D  18 0F               		jr	.start
     346:  00:E61F                      ;
     347:  00:E61F  FD CB 00 66         .error:		bit	vars.trace.ntp,(iy+vars._trace)
     348:  00:E623  C4 53 D0            		call	nz,trace.error
     349:  00:E626                      ;
     350:  00:E626  CD 71 DA            .abort:		call	socket.close_0
     351:  00:E629  CD A9 CE            		call	status.stop	; Stop waiting indicator
     352:  00:E62C  37                  		scf
     353:  00:E62D  C9                  		ret
     354:  00:E62E                      ;
     355:  00:E62E                      .start:
     356:  00:E62E  21 1B F0            		ld	hl,vars.ntp.retries
     357:  00:E631  34                  		inc	(hl)
     358:  00:E632  3E 0A               		ld	a,10
     359:  00:E634  BE                  		cp	(hl)
     360:  00:E635  38 E8               		jr	c,.error	; Try 10 times, then give up
     361:  00:E637                      ;
     362:  00:E637  CD C7 E6            		call	send		; Send a time request
     363:  00:E63A  38 E3               		jr	c,.error
     364:  00:E63C                      ;
     365:  00:E63C                      		; Wait for a replay with timeout
     366:  00:E63C  2A 06 F0            		ld	hl,(vars.ticks)
     367:  00:E63F  22 19 F0            		ld	(vars.ntp.timeout),hl
     368:  00:E642  CD 96 DC            .loop:		call	udp.header_0
     369:  00:E645  20 2B               		jr	nz,.gotpacket
     370:  00:E647                      ;
     371:  00:E647  CD CA CE            		call	status.waiting	; Flash status indicator
     372:  00:E64A                      ;
     373:  00:E64A  CD 94 C9            		call	exos.is_stop
     374:  00:E64D  38 D7               		jr	c,.abort
     375:  00:E64F                      ;
     376:  00:E64F  ED 5B 19 F0         		ld	de,(vars.ntp.timeout)
     377:  00:E653  2A 06 F0            		ld	hl,(vars.ticks)
     378:  00:E656  B7                  		or	a
     379:  00:E657  ED 52               		sbc	hl,de		; HL=duration so far
     380:  00:E659  11 32 00            		ld	de,TICKS_1s	; 1S timout in ticks
     381:  00:E65C  ED 52               		sbc	hl,de
     382:  00:E65E  38 E2               		jr	c,.loop		; Keep waiting if not timed out
     383:  00:E660                      ;
     384:  00:E660  FD CB 00 66         		bit	vars.trace.ntp,(iy+vars._trace)
     385:  00:E664  C4 4E D0            		call	nz,trace.timeout
     386:  00:E667                      ;
     387:  00:E667  18 C5               		jr	.start		; Timed out...send req again
     388:  00:E669                      ;
     389:  00:E669  FD CB 00 66         .badpacket:	bit	vars.trace.ntp,(iy+vars._trace)
     390:  00:E66D  C4 53 D0            		call	nz,trace.error
     391:  00:E670  18 BC               		jr	.start
     392:  00:E672                      ;
     393:  00:E672                      .gotpacket:
     394:  00:E672  FD CB 00 66         		bit	vars.trace.ntp,(iy+vars._trace)
     395:  00:E676  28 09               		jr	z,.donetrace
     396:  00:E678                      ;
     397:  00:E678  CD 23 CE            		call	io.start
     398:  00:E67B  11 21 D3            		ld	de,trace.ntp.rx
     399:  00:E67E  CD 3D CE            		call	io.str
     400:  00:E681                      .donetrace:
     401:  00:E681                      ;
     402:  00:E681  B7                  		or	a
     403:  00:E682  01 30 00            		ld	bc,vars.ntp.packet_size
     404:  00:E685  ED 42               		sbc	hl,bc
     405:  00:E687  38 E0               		jr	c,.badpacket	; Too small - ignore
     406:  00:E689                      ;
     407:  00:E689  21 00 F3            		ld	hl,vars.ntp.packet
     408:  00:E68C  01 30 00            		ld	bc,vars.ntp.packet_size
     409:  00:E68F  CD AB D8            		call	socket.read_0	; Read start of NTP packet
     410:  00:E692  CD 73 D9            		call	socket.read_end_0
     411:  00:E695                      ;
     412:  00:E695                      		; Check packet has come from the right port
     413:  00:E695  2A 15 F0            		ld	hl,(vars.udp.port)
     414:  00:E698  01 7B 00            		ld	bc,NTP_SERVER_PORT; Standard server port
     415:  00:E69B  B7                  		or	a
     416:  00:E69C  ED 42               		sbc	hl,bc
     417:  00:E69E  20 C9               		jr	nz,.badpacket
     418:  00:E6A0                      ;
     419:  00:E6A0  FD CB 00 66         		bit	vars.trace.ntp,(iy+vars._trace)
     420:  00:E6A4  28 19               		jr	z,.donetrace2
     421:  00:E6A6                      ;
     422:  00:E6A6  21 2B F3            		ld	hl,vars.ntp.packet.transmit+3	; Time packet left server
     423:  00:E6A9  5E                  		ld	e,(hl)
     424:  00:E6AA  2B                  		dec	hl
     425:  00:E6AB  56                  		ld	d,(hl)
     426:  00:E6AC  2B                  		dec	hl
     427:  00:E6AD  E5                  		push	hl
     428:  00:E6AE  EB                  		 ex	de,hl
     429:  00:E6AF  CD B1 CD            		 call	io.int
     430:  00:E6B2  E1                  		pop	hl
     431:  00:E6B3  3E 2C               		ld	a,','
     432:  00:E6B5  CD 00 CE            		call	io.char
     433:  00:E6B8  5E                  		ld	e,(hl)
     434:  00:E6B9  2B                  		dec	hl
     435:  00:E6BA  56                  		ld	d,(hl)
     436:  00:E6BB  EB                  		ex	de,hl
     437:  00:E6BC  CD B1 CD            		call	io.int
     438:  00:E6BF                      
     439:  00:E6BF                      .donetrace2:
     440:  00:E6BF  CD 71 DA            		call	socket.close_0
     441:  00:E6C2  CD A9 CE            		call	status.stop	; Stop waiting indicator
     442:  00:E6C5  B7                  		or	a		; NC=>no error
     443:  00:E6C6  C9                  		ret
     444:  00:E6C7                      ;
     445:  00:E6C7                      ;
     446:  00:E6C7                      ;------------------------------------------------------------------------------
     447:  00:E6C7                      ; send
     448:  00:E6C7                      ;
     449:  00:E6C7                      ; Sends a request to the time server
     450:  00:E6C7                      ;
     451:  00:E6C7                      ; Out: NC=>ok
     452:  00:E6C7                      send:
     453:  00:E6C7                      		; If we got an NTP address via DHCP, we use that. Otherwise
     454:  00:E6C7                      		; we use the standard broadcast address
     455:  00:E6C7  21 30 F0            		ld	hl,vars.dhcp.ntp; HL->DHCP NTP IP adrdess
     456:  00:E6CA  7E                  		ld	a,(hl)		; 0=>not set
     457:  00:E6CB  B7                  		or	a
     458:  00:E6CC  20 03               		jr	nz,.gotntp	; Go if got an IP address via DHCP
     459:  00:E6CE                      ;
     460:  00:E6CE  21 2C E7            		ld	hl,broadcast_ip	; Else use standard broadcast
     461:  00:E6D1  11 11 F0            .gotntp:	ld	de,vars.udp.ip	; Copy IP to use to udp.ip
     462:  00:E6D4  01 04 00            		ld	bc,4
     463:  00:E6D7  ED B0               		ldir
     464:  00:E6D9                      ;
     465:  00:E6D9  21 7B 00            		ld	hl,NTP_SERVER_PORT	; Standard NTP port
     466:  00:E6DC  22 15 F0            		ld	(vars.udp.port),hl
     467:  00:E6DF                      ;
     468:  00:E6DF  FD CB 00 66         		bit	vars.trace.ntp,(iy+vars._trace)
     469:  00:E6E3  28 1D               		jr	z,.donetrace
     470:  00:E6E5                      ;
     471:  00:E6E5  CD 23 CE            		call	io.start
     472:  00:E6E8  11 0E D3            		ld	de,trace.ntp.tx
     473:  00:E6EB  CD 3D CE            		call	io.str
     474:  00:E6EE  21 11 F0            		ld	hl,vars.udp.ip
     475:  00:E6F1  CD 8C CD            		call	io.ip
     476:  00:E6F4  3E 3A               		ld	a,':'
     477:  00:E6F6  CD 00 CE            		call	io.char
     478:  00:E6F9  2A 15 F0            		ld	hl,(vars.udp.port)
     479:  00:E6FC  CD B1 CD            		call	io.int
     480:  00:E6FF  CD 3C D0            		call	trace.dots
     481:  00:E702                      .donetrace:
     482:  00:E702                      		; Construct a SNTP packet
     483:  00:E702  21 00 F3            		ld	hl,vars.ntp.packet
     484:  00:E705  01 30 00            		ld	bc,vars.ntp.packet_size
     485:  00:E708  E5                  		push	hl			; Save ->packet
     486:  00:E709  C5                  		push	bc			; Save packet size
     487:  00:E70A  CD 27 CF            		 call	util.memzero		; Zero packet buffer
     488:  00:E70D                      ;
     489:  00:E70D  36 E3               		 ld	(hl),11100011b		; LI, Version, mode
     490:  00:E70F  23                  		 inc	hl			; HL->stratum
     491:  00:E710  23                  		 inc	hl			; HL->poll
     492:  00:E711  36 06               		 ld	(hl),6			; Poll interval=6
     493:  00:E713  23                  		 inc	hl			; HL->Precision
     494:  00:E714  36 EC               		 ld	(hl),0ech
     495:  00:E716                      ;
     496:  00:E716  21 0C F3            		 ld	hl,vars.ntp.packet.identifier
     497:  00:E719  36 31               		 ld	(hl),49
     498:  00:E71B  23                  		 inc	hl
     499:  00:E71C  36 4E               		 ld	(hl),4eh
     500:  00:E71E  23                  		 inc	hl
     501:  00:E71F  36 31               		 ld	(hl),49
     502:  00:E721  23                  		 inc	hl
     503:  00:E722  36 34               		 ld	(hl),52
     504:  00:E724  C1                  		pop	bc			; BC=packet size
     505:  00:E725  E1                  		pop	hl			; HL->packet
     506:  00:E726  CD 8B D9            		call	socket.write_0
     507:  00:E729                      ;
     508:  00:E729  C3 DF DC            		jp	udp.send_0
     509:  00:E72C                      ;
     510:  00:E72C                      ;broadcast_ip:	db	224,0,1,1	; Standard NTP default broadcast ip
     511:  00:E72C  FF FF FF FF         broadcast_ip:	db	255,255,255,255	; Standard NTP default broadcast ip
     512:  00:E730                      ;
     513:  00:E730                      ;
     514:  00:E730  4E 54 50 00         owner_str:	db	"NTP",0
     515:  00:E734                      ;
     516:  00:E734                      ;
     517:  00:E734                      		endmodule
     110.  00:E734                      	include	ftp.asm
       1:  00:E734                      ; FTP
       2:  00:E734                      ;
       3:  00:E734                      ; This module implements the FTP protocol
       4:  00:E734                      ;
       5:  00:E734                      		module	ftp
       6:  00:E734                      ;
       7:  00:E734                      ;==============================================================================
       8:  00:E734                      ;
       9:  00:E734                      ; This file is part of the EPNET software
      10:  00:E734                      ;
      11:  00:E734                      ; Copyright (C) 2015  Bruce Tanner
      12:  00:E734                      ;
      13:  00:E734                      ;    This program is free software: you can redistribute it and/or modify
      14:  00:E734                      ;    it under the terms of the GNU General Public License as published by
      15:  00:E734                      ;    the Free Software Foundation, either version 3 of the License, or
      16:  00:E734                      ;    (at your option) any later version.
      17:  00:E734                      ;
      18:  00:E734                      ;    This program is distributed in the hope that it will be useful,
      19:  00:E734                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      20:  00:E734                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      21:  00:E734                      ;    GNU General Public License for more details.
      22:  00:E734                      ;
      23:  00:E734                      ;    You should have received a copy of the GNU General Public License
      24:  00:E734                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      25:  00:E734                      ;
      26:  00:E734                      ; If you do use or modify this file, either for its original purpose or for
      27:  00:E734                      ; something new, I'd love to hear about it! I can be contacted by email at:
      28:  00:E734                      ;
      29:  00:E734                      ; brucetanner@btopenworld.com
      30:  00:E734                      ;
      31:  00:E734                      ;==============================================================================
      32:  00:E734                      ;
      33:  00:E734                      ; For reference, here are the interesting bits of RFC 959:
      34:  00:E734                      ;
      35:  00:E734                      ; 4.  FILE TRANSFER FUNCTIONS
      36:  00:E734                      ;
      37:  00:E734                      ;   The communication channel from the user-PI to the server-PI is
      38:  00:E734                      ;   established as a TCP connection from the user to the standard server
      39:  00:E734                      ;   port.  The user protocol interpreter is responsible for sending FTP
      40:  00:E734                      ;   commands and interpreting the replies received; the server-PI
      41:  00:E734                      ;   interprets commands, sends replies and directs its DTP to set up the
      42:  00:E734                      ;   data connection and transfer the data.  If the second party to the
      43:  00:E734                      ;   data transfer (the passive transfer process) is the user-DTP, then it
      44:  00:E734                      ;   is governed through the internal protocol of the user-FTP host; if it
      45:  00:E734                      ;   is a second server-DTP, then it is governed by its PI on command from
      46:  00:E734                      ;   the user-PI.  The FTP replies are discussed in the next section.  In
      47:  00:E734                      ;   the description of a few of the commands in this section, it is
      48:  00:E734                      ;   helpful to be explicit about the possible replies.
      49:  00:E734                      ;
      50:  00:E734                      ;   4.1.  FTP COMMANDS
      51:  00:E734                      ;
      52:  00:E734                      ;      4.1.1.  ACCESS CONTROL COMMANDS
      53:  00:E734                      ;
      54:  00:E734                      ;         The following commands specify access control identifiers
      55:  00:E734                      ;         (command codes are shown in parentheses).
      56:  00:E734                      ;
      57:  00:E734                      ;         USER NAME (USER)
      58:  00:E734                      ;
      59:  00:E734                      ;            The argument field is a Telnet string identifying the user.
      60:  00:E734                      ;            The user identification is that which is required by the
      61:  00:E734                      ;            server for access to its file system.  This command will
      62:  00:E734                      ;            normally be the first command transmitted by the user after
      63:  00:E734                      ;            the control connections are made (some servers may require
      64:  00:E734                      ;            this).  Additional identification information in the form of
      65:  00:E734                      ;            a password and/or an account command may also be required by
      66:  00:E734                      ;            some servers.  Servers may allow a new USER command to be
      67:  00:E734                      ;            entered at any point in order to change the access control
      68:  00:E734                      ;            and/or accounting information.  This has the effect of
      69:  00:E734                      ;            flushing any user, password, and account information already
      70:  00:E734                      ;            supplied and beginning the login sequence again.  All
      71:  00:E734                      ;            transfer parameters are unchanged and any file transfer in
      72:  00:E734                      ;            progress is completed under the old access control
      73:  00:E734                      ;            parameters.
      74:  00:E734                      ;
      75:  00:E734                      ;         PASSWORD (PASS)
      76:  00:E734                      ;
      77:  00:E734                      ;            The argument field is a Telnet string specifying the user's
      78:  00:E734                      ;            password.  This command must be immediately preceded by the
      79:  00:E734                      ;            user name command, and, for some sites, completes the user's
      80:  00:E734                      ;            identification for access control.  Since password
      81:  00:E734                      ;            information is quite sensitive, it is desirable in general
      82:  00:E734                      ;            to "mask" it or suppress typeout.  It appears that the
      83:  00:E734                      ;            server has no foolproof way to achieve this.  It is
      84:  00:E734                      ;            therefore the responsibility of the user-FTP process to hide
      85:  00:E734                      ;            the sensitive password information.
      86:  00:E734                      ;
      87:  00:E734                      ;         ACCOUNT (ACCT)
      88:  00:E734                      ;
      89:  00:E734                      ;            The argument field is a Telnet string identifying the user's
      90:  00:E734                      ;            account.  The command is not necessarily related to the USER
      91:  00:E734                      ;            command, as some sites may require an account for login and
      92:  00:E734                      ;            others only for specific access, such as storing files.  In
      93:  00:E734                      ;            the latter case the command may arrive at any time.
      94:  00:E734                      ;
      95:  00:E734                      ;            There are reply codes to differentiate these cases for the
      96:  00:E734                      ;            automation: when account information is required for login,
      97:  00:E734                      ;            the response to a successful PASSword command is reply code
      98:  00:E734                      ;            332.  On the other hand, if account information is NOT
      99:  00:E734                      ;            required for login, the reply to a successful PASSword
     100:  00:E734                      ;            command is 230; and if the account information is needed for
     101:  00:E734                      ;            a command issued later in the dialogue, the server should
     102:  00:E734                      ;            return a 332 or 532 reply depending on whether it stores
     103:  00:E734                      ;            (pending receipt of the ACCounT command) or discards the
     104:  00:E734                      ;            command, respectively.
     105:  00:E734                      ;
     106:  00:E734                      ;         CHANGE WORKING DIRECTORY (CWD)
     107:  00:E734                      ;
     108:  00:E734                      ;            This command allows the user to work with a different
     109:  00:E734                      ;            directory or dataset for file storage or retrieval without
     110:  00:E734                      ;            altering his login or accounting information.  Transfer
     111:  00:E734                      ;            parameters are similarly unchanged.  The argument is a
     112:  00:E734                      ;            pathname specifying a directory or other system dependent
     113:  00:E734                      ;            file group designator.
     114:  00:E734                      ;
     115:  00:E734                      ;         CHANGE TO PARENT DIRECTORY (CDUP)
     116:  00:E734                      ;
     117:  00:E734                      ;            This command is a special case of CWD, and is included to
     118:  00:E734                      ;            simplify the implementation of programs for transferring
     119:  00:E734                      ;            directory trees between operating systems having different
     120:  00:E734                      ;            syntaxes for naming the parent directory.  The reply codes
     121:  00:E734                      ;            shall be identical to the reply codes of CWD.  See
     122:  00:E734                      ;            Appendix II for further details.
     123:  00:E734                      ;
     124:  00:E734                      ;         STRUCTURE MOUNT (SMNT)
     125:  00:E734                      ;
     126:  00:E734                      ;            This command allows the user to mount a different file
     127:  00:E734                      ;            system data structure without altering his login or
     128:  00:E734                      ;            accounting information.  Transfer parameters are similarly
     129:  00:E734                      ;            unchanged.  The argument is a pathname specifying a
     130:  00:E734                      ;            directory or other system dependent file group designator.
     131:  00:E734                      ;
     132:  00:E734                      ;         REINITIALIZE (REIN)
     133:  00:E734                      ;
     134:  00:E734                      ;            This command terminates a USER, flushing all I/O and account
     135:  00:E734                      ;            information, except to allow any transfer in progress to be
     136:  00:E734                      ;            completed.  All parameters are reset to the default settings
     137:  00:E734                      ;            and the control connection is left open.  This is identical
     138:  00:E734                      ;            to the state in which a user finds himself immediately after
     139:  00:E734                      ;            the control connection is opened.  A USER command may be
     140:  00:E734                      ;            expected to follow.
     141:  00:E734                      ;
     142:  00:E734                      ;         LOGOUT (QUIT)
     143:  00:E734                      ;
     144:  00:E734                      ;            This command terminates a USER and if file transfer is not
     145:  00:E734                      ;            in progress, the server closes the control connection.  If
     146:  00:E734                      ;            file transfer is in progress, the connection will remain
     147:  00:E734                      ;            open for result response and the server will then close it.
     148:  00:E734                      ;            If the user-process is transferring files for several USERs
     149:  00:E734                      ;            but does not wish to close and then reopen connections for
     150:  00:E734                      ;            each, then the REIN command should be used instead of QUIT.
     151:  00:E734                      ;
     152:  00:E734                      ;            An unexpected close on the control connection will cause the
     153:  00:E734                      ;            server to take the effective action of an abort (ABOR) and a
     154:  00:E734                      ;            logout (QUIT).
     155:  00:E734                      ;
     156:  00:E734                      ;      4.1.2.  TRANSFER PARAMETER COMMANDS
     157:  00:E734                      ;
     158:  00:E734                      ;         All data transfer parameters have default values, and the
     159:  00:E734                      ;         commands specifying data transfer parameters are required only
     160:  00:E734                      ;         if the default parameter values are to be changed.  The default
     161:  00:E734                      ;         value is the last specified value, or if no value has been
     162:  00:E734                      ;         specified, the standard default value is as stated here.  This
     163:  00:E734                      ;         implies that the server must "remember" the applicable default
     164:  00:E734                      ;         values.  The commands may be in any order except that they must
     165:  00:E734                      ;         precede the FTP service request.  The following commands
     166:  00:E734                      ;         specify data transfer parameters:
     167:  00:E734                      ;
     168:  00:E734                      ;         DATA PORT (PORT)
     169:  00:E734                      ;
     170:  00:E734                      ;            The argument is a HOST-PORT specification for the data port
     171:  00:E734                      ;            to be used in data connection.  There are defaults for both
     172:  00:E734                      ;            the user and server data ports, and under normal
     173:  00:E734                      ;            circumstances this command and its reply are not needed.  If
     174:  00:E734                      ;            this command is used, the argument is the concatenation of a
     175:  00:E734                      ;            32-bit internet host address and a 16-bit TCP port address.
     176:  00:E734                      ;            This address information is broken into 8-bit fields and the
     177:  00:E734                      ;            value of each field is transmitted as a decimal number (in
     178:  00:E734                      ;            character string representation).  The fields are separated
     179:  00:E734                      ;            by commas.  A port command would be:
     180:  00:E734                      ;
     181:  00:E734                      ;               PORT h1,h2,h3,h4,p1,p2
     182:  00:E734                      ;
     183:  00:E734                      ;            where h1 is the high order 8 bits of the internet host
     184:  00:E734                      ;            address.
     185:  00:E734                      ;
     186:  00:E734                      ;         PASSIVE (PASV)
     187:  00:E734                      ;
     188:  00:E734                      ;            This command requests the server-DTP to "listen" on a data
     189:  00:E734                      ;            port (which is not its default data port) and to wait for a
     190:  00:E734                      ;            connection rather than initiate one upon receipt of a
     191:  00:E734                      ;            transfer command.  The response to this command includes the
     192:  00:E734                      ;            host and port address this server is listening on.
     193:  00:E734                      ;
     194:  00:E734                      ;         REPRESENTATION TYPE (TYPE)
     195:  00:E734                      ;
     196:  00:E734                      ;            The argument specifies the representation type as described
     197:  00:E734                      ;            in the Section on Data Representation and Storage.  Several
     198:  00:E734                      ;            types take a second parameter.  The first parameter is
     199:  00:E734                      ;            denoted by a single Telnet character, as is the second
     200:  00:E734                      ;            Format parameter for ASCII and EBCDIC; the second parameter
     201:  00:E734                      ;            for local byte is a decimal integer to indicate Bytesize.
     202:  00:E734                      ;            The parameters are separated by a <SP> (Space, ASCII code
     203:  00:E734                      ;            32).
     204:  00:E734                      ;
     205:  00:E734                      ;            The following codes are assigned for type:
     206:  00:E734                      ;
     207:  00:E734                      ;                         \    /
     208:  00:E734                      ;               A - ASCII |    | N - Non-print
     209:  00:E734                      ;                         |-><-| T - Telnet format effectors
     210:  00:E734                      ;               E - EBCDIC|    | C - Carriage Control (ASA)
     211:  00:E734                      ;                         /    \
     212:  00:E734                      ;               I - Image
     213:  00:E734                      ;               
     214:  00:E734                      ;               L <byte size> - Local byte Byte size
     215:  00:E734                      ;
     216:  00:E734                      ;            The default representation type is ASCII Non-print.  If the
     217:  00:E734                      ;            Format parameter is changed, and later just the first
     218:  00:E734                      ;            argument is changed, Format then returns to the Non-print
     219:  00:E734                      ;            default.
     220:  00:E734                      ;
     221:  00:E734                      ;         FILE STRUCTURE (STRU)
     222:  00:E734                      ;
     223:  00:E734                      ;            The argument is a single Telnet character code specifying
     224:  00:E734                      ;            file structure described in the Section on Data
     225:  00:E734                      ;            Representation and Storage.
     226:  00:E734                      ;
     227:  00:E734                      ;            The following codes are assigned for structure:
     228:  00:E734                      ;
     229:  00:E734                      ;               F - File (no record structure)
     230:  00:E734                      ;               R - Record structure
     231:  00:E734                      ;               P - Page structure
     232:  00:E734                      ;
     233:  00:E734                      ;            The default structure is File.
     234:  00:E734                      ;
     235:  00:E734                      ;         TRANSFER MODE (MODE)
     236:  00:E734                      ;
     237:  00:E734                      ;            The argument is a single Telnet character code specifying
     238:  00:E734                      ;            the data transfer modes described in the Section on
     239:  00:E734                      ;            Transmission Modes.
     240:  00:E734                      ;
     241:  00:E734                      ;            The following codes are assigned for transfer modes:
     242:  00:E734                      ;
     243:  00:E734                      ;               S - Stream
     244:  00:E734                      ;               B - Block
     245:  00:E734                      ;               C - Compressed
     246:  00:E734                      ;
     247:  00:E734                      ;            The default transfer mode is Stream.
     248:  00:E734                      ;
     249:  00:E734                      ;      4.1.3.  FTP SERVICE COMMANDS
     250:  00:E734                      ;
     251:  00:E734                      ;         The FTP service commands define the file transfer or the file
     252:  00:E734                      ;         system function requested by the user.  The argument of an FTP
     253:  00:E734                      ;         service command will normally be a pathname.  The syntax of
     254:  00:E734                      ;         pathnames must conform to server site conventions (with
     255:  00:E734                      ;         standard defaults applicable), and the language conventions of
     256:  00:E734                      ;         the control connection.  The suggested default handling is to
     257:  00:E734                      ;         use the last specified device, directory or file name, or the
     258:  00:E734                      ;         standard default defined for local users.  The commands may be
     259:  00:E734                      ;         in any order except that a "rename from" command must be
     260:  00:E734                      ;         followed by a "rename to" command and the restart command must
     261:  00:E734                      ;         be followed by the interrupted service command (e.g., STOR or
     262:  00:E734                      ;         RETR).  The data, when transferred in response to FTP service
     263:  00:E734                      ;         commands, shall always be sent over the data connection, except
     264:  00:E734                      ;         for certain informative replies.  The following commands
     265:  00:E734                      ;         specify FTP service requests:
     266:  00:E734                      ;
     267:  00:E734                      ;         RETRIEVE (RETR)
     268:  00:E734                      ;
     269:  00:E734                      ;            This command causes the server-DTP to transfer a copy of the
     270:  00:E734                      ;            file, specified in the pathname, to the server- or user-DTP
     271:  00:E734                      ;            at the other end of the data connection.  The status and
     272:  00:E734                      ;            contents of the file at the server site shall be unaffected.
     273:  00:E734                      ;
     274:  00:E734                      ;         STORE (STOR)
     275:  00:E734                      ;
     276:  00:E734                      ;            This command causes the server-DTP to accept the data
     277:  00:E734                      ;            transferred via the data connection and to store the data as
     278:  00:E734                      ;            a file at the server site.  If the file specified in the
     279:  00:E734                      ;            pathname exists at the server site, then its contents shall
     280:  00:E734                      ;            be replaced by the data being transferred.  A new file is
     281:  00:E734                      ;            created at the server site if the file specified in the
     282:  00:E734                      ;            pathname does not already exist.
     283:  00:E734                      ;
     284:  00:E734                      ;         STORE UNIQUE (STOU)
     285:  00:E734                      ;
     286:  00:E734                      ;            This command behaves like STOR except that the resultant
     287:  00:E734                      ;            file is to be created in the current directory under a name
     288:  00:E734                      ;            unique to that directory.  The 250 Transfer Started response
     289:  00:E734                      ;            must include the name generated.
     290:  00:E734                      ;
     291:  00:E734                      ;         APPEND (with create) (APPE)
     292:  00:E734                      ;
     293:  00:E734                      ;            This command causes the server-DTP to accept the data
     294:  00:E734                      ;            transferred via the data connection and to store the data in
     295:  00:E734                      ;            a file at the server site.  If the file specified in the
     296:  00:E734                      ;            pathname exists at the server site, then the data shall be
     297:  00:E734                      ;            appended to that file; otherwise the file specified in the
     298:  00:E734                      ;            pathname shall be created at the server site.
     299:  00:E734                      ;
     300:  00:E734                      ;         ALLOCATE (ALLO)
     301:  00:E734                      ;
     302:  00:E734                      ;            This command may be required by some servers to reserve
     303:  00:E734                      ;            sufficient storage to accommodate the new file to be
     304:  00:E734                      ;            transferred.  The argument shall be a decimal integer
     305:  00:E734                      ;            representing the number of bytes (using the logical byte
     306:  00:E734                      ;            size) of storage to be reserved for the file.  For files
     307:  00:E734                      ;            sent with record or page structure a maximum record or page
     308:  00:E734                      ;            size (in logical bytes) might also be necessary; this is
     309:  00:E734                      ;            indicated by a decimal integer in a second argument field of
     310:  00:E734                      ;            the command.  This second argument is optional, but when
     311:  00:E734                      ;            present should be separated from the first by the three
     312:  00:E734                      ;            Telnet characters <SP> R <SP>.  This command shall be
     313:  00:E734                      ;            followed by a STORe or APPEnd command.  The ALLO command
     314:  00:E734                      ;            should be treated as a NOOP (no operation) by those servers
     315:  00:E734                      ;            which do not require that the maximum size of the file be
     316:  00:E734                      ;            declared beforehand, and those servers interested in only
     317:  00:E734                      ;            the maximum record or page size should accept a dummy value
     318:  00:E734                      ;            in the first argument and ignore it.
     319:  00:E734                      ;
     320:  00:E734                      ;         RESTART (REST)
     321:  00:E734                      ;
     322:  00:E734                      ;            The argument field represents the server marker at which
     323:  00:E734                      ;            file transfer is to be restarted.  This command does not
     324:  00:E734                      ;            cause file transfer but skips over the file to the specified
     325:  00:E734                      ;            data checkpoint.  This command shall be immediately followed
     326:  00:E734                      ;            by the appropriate FTP service command which shall cause
     327:  00:E734                      ;            file transfer to resume.
     328:  00:E734                      ;
     329:  00:E734                      ;         RENAME FROM (RNFR)
     330:  00:E734                      ;
     331:  00:E734                      ;            This command specifies the old pathname of the file which is
     332:  00:E734                      ;            to be renamed.  This command must be immediately followed by
     333:  00:E734                      ;            a "rename to" command specifying the new file pathname.
     334:  00:E734                      ;
     335:  00:E734                      ;         RENAME TO (RNTO)
     336:  00:E734                      ;
     337:  00:E734                      ;            This command specifies the new pathname of the file
     338:  00:E734                      ;            specified in the immediately preceding "rename from"
     339:  00:E734                      ;            command.  Together the two commands cause a file to be
     340:  00:E734                      ;            renamed.
     341:  00:E734                      ;
     342:  00:E734                      ;         ABORT (ABOR)
     343:  00:E734                      ;
     344:  00:E734                      ;            This command tells the server to abort the previous FTP
     345:  00:E734                      ;            service command and any associated transfer of data.  The
     346:  00:E734                      ;            abort command may require "special action", as discussed in
     347:  00:E734                      ;            the Section on FTP Commands, to force recognition by the
     348:  00:E734                      ;            server.  No action is to be taken if the previous command
     349:  00:E734                      ;            has been completed (including data transfer).  The control
     350:  00:E734                      ;            connection is not to be closed by the server, but the data
     351:  00:E734                      ;            connection must be closed.
     352:  00:E734                      ;
     353:  00:E734                      ;            There are two cases for the server upon receipt of this
     354:  00:E734                      ;            command: (1) the FTP service command was already completed,
     355:  00:E734                      ;            or (2) the FTP service command is still in progress.
     356:  00:E734                      ;
     357:  00:E734                      ;               In the first case, the server closes the data connection
     358:  00:E734                      ;               (if it is open) and responds with a 226 reply, indicating
     359:  00:E734                      ;               that the abort command was successfully processed.
     360:  00:E734                      ;
     361:  00:E734                      ;               In the second case, the server aborts the FTP service in
     362:  00:E734                      ;               progress and closes the data connection, returning a 426
     363:  00:E734                      ;               reply to indicate that the service request terminated
     364:  00:E734                      ;               abnormally.  The server then sends a 226 reply,
     365:  00:E734                      ;               indicating that the abort command was successfully
     366:  00:E734                      ;               processed.
     367:  00:E734                      ;
     368:  00:E734                      ;         DELETE (DELE)
     369:  00:E734                      ;
     370:  00:E734                      ;            This command causes the file specified in the pathname to be
     371:  00:E734                      ;            deleted at the server site.  If an extra level of protection
     372:  00:E734                      ;            is desired (such as the query, "Do you really wish to
     373:  00:E734                      ;            delete?"), it should be provided by the user-FTP process.
     374:  00:E734                      ;
     375:  00:E734                      ;         REMOVE DIRECTORY (RMD)
     376:  00:E734                      ;
     377:  00:E734                      ;            This command causes the directory specified in the pathname
     378:  00:E734                      ;            to be removed as a directory (if the pathname is absolute)
     379:  00:E734                      ;            or as a subdirectory of the current working directory (if
     380:  00:E734                      ;            the pathname is relative).  See Appendix II.
     381:  00:E734                      ;
     382:  00:E734                      ;         MAKE DIRECTORY (MKD)
     383:  00:E734                      ;
     384:  00:E734                      ;            This command causes the directory specified in the pathname
     385:  00:E734                      ;            to be created as a directory (if the pathname is absolute)
     386:  00:E734                      ;            or as a subdirectory of the current working directory (if
     387:  00:E734                      ;            the pathname is relative).  See Appendix II.
     388:  00:E734                      ;
     389:  00:E734                      ;         PRINT WORKING DIRECTORY (PWD)
     390:  00:E734                      ;
     391:  00:E734                      ;            This command causes the name of the current working
     392:  00:E734                      ;            directory to be returned in the reply.  See Appendix II.
     393:  00:E734                      ;
     394:  00:E734                      ;         LIST (LIST)
     395:  00:E734                      ;
     396:  00:E734                      ;            This command causes a list to be sent from the server to the
     397:  00:E734                      ;            passive DTP.  If the pathname specifies a directory or other
     398:  00:E734                      ;            group of files, the server should transfer a list of files
     399:  00:E734                      ;            in the specified directory.  If the pathname specifies a
     400:  00:E734                      ;            file then the server should send current information on the
     401:  00:E734                      ;            file.  A null argument implies the user's current working or
     402:  00:E734                      ;            default directory.  The data transfer is over the data
     403:  00:E734                      ;            connection in type ASCII or type EBCDIC.  (The user must
     404:  00:E734                      ;            ensure that the TYPE is appropriately ASCII or EBCDIC).
     405:  00:E734                      ;            Since the information on a file may vary widely from system
     406:  00:E734                      ;            to system, this information may be hard to use automatically
     407:  00:E734                      ;            in a program, but may be quite useful to a human user.
     408:  00:E734                      ;
     409:  00:E734                      ;         NAME LIST (NLST)
     410:  00:E734                      ;
     411:  00:E734                      ;            This command causes a directory listing to be sent from
     412:  00:E734                      ;            server to user site.  The pathname should specify a
     413:  00:E734                      ;            directory or other system-specific file group descriptor; a
     414:  00:E734                      ;            null argument implies the current directory.  The server
     415:  00:E734                      ;            will return a stream of names of files and no other
     416:  00:E734                      ;            information.  The data will be transferred in ASCII or
     417:  00:E734                      ;            EBCDIC type over the data connection as valid pathname
     418:  00:E734                      ;            strings separated by <CRLF> or <NL>.  (Again the user must
     419:  00:E734                      ;            ensure that the TYPE is correct.)  This command is intended
     420:  00:E734                      ;            to return information that can be used by a program to
     421:  00:E734                      ;            further process the files automatically.  For example, in
     422:  00:E734                      ;            the implementation of a "multiple get" function.
     423:  00:E734                      ;
     424:  00:E734                      ;         SITE PARAMETERS (SITE)
     425:  00:E734                      ;
     426:  00:E734                      ;            This command is used by the server to provide services
     427:  00:E734                      ;            specific to his system that are essential to file transfer
     428:  00:E734                      ;            but not sufficiently universal to be included as commands in
     429:  00:E734                      ;            the protocol.  The nature of these services and the
     430:  00:E734                      ;            specification of their syntax can be stated in a reply to
     431:  00:E734                      ;            the HELP SITE command.
     432:  00:E734                      ;
     433:  00:E734                      ;         SYSTEM (SYST)
     434:  00:E734                      ;
     435:  00:E734                      ;            This command is used to find out the type of operating
     436:  00:E734                      ;            system at the server.  The reply shall have as its first
     437:  00:E734                      ;            word one of the system names listed in the current version
     438:  00:E734                      ;            of the Assigned Numbers document [4].
     439:  00:E734                      ;
     440:  00:E734                      ;         STATUS (STAT)
     441:  00:E734                      ;
     442:  00:E734                      ;            This command shall cause a status response to be sent over
     443:  00:E734                      ;            the control connection in the form of a reply.  The command
     444:  00:E734                      ;            may be sent during a file transfer (along with the Telnet IP
     445:  00:E734                      ;            and Synch signals--see the Section on FTP Commands) in which
     446:  00:E734                      ;            case the server will respond with the status of the
     447:  00:E734                      ;            operation in progress, or it may be sent between file
     448:  00:E734                      ;            transfers.  In the latter case, the command may have an
     449:  00:E734                      ;            argument field.  If the argument is a pathname, the command
     450:  00:E734                      ;            is analogous to the "list" command except that data shall be
     451:  00:E734                      ;            transferred over the control connection.  If a partial
     452:  00:E734                      ;            pathname is given, the server may respond with a list of
     453:  00:E734                      ;            file names or attributes associated with that specification.
     454:  00:E734                      ;            If no argument is given, the server should return general
     455:  00:E734                      ;            status information about the server FTP process.  This
     456:  00:E734                      ;            should include current values of all transfer parameters and
     457:  00:E734                      ;            the status of connections.
     458:  00:E734                      ;
     459:  00:E734                      ;         HELP (HELP)
     460:  00:E734                      ;
     461:  00:E734                      ;            This command shall cause the server to send helpful
     462:  00:E734                      ;            information regarding its implementation status over the
     463:  00:E734                      ;            control connection to the user.  The command may take an
     464:  00:E734                      ;            argument (e.g., any command name) and return more specific
     465:  00:E734                      ;            information as a response.  The reply is type 211 or 214.
     466:  00:E734                      ;            It is suggested that HELP be allowed before entering a USER
     467:  00:E734                      ;            command. The server may use this reply to specify
     468:  00:E734                      ;            site-dependent parameters, e.g., in response to HELP SITE.
     469:  00:E734                      ;
     470:  00:E734                      ;         NOOP (NOOP)
     471:  00:E734                      ;
     472:  00:E734                      ;            This command does not affect any parameters or previously
     473:  00:E734                      ;            entered commands. It specifies no action other than that the
     474:  00:E734                      ;            server send an OK reply.
     475:  00:E734                      ;
     476:  00:E734                      ;   The File Transfer Protocol follows the specifications of the Telnet
     477:  00:E734                      ;   protocol for all communications over the control connection.  Since
     478:  00:E734                      ;   the language used for Telnet communication may be a negotiated
     479:  00:E734                      ;   option, all references in the next two sections will be to the
     480:  00:E734                      ;   "Telnet language" and the corresponding "Telnet end-of-line code".
     481:  00:E734                      ;   Currently, one may take these to mean NVT-ASCII and <CRLF>.  No other
     482:  00:E734                      ;   specifications of the Telnet protocol will be cited.
     483:  00:E734                      ;
     484:  00:E734                      ;   FTP commands are "Telnet strings" terminated by the "Telnet end of
     485:  00:E734                      ;   line code".  The command codes themselves are alphabetic characters
     486:  00:E734                      ;   terminated by the character <SP> (Space) if parameters follow and
     487:  00:E734                      ;   Telnet-EOL otherwise.  The command codes and the semantics of
     488:  00:E734                      ;   commands are described in this section; the detailed syntax of
     489:  00:E734                      ;   commands is specified in the Section on Commands, the reply sequences
     490:  00:E734                      ;   are discussed in the Section on Sequencing of Commands and Replies,
     491:  00:E734                      ;   and scenarios illustrating the use of commands are provided in the
     492:  00:E734                      ;   Section on Typical FTP Scenarios.
     493:  00:E734                      ;
     494:  00:E734                      ;   FTP commands may be partitioned as those specifying access-control
     495:  00:E734                      ;   identifiers, data transfer parameters, or FTP service requests.
     496:  00:E734                      ;   Certain commands (such as ABOR, STAT, QUIT) may be sent over the
     497:  00:E734                      ;   control connection while a data transfer is in progress.  Some
     498:  00:E734                      ;   servers may not be able to monitor the control and data connections
     499:  00:E734                      ;   simultaneously, in which case some special action will be necessary
     500:  00:E734                      ;   to get the server's attention.  The following ordered format is
     501:  00:E734                      ;   tentatively recommended:
     502:  00:E734                      ;
     503:  00:E734                      ;      1. User system inserts the Telnet "Interrupt Process" (IP) signal
     504:  00:E734                      ;      in the Telnet stream.
     505:  00:E734                      ;
     506:  00:E734                      ;      2. User system sends the Telnet "Synch" signal.
     507:  00:E734                      ;
     508:  00:E734                      ;      3. User system inserts the command (e.g., ABOR) in the Telnet
     509:  00:E734                      ;      stream.
     510:  00:E734                      ;
     511:  00:E734                      ;      4. Server PI, after receiving "IP", scans the Telnet stream for
     512:  00:E734                      ;      EXACTLY ONE FTP command.
     513:  00:E734                      ;
     514:  00:E734                      ;   (For other servers this may not be necessary but the actions listed
     515:  00:E734                      ;   above should have no unusual effect.)
     516:  00:E734                      ;
     517:  00:E734                      ;   4.2.  FTP REPLIES
     518:  00:E734                      ;
     519:  00:E734                      ;      Replies to File Transfer Protocol commands are devised to ensure
     520:  00:E734                      ;      the synchronization of requests and actions in the process of file
     521:  00:E734                      ;      transfer, and to guarantee that the user process always knows the
     522:  00:E734                      ;      state of the Server.  Every command must generate at least one
     523:  00:E734                      ;      reply, although there may be more than one; in the latter case,
     524:  00:E734                      ;      the multiple replies must be easily distinguished.  In addition,
     525:  00:E734                      ;      some commands occur in sequential groups, such as USER, PASS and
     526:  00:E734                      ;      ACCT, or RNFR and RNTO.  The replies show the existence of an
     527:  00:E734                      ;      intermediate state if all preceding commands have been successful.
     528:  00:E734                      ;      A failure at any point in the sequence necessitates the repetition
     529:  00:E734                      ;      of the entire sequence from the beginning.
     530:  00:E734                      ;
     531:  00:E734                      ;         The details of the command-reply sequence are made explicit in
     532:  00:E734                      ;         a set of state diagrams below.
     533:  00:E734                      ;
     534:  00:E734                      ;      An FTP reply consists of a three digit number (transmitted as
     535:  00:E734                      ;      three alphanumeric characters) followed by some text.  The number
     536:  00:E734                      ;      is intended for use by automata to determine what state to enter
     537:  00:E734                      ;      next; the text is intended for the human user.  It is intended
     538:  00:E734                      ;      that the three digits contain enough encoded information that the
     539:  00:E734                      ;      user-process (the User-PI) will not need to examine the text and
     540:  00:E734                      ;      may either discard it or pass it on to the user, as appropriate.
     541:  00:E734                      ;      In particular, the text may be server-dependent, so there are
     542:  00:E734                      ;      likely to be varying texts for each reply code.
     543:  00:E734                      ;
     544:  00:E734                      ;      A reply is defined to contain the 3-digit code, followed by Space
     545:  00:E734                      ;      <SP>, followed by one line of text (where some maximum line length
     546:  00:E734                      ;      has been specified), and terminated by the Telnet end-of-line
     547:  00:E734                      ;      code.  There will be cases however, where the text is longer than
     548:  00:E734                      ;      a single line.  In these cases the complete text must be bracketed
     549:  00:E734                      ;      so the User-process knows when it may stop reading the reply (i.e.
     550:  00:E734                      ;      stop processing input on the control connection) and go do other
     551:  00:E734                      ;      things.  This requires a special format on the first line to
     552:  00:E734                      ;      indicate that more than one line is coming, and another on the
     553:  00:E734                      ;      last line to designate it as the last.  At least one of these must
     554:  00:E734                      ;      contain the appropriate reply code to indicate the state of the
     555:  00:E734                      ;      transaction.  To satisfy all factions, it was decided that both
     556:  00:E734                      ;      the first and last line codes should be the same.
     557:  00:E734                      ;
     558:  00:E734                      ;         Thus the format for multi-line replies is that the first line
     559:  00:E734                      ;         will begin with the exact required reply code, followed
     560:  00:E734                      ;         immediately by a Hyphen, "-" (also known as Minus), followed by
     561:  00:E734                      ;         text.  The last line will begin with the same code, followed
     562:  00:E734                      ;         immediately by Space <SP>, optionally some text, and the Telnet
     563:  00:E734                      ;         end-of-line code.
     564:  00:E734                      ;
     565:  00:E734                      ;            For example:
     566:  00:E734                      ;                                123-First line
     567:  00:E734                      ;                                Second line
     568:  00:E734                      ;                                  234 A line beginning with numbers
     569:  00:E734                      ;                                123 The last line
     570:  00:E734                      ;
     571:  00:E734                      ;         The user-process then simply needs to search for the second
     572:  00:E734                      ;         occurrence of the same reply code, followed by <SP> (Space), at
     573:  00:E734                      ;         the beginning of a line, and ignore all intermediary lines.  If
     574:  00:E734                      ;         an intermediary line begins with a 3-digit number, the Server
     575:  00:E734                      ;         must pad the front  to avoid confusion.
     576:  00:E734                      ;
     577:  00:E734                      ;            This scheme allows standard system routines to be used for
     578:  00:E734                      ;            reply information (such as for the STAT reply), with
     579:  00:E734                      ;            "artificial" first and last lines tacked on.  In rare cases
     580:  00:E734                      ;            where these routines are able to generate three digits and a
     581:  00:E734                      ;            Space at the beginning of any line, the beginning of each
     582:  00:E734                      ;            text line should be offset by some neutral text, like Space.
     583:  00:E734                      ;
     584:  00:E734                      ;         This scheme assumes that multi-line replies may not be nested.
     585:  00:E734                      ;
     586:  00:E734                      ;      The three digits of the reply each have a special significance.
     587:  00:E734                      ;      This is intended to allow a range of very simple to very
     588:  00:E734                      ;      sophisticated responses by the user-process.  The first digit
     589:  00:E734                      ;      denotes whether the response is good, bad or incomplete.
     590:  00:E734                      ;      (Referring to the state diagram), an unsophisticated user-process
     591:  00:E734                      ;      will be able to determine its next action (proceed as planned,
     592:  00:E734                      ;      redo, retrench, etc.) by simply examining this first digit.  A
     593:  00:E734                      ;      user-process that wants to know approximately what kind of error
     594:  00:E734                      ;      occurred (e.g. file system error, command syntax error) may
     595:  00:E734                      ;      examine the second digit, reserving the third digit for the finest
     596:  00:E734                      ;      gradation of information (e.g., RNTO command without a preceding
     597:  00:E734                      ;      RNFR).
     598:  00:E734                      ;
     599:  00:E734                      ;         There are five values for the first digit of the reply code:
     600:  00:E734                      ;
     601:  00:E734                      ;            1yz   Positive Preliminary reply
     602:  00:E734                      ;
     603:  00:E734                      ;               The requested action is being initiated; expect another
     604:  00:E734                      ;               reply before proceeding with a new command.  (The
     605:  00:E734                      ;               user-process sending another command before the
     606:  00:E734                      ;               completion reply would be in violation of protocol; but
     607:  00:E734                      ;               server-FTP processes should queue any commands that
     608:  00:E734                      ;               arrive while a preceding command is in progress.)  This
     609:  00:E734                      ;               type of reply can be used to indicate that the command
     610:  00:E734                      ;               was accepted and the user-process may now pay attention
     611:  00:E734                      ;               to the data connections, for implementations where
     612:  00:E734                      ;               simultaneous monitoring is difficult.  The server-FTP
     613:  00:E734                      ;               process may send at most, one 1yz reply per command.
     614:  00:E734                      ;
     615:  00:E734                      ;            2yz   Positive Completion reply
     616:  00:E734                      ;
     617:  00:E734                      ;               The requested action has been successfully completed.  A
     618:  00:E734                      ;               new request may be initiated.
     619:  00:E734                      ;
     620:  00:E734                      ;            3yz   Positive Intermediate reply
     621:  00:E734                      ;
     622:  00:E734                      ;               The command has been accepted, but the requested action
     623:  00:E734                      ;               is being held in abeyance, pending receipt of further
     624:  00:E734                      ;               information.  The user should send another command
     625:  00:E734                      ;               specifying this information.  This reply is used in
     626:  00:E734                      ;               command sequence groups.
     627:  00:E734                      ;
     628:  00:E734                      ;            4yz   Transient Negative Completion reply
     629:  00:E734                      ;
     630:  00:E734                      ;               The command was not accepted and the requested action did
     631:  00:E734                      ;               not take place, but the error condition is temporary and
     632:  00:E734                      ;               the action may be requested again.  The user should
     633:  00:E734                      ;               return to the beginning of the command sequence, if any.
     634:  00:E734                      ;               It is difficult to assign a meaning to "transient",
     635:  00:E734                      ;               particularly when two distinct sites (Server- and
     636:  00:E734                      ;               User-processes) have to agree on the interpretation.
     637:  00:E734                      ;               Each reply in the 4yz category might have a slightly
     638:  00:E734                      ;               different time value, but the intent is that the
     639:  00:E734                      ;               user-process is encouraged to try again.  A rule of thumb
     640:  00:E734                      ;               in determining if a reply fits into the 4yz or the 5yz
     641:  00:E734                      ;               (Permanent Negative) category is that replies are 4yz if
     642:  00:E734                      ;               the commands can be repeated without any change in
     643:  00:E734                      ;               command form or in properties of the User or Server
     644:  00:E734                      ;               (e.g., the command is spelled the same with the same
     645:  00:E734                      ;               arguments used; the user does not change his file access
     646:  00:E734                      ;               or user name; the server does not put up a new
     647:  00:E734                      ;               implementation.)
     648:  00:E734                      ;
     649:  00:E734                      ;            5yz   Permanent Negative Completion reply
     650:  00:E734                      ;
     651:  00:E734                      ;               The command was not accepted and the requested action did
     652:  00:E734                      ;               not take place.  The User-process is discouraged from
     653:  00:E734                      ;               repeating the exact request (in the same sequence).  Even
     654:  00:E734                      ;               some "permanent" error conditions can be corrected, so
     655:  00:E734                      ;               the human user may want to direct his User-process to
     656:  00:E734                      ;               reinitiate the command sequence by direct action at some
     657:  00:E734                      ;               point in the future (e.g., after the spelling has been
     658:  00:E734                      ;               changed, or the user has altered his directory status.)
     659:  00:E734                      ;
     660:  00:E734                      ;         The following function groupings are encoded in the second
     661:  00:E734                      ;         digit:
     662:  00:E734                      ;
     663:  00:E734                      ;            x0z   Syntax - These replies refer to syntax errors,
     664:  00:E734                      ;                  syntactically correct commands that don't fit any
     665:  00:E734                      ;                  functional category, unimplemented or superfluous
     666:  00:E734                      ;                  commands.
     667:  00:E734                      ;
     668:  00:E734                      ;            x1z   Information -  These are replies to requests for
     669:  00:E734                      ;                  information, such as status or help.
     670:  00:E734                      ;
     671:  00:E734                      ;            x2z   Connections - Replies referring to the control and
     672:  00:E734                      ;                  data connections.
     673:  00:E734                      ;
     674:  00:E734                      ;            x3z   Authentication and accounting - Replies for the login
     675:  00:E734                      ;                  process and accounting procedures.
     676:  00:E734                      ;
     677:  00:E734                      ;            x4z   Unspecified as yet.
     678:  00:E734                      ;
     679:  00:E734                      ;            x5z   File system - These replies indicate the status of the
     680:  00:E734                      ;                  Server file system vis-a-vis the requested transfer or
     681:  00:E734                      ;                  other file system action.
     682:  00:E734                      ;
     683:  00:E734                      ;         The third digit gives a finer gradation of meaning in each of
     684:  00:E734                      ;         the function categories, specified by the second digit.  The
     685:  00:E734                      ;         list of replies below will illustrate this.  Note that the text
     686:  00:E734                      ;         associated with each reply is recommended, rather than
     687:  00:E734                      ;         mandatory, and may even change according to the command with
     688:  00:E734                      ;         which it is associated.  The reply codes, on the other hand,
     689:  00:E734                      ;         must strictly follow the specifications in the last section;
     690:  00:E734                      ;         that is, Server implementations should not invent new codes for
     691:  00:E734                      ;         situations that are only slightly different from the ones
     692:  00:E734                      ;         described here, but rather should adapt codes already defined.
     693:  00:E734                      ;
     694:  00:E734                      ;            A command such as TYPE or ALLO whose successful execution
     695:  00:E734                      ;            does not offer the user-process any new information will
     696:  00:E734                      ;            cause a 200 reply to be returned.  If the command is not
     697:  00:E734                      ;            implemented by a particular Server-FTP process because it
     698:  00:E734                      ;            has no relevance to that computer system, for example ALLO
     699:  00:E734                      ;            at a TOPS20 site, a Positive Completion reply is still
     700:  00:E734                      ;            desired so that the simple User-process knows it can proceed
     701:  00:E734                      ;            with its course of action.  A 202 reply is used in this case
     702:  00:E734                      ;            with, for example, the reply text:  "No storage allocation
     703:  00:E734                      ;            necessary."  If, on the other hand, the command requests a
     704:  00:E734                      ;            non-site-specific action and is unimplemented, the response
     705:  00:E734                      ;            is 502.  A refinement of that is the 504 reply for a command
     706:  00:E734                      ;            that is implemented, but that requests an unimplemented
     707:  00:E734                      ;            parameter.
     708:  00:E734                      ;
     709:  00:E734                      ;      4.2.1  Reply Codes by Function Groups
     710:  00:E734                      ;
     711:  00:E734                      ;         200 Command okay.
     712:  00:E734                      ;         500 Syntax error, command unrecognized.
     713:  00:E734                      ;             This may include errors such as command line too long.
     714:  00:E734                      ;         501 Syntax error in parameters or arguments.
     715:  00:E734                      ;         202 Command not implemented, superfluous at this site.
     716:  00:E734                      ;         502 Command not implemented.
     717:  00:E734                      ;         503 Bad sequence of commands.
     718:  00:E734                      ;         504 Command not implemented for that parameter.
     719:  00:E734                      ;          
     720:  00:E734                      ;         110 Restart marker reply.
     721:  00:E734                      ;             In this case, the text is exact and not left to the
     722:  00:E734                      ;             particular implementation; it must read:
     723:  00:E734                      ;                  MARK yyyy = mmmm
     724:  00:E734                      ;             Where yyyy is User-process data stream marker, and mmmm
     725:  00:E734                      ;             server's equivalent marker (note the spaces between markers
     726:  00:E734                      ;             and "=").
     727:  00:E734                      ;         211 System status, or system help reply.
     728:  00:E734                      ;         212 Directory status.
     729:  00:E734                      ;         213 File status.
     730:  00:E734                      ;         214 Help message.
     731:  00:E734                      ;             On how to use the server or the meaning of a particular
     732:  00:E734                      ;             non-standard command.  This reply is useful only to the
     733:  00:E734                      ;             human user.
     734:  00:E734                      ;         215 NAME system type.
     735:  00:E734                      ;             Where NAME is an official system name from the list in the
     736:  00:E734                      ;             Assigned Numbers document.
     737:  00:E734                      ;          
     738:  00:E734                      ;         120 Service ready in nnn minutes.
     739:  00:E734                      ;         220 Service ready for new user.
     740:  00:E734                      ;         221 Service closing control connection.
     741:  00:E734                      ;             Logged out if appropriate.
     742:  00:E734                      ;         421 Service not available, closing control connection.
     743:  00:E734                      ;             This may be a reply to any command if the service knows it
     744:  00:E734                      ;             must shut down.
     745:  00:E734                      ;         125 Data connection already open; transfer starting.
     746:  00:E734                      ;         225 Data connection open; no transfer in progress.
     747:  00:E734                      ;         425 Can't open data connection.
     748:  00:E734                      ;         226 Closing data connection.
     749:  00:E734                      ;             Requested file action successful (for example, file
     750:  00:E734                      ;             transfer or file abort).
     751:  00:E734                      ;         426 Connection closed; transfer aborted.
     752:  00:E734                      ;         227 Entering Passive Mode (h1,h2,h3,h4,p1,p2).
     753:  00:E734                      ;          
     754:  00:E734                      ;         230 User logged in, proceed.
     755:  00:E734                      ;         530 Not logged in.
     756:  00:E734                      ;         331 User name okay, need password.
     757:  00:E734                      ;         332 Need account for login.
     758:  00:E734                      ;         532 Need account for storing files.
     759:  00:E734                      ;          
     760:  00:E734                      ;         150 File status okay; about to open data connection.
     761:  00:E734                      ;         250 Requested file action okay, completed.
     762:  00:E734                      ;         257 "PATHNAME" created.
     763:  00:E734                      ;         350 Requested file action pending further information.
     764:  00:E734                      ;         450 Requested file action not taken.
     765:  00:E734                      ;             File unavailable (e.g., file busy).
     766:  00:E734                      ;         550 Requested action not taken.
     767:  00:E734                      ;             File unavailable (e.g., file not found, no access).
     768:  00:E734                      ;         451 Requested action aborted. Local error in processing.
     769:  00:E734                      ;         551 Requested action aborted. Page type unknown.
     770:  00:E734                      ;         452 Requested action not taken.
     771:  00:E734                      ;             Insufficient storage space in system.
     772:  00:E734                      ;         552 Requested file action aborted.
     773:  00:E734                      ;             Exceeded storage allocation (for current directory or
     774:  00:E734                      ;             dataset).
     775:  00:E734                      ;         553 Requested action not taken.
     776:  00:E734                      ;             File name not allowed.
     777:  00:E734                      ;         
     778:  00:E734                      ;
     779:  00:E734                      ;      4.2.2 Numeric  Order List of Reply Codes
     780:  00:E734                      ;
     781:  00:E734                      ;         110 Restart marker reply.
     782:  00:E734                      ;             In this case, the text is exact and not left to the
     783:  00:E734                      ;             particular implementation; it must read:
     784:  00:E734                      ;                  MARK yyyy = mmmm
     785:  00:E734                      ;             Where yyyy is User-process data stream marker, and mmmm
     786:  00:E734                      ;             server's equivalent marker (note the spaces between markers
     787:  00:E734                      ;             and "=").
     788:  00:E734                      ;         120 Service ready in nnn minutes.
     789:  00:E734                      ;         125 Data connection already open; transfer starting.
     790:  00:E734                      ;         150 File status okay; about to open data connection.
     791:  00:E734                      ;         200 Command okay.
     792:  00:E734                      ;         202 Command not implemented, superfluous at this site.
     793:  00:E734                      ;         211 System status, or system help reply.
     794:  00:E734                      ;         212 Directory status.
     795:  00:E734                      ;         213 File status.
     796:  00:E734                      ;         214 Help message.
     797:  00:E734                      ;             On how to use the server or the meaning of a particular
     798:  00:E734                      ;             non-standard command.  This reply is useful only to the
     799:  00:E734                      ;             human user.
     800:  00:E734                      ;         215 NAME system type.
     801:  00:E734                      ;             Where NAME is an official system name from the list in the
     802:  00:E734                      ;             Assigned Numbers document.
     803:  00:E734                      ;         220 Service ready for new user.
     804:  00:E734                      ;         221 Service closing control connection.
     805:  00:E734                      ;             Logged out if appropriate.
     806:  00:E734                      ;         225 Data connection open; no transfer in progress.
     807:  00:E734                      ;         226 Closing data connection.
     808:  00:E734                      ;             Requested file action successful (for example, file
     809:  00:E734                      ;             transfer or file abort).
     810:  00:E734                      ;         227 Entering Passive Mode (h1,h2,h3,h4,p1,p2).
     811:  00:E734                      ;         230 User logged in, proceed.
     812:  00:E734                      ;         250 Requested file action okay, completed.
     813:  00:E734                      ;         257 "PATHNAME" created.
     814:  00:E734                      ;          
     815:  00:E734                      ;         331 User name okay, need password.
     816:  00:E734                      ;         332 Need account for login.
     817:  00:E734                      ;         350 Requested file action pending further information.
     818:  00:E734                      ;          
     819:  00:E734                      ;         421 Service not available, closing control connection.
     820:  00:E734                      ;             This may be a reply to any command if the service knows it
     821:  00:E734                      ;             must shut down.
     822:  00:E734                      ;         425 Can't open data connection.
     823:  00:E734                      ;         426 Connection closed; transfer aborted.
     824:  00:E734                      ;         450 Requested file action not taken.
     825:  00:E734                      ;             File unavailable (e.g., file busy).
     826:  00:E734                      ;         451 Requested action aborted: local error in processing.
     827:  00:E734                      ;         452 Requested action not taken.
     828:  00:E734                      ;             Insufficient storage space in system.
     829:  00:E734                      ;         500 Syntax error, command unrecognized.
     830:  00:E734                      ;             This may include errors such as command line too long.
     831:  00:E734                      ;         501 Syntax error in parameters or arguments.
     832:  00:E734                      ;         502 Command not implemented.
     833:  00:E734                      ;         503 Bad sequence of commands.
     834:  00:E734                      ;         504 Command not implemented for that parameter.
     835:  00:E734                      ;         530 Not logged in.
     836:  00:E734                      ;         532 Need account for storing files.
     837:  00:E734                      ;         550 Requested action not taken.
     838:  00:E734                      ;             File unavailable (e.g., file not found, no access).
     839:  00:E734                      ;         551 Requested action aborted: page type unknown.
     840:  00:E734                      ;         552 Requested file action aborted.
     841:  00:E734                      ;             Exceeded storage allocation (for current directory or
     842:  00:E734                      ;             dataset).
     843:  00:E734                      ;         553 Requested action not taken.
     844:  00:E734                      ;             File name not allowed.
     845:  00:E734                      ;         
     846:  00:E734                      ;
     847:  00:E734                      ; 5.  DECLARATIVE SPECIFICATIONS
     848:  00:E734                      ;
     849:  00:E734                      ;   5.1.  MINIMUM IMPLEMENTATION
     850:  00:E734                      ;
     851:  00:E734                      ;      In order to make FTP workable without needless error messages, the
     852:  00:E734                      ;      following minimum implementation is required for all servers:
     853:  00:E734                      ;
     854:  00:E734                      ;         TYPE - ASCII Non-print
     855:  00:E734                      ;         MODE - Stream
     856:  00:E734                      ;         STRUCTURE - File, Record
     857:  00:E734                      ;         COMMANDS - USER, QUIT, PORT,
     858:  00:E734                      ;                    TYPE, MODE, STRU,
     859:  00:E734                      ;                      for the default values
     860:  00:E734                      ;                    RETR, STOR,
     861:  00:E734                      ;                    NOOP.
     862:  00:E734                      ;
     863:  00:E734                      ;      The default values for transfer parameters are:
     864:  00:E734                      ;
     865:  00:E734                      ;         TYPE - ASCII Non-print
     866:  00:E734                      ;         MODE - Stream
     867:  00:E734                      ;         STRU - File
     868:  00:E734                      ;
     869:  00:E734                      ;      All hosts must accept the above as the standard defaults.
     870:  00:E734                      ;
     871:  00:E734                      ;   5.2.  CONNECTIONS
     872:  00:E734                      ;
     873:  00:E734                      ;      The server protocol interpreter shall "listen" on Port L.  The
     874:  00:E734                      ;      user or user protocol interpreter shall initiate the full-duplex
     875:  00:E734                      ;      control connection.  Server- and user- processes should follow the
     876:  00:E734                      ;      conventions of the Telnet protocol as specified in the
     877:  00:E734                      ;      ARPA-Internet Protocol Handbook [1].  Servers are under no
     878:  00:E734                      ;      obligation to provide for editing of command lines and may require
     879:  00:E734                      ;      that it be done in the user host.  The control connection shall be
     880:  00:E734                      ;      closed by the server at the user's request after all transfers and
     881:  00:E734                      ;      replies are completed.
     882:  00:E734                      ;
     883:  00:E734                      ;      The user-DTP must "listen" on the specified data port; this may be
     884:  00:E734                      ;      the default user port (U) or a port specified in the PORT command.
     885:  00:E734                      ;      The server shall initiate the data connection from his own default
     886:  00:E734                      ;      data port (L-1) using the specified user data port.  The direction
     887:  00:E734                      ;      of the transfer and the port used will be determined by the FTP
     888:  00:E734                      ;      service command.
     889:  00:E734                      ;
     890:  00:E734                      ;      Note that all FTP implementation must support data transfer using
     891:  00:E734                      ;      the default port, and that only the USER-PI may initiate the use
     892:  00:E734                      ;      of non-default ports.
     893:  00:E734                      ;
     894:  00:E734                      ;      When data is to be transferred between two servers, A and B (refer
     895:  00:E734                      ;      to Figure 2), the user-PI, C, sets up control connections with
     896:  00:E734                      ;      both server-PI's.  One of the servers, say A, is then sent a PASV
     897:  00:E734                      ;      command telling him to "listen" on his data port rather than
     898:  00:E734                      ;      initiate a connection when he receives a transfer service command.
     899:  00:E734                      ;      When the user-PI receives an acknowledgment to the PASV command,
     900:  00:E734                      ;      which includes the identity of the host and port being listened
     901:  00:E734                      ;      on, the user-PI then sends A's port, a, to B in a PORT command; a
     902:  00:E734                      ;      reply is returned.  The user-PI may then send the corresponding
     903:  00:E734                      ;      service commands to A and B.  Server B initiates the connection
     904:  00:E734                      ;      and the transfer proceeds.  The command-reply sequence is listed
     905:  00:E734                      ;      below where the messages are vertically synchronous but
     906:  00:E734                      ;      horizontally asynchronous:
     907:  00:E734                      ;
     908:  00:E734                      ;         User-PI - Server A                User-PI - Server B
     909:  00:E734                      ;         ------------------                ------------------
     910:  00:E734                      ;         
     911:  00:E734                      ;         C->A : Connect                    C->B : Connect
     912:  00:E734                      ;         C->A : PASV
     913:  00:E734                      ;         A->C : 227 Entering Passive Mode. A1,A2,A3,A4,a1,a2
     914:  00:E734                      ;                                           C->B : PORT A1,A2,A3,A4,a1,a2
     915:  00:E734                      ;                                           B->C : 200 Okay
     916:  00:E734                      ;         C->A : STOR                       C->B : RETR
     917:  00:E734                      ;                    B->A : Connect to HOST-A, PORT-a
     918:  00:E734                      ;
     919:  00:E734                      ;                                Figure 3
     920:  00:E734                      ;
     921:  00:E734                      ;      The data connection shall be closed by the server under the
     922:  00:E734                      ;      conditions described in the Section on Establishing Data
     923:  00:E734                      ;      Connections.  If the data connection is to be closed following a
     924:  00:E734                      ;      data transfer where closing the connection is not required to
     925:  00:E734                      ;      indicate the end-of-file, the server must do so immediately.
     926:  00:E734                      ;      Waiting until after a new transfer command is not permitted
     927:  00:E734                      ;      because the user-process will have already tested the data
     928:  00:E734                      ;      connection to see if it needs to do a "listen"; (remember that the
     929:  00:E734                      ;      user must "listen" on a closed data port BEFORE sending the
     930:  00:E734                      ;      transfer request).  To prevent a race condition here, the server
     931:  00:E734                      ;      sends a reply (226) after closing the data connection (or if the
     932:  00:E734                      ;      connection is left open, a "file transfer completed" reply (250)
     933:  00:E734                      ;      and the user-PI should wait for one of these replies before
     934:  00:E734                      ;      issuing a new transfer command).
     935:  00:E734                      ;
     936:  00:E734                      ;      Any time either the user or server see that the connection is
     937:  00:E734                      ;      being closed by the other side, it should promptly read any
     938:  00:E734                      ;      remaining data queued on the connection and issue the close on its
     939:  00:E734                      ;      own side.
     940:  00:E734                      ;
     941:  00:E734                      ;   5.3.  COMMANDS
     942:  00:E734                      ;
     943:  00:E734                      ;      The commands are Telnet character strings transmitted over the
     944:  00:E734                      ;      control connections as described in the Section on FTP Commands.
     945:  00:E734                      ;      The command functions and semantics are described in the Section
     946:  00:E734                      ;      on Access Control Commands, Transfer Parameter Commands, FTP
     947:  00:E734                      ;      Service Commands, and Miscellaneous Commands.  The command syntax
     948:  00:E734                      ;      is specified here.
     949:  00:E734                      ;
     950:  00:E734                      ;      The commands begin with a command code followed by an argument
     951:  00:E734                      ;      field.  The command codes are four or fewer alphabetic characters.
     952:  00:E734                      ;      Upper and lower case alphabetic characters are to be treated
     953:  00:E734                      ;      identically.  Thus, any of the following may represent the
     954:  00:E734                      ;      retrieve command:
     955:  00:E734                      ;
     956:  00:E734                      ;                  RETR    Retr    retr    ReTr    rETr
     957:  00:E734                      ;
     958:  00:E734                      ;      This also applies to any symbols representing parameter values,
     959:  00:E734                      ;      such as A or a for ASCII TYPE.  The command codes and the argument
     960:  00:E734                      ;      fields are separated by one or more spaces.
     961:  00:E734                      ;
     962:  00:E734                      ;      The argument field consists of a variable length character string
     963:  00:E734                      ;      ending with the character sequence <CRLF> (Carriage Return, Line
     964:  00:E734                      ;      Feed) for NVT-ASCII representation; for other negotiated languages
     965:  00:E734                      ;      a different end of line character might be used.  It should be
     966:  00:E734                      ;      noted that the server is to take no action until the end of line
     967:  00:E734                      ;      code is received.
     968:  00:E734                      ;
     969:  00:E734                      ;      The syntax is specified below in NVT-ASCII.  All characters in the
     970:  00:E734                      ;      argument field are ASCII characters including any ASCII
     971:  00:E734                      ;      represented decimal integers.  Square brackets denote an optional
     972:  00:E734                      ;      argument field.  If the option is not taken, the appropriate
     973:  00:E734                      ;      default is implied.
     974:  00:E734                      ;
     975:  00:E734                      ;      5.3.1.  FTP COMMANDS
     976:  00:E734                      ;
     977:  00:E734                      ;         The following are the FTP commands:
     978:  00:E734                      ;
     979:  00:E734                      ;            USER <SP> <username> <CRLF>
     980:  00:E734                      ;            PASS <SP> <password> <CRLF>
     981:  00:E734                      ;            ACCT <SP> <account-information> <CRLF>
     982:  00:E734                      ;            CWD  <SP> <pathname> <CRLF>
     983:  00:E734                      ;            CDUP <CRLF>
     984:  00:E734                      ;            SMNT <SP> <pathname> <CRLF>
     985:  00:E734                      ;            QUIT <CRLF>
     986:  00:E734                      ;            REIN <CRLF>
     987:  00:E734                      ;            PORT <SP> <host-port> <CRLF>
     988:  00:E734                      ;            PASV <CRLF>
     989:  00:E734                      ;            TYPE <SP> <type-code> <CRLF>
     990:  00:E734                      ;            STRU <SP> <structure-code> <CRLF>
     991:  00:E734                      ;            MODE <SP> <mode-code> <CRLF>
     992:  00:E734                      ;            RETR <SP> <pathname> <CRLF>
     993:  00:E734                      ;            STOR <SP> <pathname> <CRLF>
     994:  00:E734                      ;            STOU <CRLF>
     995:  00:E734                      ;            APPE <SP> <pathname> <CRLF>
     996:  00:E734                      ;            ALLO <SP> <decimal-integer>
     997:  00:E734                      ;                [<SP> R <SP> <decimal-integer>] <CRLF>
     998:  00:E734                      ;            REST <SP> <marker> <CRLF>
     999:  00:E734                      ;            RNFR <SP> <pathname> <CRLF>
    1000:  00:E734                      ;            RNTO <SP> <pathname> <CRLF>
    1001:  00:E734                      ;            ABOR <CRLF>
    1002:  00:E734                      ;            DELE <SP> <pathname> <CRLF>
    1003:  00:E734                      ;            RMD  <SP> <pathname> <CRLF>
    1004:  00:E734                      ;            MKD  <SP> <pathname> <CRLF>
    1005:  00:E734                      ;            PWD  <CRLF>
    1006:  00:E734                      ;            LIST [<SP> <pathname>] <CRLF>
    1007:  00:E734                      ;            NLST [<SP> <pathname>] <CRLF>
    1008:  00:E734                      ;            SITE <SP> <string> <CRLF>
    1009:  00:E734                      ;            SYST <CRLF>
    1010:  00:E734                      ;            STAT [<SP> <pathname>] <CRLF>
    1011:  00:E734                      ;            HELP [<SP> <string>] <CRLF>
    1012:  00:E734                      ;            NOOP <CRLF>
    1013:  00:E734                      ;
    1014:  00:E734                      ;      5.3.2.  FTP COMMAND ARGUMENTS
    1015:  00:E734                      ;
    1016:  00:E734                      ;         The syntax of the above argument fields (using BNF notation
    1017:  00:E734                      ;         where applicable) is:
    1018:  00:E734                      ;
    1019:  00:E734                      ;            <username> ::= <string>
    1020:  00:E734                      ;            <password> ::= <string>
    1021:  00:E734                      ;            <account-information> ::= <string>
    1022:  00:E734                      ;            <string> ::= <char> | <char><string>
    1023:  00:E734                      ;            <char> ::= any of the 128 ASCII characters except <CR> and
    1024:  00:E734                      ;            <LF>
    1025:  00:E734                      ;            <marker> ::= <pr-string>
    1026:  00:E734                      ;            <pr-string> ::= <pr-char> | <pr-char><pr-string>
    1027:  00:E734                      ;            <pr-char> ::= printable characters, any
    1028:  00:E734                      ;                          ASCII code 33 through 126
    1029:  00:E734                      ;            <byte-size> ::= <number>
    1030:  00:E734                      ;            <host-port> ::= <host-number>,<port-number>
    1031:  00:E734                      ;            <host-number> ::= <number>,<number>,<number>,<number>
    1032:  00:E734                      ;            <port-number> ::= <number>,<number>
    1033:  00:E734                      ;            <number> ::= any decimal integer 1 through 255
    1034:  00:E734                      ;            <form-code> ::= N | T | C
    1035:  00:E734                      ;            <type-code> ::= A [<sp> <form-code>]
    1036:  00:E734                      ;                          | E [<sp> <form-code>]
    1037:  00:E734                      ;                          | I
    1038:  00:E734                      ;                          | L <sp> <byte-size>
    1039:  00:E734                      ;            <structure-code> ::= F | R | P
    1040:  00:E734                      ;            <mode-code> ::= S | B | C
    1041:  00:E734                      ;            <pathname> ::= <string>
    1042:  00:E734                      ;            <decimal-integer> ::= any decimal integer
    1043:  00:E734                      ;
    1044:  00:E734                      ;   5.4.  SEQUENCING OF COMMANDS AND REPLIES
    1045:  00:E734                      ;
    1046:  00:E734                      ;      The communication between the user and server is intended to be an
    1047:  00:E734                      ;      alternating dialogue.  As such, the user issues an FTP command and
    1048:  00:E734                      ;      the server responds with a prompt primary reply.  The user should
    1049:  00:E734                      ;      wait for this initial primary success or failure response before
    1050:  00:E734                      ;      sending further commands.
    1051:  00:E734                      ;
    1052:  00:E734                      ;      Certain commands require a second reply for which the user should
    1053:  00:E734                      ;      also wait.  These replies may, for example, report on the progress
    1054:  00:E734                      ;      or completion of file transfer or the closing of the data
    1055:  00:E734                      ;      connection.  They are secondary replies to file transfer commands.
    1056:  00:E734                      ;
    1057:  00:E734                      ;      One important group of informational replies is the connection
    1058:  00:E734                      ;      greetings.  Under normal circumstances, a server will send a 220
    1059:  00:E734                      ;      reply, "awaiting input", when the connection is completed.  The
    1060:  00:E734                      ;      user should wait for this greeting message before sending any
    1061:  00:E734                      ;      commands.  If the server is unable to accept input right away, a
    1062:  00:E734                      ;      120 "expected delay" reply should be sent immediately and a 220
    1063:  00:E734                      ;      reply when ready.  The user will then know not to hang up if there
    1064:  00:E734                      ;      is a delay.
    1065:  00:E734                      ;
    1066:  00:E734                      ;      Spontaneous Replies
    1067:  00:E734                      ;
    1068:  00:E734                      ;         Sometimes "the system" spontaneously has a message to be sent
    1069:  00:E734                      ;         to a user (usually all users).  For example, "System going down
    1070:  00:E734                      ;         in 15 minutes".  There is no provision in FTP for such
    1071:  00:E734                      ;         spontaneous information to be sent from the server to the user.
    1072:  00:E734                      ;         It is recommended that such information be queued in the
    1073:  00:E734                      ;         server-PI and delivered to the user-PI in the next reply
    1074:  00:E734                      ;         (possibly making it a multi-line reply).
    1075:  00:E734                      ;
    1076:  00:E734                      ;      The table below lists alternative success and failure replies for
    1077:  00:E734                      ;      each command.  These must be strictly adhered to; a server may
    1078:  00:E734                      ;      substitute text in the replies, but the meaning and action implied
    1079:  00:E734                      ;      by the code numbers and by the specific command reply sequence
    1080:  00:E734                      ;      cannot be altered.
    1081:  00:E734                      ;
    1082:  00:E734                      ;      Command-Reply Sequences
    1083:  00:E734                      ;
    1084:  00:E734                      ;         In this section, the command-reply sequence is presented.  Each
    1085:  00:E734                      ;         command is listed with its possible replies; command groups are
    1086:  00:E734                      ;         listed together.  Preliminary replies are listed first (with
    1087:  00:E734                      ;         their succeeding replies indented and under them), then
    1088:  00:E734                      ;         positive and negative completion, and finally intermediary
    1089:  00:E734                      ;         replies with the remaining commands from the sequence
    1090:  00:E734                      ;         following.  This listing forms the basis for the state
    1091:  00:E734                      ;         diagrams, which will be presented separately.
    1092:  00:E734                      ;
    1093:  00:E734                      ;            Connection Establishment
    1094:  00:E734                      ;               120
    1095:  00:E734                      ;                  220
    1096:  00:E734                      ;               220
    1097:  00:E734                      ;               421
    1098:  00:E734                      ;            Login
    1099:  00:E734                      ;               USER
    1100:  00:E734                      ;                  230
    1101:  00:E734                      ;                  530
    1102:  00:E734                      ;                  500, 501, 421
    1103:  00:E734                      ;                  331, 332
    1104:  00:E734                      ;               PASS
    1105:  00:E734                      ;                  230
    1106:  00:E734                      ;                  202
    1107:  00:E734                      ;                  530
    1108:  00:E734                      ;                  500, 501, 503, 421
    1109:  00:E734                      ;                  332
    1110:  00:E734                      ;               ACCT
    1111:  00:E734                      ;                  230
    1112:  00:E734                      ;                  202
    1113:  00:E734                      ;                  530
    1114:  00:E734                      ;                  500, 501, 503, 421
    1115:  00:E734                      ;               CWD
    1116:  00:E734                      ;                  250
    1117:  00:E734                      ;                  500, 501, 502, 421, 530, 550
    1118:  00:E734                      ;               CDUP
    1119:  00:E734                      ;                  200
    1120:  00:E734                      ;                  500, 501, 502, 421, 530, 550
    1121:  00:E734                      ;               SMNT
    1122:  00:E734                      ;                  202, 250
    1123:  00:E734                      ;                  500, 501, 502, 421, 530, 550
    1124:  00:E734                      ;            Logout
    1125:  00:E734                      ;               REIN
    1126:  00:E734                      ;                  120
    1127:  00:E734                      ;                     220
    1128:  00:E734                      ;                  220
    1129:  00:E734                      ;                  421
    1130:  00:E734                      ;                  500, 502
    1131:  00:E734                      ;               QUIT
    1132:  00:E734                      ;                  221
    1133:  00:E734                      ;                  500
    1134:  00:E734                      ;            Transfer parameters
    1135:  00:E734                      ;               PORT
    1136:  00:E734                      ;                  200
    1137:  00:E734                      ;                  500, 501, 421, 530
    1138:  00:E734                      ;               PASV
    1139:  00:E734                      ;                  227
    1140:  00:E734                      ;                  500, 501, 502, 421, 530
    1141:  00:E734                      ;               MODE
    1142:  00:E734                      ;                  200
    1143:  00:E734                      ;                  500, 501, 504, 421, 530
    1144:  00:E734                      ;               TYPE
    1145:  00:E734                      ;                  200
    1146:  00:E734                      ;                  500, 501, 504, 421, 530
    1147:  00:E734                      ;               STRU
    1148:  00:E734                      ;                  200
    1149:  00:E734                      ;                  500, 501, 504, 421, 530
    1150:  00:E734                      ;            File action commands
    1151:  00:E734                      ;               ALLO
    1152:  00:E734                      ;                  200
    1153:  00:E734                      ;                  202
    1154:  00:E734                      ;                  500, 501, 504, 421, 530
    1155:  00:E734                      ;               REST
    1156:  00:E734                      ;                  500, 501, 502, 421, 530
    1157:  00:E734                      ;                  350
    1158:  00:E734                      ;               STOR
    1159:  00:E734                      ;                  125, 150
    1160:  00:E734                      ;                     (110)
    1161:  00:E734                      ;                     226, 250
    1162:  00:E734                      ;                     425, 426, 451, 551, 552
    1163:  00:E734                      ;                  532, 450, 452, 553
    1164:  00:E734                      ;                  500, 501, 421, 530
    1165:  00:E734                      ;               STOU
    1166:  00:E734                      ;                  125, 150
    1167:  00:E734                      ;                     (110)
    1168:  00:E734                      ;                     226, 250
    1169:  00:E734                      ;                     425, 426, 451, 551, 552
    1170:  00:E734                      ;                  532, 450, 452, 553
    1171:  00:E734                      ;                  500, 501, 421, 530
    1172:  00:E734                      ;               RETR
    1173:  00:E734                      ;                  125, 150
    1174:  00:E734                      ;                     (110)
    1175:  00:E734                      ;                     226, 250
    1176:  00:E734                      ;                     425, 426, 451
    1177:  00:E734                      ;                  450, 550
    1178:  00:E734                      ;                  500, 501, 421, 530
    1179:  00:E734                      ;               LIST
    1180:  00:E734                      ;                  125, 150
    1181:  00:E734                      ;                     226, 250
    1182:  00:E734                      ;                     425, 426, 451
    1183:  00:E734                      ;                  450
    1184:  00:E734                      ;                  500, 501, 502, 421, 530
    1185:  00:E734                      ;               NLST
    1186:  00:E734                      ;                  125, 150
    1187:  00:E734                      ;                     226, 250
    1188:  00:E734                      ;                     425, 426, 451
    1189:  00:E734                      ;                  450
    1190:  00:E734                      ;                  500, 501, 502, 421, 530
    1191:  00:E734                      ;               APPE
    1192:  00:E734                      ;                  125, 150
    1193:  00:E734                      ;                     (110)
    1194:  00:E734                      ;                     226, 250
    1195:  00:E734                      ;                     425, 426, 451, 551, 552
    1196:  00:E734                      ;                  532, 450, 550, 452, 553
    1197:  00:E734                      ;                  500, 501, 502, 421, 530
    1198:  00:E734                      ;               RNFR
    1199:  00:E734                      ;                  450, 550
    1200:  00:E734                      ;                  500, 501, 502, 421, 530
    1201:  00:E734                      ;                  350
    1202:  00:E734                      ;               RNTO
    1203:  00:E734                      ;                  250
    1204:  00:E734                      ;                  532, 553
    1205:  00:E734                      ;                  500, 501, 502, 503, 421, 530
    1206:  00:E734                      ;               DELE
    1207:  00:E734                      ;                  250
    1208:  00:E734                      ;                  450, 550
    1209:  00:E734                      ;                  500, 501, 502, 421, 530
    1210:  00:E734                      ;               RMD
    1211:  00:E734                      ;                  250
    1212:  00:E734                      ;                  500, 501, 502, 421, 530, 550
    1213:  00:E734                      ;               MKD
    1214:  00:E734                      ;                  257
    1215:  00:E734                      ;                  500, 501, 502, 421, 530, 550
    1216:  00:E734                      ;               PWD
    1217:  00:E734                      ;                  257
    1218:  00:E734                      ;                  500, 501, 502, 421, 550
    1219:  00:E734                      ;               ABOR
    1220:  00:E734                      ;                  225, 226
    1221:  00:E734                      ;                  500, 501, 502, 421
    1222:  00:E734                      ;            Informational commands
    1223:  00:E734                      ;               SYST
    1224:  00:E734                      ;                  215
    1225:  00:E734                      ;                  500, 501, 502, 421
    1226:  00:E734                      ;               STAT
    1227:  00:E734                      ;                  211, 212, 213
    1228:  00:E734                      ;                  450
    1229:  00:E734                      ;                  500, 501, 502, 421, 530
    1230:  00:E734                      ;               HELP
    1231:  00:E734                      ;                  211, 214
    1232:  00:E734                      ;                  500, 501, 502, 421
    1233:  00:E734                      ;            Miscellaneous commands
    1234:  00:E734                      ;               SITE
    1235:  00:E734                      ;                  200
    1236:  00:E734                      ;                  202
    1237:  00:E734                      ;                  500, 501, 530
    1238:  00:E734                      ;               NOOP
    1239:  00:E734                      ;                  200
    1240:  00:E734                      ;                  500 421
    1241:  00:E734                      ;
    1242:  00:E734                      ; 7.  TYPICAL FTP SCENARIO
    1243:  00:E734                      ;
    1244:  00:E734                      ;   User at host U wanting to transfer files to/from host S:
    1245:  00:E734                      ;
    1246:  00:E734                      ;   In general, the user will communicate to the server via a mediating
    1247:  00:E734                      ;   user-FTP process.  The following may be a typical scenario.  The
    1248:  00:E734                      ;   user-FTP prompts are shown in parentheses, '---->' represents
    1249:  00:E734                      ;   commands from host U to host S, and '<----' represents replies from
    1250:  00:E734                      ;   host S to host U.
    1251:  00:E734                      ;
    1252:  00:E734                      ;      LOCAL COMMANDS BY USER              ACTION INVOLVED
    1253:  00:E734                      ;
    1254:  00:E734                      ;      ftp (host) multics<CR>         Connect to host S, port L,
    1255:  00:E734                      ;                                     establishing control connections.
    1256:  00:E734                      ;                                     <---- 220 Service ready <CRLF>.
    1257:  00:E734                      ;      username Doe <CR>              USER Doe<CRLF>---->
    1258:  00:E734                      ;                                     <---- 331 User name ok,
    1259:  00:E734                      ;                                               need password<CRLF>.
    1260:  00:E734                      ;      password mumble <CR>           PASS mumble<CRLF>---->
    1261:  00:E734                      ;                                     <---- 230 User logged in<CRLF>.
    1262:  00:E734                      ;      retrieve (local type) ASCII<CR>
    1263:  00:E734                      ;      (local pathname) test 1 <CR>   User-FTP opens local file in ASCII.
    1264:  00:E734                      ;      (for. pathname) test.pl1<CR>   RETR test.pl1<CRLF> ---->
    1265:  00:E734                      ;                                     <---- 150 File status okay;
    1266:  00:E734                      ;                                           about to open data
    1267:  00:E734                      ;                                           connection<CRLF>.
    1268:  00:E734                      ;                                     Server makes data connection
    1269:  00:E734                      ;                                     to port U.
    1270:  00:E734                      ;      
    1271:  00:E734                      ;                                     <---- 226 Closing data connection,
    1272:  00:E734                      ;                                         file transfer successful<CRLF>.
    1273:  00:E734                      ;      type Image<CR>                 TYPE I<CRLF> ---->
    1274:  00:E734                      ;                                     <---- 200 Command OK<CRLF>
    1275:  00:E734                      ;      store (local type) image<CR>
    1276:  00:E734                      ;      (local pathname) file dump<CR> User-FTP opens local file in Image.
    1277:  00:E734                      ;      (for.pathname) >udd>cn>fd<CR>  STOR >udd>cn>fd<CRLF> ---->
    1278:  00:E734                      ;                                     <---- 550 Access denied<CRLF>
    1279:  00:E734                      ;      terminate                      QUIT <CRLF> ---->
    1280:  00:E734                      ;                                     Server closes all
    1281:  00:E734                      ;                                     connections.
    1282:  00:E734                      ;
    1283:  00:E734                      ; 8.  CONNECTION ESTABLISHMENT
    1284:  00:E734                      ;
    1285:  00:E734                      ;   The FTP control connection is established via TCP between the user
    1286:  00:E734                      ;   process port U and the server process port L.  This protocol is
    1287:  00:E734                      ;   assigned the service port 21 (25 octal), that is L=21.
    1288:  00:E734                      ;
    1289:  00:E734                      ;==============================================================================
    1290:  00:E734                      ;
    1291:  00:E734                      ;
    1292:  00:E734  (00:0015)           CONTROL_DPORT	equ	21		; Server listens on port 21
    1293:  00:E734  (00:0016)           CONTROL_SPORT	equ	22		; Our port
    1294:  00:E734                      ;
    1295:  00:E734                      ;
    1296:  00:E734                      ; open_control
    1297:  00:E734                      ;
    1298:  00:E734                      ; Opens the control session to the FTP server
    1299:  00:E734                      ;
    1300:  00:E734                      ; In:   A=socket number
    1301:  00:E734                      ;      HL->ip address to connect to
    1302:  00:E734                      ; Out: NC if successful
    1303:  00:E734                      ;
    1304:  00:E734  32 4A F0            open_control:	ld	(vars.ftp.socket),a
    1305:  00:E737                      ;
    1306:  00:E737  FD CB 00 5E         		bit	vars.trace.ftp,(iy+vars._trace)
    1307:  00:E73B  28 11               		jr	z,.notrace
    1308:  00:E73D                      ;
    1309:  00:E73D  11 4B D3            		ld	de,trace.ftp.open
    1310:  00:E740  CD 8A EA            		call	trace
    1311:  00:E743                      ;
    1312:  00:E743  E5                  		push	hl
    1313:  00:E744  CD 8C CD            		 call	io.ip
    1314:  00:E747  CD 3C D0            		 call	trace.dots
    1315:  00:E74A  E1                  		pop	hl		; HL->server IP
    1316:  00:E74B                      ;
    1317:  00:E74B  3A 4A F0            		ld	a,(vars.ftp.socket)
    1318:  00:E74E                      ;
    1319:  00:E74E  E5                  .notrace:	push	hl		; Save ->IP address
    1320:  00:E74F  21 16 00            		 ld	hl,CONTROL_SPORT; HL=our port number
    1321:  00:E752  11 12 EC            		 ld	de,owner_str
    1322:  00:E755  CD 23 DD            		 call	tcp.open
    1323:  00:E758  D1                  		pop	de		; DE->IP address
    1324:  00:E759  38 09               		jr	c,.done
    1325:  00:E75B                      ;
    1326:  00:E75B  21 15 00            		ld	hl,CONTROL_DPORT; HL=server port no.
    1327:  00:E75E  3A 4A F0            		ld	a,(vars.ftp.socket)
    1328:  00:E761  CD 32 DF            		call	tcp.connect
    1329:  00:E764                      ;
    1330:  00:E764  FD CB 00 5E         .done:		bit	vars.trace.ftp,(iy+vars._trace)
    1331:  00:E768  C8                  		ret	z
    1332:  00:E769                      ;
    1333:  00:E769  C3 44 D0            		jp	trace.is_error
    1334:  00:E76C                      ;
    1335:  00:E76C                      ;------------------------------------------------------------------------------
    1336:  00:E76C                      ; login
    1337:  00:E76C                      ;
    1338:  00:E76C                      ; Called after open_control to read the hello string from the server and send
    1339:  00:E76C                      ; login commands
    1340:  00:E76C                      ;
    1341:  00:E76C                      ; In:  vars.ftp.socket contains the socket number if called immediately
    1342:  00:E76C                      ;      after open_control
    1343:  00:E76C                      ;      DE->user name, length byte first
    1344:  00:E76C                      ; Out: Cy=>error, not logged in
    1345:  00:E76C                      ;
    1346:  00:E76C                      login:
    1347:  00:E76C  FD CB 00 5E         		bit	vars.trace.ftp,(iy+vars._trace)
    1348:  00:E770  28 08               		jr	z,.notrace
    1349:  00:E772                      ;
    1350:  00:E772  D5                  		push	de
    1351:  00:E773  11 57 D3            		 ld	de,trace.ftp.login
    1352:  00:E776  CD 8A EA            		 call	trace
    1353:  00:E779  D1                  		pop	de
    1354:  00:E77A                      .notrace:
    1355:  00:E77A                      		; Copy user name arg to buffer
    1356:  00:E77A  EB                  		ex	de,hl		; HL->user name arg
    1357:  00:E77B  11 53 F1            		ld	de,vars.ftp.user
    1358:  00:E77E  D5                  		push	de		; Save -> user name buffer
    1359:  00:E77F  4E                  		 ld	c,(hl)		; Get length byte
    1360:  00:E780  0C                  		 inc	c		; Include length byte
    1361:  00:E781  3E 27               		 ld	a,vars.ftp.user_size-1
    1362:  00:E783  B9                  		 cp	c
    1363:  00:E784  30 01               		 jr	nc,.lenok
    1364:  00:E786  4F                  		 ld	c,a
    1365:  00:E787  06 00               .lenok:		 ld	b,0
    1366:  00:E789  ED B0               		 ldir
    1367:  00:E78B                      ;
    1368:  00:E78B  CD 0E E9            		 call	get_response	; Wait for "hello message" from server
    1369:  00:E78E  E1                  		pop	hl		; HL->vars.ftp.user
    1370:  00:E78F  D8                  		ret	c
    1371:  00:E790                      ;
    1372:  00:E790  7E                  		ld	a,(hl)		; Got user name?
    1373:  00:E791  B7                  		or	a
    1374:  00:E792  20 1A               		jr	nz,.gotuser	; Go if username given on command line
    1375:  00:E794                      ;
    1376:  00:E794  11 05 E8            		ld	de,userprompt_str
    1377:  00:E797  0E 28               		ld	c,vars.ftp.user_size
    1378:  00:E799  E5                  		push	hl		; Save -> user name buffer
    1379:  00:E79A  CD 7E CE            		 call	io.input	; Prompt user for user name
    1380:  00:E79D  E1                  		pop	hl		; HL->user name buffer
    1381:  00:E79E  D8                  		ret	c
    1382:  00:E79F                      ;
    1383:  00:E79F  7E                  		ld	a,(hl)
    1384:  00:E7A0  B7                  		or	a
    1385:  00:E7A1  20 0B               		jr	nz,.gotuser
    1386:  00:E7A3                      ;
    1387:  00:E7A3  E5                  		push	hl		; Save -> user name buffer
    1388:  00:E7A4  EB                  		ex	de,hl		; DE->username buffer
    1389:  00:E7A5  21 EC E7            		ld	hl,anonymous_str
    1390:  00:E7A8  01 0A 00            		ld	bc,anonymous_str_size
    1391:  00:E7AB  ED B0               		ldir			; Copy default username
    1392:  00:E7AD  E1                  		pop	hl		; HL->user name buffer
    1393:  00:E7AE                      ;
    1394:  00:E7AE  EB                  .gotuser:	ex	de,hl		; DE->user name
    1395:  00:E7AF  21 E5 EB            		ld	hl,user_str
    1396:  00:E7B2  CD 02 E9            		call	issue_arg
    1397:  00:E7B5  D8                  		ret	c
    1398:  00:E7B6                      ;
    1399:  00:E7B6  11 4B 01            		ld	de,331		; Password required
    1400:  00:E7B9  B7                  		or	a
    1401:  00:E7BA  ED 52               		sbc	hl,de
    1402:  00:E7BC  C0                  		ret	nz
    1403:  00:E7BD                      ;
    1404:  00:E7BD  21 7B F1            		ld	hl,vars.ftp.pass
    1405:  00:E7C0  11 1D E8            		ld	de,passprompt_str
    1406:  00:E7C3  0E 28               		ld	c,vars.ftp.pass_size
    1407:  00:E7C5  E5                  		push	hl
    1408:  00:E7C6  CD 7E CE            		 call	io.input	; Prompt usert for password
    1409:  00:E7C9  E1                  		pop	hl		; HL->password buffer
    1410:  00:E7CA  D8                  		ret	c
    1411:  00:E7CB                      ;
    1412:  00:E7CB  7E                  		ld	a,(hl)
    1413:  00:E7CC  B7                  		or	a
    1414:  00:E7CD  20 0B               		jr	nz,.gotpass
    1415:  00:E7CF                      ;
    1416:  00:E7CF  E5                  		push	hl		; Save -> password buffer
    1417:  00:E7D0  EB                  		ex	de,hl		; DE->password buffer
    1418:  00:E7D1  21 F6 E7            		ld	hl,localhost_str
    1419:  00:E7D4  01 0F 00            		ld	bc,localhost_str_size
    1420:  00:E7D7  ED B0               		ldir			; Copy default password
    1421:  00:E7D9  E1                  		pop	hl		; HL->password buffer
    1422:  00:E7DA                      ;
    1423:  00:E7DA  EB                  .gotpass:	ex	de,hl		; DE->password
    1424:  00:E7DB  21 EB EB            		ld	hl,pass_str
    1425:  00:E7DE  11 7B F1            		ld	de,vars.ftp.pass
    1426:  00:E7E1  CD 02 E9            		call	issue_arg
    1427:  00:E7E4  D8                  		ret	c
    1428:  00:E7E5                      ;
    1429:  00:E7E5  11 90 01            		ld	de,400		; <400 ok, >=400 =>error
    1430:  00:E7E8  ED 52               		sbc	hl,de
    1431:  00:E7EA  3F                  		ccf
    1432:  00:E7EB  C9                  		ret
    1433:  00:E7EC                      ;
    1434:  00:E7EC                      ;
    1435:  00:E7EC                      anonymous_str:		db	9,"anonymous"
    1435:  00:E7EC  09 61 6E 6F 6E 79 6D 6F 75 73 
    1436:  00:E7F6  (00:000A)           anonymous_str_size	equ	$-anonymous_str		; Includes length byte
    1437:  00:E7F6                      ;
    1438:  00:E7F6                      localhost_str:		db	14,"anon@localhost"
    1438:  00:E7F6  0E 61 6E 6F 6E 40 6C 6F 63 61 6C 68 6F 73 74 
    1439:  00:E805  (00:000F)           localhost_str_size	equ	$-localhost_str		; Includes length byte
    1440:  00:E805                      ;
    1441:  00:E805                      userprompt_str:		db	"User name [anonymous]: ",0
    1441:  00:E805  55 73 65 72 20 6E 61 6D 65 20 5B 61 6E 6F 6E 79 
    1441:  00:E815  6D 6F 75 73 5D 3A 20 00 
    1442:  00:E81D                      passprompt_str:		db	"Password [anon@localhost]: ",0
    1442:  00:E81D  50 61 73 73 77 6F 72 64 20 5B 61 6E 6F 6E 40 6C 
    1442:  00:E82D  6F 63 61 6C 68 6F 73 74 5D 3A 20 00 
    1443:  00:E839                      ;
    1444:  00:E839                      ;
    1445:  00:E839                      ;------------------------------------------------------------------------------
    1446:  00:E839                      ; logout
    1447:  00:E839                      ;
    1448:  00:E839                      ; This is called to cleanly log out of the FTP session.
    1449:  00:E839                      ;
    1450:  00:E839                      ; In:  A=socket number
    1451:  00:E839                      ;
    1452:  00:E839  32 4A F0            logout:		ld	(vars.ftp.socket),a
    1453:  00:E83C                      ;
    1454:  00:E83C  21 0D EC            		ld	hl,quit_str
    1455:  00:E83F  C3 FF E8            		jp	issue
    1456:  00:E842                      ;
    1457:  00:E842                      ;
    1458:  00:E842                      ;------------------------------------------------------------------------------
    1459:  00:E842                      ; dir
    1460:  00:E842                      ;
    1461:  00:E842                      ; Issues an FTP LIST command
    1462:  00:E842                      ;
    1463:  00:E842                      ; DIR is more complicated than most of the commands because the response to
    1464:  00:E842                      ; the LIST command is sent to the FTP data connection, so we have to issue
    1465:  00:E842                      ; a PASV command, open the channel...
    1466:  00:E842                      ;
    1467:  00:E842                      ; In:  A=socket number
    1468:  00:E842                      ;     DE->argment, length byte first
    1469:  00:E842                      ; Out: A=EXOS error code
    1470:  00:E842                      ;
    1471:  00:E842  32 4A F0            dir:		ld	(vars.ftp.socket),a
    1472:  00:E845                      ;
    1473:  00:E845  D5                  		push	de		; Save ->arg
    1474:  00:E846  CD 60 E9            		 call	open_data	; Open data connection
    1475:  00:E849  D1                  		pop	de		; DE->arg
    1476:  00:E84A  3E 65               		ld	a,exos.ERR_FTPDATA
    1477:  00:E84C  DA A2 C9            		jp	c,exos.check_stop
    1478:  00:E84F                      ;
    1479:  00:E84F  21 F6 EB            		ld	hl,list_str
    1480:  00:E852  CD 02 E9            		call	issue_arg	; Send LIST command
    1481:  00:E855  38 36               		jr	c,.timeout	; Go with Cy if timeout
    1482:  00:E857                      ;
    1483:  00:E857  AF                  		xor	a		; Socket 0
    1484:  00:E858  CD 80 E9            		call	read		; Read data from socket
    1485:  00:E85B  38 30               		jr	c,.timeout	; Go with Cy if timeout
    1486:  00:E85D                      ;
    1487:  00:E85D  E5                  .print:		push	hl		; Save buffer start
    1488:  00:E85E  09                  		 add	hl,bc		; Point to last byte read
    1489:  00:E85F  36 00               		 ld	(hl),0		; Terminate it
    1490:  00:E861  E1                  		pop	hl		; HL->response
    1491:  00:E862                      ;
    1492:  00:E862  EB                  		ex	de,hl		; DE->data
    1493:  00:E863  CD 3D CE            		call	io.str		; Print it
    1494:  00:E866                      ;
    1495:  00:E866  AF                  		xor	a		; Socket 0
    1496:  00:E867  CD B1 DB            		call	socket.get_rx_size; More than 1 buffer full?
    1497:  00:E86A  7C                  		ld	a,h
    1498:  00:E86B  B5                  		or	l
    1499:  00:E86C  28 1A               		jr	z,.done		; Go if not
    1500:  00:E86E                      ;
    1501:  00:E86E  4D                  		ld	c,l
    1502:  00:E86F  44                  		ld	b,h		; BC=remainder size
    1503:  00:E870  21 FE 00            		ld	hl,vars.ftp.buffer_size-2; See if it will fit in buffer
    1504:  00:E873  B7                  		or	a
    1505:  00:E874  ED 42               		sbc	hl,bc
    1506:  00:E876  30 03               		jr	nc,.doread	; Go if it will fit in buffer
    1507:  00:E878                      ;
    1508:  00:E878  01 FE 00            		ld	bc,vars.ftp.buffer_size-2; Else limit to buffer size
    1509:  00:E87B  21 53 F0            .doread:	ld	hl,vars.ftp.buffer
    1510:  00:E87E  E5                  		push	hl		; Save start of buffer
    1511:  00:E87F  C5                  		push	bc		; Save bytes that will be in buffer
    1512:  00:E880  AF                  		 xor	a
    1513:  00:E881  CD AC D8            		 call	socket.read	; Read response
    1514:  00:E884  C1                  		pop	bc		; BC=size of response
    1515:  00:E885  E1                  		pop	hl		; HL->response
    1516:  00:E886  18 D5               		jr	.print
    1517:  00:E888                      ;
    1518:  00:E888  AF                  .done:		xor	a
    1519:  00:E889  CD 74 D9            		call	socket.read_end
    1520:  00:E88C                      
    1521:  00:E88C  B7                  		or	a		; NC=>No error
    1522:  00:E88D  9F                  .timeout:	sbc	a,a		; ff=>error, 0 => ok
    1523:  00:E88E  E6 6A               		and	exos.ERR_TIMEOUT; Error code or 0
    1524:  00:E890  F5                  .close:		push	af
    1525:  00:E891  AF                  		xor	a
    1526:  00:E892  CD 73 DF            		call	tcp.close	; Close data channel
    1527:  00:E895  F1                  		pop	af
    1528:  00:E896  C0                  		ret	nz		; Return if error
    1529:  00:E897                      ;
    1530:  00:E897  3A 4A F0            		ld	a,(vars.ftp.socket)
    1531:  00:E89A  CD 07 E9            		call	is_response	; Get any response after data
    1532:  00:E89D                      ;
    1533:  00:E89D  AF                  		xor	a		; 0=>no error
    1534:  00:E89E  C9                  		ret
    1535:  00:E89F                      ;
    1536:  00:E89F                      ;
    1537:  00:E89F                      ;------------------------------------------------------------------------------
    1538:  00:E89F                      ; status
    1539:  00:E89F                      ;
    1540:  00:E89F                      ; Issues an FTP SYST command
    1541:  00:E89F                      ;
    1542:  00:E89F                      ; In:  A=socket number
    1543:  00:E89F                      ;
    1544:  00:E89F                      status:
    1545:  00:E89F  32 4A F0            		ld	(vars.ftp.socket),a
    1546:  00:E8A2                      ;
    1547:  00:E8A2  21 08 EC            		ld	hl,syst_str
    1548:  00:E8A5  18 26               		jr	issue_print
    1549:  00:E8A7                      ;
    1550:  00:E8A7                      ;
    1551:  00:E8A7                      ;------------------------------------------------------------------------------
    1552:  00:E8A7                      ; chdir
    1553:  00:E8A7                      ;
    1554:  00:E8A7                      ; Issues an FTP PWD, CWD or CDUP command depending on the argument.
    1555:  00:E8A7                      ;
    1556:  00:E8A7                      ; In:  A=socket number
    1557:  00:E8A7                      ;     DE->argment, length byte first
    1558:  00:E8A7                      ;
    1559:  00:E8A7  32 4A F0            chdir:		ld	(vars.ftp.socket),a
    1560:  00:E8AA                      ;
    1561:  00:E8AA  1A                  		ld	a,(de)
    1562:  00:E8AB  B7                  		or	a
    1563:  00:E8AC  28 1C               		jr	z,.pwd		; No arg - just print current directory
    1564:  00:E8AE                      ;
    1565:  00:E8AE  FE 02               		cp	2
    1566:  00:E8B0  20 0E               		jr	nz,.cd		; Not ".." - cd to specified directory
    1567:  00:E8B2                      ;
    1568:  00:E8B2  13                  		inc	de
    1569:  00:E8B3  1A                  		ld	a,(de)
    1570:  00:E8B4  FE 2E               		cp	'.'
    1571:  00:E8B6  20 07               		jr	nz,.deccd
    1572:  00:E8B8  13                  		inc	de
    1573:  00:E8B9  1A                  		ld	a,(de)
    1574:  00:E8BA  FE 2E               		cp	'.'
    1575:  00:E8BC  28 07               		jr	z,.cdup
    1576:  00:E8BE  1B                  		dec	de
    1577:  00:E8BF  1B                  .deccd:		dec	de
    1578:  00:E8C0                      ;
    1579:  00:E8C0  21 BB EB            .cd:		ld	hl,cwd_str	; Send CWD <dir> command
    1580:  00:E8C3  18 3D               		jr	issue_arg
    1581:  00:E8C5                      ;
    1582:  00:E8C5  21 C4 EB            .cdup:		ld	hl,cdup_str	; Send CDUP command
    1583:  00:E8C8  18 35               		jr	issue
    1584:  00:E8CA                      ;
    1585:  00:E8CA  21 C0 EB            .pwd:		ld	hl,pwd_str	; Send PWD command
    1586:  00:E8CD  CD FF E8            issue_print:	call	issue
    1587:  00:E8D0  11 53 F0            		ld	de,vars.ftp.buffer	; Print response
    1588:  00:E8D3  C3 3D CE            		jp	io.str
    1589:  00:E8D6                      ;
    1590:  00:E8D6                      ;
    1591:  00:E8D6                      ;------------------------------------------------------------------------------
    1592:  00:E8D6                      ; mkdir
    1593:  00:E8D6                      ;
    1594:  00:E8D6                      ; Issues an FTP MKD command
    1595:  00:E8D6                      ;
    1596:  00:E8D6                      ; In:  A=socket number
    1597:  00:E8D6                      ;     DE->pathname, length byte first
    1598:  00:E8D6                      ;
    1599:  00:E8D6  32 4A F0            mkdir:		ld	(vars.ftp.socket),a
    1600:  00:E8D9                      ;
    1601:  00:E8D9  21 C9 EB            		ld	hl,mkd_str
    1602:  00:E8DC  18 24               		jr	issue_arg		; Issue command and arg
    1603:  00:E8DE                      ;
    1604:  00:E8DE                      ;
    1605:  00:E8DE                      ;------------------------------------------------------------------------------
    1606:  00:E8DE                      ; rmdir
    1607:  00:E8DE                      ;
    1608:  00:E8DE                      ; Issues an FTP RMD command
    1609:  00:E8DE                      ;
    1610:  00:E8DE                      ; In:  A=socket number
    1611:  00:E8DE                      ;     DE->pathname, length byte first
    1612:  00:E8DE                      ;
    1613:  00:E8DE                      rmdir:
    1614:  00:E8DE  32 4A F0            		ld	(vars.ftp.socket),a
    1615:  00:E8E1                      ;
    1616:  00:E8E1  21 CE EB            		ld	hl,rmd_str
    1617:  00:E8E4  18 1C               		jr	issue_arg		; Issue command and arg
    1618:  00:E8E6                      ;
    1619:  00:E8E6                      ;
    1620:  00:E8E6                      ;------------------------------------------------------------------------------
    1621:  00:E8E6                      ; del
    1622:  00:E8E6                      ;
    1623:  00:E8E6                      ; Issues an FTP DELE command
    1624:  00:E8E6                      ;
    1625:  00:E8E6                      ; In:  A=socket number
    1626:  00:E8E6                      ;     DE->pathname, length byte first
    1627:  00:E8E6                      ;
    1628:  00:E8E6                      del:
    1629:  00:E8E6  32 4A F0            		ld	(vars.ftp.socket),a
    1630:  00:E8E9                      ;
    1631:  00:E8E9  21 D3 EB            		ld	hl,dele_str
    1632:  00:E8EC  18 14               		jr	issue_arg		; Issue command and arg
    1633:  00:E8EE                      
    1634:  00:E8EE                      ;------------------------------------------------------------------------------
    1635:  00:E8EE                      ; ren
    1636:  00:E8EE                      ;
    1637:  00:E8EE                      ; Issues FTP RNFR and RNTO commands
    1638:  00:E8EE                      ;
    1639:  00:E8EE                      ; In:  A=socket number
    1640:  00:E8EE                      ;     DE->from name, length byte first
    1641:  00:E8EE                      ;     HL->to name, length byte first
    1642:  00:E8EE                      ;
    1643:  00:E8EE                      ren:
    1644:  00:E8EE  32 4A F0            		ld	(vars.ftp.socket),a
    1645:  00:E8F1                      ;
    1646:  00:E8F1  E5                  		push	hl		; Save to name
    1647:  00:E8F2  21 D9 EB            		 ld	hl,rnfr_str
    1648:  00:E8F5  CD 02 E9            		 call	issue_arg	; Issue command and arg
    1649:  00:E8F8  D1                  		pop	de		; DE->to name
    1650:  00:E8F9  D8                  		ret	c
    1651:  00:E8FA                      ;
    1652:  00:E8FA  21 DF EB            		ld	hl,rnto_str
    1653:  00:E8FD  18 03               		jr	issue_arg	; Issue command and arg
    1654:  00:E8FF                      ;
    1655:  00:E8FF                      ;
    1656:  00:E8FF                      ;------------------------------------------------------------------------------
    1657:  00:E8FF                      ; get_response
    1658:  00:E8FF                      ;
    1659:  00:E8FF                      ; After issuing an FTP command reads the response with timeout, and returns
    1660:  00:E8FF                      ; the response code
    1661:  00:E8FF                      ;
    1662:  00:E8FF                      ; Out: Cy=>we didn't get a response
    1663:  00:E8FF                      ;      HL=response code
    1664:  00:E8FF                      ;       A=EXOS error code corresponding to the FTP response code
    1665:  00:E8FF  11 00 00            issue:		ld	de,0
    1666:  00:E902  CD EF E9            issue_arg:	call	issue_cmd
    1667:  00:E905  18 07               		jr	get_response
    1668:  00:E907                      ;
    1669:  00:E907  3A 4A F0            is_response:	ld	a,(vars.ftp.socket)	; See if any response yet
    1670:  00:E90A  CD 76 D8            		call	socket.available
    1671:  00:E90D  C8                  		ret	z
    1672:  00:E90E                      get_response:
    1673:  00:E90E  3A 4A F0            		ld	a,(vars.ftp.socket)	; See if any response yet
    1674:  00:E911  CD 80 E9            		call	read
    1675:  00:E914  3E 6A               		ld	a,exos.ERR_TIMEOUT
    1676:  00:E916  DA A2 C9            		jp	c,exos.check_stop
    1677:  00:E919                      ;
    1678:  00:E919                      .noerr:
    1679:  00:E919  E5                  		push	hl			; Save buffer start
    1680:  00:E91A  09                  		 add	hl,bc			; Point to last byte read
    1681:  00:E91B  36 00               		 ld	(hl),0			; Terminate it
    1682:  00:E91D  C5                  		 push	bc
    1683:  00:E91E  3A 4A F0            		  ld	a,(vars.ftp.socket)
    1684:  00:E921  CD 74 D9            		  call	socket.read_end
    1685:  00:E924  C1                  		 pop	bc
    1686:  00:E925  E1                  		pop	hl			; HL->response
    1687:  00:E926                      ;
    1688:  00:E926  FD CB 00 5E         		bit	vars.trace.ftp,(iy+vars._trace)
    1689:  00:E92A  28 0E               		jr	z,.donetrace
    1690:  00:E92C                      ;
    1691:  00:E92C  E5                  		push	hl			; Save->response string
    1692:  00:E92D  C5                  		push	bc			; Save #bytes
    1693:  00:E92E  11 64 D3            		 ld	de,trace.ftp.rx
    1694:  00:E931  CD 8A EA            		 call	trace
    1695:  00:E934  EB                  		 ex	de,hl			; DE->response string
    1696:  00:E935  CD 3D CE            		 call	io.str
    1697:  00:E938  C1                  		pop	bc			; BC=byte count
    1698:  00:E939  E1                  		pop	hl			; HL->response string
    1699:  00:E93A                      .donetrace:
    1700:  00:E93A                      ;
    1701:  00:E93A  E5                  		push	hl			; Save->response string
    1702:  00:E93B  C5                  		push	bc			; Save byte count
    1703:  00:E93C  CD CC E9            		 call	read_code		; HL=response error/status code
    1704:  00:E93F  C1                  		pop	bc			; BC=byte count
    1705:  00:E940  D1                  		pop	de			; DE->response string
    1706:  00:E941                      ;
    1707:  00:E941  E5                  		push	hl			; Save FTP response code
    1708:  00:E942  CD 94 EB            		 call	ftp_to_exos		; A=equivalent EXOS error code
    1709:  00:E945  E1                  		pop	hl			; HL=FTP response code
    1710:  00:E946                      ;
    1711:  00:E946  FD CB 00 5E         		bit	vars.trace.ftp,(iy+vars._trace)
    1712:  00:E94A  C8                  		ret	z
    1713:  00:E94B                      ;
    1714:  00:E94B  F5                  		push	af			; Save EXOS error & NC
    1715:  00:E94C  D5                  		push	de			; Save ->response code
    1716:  00:E94D  E5                  		 push	hl			; Save response code
    1717:  00:E94E  11 74 D3            		   ld	de,trace.ftp.code		;      "Rx code="
    1718:  00:E951  CD 8A EA            		   call	trace			; "FTPn:"
    1719:  00:E954  E1                  		 pop	hl			; HL=response code
    1720:  00:E955                      ;
    1721:  00:E955  E5                  		 push	hl			; Save response code again
    1722:  00:E956  CD B1 CD            		  call	io.int			; Print it
    1723:  00:E959  CD 28 CE            		  call	io.crlf
    1724:  00:E95C  E1                  		 pop	hl			; HL=response code
    1725:  00:E95D  D1                  		pop	de			; DE->buffer
    1726:  00:E95E  F1                  		pop	af			; A=EXOS error, F=NC
    1727:  00:E95F                      ;
    1728:  00:E95F  C9                  		ret
    1729:  00:E960                      ;
    1730:  00:E960                      ;
    1731:  00:E960                      ;------------------------------------------------------------------------------
    1732:  00:E960                      ; open_data
    1733:  00:E960                      ;
    1734:  00:E960                      ; opens and reads a FTP data channel
    1735:  00:E960                      ;
    1736:  00:E960  CD 2D EA            open_data:	call	send_pasv	; First get PASV parameters
    1737:  00:E963  D8                  		ret	c
    1738:  00:E964                      ;
    1739:  00:E964  AF                  		xor	a		; Socket 0
    1740:  00:E965  21 42 42            		ld	hl,4242h	; Our port number, any?
    1741:  00:E968  11 16 EC            		ld	de,owner_data_str
    1742:  00:E96B  CD 23 DD            		call	tcp.open
    1743:  00:E96E  D8                  		ret	c
    1744:  00:E96F                      ;
    1745:  00:E96F  AF                  		xor	a		; Socket 0
    1746:  00:E970  2A 51 F0            		ld	hl,(vars.ftp.data_port)
    1747:  00:E973  11 4D F0            		ld	de,vars.ftp.data_ip
    1748:  00:E976  CD 32 DF            		call	tcp.connect
    1749:  00:E979  D0                  		ret	nc
    1750:  00:E97A                      ;
    1751:  00:E97A  AF                  		xor	a
    1752:  00:E97B  CD 73 DF            		call	tcp.close
    1753:  00:E97E  37                  		scf
    1754:  00:E97F  C9                  		ret
    1755:  00:E980                      ;
    1756:  00:E980                      ;
    1757:  00:E980                      ;------------------------------------------------------------------------------
    1758:  00:E980                      ; read
    1759:  00:E980                      ;
    1760:  00:E980                      ; reads from an FTP socket into a buffer
    1761:  00:E980                      ; The caller must call socket.read_end afterwards
    1762:  00:E980                      ;
    1763:  00:E980                      ; In:  A=socket number
    1764:  00:E980                      ; Out: Cy=>timeout waiting for data
    1765:  00:E980                      ;      HL->data read
    1766:  00:E980                      ;      BC=size of data
    1767:  00:E980                      read:
    1768:  00:E980  2A 06 F0            		ld	hl,(vars.ticks)
    1769:  00:E983  22 4B F0            		ld	(vars.ftp.start),hl
    1770:  00:E986                      ;
    1771:  00:E986                      .loop:
    1772:  00:E986  F5                  		push	af			; Save socket number
    1773:  00:E987  CD 29 DD            		 call	tcp.header		; Packet received?
    1774:  00:E98A  20 26               		 jr	nz,.readit		; Go & read it if yes
    1775:  00:E98C                      ;
    1776:  00:E98C  F1                  		pop	af			; A=socket number
    1777:  00:E98D  F5                  		push	af			; Save socket number
    1778:  00:E98E  CD 8A D8            		 call	socket.is_closed	; Check socket not closed
    1779:  00:E991  20 03               		 jr	nz,.notclosed		; Go if ok
    1780:  00:E993                      ;
    1781:  00:E993  F1                  		pop	af			; Drop saved socket number
    1782:  00:E994  37                  		scf
    1783:  00:E995  C9                  		ret
    1784:  00:E996                      ;
    1785:  00:E996                      .notclosed:
    1786:  00:E996  CD CA CE            		call	status.waiting		; Flash status indicator
    1787:  00:E999                      ;
    1788:  00:E999  F1                  		pop	af			; A=socket number
    1789:  00:E99A  CD 94 C9            		call	exos.is_stop
    1790:  00:E99D  D8                  		ret	c
    1791:  00:E99E                      ;
    1792:  00:E99E  2A 06 F0            		ld	hl,(vars.ticks)
    1793:  00:E9A1  ED 4B 4B F0         		ld	bc,(vars.ftp.start)
    1794:  00:E9A5  B7                  		or	a
    1795:  00:E9A6  ED 42               		sbc	hl,bc			; HL=duration in ticks
    1796:  00:E9A8  01 B8 0B            		ld	bc,TICKS_1m		; 1 minute timeout
    1797:  00:E9AB  B7                  		or	a
    1798:  00:E9AC  ED 42               		sbc	hl,bc
    1799:  00:E9AE  38 D6               		jr	c,.loop
    1800:  00:E9B0                      ;
    1801:  00:E9B0  37                  		scf				; Timed out
    1802:  00:E9B1  C9                  		ret
    1803:  00:E9B2                      ;
    1804:  00:E9B2  F1                  .readit:	pop	af			; A=socket number
    1805:  00:E9B3                      ;
    1806:  00:E9B3  4D                  		ld	c,l
    1807:  00:E9B4  44                  		ld	b,h			; BC=response size
    1808:  00:E9B5  21 FE 00            		ld	hl,vars.ftp.buffer_size-2; See if it will fit in buffer
    1809:  00:E9B8  B7                  		or	a
    1810:  00:E9B9  ED 42               		sbc	hl,bc
    1811:  00:E9BB  30 03               		jr	nc,.doread		; Go if it will fit in buffer
    1812:  00:E9BD                      ;
    1813:  00:E9BD  01 FE 00            		ld	bc,vars.ftp.buffer_size-2; Else limit to buffer size
    1814:  00:E9C0  21 53 F0            .doread:	ld	hl,vars.ftp.buffer
    1815:  00:E9C3  E5                  		push	hl			; Save start of buffer
    1816:  00:E9C4  C5                  		push	bc			; Save response size
    1817:  00:E9C5  CD AC D8            		 call	socket.read		; Read response
    1818:  00:E9C8  C1                  		pop	bc			; BC=size of response
    1819:  00:E9C9  E1                  		pop	hl			; HL->response
    1820:  00:E9CA                      ;
    1821:  00:E9CA  B7                  		or	a			; No error
    1822:  00:E9CB  C9                  		ret
    1823:  00:E9CC                      ;
    1824:  00:E9CC                      ;
    1825:  00:E9CC                      ;------------------------------------------------------------------------------
    1826:  00:E9CC                      ; read_code
    1827:  00:E9CC                      ;
    1828:  00:E9CC                      ; Finds the response/error number at the beginning of the line in an
    1829:  00:E9CC                      ; FTP response. We don't just find the first one - if there is more than one
    1830:  00:E9CC                      ; line we return the last (ie most recent) one
    1831:  00:E9CC                      ; In:  HL->FTP response string
    1832:  00:E9CC                      ; Out: HL=code
    1833:  00:E9CC                      ;
    1834:  00:E9CC                      read_code:
    1835:  00:E9CC  5D                  		ld	e,l		; DE->response
    1836:  00:E9CD  54                  		ld	d,h
    1837:  00:E9CE                      ;
    1838:  00:E9CE  B7                  		or	a
    1839:  00:E9CF  ED 62               		sbc	hl,hl		; HL=0 (last code found)
    1840:  00:E9D1                      
    1841:  00:E9D1                      		; At this point we are at the beginning of the line
    1842:  00:E9D1  CD C4 CF            .first:		call	util.get_num16
    1843:  00:E9D4                      ;
    1844:  00:E9D4                      		; We've done one line - now find the start of the next
    1845:  00:E9D4  1A                  .nextline:	ld	a,(de)		; Get char from response
    1846:  00:E9D5  13                  		inc	de
    1847:  00:E9D6  B7                  		or	a
    1848:  00:E9D7  C8                  		ret	z		; Ret if end of response
    1849:  00:E9D8                      ;
    1850:  00:E9D8  FE 0D               		cp	CR		; If it's a CR we've found end of line
    1851:  00:E9DA  28 04               		jr	z,.skip
    1852:  00:E9DC                      ;
    1853:  00:E9DC  FE 0A               		cp	LF		; Ditto LF
    1854:  00:E9DE  20 F4               		jr	nz,.nextline
    1855:  00:E9E0                      ;
    1856:  00:E9E0                      		; Found first CR or LF, now skip all CRs & LFs
    1857:  00:E9E0  1A                  .skip:		ld	a,(de)
    1858:  00:E9E1  13                  		inc	de
    1859:  00:E9E2  B7                  		or	a
    1860:  00:E9E3  C8                  		ret	z
    1861:  00:E9E4                      ;
    1862:  00:E9E4  FE 0D               		cp	CR
    1863:  00:E9E6  28 F8               		jr	z,.skip
    1864:  00:E9E8                      ;
    1865:  00:E9E8  FE 0A               		cp	LF
    1866:  00:E9EA  28 F4               		jr	z,.skip
    1867:  00:E9EC                      ;
    1868:  00:E9EC  1B                  		dec	de
    1869:  00:E9ED  18 E2               		jr	.first		; First non-CRLF = start of line
    1870:  00:E9EF                      ;
    1871:  00:E9EF                      ;
    1872:  00:E9EF                      ;------------------------------------------------------------------------------
    1873:  00:E9EF                      ; issue_cmd
    1874:  00:E9EF                      ;
    1875:  00:E9EF                      ; Sends an ftp command with optional argument from command line
    1876:  00:E9EF                      ;
    1877:  00:E9EF                      ; In:  HL->FTP command
    1878:  00:E9EF                      ;      DE->arg, length byte first, or 0 if none
    1879:  00:E9EF                      ;      vars.ftp.socket
    1880:  00:E9EF                      ;
    1881:  00:E9EF  D5                  issue_cmd:	push	de		; Save ->arg
    1882:  00:E9F0  11 53 F0            		 ld	de,vars.ftp.buffer
    1883:  00:E9F3  CD F8 CE            		 call	util.copystr	; Copy command string at (HL)
    1884:  00:E9F6  E1                  		pop	hl		; HL->arg
    1885:  00:E9F7  7C                  		ld	a,h
    1886:  00:E9F8  B5                  		or	l
    1887:  00:E9F9  C4 00 CF            		call	nz,util.copyarg	; Add arg to command string
    1888:  00:E9FC                      ;
    1889:  00:E9FC  FD CB 00 5E         		bit	vars.trace.ftp,(iy+vars._trace)
    1890:  00:EA00  28 11               		jr	z,.notrace
    1891:  00:EA02                      ;
    1892:  00:EA02  D5                  		push	de		; Save end of command in buffer
    1893:  00:EA03  11 60 D3            		 ld	de,trace.ftp.tx	;      "Tx "
    1894:  00:EA06  CD 8A EA            		 call	trace		; "FTPn:"
    1895:  00:EA09                      ;
    1896:  00:EA09  11 53 F0            		 ld	de,vars.ftp.buffer
    1897:  00:EA0C  CD 3D CE            		 call	io.str		; Print FTP command before CRLF added
    1898:  00:EA0F  CD 28 CE            		 call	io.crlf
    1899:  00:EA12  D1                  		pop	de		; DE->end of command in buffer
    1900:  00:EA13                      ;
    1901:  00:EA13  21 2A EA            .notrace:	ld	hl,crlf_str	; FTP commands end in CRLF
    1902:  00:EA16  CD F8 CE            		call	util.copystr
    1903:  00:EA19                      
    1904:  00:EA19  21 53 F0            		ld	hl,vars.ftp.buffer
    1905:  00:EA1C  CD 15 CF            		call	util.strlen	; BC=total length of command, HL->start
    1906:  00:EA1F                      ;
    1907:  00:EA1F  3A 4A F0            		ld	a,(vars.ftp.socket)
    1908:  00:EA22  F5                  		push	af
    1909:  00:EA23  CD 8C D9            		 call	socket.write
    1910:  00:EA26  F1                  		pop	af
    1911:  00:EA27                      ;
    1912:  00:EA27  C3 04 DF            		jp	tcp.send
    1913:  00:EA2A                      ;
    1914:  00:EA2A  0D 0A 00            crlf_str:	db	CR,LF,0
    1915:  00:EA2D                      ;
    1916:  00:EA2D                      ;
    1917:  00:EA2D                      ;------------------------------------------------------------------------------
    1918:  00:EA2D                      ; send_pasv
    1919:  00:EA2D                      ;
    1920:  00:EA2D                      ; Sends an FTP PASV command and parses the result
    1921:  00:EA2D                      ;
    1922:  00:EA2D                      ; Out:  Cy=>error
    1923:  00:EA2D                      ;       vars.ftp.data_ip and vars.ftp.data_port filled in
    1924:  00:EA2D                      ;
    1925:  00:EA2D  21 F1 EB            send_pasv:	ld	hl,pasv_str
    1926:  00:EA30  CD FF E8            		call	issue
    1927:  00:EA33  D8                  		ret	c
    1928:  00:EA34                      ;
    1929:  00:EA34  11 56 F0            		ld	de,vars.ftp.buffer+3	; Point passed response code
    1930:  00:EA37  CD 7F EA            		call	findnum		; DE->next number in message
    1931:  00:EA3A  6B                  		ld	l,e
    1932:  00:EA3B  62                  		ld	h,d		; HL->remaining message
    1933:  00:EA3C  CD 15 CF            		call	util.strlen	; BC=length of remaining message
    1934:  00:EA3F  41                  		ld	b,c		; B=length of remaing message		
    1935:  00:EA40  1B                  		dec	de		; Pretend to point to length byte
    1936:  00:EA41  21 4D F0            		ld	hl,vars.ftp.data_ip
    1937:  00:EA44  CD 78 CF            		call	util.get_ip	; Interpret IP address
    1938:  00:EA47  CD 7F EA            		call	findnum		; DE->first number after IP
    1939:  00:EA4A  CD C4 CF            		call	util.get_num16	; Assume port H for data connection
    1940:  00:EA4D  1A                  		ld	a,(de)
    1941:  00:EA4E  FE 2C               		cp	','		; Skip likely separators
    1942:  00:EA50  28 08               		jr	z,.gotsep
    1943:  00:EA52  FE 2E               		cp	'.'
    1944:  00:EA54  28 04               		jr	z,.gotsep
    1945:  00:EA56  FE 20               		cp	' '
    1946:  00:EA58  20 07               		jr	nz,.notsep
    1947:  00:EA5A                      ;
    1948:  00:EA5A  E5                  .gotsep:	push	hl		; Save port num H
    1949:  00:EA5B  13                  		inc	de		; Skip separator
    1950:  00:EA5C  CD C4 CF            		call	util.get_num16	; HL=port num L
    1951:  00:EA5F  C1                  		pop	bc		; BC=port num H
    1952:  00:EA60  61                  		ld	h,c		; HL=port number
    1953:  00:EA61  22 51 F0            .notsep:	ld	(vars.ftp.data_port),hl
    1954:  00:EA64                      ;
    1955:  00:EA64  FD CB 00 5E         		bit	vars.trace.ftp,(iy+vars._trace)
    1956:  00:EA68  C8                  		ret	z
    1957:  00:EA69                      ;
    1958:  00:EA69  11 6E D3            		ld	de,trace.ftp.pasv	;      "pasv="
    1959:  00:EA6C  CD 8A EA            		call	trace			; "FTPn:"
    1960:  00:EA6F                      ;
    1961:  00:EA6F  E5                  		push	hl		; Save port number
    1962:  00:EA70  21 4D F0            		 ld	hl,vars.ftp.data_ip
    1963:  00:EA73  CD 8C CD            		 call	io.ip		; Print ip address
    1964:  00:EA76  3E 3A               		 ld	a,':'
    1965:  00:EA78  CD 00 CE            		 call	io.char
    1966:  00:EA7B  E1                  		pop	hl
    1967:  00:EA7C  C3 B1 CD            		jp	io.int		; And port no.
    1968:  00:EA7F                      ;
    1969:  00:EA7F                      ;
    1970:  00:EA7F                      ;
    1971:  00:EA7F  1B                  findnum:	dec	de
    1972:  00:EA80  13                  .loop:		inc	de		; Look for first numerical digit
    1973:  00:EA81  1A                  		ld	a,(de)
    1974:  00:EA82  B7                  		or	a
    1975:  00:EA83  C8                  		ret	z
    1976:  00:EA84                      ;
    1977:  00:EA84  CD BD CF            		call	util.isdig
    1978:  00:EA87  38 F7               		jr	c,.loop
    1979:  00:EA89                      ;
    1980:  00:EA89  C9                  		ret			; HL->first digit
    1981:  00:EA8A                      ;
    1982:  00:EA8A                      ;
    1983:  00:EA8A                      ;------------------------------------------------------------------------------
    1984:  00:EA8A                      ; trace_start
    1985:  00:EA8A                      ;
    1986:  00:EA8A                      ; Outputs "FTPn:<str>" at start of trace line
    1987:  00:EA8A                      ;
    1988:  00:EA8A                      ; In:  DE->str
    1989:  00:EA8A                      ;
    1990:  00:EA8A  CD 23 CE            trace:		call	io.start
    1991:  00:EA8D  3E 46               		ld	a,'F'
    1992:  00:EA8F  CD 00 CE            		call	io.char
    1993:  00:EA92  3E 54               		ld	a,'T'
    1994:  00:EA94  CD 00 CE            		call	io.char
    1995:  00:EA97  3E 50               		ld	a,'P'
    1996:  00:EA99  CD 00 CE            		call	io.char
    1997:  00:EA9C  3A 4A F0            		ld	a,(vars.ftp.socket)
    1998:  00:EA9F  C6 30               		add	a,'0'
    1999:  00:EAA1  CD 00 CE            		call	io.char
    2000:  00:EAA4  3E 3A               		ld	a,':'
    2001:  00:EAA6  CD 00 CE            		call	io.char
    2002:  00:EAA9  C3 3D CE            		jp	io.str
    2003:  00:EAAC                      ;
    2004:  00:EAAC                      ;
    2005:  00:EAAC                      ;==============================================================================
    2006:  00:EAAC                      ; The following functions are called by the EXOS FTP: device
    2007:  00:EAAC                      ;
    2008:  00:EAAC                      ;
    2009:  00:EAAC                      ; This is the data kept in EXOS channel RAM.
    2010:  00:EAAC                      ;
    2011:  00:EAAC                      ; EXOS channel RAM is accessed at (ix-1), (ix-2)...etc so our data here is
    2012:  00:EAAC                      ; accessed with (ix-1-<item>) eg (ix-1-socket)
    2013:  00:EAAC                      ;
    2014:  00:EAAC                      ; socket must be first as some of the generic device code expects it here.
    2015:  00:EAAC                      ;
    2016:  00:EAAC                      		struct	ftp_channel	; Variables in EXOS channel RAM
    2017:  00:EAAC                    < socket		 byte			; WIZ socket # for this channel
    2018:  00:EAAC                    < data		 byte			; NZ=>data socket is open
    2019:  00:EAAC                    < 		ends
    2020:  00:EAAC                      ;
    2021:  00:EAAC                      ;
    2022:  00:EAAC                      ;------------------------------------------------------------------------------
    2023:  00:EAAC                      ; device_open
    2024:  00:EAAC                      ;
    2025:  00:EAAC                      ; This is called by the EXOS device open function call
    2026:  00:EAAC                      ;
    2027:  00:EAAC                      ; In:  DE->filename, length byte first
    2028:  00:EAAC                      ;      IX->EXOS channel RAM
    2029:  00:EAAC                      ;       A=socket number
    2030:  00:EAAC                      ; Out: A=EXOS error code, Z not necessarily set appropriately
    2031:  00:EAAC                      ;
    2032:  00:EAAC                      device_open:
    2033:  00:EAAC  21 FC EB            		ld	hl,retr_str
    2034:  00:EAAF  18 03               		jr	opencreate
    2035:  00:EAB1                      		
    2036:  00:EAB1                      ;
    2037:  00:EAB1                      ;
    2038:  00:EAB1                      ;------------------------------------------------------------------------------
    2039:  00:EAB1                      ; device_create
    2040:  00:EAB1                      ;
    2041:  00:EAB1                      ; This is called by the EXOS device create function call
    2042:  00:EAB1                      ; In:   A=socket number (control)
    2043:  00:EAB1                      ;      DE->filename, length byte first
    2044:  00:EAB1                      ;      IX->EXOS channel RAM
    2045:  00:EAB1                      ; Out: A=EXOS error code
    2046:  00:EAB1                      ;
    2047:  00:EAB1                      device_create:
    2048:  00:EAB1  21 02 EC            		ld	hl,stor_str
    2049:  00:EAB4                      
    2050:  00:EAB4                      		; Open and create are identical except for the FTP command
    2051:  00:EAB4                      		; string
    2052:  00:EAB4                      opencreate:
    2053:  00:EAB4  FD E5               		push	iy
    2054:  00:EAB6  FD 21 00 F0         		 ld	iy,vars
    2055:  00:EABA                      ;		
    2056:  00:EABA  32 4A F0            		 ld	(vars.ftp.socket),a
    2057:  00:EABD  DD 36 FE 00         		 ld	(ix-1-ftp_channel.data),0; 0=>no data channel open
    2058:  00:EAC1                      ;
    2059:  00:EAC1  CD B5 CE            		 call	status.start	; Start activity indicator
    2060:  00:EAC4                      
    2061:  00:EAC4  E5                  		 push	hl		; Save FTP command
    2062:  00:EAC5  D5                  		 push	de		; Save ->arg
    2063:  00:EAC6  CD 60 E9            		  call	open_data	; Open data connection
    2064:  00:EAC9  D1                  		 pop	de		; DE->arg
    2065:  00:EACA  E1                  		 pop	hl		; HL->FTP command
    2066:  00:EACB  3E 6B               		 ld	a,exos.ERR_NOCON
    2067:  00:EACD  38 12               		 jr	c,.ret
    2068:  00:EACF                      ;
    2069:  00:EACF  AF                  		 xor	a		; Data channel; socket always 0
    2070:  00:EAD0  DD 77 FF            		 ld	(ix-1-ftp_channel.socket),a
    2071:  00:EAD3  DD 36 FE FF         		 ld	(ix-1-ftp_channel.data),0xff;	; NZ=>data socket open
    2072:  00:EAD7                      ;
    2073:  00:EAD7  CD 02 E9            		 call	issue_arg	; Send FTP command, HL=response code
    2074:  00:EADA  3E 6A               		 ld	a,exos.ERR_TIMEOUT
    2075:  00:EADC  38 03               		 jr	c,.ret
    2076:  00:EADE                      ;
    2077:  00:EADE  CD 94 EB            		 call	ftp_to_exos
    2078:  00:EAE1  F5                  .ret:		 push	af
    2079:  00:EAE2  CD A9 CE            	 	  call	status.stop	; Stop activity indicator
    2080:  00:EAE5  F1                  		 pop	af
    2081:  00:EAE6  FD E1               		pop	iy
    2082:  00:EAE8  C9                  		ret
    2083:  00:EAE9                      ;
    2084:  00:EAE9                      ;
    2085:  00:EAE9                      ;------------------------------------------------------------------------------
    2086:  00:EAE9                      ; device_close
    2087:  00:EAE9                      ;
    2088:  00:EAE9                      ; This is called by the EXOS device close function call
    2089:  00:EAE9                      ;
    2090:  00:EAE9                      ; In:   A=socket number (control)
    2091:  00:EAE9                      ;      IX->EXOS channel RAM
    2092:  00:EAE9                      ; Out: A=EXOS error code
    2093:  00:EAE9                      ;
    2094:  00:EAE9                      device_close:
    2095:  00:EAE9  FD E5               		push	iy
    2096:  00:EAEB  FD 21 00 F0         		 ld	iy,vars
    2097:  00:EAEF                      ;		
    2098:  00:EAEF  32 4A F0            		 ld	(vars.ftp.socket),a
    2099:  00:EAF2                      ;
    2100:  00:EAF2  CD B5 CE            		 call	status.start	; Start activity indicator
    2101:  00:EAF5                      
    2102:  00:EAF5  AF                  		 xor	a
    2103:  00:EAF6  DD CB FE 46         		 bit	0,(ix-1-ftp_channel.data);
    2104:  00:EAFA  C4 73 DF            		 call	nz,tcp.close	; Close data socket (socket = 0)
    2105:  00:EAFD                      ;
    2106:  00:EAFD  DD 36 FE 00         		 ld	(ix-1-ftp_channel.data),0; Not open now
    2107:  00:EB01                      ;
    2108:  00:EB01  CD 07 E9            		 call	is_response	; Read any final reponse to RETR/STOR
    2109:  00:EB04                      
    2110:  00:EB04  CD A9 CE            	 	 call	status.stop	; Stop activity indicator
    2111:  00:EB07                      
    2112:  00:EB07  AF                  		 xor	a		; No error
    2113:  00:EB08  FD E1               		pop	iy
    2114:  00:EB0A  C9                  		ret
    2115:  00:EB0B                      ;
    2116:  00:EB0B                      ;
    2117:  00:EB0B                      ;------------------------------------------------------------------------------
    2118:  00:EB0B                      ; device_read_byte
    2119:  00:EB0B                      ;
    2120:  00:EB0B                      ; This is called by the EXOS device read_byte function call
    2121:  00:EB0B                      ;
    2122:  00:EB0B                      ; In:   A=socket number (control)
    2123:  00:EB0B                      ;      IX->EXOS channel RAM
    2124:  00:EB0B                      ; Out:  B=byte
    2125:  00:EB0B                      ;       A=EXOS error code
    2126:  00:EB0B                      ;
    2127:  00:EB0B                      device_read_byte:
    2128:  00:EB0B  FD E5               		push	iy
    2129:  00:EB0D  FD 21 00 F0         		 ld	iy,vars
    2130:  00:EB11                      ;
    2131:  00:EB11                      ; POKE 'd'
    2132:  00:EB11                      ; POKE 'c'
    2133:  00:EB11                       
    2134:  00:EB11  32 4A F0            		 ld	(vars.ftp.socket),a
    2135:  00:EB14                      ;
    2136:  00:EB14  CD B5 CE            		 call	status.start		; Start activity indicator
    2137:  00:EB17                      ;
    2138:  00:EB17  11 0E F0            		 ld	de,vars.device.byte	; 1 byte buffer
    2139:  00:EB1A  01 01 00            		 ld	bc,1
    2140:  00:EB1D  AF                  		 xor	a			; Socket 0 for data
    2141:  00:EB1E  CD 6F DD            		 call	tcp.read_block		; Read 1 byte
    2142:  00:EB21  FD 46 0E            		 ld	b,(iy+vars.device._byte)	; Return 1 byte in B
    2143:  00:EB24                      ; POKE '='
    2144:  00:EB24                      ; POKEBYTE b
    2145:  00:EB24  F5                  		 push	af
    2146:  00:EB25  CD A9 CE            	 	  call	status.stop		; Stop activity indicator
    2147:  00:EB28  F1                  		 pop	af
    2148:  00:EB29                      
    2149:  00:EB29  18 0F               		 jr	read_ret
    2150:  00:EB2B                      ;		
    2151:  00:EB2B                      ;
    2152:  00:EB2B                      ;------------------------------------------------------------------------------
    2153:  00:EB2B                      ; device_read_block
    2154:  00:EB2B                      ;
    2155:  00:EB2B                      ; This is called by the EXOS device read_block function call
    2156:  00:EB2B                      ;
    2157:  00:EB2B                      ; In:   A=socket number (control)
    2158:  00:EB2B                      ;      IX->EXOS channel RAM
    2159:  00:EB2B                      ;      DE->user's buffer
    2160:  00:EB2B                      ;      BC=byte count
    2161:  00:EB2B                      ; Out: A=EXOS error code
    2162:  00:EB2B                      ;
    2163:  00:EB2B                      device_read_block:
    2164:  00:EB2B  FD E5               		push	iy
    2165:  00:EB2D  FD 21 00 F0         		 ld	iy,vars
    2166:  00:EB31                      ;
    2167:  00:EB31                      ; POKE 'd'
    2168:  00:EB31                      ; POKE 'b'
    2169:  00:EB31                      ; POKEBYTE d
    2170:  00:EB31                      ; POKEBYTE e
    2171:  00:EB31                      ; POKE '('
    2172:  00:EB31                      ; POKEBYTE b
    2173:  00:EB31                      ; POKEBYTE c
    2174:  00:EB31                      ; POKE ')'
    2175:  00:EB31  32 4A F0            		 ld	(vars.ftp.socket),a
    2176:  00:EB34  21 6F DD            		 ld	hl,tcp.read_block
    2177:  00:EB37  CD 76 CC            		 call	device.block
    2178:  00:EB3A                      ;
    2179:  00:EB3A  FD E1               read_ret:	pop	iy
    2180:  00:EB3C  D0                  		ret	nc
    2181:  00:EB3D                      ;
    2182:  00:EB3D                      ; POKE '!'
    2183:  00:EB3D                      ; POKEBYTE a
    2184:  00:EB3D  D6 02               		sub	2
    2185:  00:EB3F  3E E4               		ld	a,exos.ERR_EOF
    2186:  00:EB41  F8                  		ret	m		; Code 1=>socket closed
    2187:  00:EB42                      ;
    2188:  00:EB42  3E E5               		ld	a,exos.ERR_STOP
    2189:  00:EB44  C8                  		ret	z		; Code 2=>STOP pressed
    2190:  00:EB45                      ;
    2191:  00:EB45  3E 6A               		ld	a,exos.ERR_TIMEOUT; Code 3=>timeout
    2192:  00:EB47  C9                  		ret
    2193:  00:EB48                      ;
    2194:  00:EB48                      ;
    2195:  00:EB48                      ;------------------------------------------------------------------------------
    2196:  00:EB48                      ; device_write_byte
    2197:  00:EB48                      ;
    2198:  00:EB48                      ; This is called by the EXOS device write_byte function call
    2199:  00:EB48                      ;
    2200:  00:EB48                      ; In:   A=socket number (control)
    2201:  00:EB48                      ;       B=byte
    2202:  00:EB48                      ;      IX->EXOS channel RAM
    2203:  00:EB48                      ; Out: A=EXOS error code
    2204:  00:EB48                      ;
    2205:  00:EB48                      device_write_byte:
    2206:  00:EB48  FD E5               		push	iy
    2207:  00:EB4A  FD 21 00 F0         		 ld	iy,vars
    2208:  00:EB4E                      ;
    2209:  00:EB4E  32 4A F0            		 ld	(vars.ftp.socket),a
    2210:  00:EB51                      ;
    2211:  00:EB51  CD B5 CE            		 call	status.start	; Start activity indicator
    2212:  00:EB54                      ;
    2213:  00:EB54  11 0E F0            		 ld	de,vars.device.byte	; 1 byte buffer
    2214:  00:EB57  78                  		 ld	a,b
    2215:  00:EB58  12                  		 ld	(de),a
    2216:  00:EB59  01 01 00            		 ld	bc,1
    2217:  00:EB5C  AF                  		 xor	a			; Socket 0 for data
    2218:  00:EB5D  CD 45 DE            		 call	tcp.write_block		; Write 1 byte
    2219:  00:EB60  9F                  		 sbc	a,a			; Cy->FF, NC->0
    2220:  00:EB61  E6 6A               		 and	exos.ERR_TIMEOUT	; Cy->error code, 0 if no error
    2221:  00:EB63                      ;
    2222:  00:EB63  F5                  		 push	af
    2223:  00:EB64  CD A9 CE            	 	  call	status.stop		; Stop activity indicator
    2224:  00:EB67  F1                  		 pop	af
    2225:  00:EB68  FD E1               		pop	iy
    2226:  00:EB6A  C9                  		ret
    2227:  00:EB6B                      ;		
    2228:  00:EB6B                      ;
    2229:  00:EB6B                      ;------------------------------------------------------------------------------
    2230:  00:EB6B                      ; device_write_block
    2231:  00:EB6B                      ;
    2232:  00:EB6B                      ; This is called by the EXOS device write_block function call
    2233:  00:EB6B                      ;
    2234:  00:EB6B                      ; In:   A=socket number (control)
    2235:  00:EB6B                      ;      IX->EXOS channel RAM
    2236:  00:EB6B                      ; Out: A=EXOS error code
    2237:  00:EB6B                      ;
    2238:  00:EB6B                      device_write_block:
    2239:  00:EB6B  FD E5               		push	iy
    2240:  00:EB6D  FD 21 00 F0         		 ld	iy,vars
    2241:  00:EB71                      ;
    2242:  00:EB71  32 4A F0            		 ld	(vars.ftp.socket),a
    2243:  00:EB74  21 45 DE            		 ld	hl,tcp.write_block
    2244:  00:EB77  CD 76 CC            		 call	device.block
    2245:  00:EB7A  9F                  		 sbc	a,a			; Cy->FF, NC->0
    2246:  00:EB7B  E6 6A               		 and	exos.ERR_TIMEOUT	; Cy->error code, 0 if no error
    2247:  00:EB7D  FD E1               		pop	iy
    2248:  00:EB7F  C9                  		ret
    2249:  00:EB80                      ;
    2250:  00:EB80                      ;
    2251:  00:EB80                      ;------------------------------------------------------------------------------
    2252:  00:EB80                      ; device_status
    2253:  00:EB80                      ;
    2254:  00:EB80                      ; This is called by the EXOS device get_read_status function call
    2255:  00:EB80                      ;
    2256:  00:EB80                      ; In:  A=socket number (control)
    2257:  00:EB80                      ;     IX->EXOS channel RAM
    2258:  00:EB80                      ; Out: A=EXOS error code
    2259:  00:EB80                      ;      C=0=>byte ready, FF=>end of file, 1 otherwise
    2260:  00:EB80                      ;
    2261:  00:EB80                      device_status:
    2262:  00:EB80  FD E5               		push	iy
    2263:  00:EB82  FD 21 00 F0         		 ld	iy,vars
    2264:  00:EB86                      ;
    2265:  00:EB86  32 4A F0            		 ld	(vars.ftp.socket),a
    2266:  00:EB89                      ;
    2267:  00:EB89  AF                  		 xor	a		; Data socket 0
    2268:  00:EB8A  CD CF DE            		 call	tcp.status
    2269:  00:EB8D  4F                  		 ld	c,a
    2270:  00:EB8E  9F                  		 sbc	a,a
    2271:  00:EB8F  E6 6A               		 and	exos.ERR_TIMEOUT
    2272:  00:EB91  FD E1               		pop	iy
    2273:  00:EB93  C9                  		ret
    2274:  00:EB94                      ;
    2275:  00:EB94                      ;
    2276:  00:EB94                      ;------------------------------------------------------------------------------
    2277:  00:EB94                      ; ftp_to_exos
    2278:  00:EB94                      ;
    2279:  00:EB94                      ; Converts FTP response/error codes to EXOS error codes
    2280:  00:EB94                      ;
    2281:  00:EB94                      ; In:  HL=FTP response code
    2282:  00:EB94                      ; Out:  A=EXOS error code if fatal, else 0
    2283:  00:EB94                      ;      Cy set if A <> 0
    2284:  00:EB94                      ;
    2285:  00:EB94  4D                  ftp_to_exos:	ld	c,l
    2286:  00:EB95  44                  		ld	b,h		; BC=FTP response code
    2287:  00:EB96  21 B5 EB            		ld	hl,responses
    2288:  00:EB99  5E                  .loop:		ld	e,(hl)
    2289:  00:EB9A  23                  		inc	hl
    2290:  00:EB9B  56                  		ld	d,(hl)		; DE=response code form table
    2291:  00:EB9C  23                  		inc	hl
    2292:  00:EB9D  7E                  		ld	a,(hl)		; A=equivalent EXOS code
    2293:  00:EB9E  23                  		inc	hl
    2294:  00:EB9F  B7                  		or	a
    2295:  00:EBA0  28 09               		jr	z,.notintable	; Go with NC if end of table
    2296:  00:EBA2                      ;
    2297:  00:EBA2  EB                  		ex	de,hl		; DE->table, HL=response code from table
    2298:  00:EBA3  B7                  		or	a
    2299:  00:EBA4  ED 42               		sbc	hl,bc		; Found matching response?
    2300:  00:EBA6  37                  		scf
    2301:  00:EBA7  C8                  		ret	z		; Ret with EXOS code in A if yes
    2302:  00:EBA8                      ;
    2303:  00:EBA8  EB                  		ex	de,hl		; HL->table
    2304:  00:EBA9  18 EE               		jr	.loop		; Try next entry
    2305:  00:EBAB                      ;
    2306:  00:EBAB                      .notintable:				; NC here
    2307:  00:EBAB  21 8F 01            		ld	hl,399		; >=400 are generally fatal
    2308:  00:EBAE  ED 42               		sbc	hl,bc
    2309:  00:EBB0  3E 69               		ld	a,exos.ERR_FTP
    2310:  00:EBB2  D8                  		ret	c		; Return with EXOS error if >=400
    2311:  00:EBB3                      ;
    2312:  00:EBB3  AF                  		xor	a		; Else no EXOS error
    2313:  00:EBB4  C9                  		ret
    2314:  00:EBB5                      ;
    2315:  00:EBB5  26 02               responses:	dw	550
    2316:  00:EBB7  68                  		db	exos.ERR_NOFIL
    2317:  00:EBB8                      ;
    2318:  00:EBB8  00 00               		dw	0
    2319:  00:EBBA  00                  		db	0
    2320:  00:EBBB                      ;
    2321:  00:EBBB                      ;
    2322:  00:EBBB                      ;------------------------------------------------------------------------------
    2323:  00:EBBB                      ; FTP commands that are sent
    2324:  00:EBBB                      ;
    2325:  00:EBBB  43 57 44 20 00      cwd_str:	db	"CWD ",0
    2326:  00:EBC0  50 57 44 00         pwd_str:	db	"PWD",0
    2327:  00:EBC4  43 44 55 50 00      cdup_str:	db	"CDUP",0
    2328:  00:EBC9  4D 4B 44 20 00      mkd_str:	db	"MKD ",0
    2329:  00:EBCE  52 4D 44 20 00      rmd_str:	db	"RMD ",0
    2330:  00:EBD3  44 45 4C 45 20 00   dele_str:	db	"DELE ",0
    2331:  00:EBD9  52 4E 46 52 20 00   rnfr_str:	db	"RNFR ",0
    2332:  00:EBDF  52 4E 54 4F 20 00   rnto_str:	db	"RNTO ",0
    2333:  00:EBE5  55 53 45 52 20 00   user_str:	db	"USER ",0
    2334:  00:EBEB  50 41 53 53 20 00   pass_str:	db	"PASS ",0
    2335:  00:EBF1  50 41 53 56 00      pasv_str:	db	"PASV",0
    2336:  00:EBF6  4C 49 53 54 20 00   list_str:	db	"LIST ",0
    2337:  00:EBFC  52 45 54 52 20 00   retr_str:	db	"RETR ",0
    2338:  00:EC02  53 54 4F 52 20 00   stor_str:	db	"STOR ",0
    2339:  00:EC08  53 59 53 54 00      syst_str:	db	"SYST",0
    2340:  00:EC0D  51 55 49 54 00      quit_str:	db	"QUIT",0
    2341:  00:EC12                      ;
    2342:  00:EC12                      ;
    2343:  00:EC12  46 54 50 00         owner_str:	db	"FTP",0
    2344:  00:EC16  44 41 54 41 00      owner_data_str:	db	"DATA",0
    2345:  00:EC1B                      ;
    2346:  00:EC1B                      ;
    2347:  00:EC1B                      ;
    2348:  00:EC1B                      		endmodule
     111.  00:EC1B                      	include http.asm
       1:  00:EC1B                      ; HTTP
       2:  00:EC1B                      ;
       3:  00:EC1B                      ; This module implements EPNET's HTTP protocol
       4:  00:EC1B                      ;
       5:  00:EC1B                      		module	http
       6:  00:EC1B                      ;
       7:  00:EC1B                      ;==============================================================================
       8:  00:EC1B                      ;
       9:  00:EC1B                      ; This file is part of the EPNET software
      10:  00:EC1B                      ;
      11:  00:EC1B                      ; Copyright (C) 2015  Bruce Tanner
      12:  00:EC1B                      ;
      13:  00:EC1B                      ;    This program is free software: you can redistribute it and/or modify
      14:  00:EC1B                      ;    it under the terms of the GNU General Public License as published by
      15:  00:EC1B                      ;    the Free Software Foundation, either version 3 of the License, or
      16:  00:EC1B                      ;    (at your option) any later version.
      17:  00:EC1B                      ;
      18:  00:EC1B                      ;    This program is distributed in the hope that it will be useful,
      19:  00:EC1B                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      20:  00:EC1B                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      21:  00:EC1B                      ;    GNU General Public License for more details.
      22:  00:EC1B                      ;
      23:  00:EC1B                      ;    You should have received a copy of the GNU General Public License
      24:  00:EC1B                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      25:  00:EC1B                      ;
      26:  00:EC1B                      ; If you do use or modify this file, either for its original purpose or for
      27:  00:EC1B                      ; something new, I'd love to hear about it! I can be contacted by email at:
      28:  00:EC1B                      ;
      29:  00:EC1B                      ; brucetanner@btopenworld.com
      30:  00:EC1B                      ;
      31:  00:EC1B                      ;==============================================================================
      32:  00:EC1B                      ;
      33:  00:EC1B                      ; For reference, this is the format of an HTTP 1.0 message (from RFC 1945):
      34:  00:EC1B                      ;
      35:  00:EC1B                      ; 4.  HTTP Message
      36:  00:EC1B                      ;
      37:  00:EC1B                      ; 4.1  Message Types
      38:  00:EC1B                      ;
      39:  00:EC1B                      ;   HTTP messages consist of requests from client to server and responses
      40:  00:EC1B                      ;   from server to client.
      41:  00:EC1B                      ;
      42:  00:EC1B                      ;       HTTP-message   = Simple-Request           ; HTTP/0.9 messages
      43:  00:EC1B                      ;                      | Simple-Response
      44:  00:EC1B                      ;                      | Full-Request             ; HTTP/1.0 messages
      45:  00:EC1B                      ;                      | Full-Response
      46:  00:EC1B                      ;
      47:  00:EC1B                      ;   Full-Request and Full-Response use the generic message format of RFC
      48:  00:EC1B                      ;   822 [7] for transferring entities. Both messages may include optional
      49:  00:EC1B                      ;   header fields (also known as "headers") and an entity body. The
      50:  00:EC1B                      ;   entity body is separated from the headers by a null line (i.e., a
      51:  00:EC1B                      ;   line with nothing preceding the CRLF).
      52:  00:EC1B                      ;
      53:  00:EC1B                      ;       Full-Request   = Request-Line             ; Section 5.1
      54:  00:EC1B                      ;                        *( General-Header        ; Section 4.3
      55:  00:EC1B                      ;                         | Request-Header        ; Section 5.2
      56:  00:EC1B                      ;                         | Entity-Header )       ; Section 7.1
      57:  00:EC1B                      ;                        CRLF
      58:  00:EC1B                      ;                        [ Entity-Body ]          ; Section 7.2
      59:  00:EC1B                      ;
      60:  00:EC1B                      ;       Full-Response  = Status-Line              ; Section 6.1
      61:  00:EC1B                      ;                        *( General-Header        ; Section 4.3
      62:  00:EC1B                      ;                         | Response-Header       ; Section 6.2
      63:  00:EC1B                      ;                         | Entity-Header )       ; Section 7.1
      64:  00:EC1B                      ;                        CRLF
      65:  00:EC1B                      ;                        [ Entity-Body ]          ; Section 7.2
      66:  00:EC1B                      ;
      67:  00:EC1B                      ;   Simple-Request and Simple-Response do not allow the use of any header
      68:  00:EC1B                      ;   information and are limited to a single request method (GET).
      69:  00:EC1B                      ;
      70:  00:EC1B                      ;       Simple-Request  = "GET" SP Request-URI CRLF
      71:  00:EC1B                      ;
      72:  00:EC1B                      ;       Simple-Response = [ Entity-Body ]
      73:  00:EC1B                      ;
      74:  00:EC1B                      ;   Use of the Simple-Request format is discouraged because it prevents
      75:  00:EC1B                      ;   the server from identifying the media type of the returned entity.
      76:  00:EC1B                      ;
      77:  00:EC1B                      ; 4.2  Message Headers
      78:  00:EC1B                      ;
      79:  00:EC1B                      ;   HTTP header fields, which include General-Header (Section 4.3),
      80:  00:EC1B                      ;   Request-Header (Section 5.2), Response-Header (Section 6.2), and
      81:  00:EC1B                      ;   Entity-Header (Section 7.1) fields, follow the same generic format as
      82:  00:EC1B                      ;   that given in Section 3.1 of RFC 822 [7]. Each header field consists
      83:  00:EC1B                      ;   of a name followed immediately by a colon (":"), a single space (SP)
      84:  00:EC1B                      ;   character, and the field value. Field names are case-insensitive.
      85:  00:EC1B                      ;   Header fields can be extended over multiple lines by preceding each
      86:  00:EC1B                      ;   extra line with at least one SP or HT, though this is not
      87:  00:EC1B                      ;   recommended.
      88:  00:EC1B                      ;
      89:  00:EC1B                      ;       HTTP-header    = field-name ":" [ field-value ] CRLF
      90:  00:EC1B                      ;
      91:  00:EC1B                      ;       field-name     = token
      92:  00:EC1B                      ;       field-value    = *( field-content | LWS )
      93:  00:EC1B                      ;
      94:  00:EC1B                      ;       field-content  = <the OCTETs making up the field-value
      95:  00:EC1B                      ;                        and consisting of either *TEXT or combinations
      96:  00:EC1B                      ;                        of token, tspecials, and quoted-string>
      97:  00:EC1B                      ;
      98:  00:EC1B                      ;   The order in which header fields are received is not significant.
      99:  00:EC1B                      ;   However, it is "good practice" to send General-Header fields first,
     100:  00:EC1B                      ;   followed by Request-Header or Response-Header fields prior to the
     101:  00:EC1B                      ;   Entity-Header fields.
     102:  00:EC1B                      ;
     103:  00:EC1B                      ;   Multiple HTTP-header fields with the same field-name may be present
     104:  00:EC1B                      ;   in a message if and only if the entire field-value for that header
     105:  00:EC1B                      ;   field is defined as a comma-separated list [i.e., #(values)]. It must
     106:  00:EC1B                      ;   be possible to combine the multiple header fields into one "field-
     107:  00:EC1B                      ;   name: field-value" pair, without changing the semantics of the
     108:  00:EC1B                      ;   message, by appending each subsequent field-value to the first, each
     109:  00:EC1B                      ;   separated by a comma.
     110:  00:EC1B                      ;
     111:  00:EC1B                      ; 4.3  General Header Fields
     112:  00:EC1B                      ;
     113:  00:EC1B                      ;   There are a few header fields which have general applicability for
     114:  00:EC1B                      ;   both request and response messages, but which do not apply to the
     115:  00:EC1B                      ;   entity being transferred. These headers apply only to the message
     116:  00:EC1B                      ;   being transmitted.
     117:  00:EC1B                      ;
     118:  00:EC1B                      ;       General-Header = Date                     ; Section 10.6
     119:  00:EC1B                      ;                      | Pragma                   ; Section 10.12
     120:  00:EC1B                      ;
     121:  00:EC1B                      ;   General header field names can be extended reliably only in
     122:  00:EC1B                      ;   combination with a change in the protocol version. However, new or
     123:  00:EC1B                      ;   experimental header fields may be given the semantics of general
     124:  00:EC1B                      ;   header fields if all parties in the communication recognize them to
     125:  00:EC1B                      ;   be general header fields. Unrecognized header fields are treated as
     126:  00:EC1B                      ;   Entity-Header fields.
     127:  00:EC1B                      ;
     128:  00:EC1B                      ; 5. Request
     129:  00:EC1B                      ;
     130:  00:EC1B                      ;   A request message from a client to a server includes, within the
     131:  00:EC1B                      ;   first line of that message, the method to be applied to the resource,
     132:  00:EC1B                      ;   the identifier of the resource, and the protocol version in use. For
     133:  00:EC1B                      ;   backwards compatibility with the more limited HTTP/0.9 protocol,
     134:  00:EC1B                      ;   there are two valid formats for an HTTP request:
     135:  00:EC1B                      ;
     136:  00:EC1B                      ;       Request        = Simple-Request | Full-Request
     137:  00:EC1B                      ;
     138:  00:EC1B                      ;       Simple-Request = "GET" SP Request-URI CRLF
     139:  00:EC1B                      ;
     140:  00:EC1B                      ;       Full-Request   = Request-Line             ; Section 5.1
     141:  00:EC1B                      ;                        *( General-Header        ; Section 4.3
     142:  00:EC1B                      ;                         | Request-Header        ; Section 5.2
     143:  00:EC1B                      ;                         | Entity-Header )       ; Section 7.1
     144:  00:EC1B                      ;                        CRLF
     145:  00:EC1B                      ;                        [ Entity-Body ]          ; Section 7.2
     146:  00:EC1B                      ;
     147:  00:EC1B                      ;   If an HTTP/1.0 server receives a Simple-Request, it must respond with
     148:  00:EC1B                      ;   an HTTP/0.9 Simple-Response. An HTTP/1.0 client capable of receiving
     149:  00:EC1B                      ;   a Full-Response should never generate a Simple-Request.
     150:  00:EC1B                      ;
     151:  00:EC1B                      ; 5.1  Request-Line
     152:  00:EC1B                      ;
     153:  00:EC1B                      ;   The Request-Line begins with a method token, followed by the
     154:  00:EC1B                      ;   Request-URI and the protocol version, and ending with CRLF. The
     155:  00:EC1B                      ;   elements are separated by SP characters. No CR or LF are allowed
     156:  00:EC1B                      ;   except in the final CRLF sequence.
     157:  00:EC1B                      ;
     158:  00:EC1B                      ;       Request-Line = Method SP Request-URI SP HTTP-Version CRLF
     159:  00:EC1B                      ;
     160:  00:EC1B                      ;   Note that the difference between a Simple-Request and the Request-
     161:  00:EC1B                      ;   Line of a Full-Request is the presence of the HTTP-Version field and
     162:  00:EC1B                      ;   the availability of methods other than GET.
     163:  00:EC1B                      ;
     164:  00:EC1B                      ; 5.1.1 Method
     165:  00:EC1B                      ;
     166:  00:EC1B                      ;   The Method token indicates the method to be performed on the resource
     167:  00:EC1B                      ;   identified by the Request-URI. The method is case-sensitive.
     168:  00:EC1B                      ;
     169:  00:EC1B                      ;       Method         = "GET"                    ; Section 8.1
     170:  00:EC1B                      ;                      | "HEAD"                   ; Section 8.2
     171:  00:EC1B                      ;                      | "POST"                   ; Section 8.3
     172:  00:EC1B                      ;                      | extension-method
     173:  00:EC1B                      ;
     174:  00:EC1B                      ;       extension-method = token
     175:  00:EC1B                      ;
     176:  00:EC1B                      ;   The list of methods acceptable by a specific resource can change
     177:  00:EC1B                      ;   dynamically; the client is notified through the return code of the
     178:  00:EC1B                      ;   response if a method is not allowed on a resource. Servers should
     179:  00:EC1B                      ;   return the status code 501 (not implemented) if the method is
     180:  00:EC1B                      ;   unrecognized or not implemented.
     181:  00:EC1B                      ;
     182:  00:EC1B                      ;   The methods commonly used by HTTP/1.0 applications are fully defined
     183:  00:EC1B                      ;   in Section 8.
     184:  00:EC1B                      ;
     185:  00:EC1B                      ; 5.1.2 Request-URI
     186:  00:EC1B                      ;
     187:  00:EC1B                      ;   The Request-URI is a Uniform Resource Identifier (Section 3.2) and
     188:  00:EC1B                      ;   identifies the resource upon which to apply the request.
     189:  00:EC1B                      ;
     190:  00:EC1B                      ;       Request-URI    = absoluteURI | abs_path
     191:  00:EC1B                      ;
     192:  00:EC1B                      ;   The two options for Request-URI are dependent on the nature of the
     193:  00:EC1B                      ;   request.
     194:  00:EC1B                      ;
     195:  00:EC1B                      ;   The absoluteURI form is only allowed when the request is being made
     196:  00:EC1B                      ;   to a proxy. The proxy is requested to forward the request and return
     197:  00:EC1B                      ;   the response. If the request is GET or HEAD and a prior response is
     198:  00:EC1B                      ;   cached, the proxy may use the cached message if it passes any
     199:  00:EC1B                      ;   restrictions in the Expires header field. Note that the proxy may
     200:  00:EC1B                      ;   forward the request on to another proxy or directly to the server
     201:  00:EC1B                      ;   specified by the absoluteURI. In order to avoid request loops, a
     202:  00:EC1B                      ;   proxy must be able to recognize all of its server names, including
     203:  00:EC1B                      ;   any aliases, local variations, and the numeric IP address. An example
     204:  00:EC1B                      ;   Request-Line would be:
     205:  00:EC1B                      ;
     206:  00:EC1B                      ;       GET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.0
     207:  00:EC1B                      ;
     208:  00:EC1B                      ;   The most common form of Request-URI is that used to identify a
     209:  00:EC1B                      ;   resource on an origin server or gateway. In this case, only the
     210:  00:EC1B                      ;   absolute path of the URI is transmitted (see Section 3.2.1,
     211:  00:EC1B                      ;   abs_path). For example, a client wishing to retrieve the resource
     212:  00:EC1B                      ;   above directly from the origin server would create a TCP connection
     213:  00:EC1B                      ;   to port 80 of the host "www.w3.org" and send the line:
     214:  00:EC1B                      ;
     215:  00:EC1B                      ;       GET /pub/WWW/TheProject.html HTTP/1.0
     216:  00:EC1B                      ;
     217:  00:EC1B                      ;   followed by the remainder of the Full-Request. Note that the absolute
     218:  00:EC1B                      ;   path cannot be empty; if none is present in the original URI, it must
     219:  00:EC1B                      ;   be given as "/" (the server root).
     220:  00:EC1B                      ;
     221:  00:EC1B                      ;   The Request-URI is transmitted as an encoded string, where some
     222:  00:EC1B                      ;   characters may be escaped using the "% HEX HEX" encoding defined by
     223:  00:EC1B                      ;   RFC 1738 [4]. The origin server must decode the Request-URI in order
     224:  00:EC1B                      ;   to properly interpret the request.
     225:  00:EC1B                      ;
     226:  00:EC1B                      ; 5.2  Request Header Fields
     227:  00:EC1B                      ;
     228:  00:EC1B                      ;   The request header fields allow the client to pass additional
     229:  00:EC1B                      ;   information about the request, and about the client itself, to the
     230:  00:EC1B                      ;   server. These fields act as request modifiers, with semantics
     231:  00:EC1B                      ;   equivalent to the parameters on a programming language method
     232:  00:EC1B                      ;   (procedure) invocation.
     233:  00:EC1B                      ;
     234:  00:EC1B                      ;       Request-Header = Authorization            ; Section 10.2
     235:  00:EC1B                      ;                      | From                     ; Section 10.8
     236:  00:EC1B                      ;                      | If-Modified-Since        ; Section 10.9
     237:  00:EC1B                      ;                      | Referer                  ; Section 10.13
     238:  00:EC1B                      ;                      | User-Agent               ; Section 10.15
     239:  00:EC1B                      ;
     240:  00:EC1B                      ;   Request-Header field names can be extended reliably only in
     241:  00:EC1B                      ;   combination with a change in the protocol version. However, new or
     242:  00:EC1B                      ;   experimental header fields may be given the semantics of request
     243:  00:EC1B                      ;   header fields if all parties in the communication recognize them to
     244:  00:EC1B                      ;   be request header fields. Unrecognized header fields are treated as
     245:  00:EC1B                      ;   Entity-Header fields.
     246:  00:EC1B                      ;
     247:  00:EC1B                      ; 6.  Response
     248:  00:EC1B                      ;
     249:  00:EC1B                      ;   After receiving and interpreting a request message, a server responds
     250:  00:EC1B                      ;   in the form of an HTTP response message.
     251:  00:EC1B                      ;
     252:  00:EC1B                      ;       Response        = Simple-Response | Full-Response
     253:  00:EC1B                      ;
     254:  00:EC1B                      ;       Simple-Response = [ Entity-Body ]
     255:  00:EC1B                      ;
     256:  00:EC1B                      ;       Full-Response   = Status-Line             ; Section 6.1
     257:  00:EC1B                      ;                         *( General-Header       ; Section 4.3
     258:  00:EC1B                      ;                          | Response-Header      ; Section 6.2
     259:  00:EC1B                      ;                          | Entity-Header )      ; Section 7.1
     260:  00:EC1B                      ;                         CRLF
     261:  00:EC1B                      ;                         [ Entity-Body ]         ; Section 7.2
     262:  00:EC1B                      ;
     263:  00:EC1B                      ;   A Simple-Response should only be sent in response to an HTTP/0.9
     264:  00:EC1B                      ;   Simple-Request or if the server only supports the more limited
     265:  00:EC1B                      ;   HTTP/0.9 protocol. If a client sends an HTTP/1.0 Full-Request and
     266:  00:EC1B                      ;   receives a response that does not begin with a Status-Line, it should
     267:  00:EC1B                      ;   assume that the response is a Simple-Response and parse it
     268:  00:EC1B                      ;   accordingly. Note that the Simple-Response consists only of the
     269:  00:EC1B                      ;   entity body and is terminated by the server closing the connection.
     270:  00:EC1B                      ;
     271:  00:EC1B                      ; 6.1  Status-Line
     272:  00:EC1B                      ;
     273:  00:EC1B                      ;   The first line of a Full-Response message is the Status-Line,
     274:  00:EC1B                      ;   consisting of the protocol version followed by a numeric status code
     275:  00:EC1B                      ;   and its associated textual phrase, with each element separated by SP
     276:  00:EC1B                      ;   characters. No CR or LF is allowed except in the final CRLF sequence.
     277:  00:EC1B                      ;
     278:  00:EC1B                      ;       Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
     279:  00:EC1B                      ;
     280:  00:EC1B                      ;   Since a status line always begins with the protocol version and
     281:  00:EC1B                      ;   status code
     282:  00:EC1B                      ;
     283:  00:EC1B                      ;       "HTTP/" 1*DIGIT "." 1*DIGIT SP 3DIGIT SP
     284:  00:EC1B                      ;
     285:  00:EC1B                      ;   (e.g., "HTTP/1.0 200 "), the presence of that expression is
     286:  00:EC1B                      ;   sufficient to differentiate a Full-Response from a Simple-Response.
     287:  00:EC1B                      ;   Although the Simple-Response format may allow such an expression to
     288:  00:EC1B                      ;   occur at the beginning of an entity body, and thus cause a
     289:  00:EC1B                      ;   misinterpretation of the message if it was given in response to a
     290:  00:EC1B                      ;   Full-Request, most HTTP/0.9 servers are limited to responses of type
     291:  00:EC1B                      ;   "text/html" and therefore would never generate such a response.
     292:  00:EC1B                      ;
     293:  00:EC1B                      ; 6.1.1 Status Code and Reason Phrase
     294:  00:EC1B                      ;
     295:  00:EC1B                      ;   The Status-Code element is a 3-digit integer result code of the
     296:  00:EC1B                      ;   attempt to understand and satisfy the request. The Reason-Phrase is
     297:  00:EC1B                      ;   intended to give a short textual description of the Status-Code. The
     298:  00:EC1B                      ;   Status-Code is intended for use by automata and the Reason-Phrase is
     299:  00:EC1B                      ;   intended for the human user. The client is not required to examine or
     300:  00:EC1B                      ;   display the Reason-Phrase.
     301:  00:EC1B                      ;
     302:  00:EC1B                      ;   The first digit of the Status-Code defines the class of response. The
     303:  00:EC1B                      ;   last two digits do not have any categorization role. There are 5
     304:  00:EC1B                      ;   values for the first digit:
     305:  00:EC1B                      ;
     306:  00:EC1B                      ;      o 1xx: Informational - Not used, but reserved for future use
     307:  00:EC1B                      ;
     308:  00:EC1B                      ;      o 2xx: Success - The action was successfully received,
     309:  00:EC1B                      ;             understood, and accepted.
     310:  00:EC1B                      ;
     311:  00:EC1B                      ;      o 3xx: Redirection - Further action must be taken in order to
     312:  00:EC1B                      ;             complete the request
     313:  00:EC1B                      ;
     314:  00:EC1B                      ;      o 4xx: Client Error - The request contains bad syntax or cannot
     315:  00:EC1B                      ;             be fulfilled
     316:  00:EC1B                      ;
     317:  00:EC1B                      ;      o 5xx: Server Error - The server failed to fulfill an apparently
     318:  00:EC1B                      ;             valid request
     319:  00:EC1B                      ;
     320:  00:EC1B                      ;   The individual values of the numeric status codes defined for
     321:  00:EC1B                      ;   HTTP/1.0, and an example set of corresponding Reason-Phrase's, are
     322:  00:EC1B                      ;   presented below. The reason phrases listed here are only recommended
     323:  00:EC1B                      ;   -- they may be replaced by local equivalents without affecting the
     324:  00:EC1B                      ;   protocol. These codes are fully defined in Section 9.
     325:  00:EC1B                      ;
     326:  00:EC1B                      ;       Status-Code    = "200"   ; OK
     327:  00:EC1B                      ;                      | "201"   ; Created
     328:  00:EC1B                      ;                      | "202"   ; Accepted
     329:  00:EC1B                      ;                      | "204"   ; No Content
     330:  00:EC1B                      ;                      | "301"   ; Moved Permanently
     331:  00:EC1B                      ;                      | "302"   ; Moved Temporarily
     332:  00:EC1B                      ;                      | "304"   ; Not Modified
     333:  00:EC1B                      ;                      | "400"   ; Bad Request
     334:  00:EC1B                      ;                      | "401"   ; Unauthorized
     335:  00:EC1B                      ;                      | "403"   ; Forbidden
     336:  00:EC1B                      ;                      | "404"   ; Not Found
     337:  00:EC1B                      ;                      | "500"   ; Internal Server Error
     338:  00:EC1B                      ;                      | "501"   ; Not Implemented
     339:  00:EC1B                      ;                      | "502"   ; Bad Gateway
     340:  00:EC1B                      ;                      | "503"   ; Service Unavailable
     341:  00:EC1B                      ;                      | extension-code
     342:  00:EC1B                      ;
     343:  00:EC1B                      ;       extension-code = 3DIGIT
     344:  00:EC1B                      ;
     345:  00:EC1B                      ;       Reason-Phrase  = *<TEXT, excluding CR, LF>
     346:  00:EC1B                      ;
     347:  00:EC1B                      ;   HTTP status codes are extensible, but the above codes are the only
     348:  00:EC1B                      ;   ones generally recognized in current practice. HTTP applications are
     349:  00:EC1B                      ;   not required to understand the meaning of all registered status
     350:  00:EC1B                      ;   codes, though such understanding is obviously desirable. However,
     351:  00:EC1B                      ;   applications must understand the class of any status code, as
     352:  00:EC1B                      ;   indicated by the first digit, and treat any unrecognized response as
     353:  00:EC1B                      ;   being equivalent to the x00 status code of that class, with the
     354:  00:EC1B                      ;   exception that an unrecognized response must not be cached. For
     355:  00:EC1B                      ;   example, if an unrecognized status code of 431 is received by the
     356:  00:EC1B                      ;   client, it can safely assume that there was something wrong with its
     357:  00:EC1B                      ;   request and treat the response as if it had received a 400 status
     358:  00:EC1B                      ;   code. In such cases, user agents should present to the user the
     359:  00:EC1B                      ;   entity returned with the response, since that entity is likely to
     360:  00:EC1B                      ;   include human-readable information which will explain the unusual
     361:  00:EC1B                      ;   status.
     362:  00:EC1B                      ;
     363:  00:EC1B                      ; 6.2  Response Header Fields
     364:  00:EC1B                      ;
     365:  00:EC1B                      ;   The response header fields allow the server to pass additional
     366:  00:EC1B                      ;   information about the response which cannot be placed in the Status-
     367:  00:EC1B                      ;   Line. These header fields give information about the server and about
     368:  00:EC1B                      ;   further access to the resource identified by the Request-URI.
     369:  00:EC1B                      ;
     370:  00:EC1B                      ;       Response-Header = Location                ; Section 10.11
     371:  00:EC1B                      ;                       | Server                  ; Section 10.14
     372:  00:EC1B                      ;                       | WWW-Authenticate        ; Section 10.16
     373:  00:EC1B                      ;
     374:  00:EC1B                      ;   Response-Header field names can be extended reliably only in
     375:  00:EC1B                      ;   combination with a change in the protocol version. However, new or
     376:  00:EC1B                      ;   experimental header fields may be given the semantics of response
     377:  00:EC1B                      ;   header fields if all parties in the communication recognize them to
     378:  00:EC1B                      ;    be response header fields. Unrecognized header fields are treated as
     379:  00:EC1B                      ;   Entity-Header fields.
     380:  00:EC1B                      ;
     381:  00:EC1B                      ; 7.  Entity
     382:  00:EC1B                      ;
     383:  00:EC1B                      ;   Full-Request and Full-Response messages may transfer an entity within
     384:  00:EC1B                      ;   some requests and responses. An entity consists of Entity-Header
     385:  00:EC1B                      ;   fields and (usually) an Entity-Body. In this section, both sender and
     386:  00:EC1B                      ;   recipient refer to either the client or the server, depending on who
     387:  00:EC1B                      ;   sends and who receives the entity.
     388:  00:EC1B                      ;
     389:  00:EC1B                      ;
     390:  00:EC1B                      ; 7.1  Entity Header Fields
     391:  00:EC1B                      ;
     392:  00:EC1B                      ;   Entity-Header fields define optional metainformation about the
     393:  00:EC1B                      ;   Entity-Body or, if no body is present, about the resource identified
     394:  00:EC1B                      ;   by the request.
     395:  00:EC1B                      ;
     396:  00:EC1B                      ;       Entity-Header  = Allow                    ; Section 10.1
     397:  00:EC1B                      ;                      | Content-Encoding         ; Section 10.3
     398:  00:EC1B                      ;                      | Content-Length           ; Section 10.4
     399:  00:EC1B                      ;                      | Content-Type             ; Section 10.5
     400:  00:EC1B                      ;                      | Expires                  ; Section 10.7
     401:  00:EC1B                      ;                      | Last-Modified            ; Section 10.10
     402:  00:EC1B                      ;                      | extension-header
     403:  00:EC1B                      ;
     404:  00:EC1B                      ;       extension-header = HTTP-header
     405:  00:EC1B                      ;
     406:  00:EC1B                      ;   The extension-header mechanism allows additional Entity-Header fields
     407:  00:EC1B                      ;   to be defined without changing the protocol, but these fields cannot
     408:  00:EC1B                      ;   be assumed to be recognizable by the recipient. Unrecognized header
     409:  00:EC1B                      ;   fields should be ignored by the recipient and forwarded by proxies.
     410:  00:EC1B                      ;
     411:  00:EC1B                      ; 7.2  Entity Body
     412:  00:EC1B                      ;
     413:  00:EC1B                      ;   The entity body (if any) sent with an HTTP request or response is in
     414:  00:EC1B                      ;   a format and encoding defined by the Entity-Header fields.
     415:  00:EC1B                      ;
     416:  00:EC1B                      ;       Entity-Body    = *OCTET
     417:  00:EC1B                      ;
     418:  00:EC1B                      ;   An entity body is included with a request message only when the
     419:  00:EC1B                      ;   request method calls for one. The presence of an entity body in a
     420:  00:EC1B                      ;   request is signaled by the inclusion of a Content-Length header field
     421:  00:EC1B                      ;   in the request message headers. HTTP/1.0 requests containing an
     422:  00:EC1B                      ;   entity body must include a valid Content-Length header field.
     423:  00:EC1B                      ;
     424:  00:EC1B                      ;   For response messages, whether or not an entity body is included with
     425:  00:EC1B                      ;   a message is dependent on both the request method and the response
     426:  00:EC1B                      ;   code. All responses to the HEAD request method must not include a
     427:  00:EC1B                      ;   body, even though the presence of entity header fields may lead one
     428:  00:EC1B                      ;   to believe they do. All 1xx (informational), 204 (no content), and
     429:  00:EC1B                      ;   304 (not modified) responses must not include a body. All other
     430:  00:EC1B                      ;   responses must include an entity body or a Content-Length header
     431:  00:EC1B                      ;   field defined with a value of zero (0).
     432:  00:EC1B                      ;
     433:  00:EC1B                      ; 7.2.1 Type
     434:  00:EC1B                      ;
     435:  00:EC1B                      ;   When an Entity-Body is included with a message, the data type of that
     436:  00:EC1B                      ;   body is determined via the header fields Content-Type and Content-
     437:  00:EC1B                      ;   Encoding. These define a two-layer, ordered encoding model:
     438:  00:EC1B                      ;
     439:  00:EC1B                      ;       entity-body := Content-Encoding( Content-Type( data ) )
     440:  00:EC1B                      ;
     441:  00:EC1B                      ;   A Content-Type specifies the media type of the underlying data. A
     442:  00:EC1B                      ;   Content-Encoding may be used to indicate any additional content
     443:  00:EC1B                      ;   coding applied to the type, usually for the purpose of data
     444:  00:EC1B                      ;   compression, that is a property of the resource requested. The
     445:  00:EC1B                      ;   default for the content encoding is none (i.e., the identity
     446:  00:EC1B                      ;   function).
     447:  00:EC1B                      ;
     448:  00:EC1B                      ;   Any HTTP/1.0 message containing an entity body should include a
     449:  00:EC1B                      ;   Content-Type header field defining the media type of that body. If
     450:  00:EC1B                      ;   and only if the media type is not given by a Content-Type header, as
     451:  00:EC1B                      ;   is the case for Simple-Response messages, the recipient may attempt
     452:  00:EC1B                      ;   to guess the media type via inspection of its content and/or the name
     453:  00:EC1B                      ;   extension(s) of the URL used to identify the resource. If the media
     454:  00:EC1B                      ;   type remains unknown, the recipient should treat it as type
     455:  00:EC1B                      ;   "application/octet-stream".
     456:  00:EC1B                      ;
     457:  00:EC1B                      ; 7.2.2 Length
     458:  00:EC1B                      ;
     459:  00:EC1B                      ;   When an Entity-Body is included with a message, the length of that
     460:  00:EC1B                      ;   body may be determined in one of two ways. If a Content-Length header
     461:  00:EC1B                      ;   field is present, its value in bytes represents the length of the
     462:  00:EC1B                      ;   Entity-Body. Otherwise, the body length is determined by the closing
     463:  00:EC1B                      ;   of the connection by the server.
     464:  00:EC1B                      ;
     465:  00:EC1B                      ;   Closing the connection cannot be used to indicate the end of a
     466:  00:EC1B                      ;   request body, since it leaves no possibility for the server to send
     467:  00:EC1B                      ;   back a response. Therefore, HTTP/1.0 requests containing an entity
     468:  00:EC1B                      ;   body must include a valid Content-Length header field. If a request
     469:  00:EC1B                      ;   contains an entity body and Content-Length is not specified, and the
     470:  00:EC1B                      ;   server does not recognize or cannot calculate the length from other
     471:  00:EC1B                      ;   fields, then the server should send a 400 (bad request) response.
     472:  00:EC1B                      ;
     473:  00:EC1B                      ;      Note: Some older servers supply an invalid Content-Length when
     474:  00:EC1B                      ;      sending a document that contains server-side includes dynamically
     475:  00:EC1B                      ;      inserted into the data stream. It must be emphasized that this
     476:  00:EC1B                      ;      will not be tolerated by future versions of HTTP. Unless the
     477:  00:EC1B                      ;      client knows that it is receiving a response from a compliant
     478:  00:EC1B                      ;      server, it should not depend on the Content-Length value being
     479:  00:EC1B                      ;      correct.
     480:  00:EC1B                      ;
     481:  00:EC1B                      ; 8.  Method Definitions
     482:  00:EC1B                      ;
     483:  00:EC1B                      ;   The set of common methods for HTTP/1.0 is defined below. Although
     484:  00:EC1B                      ;   this set can be expanded, additional methods cannot be assumed to
     485:  00:EC1B                      ;   share the same semantics for separately extended clients and servers.
     486:  00:EC1B                      ;
     487:  00:EC1B                      ; 8.1  GET
     488:  00:EC1B                      ;
     489:  00:EC1B                      ;   The GET method means retrieve whatever information (in the form of an
     490:  00:EC1B                      ;   entity) is identified by the Request-URI. If the Request-URI refers
     491:  00:EC1B                      ;   to a data-producing process, it is the produced data which shall be
     492:  00:EC1B                      ;   returned as the entity in the response and not the source text of the
     493:  00:EC1B                      ;   process, unless that text happens to be the output of the process.
     494:  00:EC1B                      ;
     495:  00:EC1B                      ;   The semantics of the GET method changes to a "conditional GET" if the
     496:  00:EC1B                      ;   request message includes an If-Modified-Since header field. A
     497:  00:EC1B                      ;   conditional GET method requests that the identified resource be
     498:  00:EC1B                      ;   transferred only if it has been modified since the date given by the
     499:  00:EC1B                      ;   If-Modified-Since header, as described in Section 10.9. The
     500:  00:EC1B                      ;   conditional GET method is intended to reduce network usage by
     501:  00:EC1B                      ;   allowing cached entities to be refreshed without requiring multiple
     502:  00:EC1B                      ;   requests or transferring unnecessary data.
     503:  00:EC1B                      ;
     504:  00:EC1B                      ; 8.2  HEAD
     505:  00:EC1B                      ;
     506:  00:EC1B                      ;   The HEAD method is identical to GET except that the server must not
     507:  00:EC1B                      ;   return any Entity-Body in the response. The metainformation contained
     508:  00:EC1B                      ;   in the HTTP headers in response to a HEAD request should be identical
     509:  00:EC1B                      ;   to the information sent in response to a GET request. This method can
     510:  00:EC1B                      ;   be used for obtaining metainformation about the resource identified
     511:  00:EC1B                      ;   by the Request-URI without transferring the Entity-Body itself. This
     512:  00:EC1B                      ;   method is often used for testing hypertext links for validity,
     513:  00:EC1B                      ;   accessibility, and recent modification.
     514:  00:EC1B                      ;
     515:  00:EC1B                      ;   There is no "conditional HEAD" request analogous to the conditional
     516:  00:EC1B                      ;   GET. If an If-Modified-Since header field is included with a HEAD
     517:  00:EC1B                      ;   request, it should be ignored.
     518:  00:EC1B                      ;
     519:  00:EC1B                      ; 8.3  POST
     520:  00:EC1B                      ;
     521:  00:EC1B                      ;   The POST method is used to request that the destination server accept
     522:  00:EC1B                      ;   the entity enclosed in the request as a new subordinate of the
     523:  00:EC1B                      ;   resource identified by the Request-URI in the Request-Line. POST is
     524:  00:EC1B                      ;   designed to allow a uniform method to cover the following functions:
     525:  00:EC1B                      ;
     526:  00:EC1B                      ;      o Annotation of existing resources;
     527:  00:EC1B                      ;
     528:  00:EC1B                      ;      o Posting a message to a bulletin board, newsgroup, mailing list,
     529:  00:EC1B                      ;        or similar group of articles;
     530:  00:EC1B                      ;
     531:  00:EC1B                      ;      o Providing a block of data, such as the result of submitting a
     532:  00:EC1B                      ;        form [3], to a data-handling process;
     533:  00:EC1B                      ;
     534:  00:EC1B                      ;      o Extending a database through an append operation.
     535:  00:EC1B                      ;
     536:  00:EC1B                      ;   The actual function performed by the POST method is determined by the
     537:  00:EC1B                      ;   server and is usually dependent on the Request-URI. The posted entity
     538:  00:EC1B                      ;   is subordinate to that URI in the same way that a file is subordinate
     539:  00:EC1B                      ;   to a directory containing it, a news article is subordinate to a
     540:  00:EC1B                      ;   newsgroup to which it is posted, or a record is subordinate to a
     541:  00:EC1B                      ;   database.
     542:  00:EC1B                      ;
     543:  00:EC1B                      ;   A successful POST does not require that the entity be created as a
     544:  00:EC1B                      ;   resource on the origin server or made accessible for future
     545:  00:EC1B                      ;   reference. That is, the action performed by the POST method might not
     546:  00:EC1B                      ;   result in a resource that can be identified by a URI. In this case,
     547:  00:EC1B                      ;   either 200 (ok) or 204 (no content) is the appropriate response
     548:  00:EC1B                      ;   status, depending on whether or not the response includes an entity
     549:  00:EC1B                      ;   that describes the result.
     550:  00:EC1B                      ;
     551:  00:EC1B                      ;   If a resource has been created on the origin server, the response
     552:  00:EC1B                      ;   should be 201 (created) and contain an entity (preferably of type
     553:  00:EC1B                      ;   "text/html") which describes the status of the request and refers to
     554:  00:EC1B                      ;   the new resource.
     555:  00:EC1B                      ;
     556:  00:EC1B                      ;   A valid Content-Length is required on all HTTP/1.0 POST requests. An
     557:  00:EC1B                      ;   HTTP/1.0 server should respond with a 400 (bad request) message if it
     558:  00:EC1B                      ;   cannot determine the length of the request message's content.
     559:  00:EC1B                      ;
     560:  00:EC1B                      ;   Applications must not cache responses to a POST request because the
     561:  00:EC1B                      ;   application has no way of knowing that the server would return an
     562:  00:EC1B                      ;   equivalent response on some future request.
     563:  00:EC1B                      ;
     564:  00:EC1B                      ; 9.  Status Code Definitions
     565:  00:EC1B                      ;
     566:  00:EC1B                      ;   Each Status-Code is described below, including a description of which
     567:  00:EC1B                      ;   method(s) it can follow and any metainformation required in the
     568:  00:EC1B                      ;   response.
     569:  00:EC1B                      ;
     570:  00:EC1B                      ; 9.1  Informational 1xx
     571:  00:EC1B                      ;
     572:  00:EC1B                      ;   This class of status code indicates a provisional response,
     573:  00:EC1B                      ;   consisting only of the Status-Line and optional headers, and is
     574:  00:EC1B                      ;   terminated by an empty line. HTTP/1.0 does not define any 1xx status
     575:  00:EC1B                      ;   codes and they are not a valid response to a HTTP/1.0 request.
     576:  00:EC1B                      ;   However, they may be useful for experimental applications which are
     577:  00:EC1B                      ;   outside the scope of this specification.
     578:  00:EC1B                      ;
     579:  00:EC1B                      ; 9.2  Successful 2xx
     580:  00:EC1B                      ;
     581:  00:EC1B                      ;   This class of status code indicates that the client's request was
     582:  00:EC1B                      ;   successfully received, understood, and accepted.
     583:  00:EC1B                      ;
     584:  00:EC1B                      ;   200 OK
     585:  00:EC1B                      ;
     586:  00:EC1B                      ;   The request has succeeded. The information returned with the
     587:  00:EC1B                      ;   response is dependent on the method used in the request, as follows:
     588:  00:EC1B                      ;
     589:  00:EC1B                      ;   GET    an entity corresponding to the requested resource is sent
     590:  00:EC1B                      ;          in the response;
     591:  00:EC1B                      ;
     592:  00:EC1B                      ;   HEAD   the response must only contain the header information and
     593:  00:EC1B                      ;          no Entity-Body;
     594:  00:EC1B                      ;
     595:  00:EC1B                      ;   POST   an entity describing or containing the result of the action.
     596:  00:EC1B                      ;
     597:  00:EC1B                      ;   201 Created
     598:  00:EC1B                      ;
     599:  00:EC1B                      ;   The request has been fulfilled and resulted in a new resource being
     600:  00:EC1B                      ;   created. The newly created resource can be referenced by the URI(s)
     601:  00:EC1B                      ;   returned in the entity of the response. The origin server should
     602:  00:EC1B                      ;   create the resource before using this Status-Code. If the action
     603:  00:EC1B                      ;   cannot be carried out immediately, the server must include in the
     604:  00:EC1B                      ;   response body a description of when the resource will be available;
     605:  00:EC1B                      ;   otherwise, the server should respond with 202 (accepted).
     606:  00:EC1B                      ;
     607:  00:EC1B                      ;   Of the methods defined by this specification, only POST can create a
     608:  00:EC1B                      ;   resource.
     609:  00:EC1B                      ;
     610:  00:EC1B                      ;   202 Accepted
     611:  00:EC1B                      ;
     612:  00:EC1B                      ;   The request has been accepted for processing, but the processing
     613:  00:EC1B                      ;   has not been completed. The request may or may not eventually be
     614:  00:EC1B                      ;   acted upon, as it may be disallowed when processing actually takes
     615:  00:EC1B                      ;   place. There is no facility for re-sending a status code from an
     616:  00:EC1B                      ;   asynchronous operation such as this.
     617:  00:EC1B                      ;
     618:  00:EC1B                      ;   The 202 response is intentionally non-committal. Its purpose is to
     619:  00:EC1B                      ;   allow a server to accept a request for some other process (perhaps
     620:  00:EC1B                      ;   a batch-oriented process that is only run once per day) without
     621:  00:EC1B                      ;   requiring that the user agent's connection to the server persist
     622:  00:EC1B                      ;   until the process is completed. The entity returned with this
     623:  00:EC1B                      ;   response should include an indication of the request's current
     624:  00:EC1B                      ;   status and either a pointer to a status monitor or some estimate of
     625:  00:EC1B                      ;   when the user can expect the request to be fulfilled.
     626:  00:EC1B                      ;
     627:  00:EC1B                      ;   204 No Content
     628:  00:EC1B                      ;
     629:  00:EC1B                      ;   The server has fulfilled the request but there is no new
     630:  00:EC1B                      ;   information to send back. If the client is a user agent, it should
     631:  00:EC1B                      ;   not change its document view from that which caused the request to
     632:  00:EC1B                      ;   be generated. This response is primarily intended to allow input
     633:  00:EC1B                      ;   for scripts or other actions to take place without causing a change
     634:  00:EC1B                      ;   to the user agent's active document view. The response may include
     635:  00:EC1B                      ;   new metainformation in the form of entity headers, which should
     636:  00:EC1B                      ;   apply to the document currently in the user agent's active view.
     637:  00:EC1B                      ;
     638:  00:EC1B                      ; 9.3  Redirection 3xx
     639:  00:EC1B                      ;
     640:  00:EC1B                      ;   This class of status code indicates that further action needs to be
     641:  00:EC1B                      ;   taken by the user agent in order to fulfill the request. The action
     642:  00:EC1B                      ;   required may be carried out by the user agent without interaction
     643:  00:EC1B                      ;   with the user if and only if the method used in the subsequent
     644:  00:EC1B                      ;   request is GET or HEAD. A user agent should never automatically
     645:  00:EC1B                      ;   redirect a request more than 5 times, since such redirections usually
     646:  00:EC1B                      ;   indicate an infinite loop.
     647:  00:EC1B                      ;
     648:  00:EC1B                      ;   300 Multiple Choices
     649:  00:EC1B                      ;
     650:  00:EC1B                      ;   This response code is not directly used by HTTP/1.0 applications,
     651:  00:EC1B                      ;   but serves as the default for interpreting the 3xx class of
     652:  00:EC1B                      ;   responses.
     653:  00:EC1B                      ;
     654:  00:EC1B                      ;   The requested resource is available at one or more locations.
     655:  00:EC1B                      ;   Unless it was a HEAD request, the response should include an entity
     656:  00:EC1B                      ;   containing a list of resource characteristics and locations from
     657:  00:EC1B                      ;   which the user or user agent can choose the one most appropriate.
     658:  00:EC1B                      ;   If the server has a preferred choice, it should include the URL in
     659:  00:EC1B                      ;   a Location field; user agents may use this field value for
     660:  00:EC1B                      ;   automatic redirection.
     661:  00:EC1B                      ;
     662:  00:EC1B                      ;   301 Moved Permanently
     663:  00:EC1B                      ;
     664:  00:EC1B                      ;   The requested resource has been assigned a new permanent URL and
     665:  00:EC1B                      ;   any future references to this resource should be done using that
     666:  00:EC1B                      ;   URL. Clients with link editing capabilities should automatically
     667:  00:EC1B                      ;   relink references to the Request-URI to the new reference returned
     668:  00:EC1B                      ;   by the server, where possible.
     669:  00:EC1B                      ;
     670:  00:EC1B                      ;   The new URL must be given by the Location field in the response.
     671:  00:EC1B                      ;   Unless it was a HEAD request, the Entity-Body of the response
     672:  00:EC1B                      ;   should contain a short note with a hyperlink to the new URL.
     673:  00:EC1B                      ;
     674:  00:EC1B                      ;   If the 301 status code is received in response to a request using
     675:  00:EC1B                      ;   the POST method, the user agent must not automatically redirect the
     676:  00:EC1B                      ;   request unless it can be confirmed by the user, since this might
     677:  00:EC1B                      ;   change the conditions under which the request was issued.
     678:  00:EC1B                      ;
     679:  00:EC1B                      ;       Note: When automatically redirecting a POST request after
     680:  00:EC1B                      ;       receiving a 301 status code, some existing user agents will
     681:  00:EC1B                      ;       erroneously change it into a GET request.
     682:  00:EC1B                      ;
     683:  00:EC1B                      ;   302 Moved Temporarily
     684:  00:EC1B                      ;
     685:  00:EC1B                      ;   The requested resource resides temporarily under a different URL.
     686:  00:EC1B                      ;   Since the redirection may be altered on occasion, the client should
     687:  00:EC1B                      ;   continue to use the Request-URI for future requests.
     688:  00:EC1B                      ;
     689:  00:EC1B                      ;   The URL must be given by the Location field in the response. Unless
     690:  00:EC1B                      ;   it was a HEAD request, the Entity-Body of the response should
     691:  00:EC1B                      ;   contain a short note with a hyperlink to the new URI(s).
     692:  00:EC1B                      ;
     693:  00:EC1B                      ;   If the 302 status code is received in response to a request using
     694:  00:EC1B                      ;   the POST method, the user agent must not automatically redirect the
     695:  00:EC1B                      ;   request unless it can be confirmed by the user, since this might
     696:  00:EC1B                      ;   change the conditions under which the request was issued.
     697:  00:EC1B                      ;
     698:  00:EC1B                      ;       Note: When automatically redirecting a POST request after
     699:  00:EC1B                      ;       receiving a 302 status code, some existing user agents will
     700:  00:EC1B                      ;       erroneously change it into a GET request.
     701:  00:EC1B                      ;
     702:  00:EC1B                      ;   304 Not Modified
     703:  00:EC1B                      ;
     704:  00:EC1B                      ;   If the client has performed a conditional GET request and access is
     705:  00:EC1B                      ;   allowed, but the document has not been modified since the date and
     706:  00:EC1B                      ;   time specified in the If-Modified-Since field, the server must
     707:  00:EC1B                      ;   respond with this status code and not send an Entity-Body to the
     708:  00:EC1B                      ;   client. Header fields contained in the response should only include
     709:  00:EC1B                      ;   information which is relevant to cache managers or which may have
     710:  00:EC1B                      ;   changed independently of the entity's Last-Modified date. Examples
     711:  00:EC1B                      ;   of relevant header fields include: Date, Server, and Expires. A
     712:  00:EC1B                      ;   cache should update its cached entity to reflect any new field
     713:  00:EC1B                      ;   values given in the 304 response.
     714:  00:EC1B                      ;
     715:  00:EC1B                      ;9.4  Client Error 4xx
     716:  00:EC1B                      ;
     717:  00:EC1B                      ;   The 4xx class of status code is intended for cases in which the
     718:  00:EC1B                      ;   client seems to have erred. If the client has not completed the
     719:  00:EC1B                      ;   request when a 4xx code is received, it should immediately cease
     720:  00:EC1B                      ;   sending data to the server. Except when responding to a HEAD request,
     721:  00:EC1B                      ;   the server should include an entity containing an explanation of the
     722:  00:EC1B                      ;   error situation, and whether it is a temporary or permanent
     723:  00:EC1B                      ;   condition. These status codes are applicable to any request method.
     724:  00:EC1B                      ;
     725:  00:EC1B                      ;      Note: If the client is sending data, server implementations on TCP
     726:  00:EC1B                      ;      should be careful to ensure that the client acknowledges receipt
     727:  00:EC1B                      ;      of the packet(s) containing the response prior to closing the
     728:  00:EC1B                      ;      input connection. If the client continues sending data to the
     729:  00:EC1B                      ;      server after the close, the server's controller will send a reset
     730:  00:EC1B                      ;      packet to the client, which may erase the client's unacknowledged
     731:  00:EC1B                      ;      input buffers before they can be read and interpreted by the HTTP
     732:  00:EC1B                      ;      application.
     733:  00:EC1B                      ;
     734:  00:EC1B                      ;   400 Bad Request
     735:  00:EC1B                      ;
     736:  00:EC1B                      ;   The request could not be understood by the server due to malformed
     737:  00:EC1B                      ;   syntax. The client should not repeat the request without
     738:  00:EC1B                      ;   modifications.
     739:  00:EC1B                      ;
     740:  00:EC1B                      ;   401 Unauthorized
     741:  00:EC1B                      ;
     742:  00:EC1B                      ;   The request requires user authentication. The response must include
     743:  00:EC1B                      ;   a WWW-Authenticate header field (Section 10.16) containing a
     744:  00:EC1B                      ;   challenge applicable to the requested resource. The client may
     745:  00:EC1B                      ;   repeat the request with a suitable Authorization header field
     746:  00:EC1B                      ;   (Section 10.2). If the request already included Authorization
     747:  00:EC1B                      ;   credentials, then the 401 response indicates that authorization has
     748:  00:EC1B                      ;   been refused for those credentials. If the 401 response contains
     749:  00:EC1B                      ;   the same challenge as the prior response, and the user agent has
     750:  00:EC1B                      ;   already attempted authentication at least once, then the user
     751:  00:EC1B                      ;   should be presented the entity that was given in the response,
     752:  00:EC1B                      ;   since that entity may include relevant diagnostic information. HTTP
     753:  00:EC1B                      ;   access authentication is explained in Section 11.
     754:  00:EC1B                      ;
     755:  00:EC1B                      ;   403 Forbidden
     756:  00:EC1B                      ;
     757:  00:EC1B                      ;   The server understood the request, but is refusing to fulfill it.
     758:  00:EC1B                      ;   Authorization will not help and the request should not be repeated.
     759:  00:EC1B                      ;   If the request method was not HEAD and the server wishes to make
     760:  00:EC1B                      ;   public why the request has not been fulfilled, it should describe
     761:  00:EC1B                      ;   the reason for the refusal in the entity body. This status code is
     762:  00:EC1B                      ;   commonly used when the server does not wish to reveal exactly why
     763:  00:EC1B                      ;   the request has been refused, or when no other response is
     764:  00:EC1B                      ;   applicable.
     765:  00:EC1B                      ;
     766:  00:EC1B                      ;   404 Not Found
     767:  00:EC1B                      ;
     768:  00:EC1B                      ;   The server has not found anything matching the Request-URI. No
     769:  00:EC1B                      ;   indication is given of whether the condition is temporary or
     770:  00:EC1B                      ;   permanent. If the server does not wish to make this information
     771:  00:EC1B                      ;   available to the client, the status code 403 (forbidden) can be
     772:  00:EC1B                      ;   used instead.
     773:  00:EC1B                      ;
     774:  00:EC1B                      ; 9.5  Server Error 5xx
     775:  00:EC1B                      ;
     776:  00:EC1B                      ;   Response status codes beginning with the digit "5" indicate cases in
     777:  00:EC1B                      ;   which the server is aware that it has erred or is incapable of
     778:  00:EC1B                      ;   performing the request. If the client has not completed the request
     779:  00:EC1B                      ;   when a 5xx code is received, it should immediately cease sending data
     780:  00:EC1B                      ;   to the server. Except when responding to a HEAD request, the server
     781:  00:EC1B                      ;   should include an entity containing an explanation of the error
     782:  00:EC1B                      ;   situation, and whether it is a temporary or permanent condition.
     783:  00:EC1B                      ;   These response codes are applicable to any request method and there
     784:  00:EC1B                      ;   are no required header fields.
     785:  00:EC1B                      ;
     786:  00:EC1B                      ;   500 Internal Server Error
     787:  00:EC1B                      ;
     788:  00:EC1B                      ;   The server encountered an unexpected condition which prevented it
     789:  00:EC1B                      ;   from fulfilling the request.
     790:  00:EC1B                      ;
     791:  00:EC1B                      ;   501 Not Implemented
     792:  00:EC1B                      ;
     793:  00:EC1B                      ;   The server does not support the functionality required to fulfill
     794:  00:EC1B                      ;   the request. This is the appropriate response when the server does
     795:  00:EC1B                      ;   not recognize the request method and is not capable of supporting
     796:  00:EC1B                      ;   it for any resource.
     797:  00:EC1B                      ;
     798:  00:EC1B                      ;   502 Bad Gateway
     799:  00:EC1B                      ;
     800:  00:EC1B                      ;   The server, while acting as a gateway or proxy, received an invalid
     801:  00:EC1B                      ;   response from the upstream server it accessed in attempting to
     802:  00:EC1B                      ;   fulfill the request.
     803:  00:EC1B                      ;
     804:  00:EC1B                      ;   503 Service Unavailable
     805:  00:EC1B                      ;
     806:  00:EC1B                      ;   The server is currently unable to handle the request due to a
     807:  00:EC1B                      ;   temporary overloading or maintenance of the server. The implication
     808:  00:EC1B                      ;   is that this is a temporary condition which will be alleviated
     809:  00:EC1B                      ;   after some delay.
     810:  00:EC1B                      ;
     811:  00:EC1B                      ;       Note: The existence of the 503 status code does not imply
     812:  00:EC1B                      ;       that a server must use it when becoming overloaded. Some
     813:  00:EC1B                      ;       servers may wish to simply refuse the connection.
     814:  00:EC1B                      ;
     815:  00:EC1B                      ; 10.  Header Field Definitions
     816:  00:EC1B                      ;
     817:  00:EC1B                      ;   This section defines the syntax and semantics of all commonly used
     818:  00:EC1B                      ;   HTTP/1.0 header fields. For general and entity header fields, both
     819:  00:EC1B                      ;   sender and recipient refer to either the client or the server,
     820:  00:EC1B                      ;   depending on who sends and who receives the message.
     821:  00:EC1B                      ;
     822:  00:EC1B                      ; 10.1  Allow
     823:  00:EC1B                      ;
     824:  00:EC1B                      ;   The Allow entity-header field lists the set of methods supported by
     825:  00:EC1B                      ;   the resource identified by the Request-URI. The purpose of this field
     826:  00:EC1B                      ;   is strictly to inform the recipient of valid methods associated with
     827:  00:EC1B                      ;   the resource. The Allow header field is not permitted in a request
     828:  00:EC1B                      ;   using the POST method, and thus should be ignored if it is received
     829:  00:EC1B                      ;   as part of a POST entity.
     830:  00:EC1B                      ;
     831:  00:EC1B                      ;       Allow          = "Allow" ":" 1#method
     832:  00:EC1B                      ;
     833:  00:EC1B                      ;    Example of use:
     834:  00:EC1B                      ;
     835:  00:EC1B                      ;       Allow: GET, HEAD
     836:  00:EC1B                      ;
     837:  00:EC1B                      ;   This field cannot prevent a client from trying other methods.
     838:  00:EC1B                      ;   However, the indications given by the Allow header field value should
     839:  00:EC1B                      ;   be followed. The actual set of allowed methods is defined by the
     840:  00:EC1B                      ;   origin server at the time of each request.
     841:  00:EC1B                      ;
     842:  00:EC1B                      ;   A proxy must not modify the Allow header field even if it does not
     843:  00:EC1B                      ;   understand all the methods specified, since the user agent may have
     844:  00:EC1B                      ;   other means of communicating with the origin server.
     845:  00:EC1B                      ;
     846:  00:EC1B                      ;   The Allow header field does not indicate what methods are implemented
     847:  00:EC1B                      ;   by the server.
     848:  00:EC1B                      ;
     849:  00:EC1B                      ; 10.2  Authorization
     850:  00:EC1B                      ;
     851:  00:EC1B                      ;   A user agent that wishes to authenticate itself with a server--
     852:  00:EC1B                      ;   usually, but not necessarily, after receiving a 401 response--may do
     853:  00:EC1B                      ;   so by including an Authorization request-header field with the
     854:  00:EC1B                      ;   request. The Authorization field value consists of credentials
     855:  00:EC1B                      ;   containing the authentication information of the user agent for the
     856:  00:EC1B                      ;   realm of the resource being requested.
     857:  00:EC1B                      ;
     858:  00:EC1B                      ;       Authorization  = "Authorization" ":" credentials
     859:  00:EC1B                      ;
     860:  00:EC1B                      ;   HTTP access authentication is described in Section 11. If a request
     861:  00:EC1B                      ;   is authenticated and a realm specified, the same credentials should
     862:  00:EC1B                      ;   be valid for all other requests within this realm.
     863:  00:EC1B                      ;
     864:  00:EC1B                      ;   Responses to requests containing an Authorization field are not
     865:  00:EC1B                      ;   cachable.
     866:  00:EC1B                      ;
     867:  00:EC1B                      ; 10.3  Content-Encoding
     868:  00:EC1B                      ;
     869:  00:EC1B                      ;   The Content-Encoding entity-header field is used as a modifier to the
     870:  00:EC1B                      ;   media-type. When present, its value indicates what additional content
     871:  00:EC1B                      ;   coding has been applied to the resource, and thus what decoding
     872:  00:EC1B                      ;   mechanism must be applied in order to obtain the media-type
     873:  00:EC1B                      ;   referenced by the Content-Type header field. The Content-Encoding is
     874:  00:EC1B                      ;   primarily used to allow a document to be compressed without losing
     875:  00:EC1B                      ;   the identity of its underlying media type.
     876:  00:EC1B                      ;
     877:  00:EC1B                      ;       Content-Encoding = "Content-Encoding" ":" content-coding
     878:  00:EC1B                      ;
     879:  00:EC1B                      ;   Content codings are defined in Section 3.5. An example of its use is
     880:  00:EC1B                      ;
     881:  00:EC1B                      ;       Content-Encoding: x-gzip
     882:  00:EC1B                      ;
     883:  00:EC1B                      ;   The Content-Encoding is a characteristic of the resource identified
     884:  00:EC1B                      ;   by the Request-URI. Typically, the resource is stored with this
     885:  00:EC1B                      ;   encoding and is only decoded before rendering or analogous usage.
     886:  00:EC1B                      ;
     887:  00:EC1B                      ; 10.4  Content-Length
     888:  00:EC1B                      ;
     889:  00:EC1B                      ;   The Content-Length entity-header field indicates the size of the
     890:  00:EC1B                      ;   Entity-Body, in decimal number of octets, sent to the recipient or,
     891:  00:EC1B                      ;   in the case of the HEAD method, the size of the Entity-Body that
     892:  00:EC1B                      ;   would have been sent had the request been a GET.
     893:  00:EC1B                      ;
     894:  00:EC1B                      ;       Content-Length = "Content-Length" ":" 1*DIGIT
     895:  00:EC1B                      ;
     896:  00:EC1B                      ;   An example is
     897:  00:EC1B                      ;
     898:  00:EC1B                      ;       Content-Length: 3495
     899:  00:EC1B                      ;
     900:  00:EC1B                      ;   Applications should use this field to indicate the size of the
     901:  00:EC1B                      ;   Entity-Body to be transferred, regardless of the media type of the
     902:  00:EC1B                      ;   entity. A valid Content-Length field value is required on all
     903:  00:EC1B                      ;   HTTP/1.0 request messages containing an entity body.
     904:  00:EC1B                      ;
     905:  00:EC1B                      ;   Any Content-Length greater than or equal to zero is a valid value.
     906:  00:EC1B                      ;   Section 7.2.2 describes how to determine the length of a response
     907:  00:EC1B                      ;   entity body if a Content-Length is not given.
     908:  00:EC1B                      ;
     909:  00:EC1B                      ;      Note: The meaning of this field is significantly different from
     910:  00:EC1B                      ;      the corresponding definition in MIME, where it is an optional
     911:  00:EC1B                      ;      field used within the "message/external-body" content-type. In
     912:  00:EC1B                      ;      HTTP, it should be used whenever the entity's length can be
     913:  00:EC1B                      ;      determined prior to being transferred.
     914:  00:EC1B                      ;
     915:  00:EC1B                      ; 10.5  Content-Type
     916:  00:EC1B                      ;
     917:  00:EC1B                      ;   The Content-Type entity-header field indicates the media type of the
     918:  00:EC1B                      ;   Entity-Body sent to the recipient or, in the case of the HEAD method,
     919:  00:EC1B                      ;   the media type that would have been sent had the request been a GET.
     920:  00:EC1B                      ;
     921:  00:EC1B                      ;       Content-Type   = "Content-Type" ":" media-type
     922:  00:EC1B                      ;
     923:  00:EC1B                      ;   Media types are defined in Section 3.6. An example of the field is
     924:  00:EC1B                      ;
     925:  00:EC1B                      ;       Content-Type: text/html
     926:  00:EC1B                      ;
     927:  00:EC1B                      ;   Further discussion of methods for identifying the media type of an
     928:  00:EC1B                      ;   entity is provided in Section 7.2.1.
     929:  00:EC1B                      ;
     930:  00:EC1B                      ; 10.6  Date
     931:  00:EC1B                      ;
     932:  00:EC1B                      ;   The Date general-header field represents the date and time at which
     933:  00:EC1B                      ;   the message was originated, having the same semantics as orig-date in
     934:  00:EC1B                      ;   RFC 822. The field value is an HTTP-date, as described in Section
     935:  00:EC1B                      ;   3.3.
     936:  00:EC1B                      ;
     937:  00:EC1B                      ;       Date           = "Date" ":" HTTP-date
     938:  00:EC1B                      ;
     939:  00:EC1B                      ;   An example is
     940:  00:EC1B                      ;
     941:  00:EC1B                      ;       Date: Tue, 15 Nov 1994 08:12:31 GMT
     942:  00:EC1B                      ;
     943:  00:EC1B                      ;   If a message is received via direct connection with the user agent
     944:  00:EC1B                      ;   (in the case of requests) or the origin server (in the case of
     945:  00:EC1B                      ;   responses), then the date can be assumed to be the current date at
     946:  00:EC1B                      ;   the receiving end. However, since the date--as it is believed by the
     947:  00:EC1B                      ;   origin--is important for evaluating cached responses, origin servers
     948:  00:EC1B                      ;   should always include a Date header. Clients should only send a Date
     949:  00:EC1B                      ;   header field in messages that include an entity body, as in the case
     950:  00:EC1B                      ;   of the POST request, and even then it is optional. A received message
     951:  00:EC1B                      ;   which does not have a Date header field should be assigned one by the
     952:  00:EC1B                      ;   recipient if the message will be cached by that recipient or
     953:  00:EC1B                      ;   gatewayed via a protocol which requires a Date.
     954:  00:EC1B                      ;
     955:  00:EC1B                      ;   In theory, the date should represent the moment just before the
     956:  00:EC1B                      ;   entity is generated. In practice, the date can be generated at any
     957:  00:EC1B                      ;   time during the message origination without affecting its semantic
     958:  00:EC1B                      ;   value.
     959:  00:EC1B                      ;
     960:  00:EC1B                      ;      Note: An earlier version of this document incorrectly specified
     961:  00:EC1B                      ;      that this field should contain the creation date of the enclosed
     962:  00:EC1B                      ;      Entity-Body. This has been changed to reflect actual (and proper)
     963:  00:EC1B                      ;      usage.
     964:  00:EC1B                      ;
     965:  00:EC1B                      ; 10.7  Expires
     966:  00:EC1B                      ;
     967:  00:EC1B                      ;   The Expires entity-header field gives the date/time after which the
     968:  00:EC1B                      ;   entity should be considered stale. This allows information providers
     969:  00:EC1B                      ;   to suggest the volatility of the resource, or a date after which the
     970:  00:EC1B                      ;   information may no longer be valid. Applications must not cache this
     971:  00:EC1B                      ;   entity beyond the date given. The presence of an Expires field does
     972:  00:EC1B                      ;   not imply that the original resource will change or cease to exist
     973:  00:EC1B                      ;   at, before, or after that time. However, information providers that
     974:  00:EC1B                      ;   know or even suspect that a resource will change by a certain date
     975:  00:EC1B                      ;   should include an Expires header with that date. The format is an
     976:  00:EC1B                      ;   absolute date and time as defined by HTTP-date in Section 3.3.
     977:  00:EC1B                      ;
     978:  00:EC1B                      ;       Expires        = "Expires" ":" HTTP-date
     979:  00:EC1B                      ;
     980:  00:EC1B                      ;   An example of its use is
     981:  00:EC1B                      ;
     982:  00:EC1B                      ;       Expires: Thu, 01 Dec 1994 16:00:00 GMT
     983:  00:EC1B                      ;
     984:  00:EC1B                      ;   If the date given is equal to or earlier than the value of the Date
     985:  00:EC1B                      ;   header, the recipient must not cache the enclosed entity. If a
     986:  00:EC1B                      ;   resource is dynamic by nature, as is the case with many data-
     987:  00:EC1B                      ;   producing processes, entities from that resource should be given an
     988:  00:EC1B                      ;   appropriate Expires value which reflects that dynamism.
     989:  00:EC1B                      ;
     990:  00:EC1B                      ;   The Expires field cannot be used to force a user agent to refresh its
     991:  00:EC1B                      ;   display or reload a resource; its semantics apply only to caching
     992:  00:EC1B                      ;   mechanisms, and such mechanisms need only check a resource's
     993:  00:EC1B                      ;   expiration status when a new request for that resource is initiated.
     994:  00:EC1B                      ;
     995:  00:EC1B                      ;   User agents often have history mechanisms, such as "Back" buttons and
     996:  00:EC1B                      ;   history lists, which can be used to redisplay an entity retrieved
     997:  00:EC1B                      ;   earlier in a session. By default, the Expires field does not apply to
     998:  00:EC1B                      ;   history mechanisms. If the entity is still in storage, a history
     999:  00:EC1B                      ;   mechanism should display it even if the entity has expired, unless
    1000:  00:EC1B                      ;   the user has specifically configured the agent to refresh expired
    1001:  00:EC1B                      ;   history documents.
    1002:  00:EC1B                      ;
    1003:  00:EC1B                      ;      Note: Applications are encouraged to be tolerant of bad or
    1004:  00:EC1B                      ;      misinformed implementations of the Expires header. A value of zero
    1005:  00:EC1B                      ;      (0) or an invalid date format should be considered equivalent to
    1006:  00:EC1B                      ;      an "expires immediately." Although these values are not legitimate
    1007:  00:EC1B                      ;      for HTTP/1.0, a robust implementation is always desirable.
    1008:  00:EC1B                      ;
    1009:  00:EC1B                      ; 10.8  From
    1010:  00:EC1B                      ;
    1011:  00:EC1B                      ;   The From request-header field, if given, should contain an Internet
    1012:  00:EC1B                      ;   e-mail address for the human user who controls the requesting user
    1013:  00:EC1B                      ;   agent. The address should be machine-usable, as defined by mailbox in
    1014:  00:EC1B                      ;   RFC 822 [7] (as updated by RFC 1123 [6]):
    1015:  00:EC1B                      ;
    1016:  00:EC1B                      ;       From           = "From" ":" mailbox
    1017:  00:EC1B                      ;
    1018:  00:EC1B                      ;   An example is:
    1019:  00:EC1B                      ;
    1020:  00:EC1B                      ;       From: webmaster@w3.org
    1021:  00:EC1B                      ;
    1022:  00:EC1B                      ;   This header field may be used for logging purposes and as a means for
    1023:  00:EC1B                      ;   identifying the source of invalid or unwanted requests. It should not
    1024:  00:EC1B                      ;   be used as an insecure form of access protection. The interpretation
    1025:  00:EC1B                      ;   of this field is that the request is being performed on behalf of the
    1026:  00:EC1B                      ;   person given, who accepts responsibility for the method performed. In
    1027:  00:EC1B                      ;   particular, robot agents should include this header so that the
    1028:  00:EC1B                      ;   person responsible for running the robot can be contacted if problems
    1029:  00:EC1B                      ;   occur on the receiving end.
    1030:  00:EC1B                      ;
    1031:  00:EC1B                      ;   The Internet e-mail address in this field may be separate from the
    1032:  00:EC1B                      ;   Internet host which issued the request. For example, when a request
    1033:  00:EC1B                      ;   is passed through a proxy, the original issuer's address should be
    1034:  00:EC1B                      ;   used.
    1035:  00:EC1B                      ;
    1036:  00:EC1B                      ;      Note: The client should not send the From header field without the
    1037:  00:EC1B                      ;      user's approval, as it may conflict with the user's privacy
    1038:  00:EC1B                      ;      interests or their site's security policy. It is strongly
    1039:  00:EC1B                      ;      recommended that the user be able to disable, enable, and modify
    1040:  00:EC1B                      ;      the value of this field at any time prior to a request.
    1041:  00:EC1B                      ;
    1042:  00:EC1B                      ; 10.9  If-Modified-Since
    1043:  00:EC1B                      ;
    1044:  00:EC1B                      ;   The If-Modified-Since request-header field is used with the GET
    1045:  00:EC1B                      ;   method to make it conditional: if the requested resource has not been
    1046:  00:EC1B                      ;   modified since the time specified in this field, a copy of the
    1047:  00:EC1B                      ;   resource will not be returned from the server; instead, a 304 (not
    1048:  00:EC1B                      ;   modified) response will be returned without any Entity-Body.
    1049:  00:EC1B                      ;
    1050:  00:EC1B                      ;       If-Modified-Since = "If-Modified-Since" ":" HTTP-date
    1051:  00:EC1B                      ;
    1052:  00:EC1B                      ;   An example of the field is:
    1053:  00:EC1B                      ;
    1054:  00:EC1B                      ;       If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT
    1055:  00:EC1B                      ;
    1056:  00:EC1B                      ;   A conditional GET method requests that the identified resource be
    1057:  00:EC1B                      ;   transferred only if it has been modified since the date given by the
    1058:  00:EC1B                      ;   If-Modified-Since header. The algorithm for determining this includes
    1059:  00:EC1B                      ;   the following cases:
    1060:  00:EC1B                      ;
    1061:  00:EC1B                      ;      a) If the request would normally result in anything other than
    1062:  00:EC1B                      ;         a 200 (ok) status, or if the passed If-Modified-Since date
    1063:  00:EC1B                      ;         is invalid, the response is exactly the same as for a
    1064:  00:EC1B                      ;         normal GET. A date which is later than the server's current
    1065:  00:EC1B                      ;         time is invalid.
    1066:  00:EC1B                      ;
    1067:  00:EC1B                      ;      b) If the resource has been modified since the
    1068:  00:EC1B                      ;         If-Modified-Since date, the response is exactly the same as
    1069:  00:EC1B                      ;         for a normal GET.
    1070:  00:EC1B                      ;
    1071:  00:EC1B                      ;      c) If the resource has not been modified since a valid
    1072:  00:EC1B                      ;         If-Modified-Since date, the server shall return a 304 (not
    1073:  00:EC1B                      ;         modified) response.
    1074:  00:EC1B                      ;
    1075:  00:EC1B                      ;   The purpose of this feature is to allow efficient updates of cached
    1076:  00:EC1B                      ;   information with a minimum amount of transaction overhead.
    1077:  00:EC1B                      ;
    1078:  00:EC1B                      ; 10.10  Last-Modified
    1079:  00:EC1B                      ;
    1080:  00:EC1B                      ;   The Last-Modified entity-header field indicates the date and time at
    1081:  00:EC1B                      ;   which the sender believes the resource was last modified. The exact
    1082:  00:EC1B                      ;   semantics of this field are defined in terms of how the recipient
    1083:  00:EC1B                      ;   should interpret it:  if the recipient has a copy of this resource
    1084:  00:EC1B                      ;   which is older than the date given by the Last-Modified field, that
    1085:  00:EC1B                      ;   copy should be considered stale.
    1086:  00:EC1B                      ;
    1087:  00:EC1B                      ;       Last-Modified  = "Last-Modified" ":" HTTP-date
    1088:  00:EC1B                      ;
    1089:  00:EC1B                      ;   An example of its use is
    1090:  00:EC1B                      ;
    1091:  00:EC1B                      ;       Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT
    1092:  00:EC1B                      ;
    1093:  00:EC1B                      ;   The exact meaning of this header field depends on the implementation
    1094:  00:EC1B                      ;   of the sender and the nature of the original resource. For files, it
    1095:  00:EC1B                      ;   may be just the file system last-modified time. For entities with
    1096:  00:EC1B                      ;   dynamically included parts, it may be the most recent of the set of
    1097:  00:EC1B                      ;   last-modify times for its component parts. For database gateways, it
    1098:  00:EC1B                      ;   may be the last-update timestamp of the record. For virtual objects,
    1099:  00:EC1B                      ;   it may be the last time the internal state changed.
    1100:  00:EC1B                      ;
    1101:  00:EC1B                      ;   An origin server must not send a Last-Modified date which is later
    1102:  00:EC1B                      ;   than the server's time of message origination. In such cases, where
    1103:  00:EC1B                      ;   the resource's last modification would indicate some time in the
    1104:  00:EC1B                      ;   future, the server must replace that date with the message
    1105:  00:EC1B                      ;   origination date.
    1106:  00:EC1B                      ;
    1107:  00:EC1B                      ; 10.11  Location
    1108:  00:EC1B                      ;
    1109:  00:EC1B                      ;   The Location response-header field defines the exact location of the
    1110:  00:EC1B                      ;   resource that was identified by the Request-URI. For 3xx responses,
    1111:  00:EC1B                      ;   the location must indicate the server's preferred URL for automatic
    1112:  00:EC1B                      ;   redirection to the resource. Only one absolute URL is allowed.
    1113:  00:EC1B                      ;
    1114:  00:EC1B                      ;       Location       = "Location" ":" absoluteURI
    1115:  00:EC1B                      ;
    1116:  00:EC1B                      ;   An example is
    1117:  00:EC1B                      ;
    1118:  00:EC1B                      ;       Location: http://www.w3.org/hypertext/WWW/NewLocation.html
    1119:  00:EC1B                      ;
    1120:  00:EC1B                      ; 10.12  Pragma
    1121:  00:EC1B                      ;
    1122:  00:EC1B                      ;   The Pragma general-header field is used to include implementation-
    1123:  00:EC1B                      ;   specific directives that may apply to any recipient along the
    1124:  00:EC1B                      ;   request/response chain. All pragma directives specify optional
    1125:  00:EC1B                      ;   behavior from the viewpoint of the protocol; however, some systems
    1126:  00:EC1B                      ;   may require that behavior be consistent with the directives.
    1127:  00:EC1B                      ;
    1128:  00:EC1B                      ;       Pragma           = "Pragma" ":" 1#pragma-directive
    1129:  00:EC1B                      ;
    1130:  00:EC1B                      ;       pragma-directive = "no-cache" | extension-pragma
    1131:  00:EC1B                      ;       extension-pragma = token [ "=" word ]
    1132:  00:EC1B                      ;
    1133:  00:EC1B                      ;   When the "no-cache" directive is present in a request message, an
    1134:  00:EC1B                      ;   application should forward the request toward the origin server even
    1135:  00:EC1B                      ;   if it has a cached copy of what is being requested. This allows a
    1136:  00:EC1B                      ;   client to insist upon receiving an authoritative response to its
    1137:  00:EC1B                      ;   request. It also allows a client to refresh a cached copy which is
    1138:  00:EC1B                      ;   known to be corrupted or stale.
    1139:  00:EC1B                      ;
    1140:  00:EC1B                      ;   Pragma directives must be passed through by a proxy or gateway
    1141:  00:EC1B                      ;   application, regardless of their significance to that application,
    1142:  00:EC1B                      ;   since the directives may be applicable to all recipients along the
    1143:  00:EC1B                      ;   request/response chain. It is not possible to specify a pragma for a
    1144:  00:EC1B                      ;   specific recipient; however, any pragma directive not relevant to a
    1145:  00:EC1B                      ;   recipient should be ignored by that recipient.
    1146:  00:EC1B                      ;
    1147:  00:EC1B                      ; 10.13  Referer
    1148:  00:EC1B                      ;
    1149:  00:EC1B                      ;   The Referer request-header field allows the client to specify, for
    1150:  00:EC1B                      ;   the server's benefit, the address (URI) of the resource from which
    1151:  00:EC1B                      ;   the Request-URI was obtained. This allows a server to generate lists
    1152:  00:EC1B                      ;   of back-links to resources for interest, logging, optimized caching,
    1153:  00:EC1B                      ;   etc. It also allows obsolete or mistyped links to be traced for
    1154:  00:EC1B                      ;   maintenance. The Referer field must not be sent if the Request-URI
    1155:  00:EC1B                      ;   was obtained from a source that does not have its own URI, such as
    1156:  00:EC1B                      ;   input from the user keyboard.
    1157:  00:EC1B                      ;
    1158:  00:EC1B                      ;       Referer        = "Referer" ":" ( absoluteURI | relativeURI )
    1159:  00:EC1B                      ;
    1160:  00:EC1B                      ;   Example:
    1161:  00:EC1B                      ;
    1162:  00:EC1B                      ;       Referer: http://www.w3.org/hypertext/DataSources/Overview.html
    1163:  00:EC1B                      ;
    1164:  00:EC1B                      ;   If a partial URI is given, it should be interpreted relative to the
    1165:  00:EC1B                      ;   Request-URI. The URI must not include a fragment.
    1166:  00:EC1B                      ;
    1167:  00:EC1B                      ;      Note: Because the source of a link may be private information or
    1168:  00:EC1B                      ;      may reveal an otherwise private information source, it is strongly
    1169:  00:EC1B                      ;      recommended that the user be able to select whether or not the
    1170:  00:EC1B                      ;      Referer field is sent. For example, a browser client could have a
    1171:  00:EC1B                      ;      toggle switch for browsing openly/anonymously, which would
    1172:  00:EC1B                      ;      respectively enable/disable the sending of Referer and From
    1173:  00:EC1B                      ;      information.
    1174:  00:EC1B                      ;
    1175:  00:EC1B                      ; 10.14  Server
    1176:  00:EC1B                      ;
    1177:  00:EC1B                      ;   The Server response-header field contains information about the
    1178:  00:EC1B                      ;   software used by the origin server to handle the request. The field
    1179:  00:EC1B                      ;   can contain multiple product tokens (Section 3.7) and comments
    1180:  00:EC1B                      ;   identifying the server and any significant subproducts. By
    1181:  00:EC1B                      ;   convention, the product tokens are listed in order of their
    1182:  00:EC1B                      ;   significance for identifying the application.
    1183:  00:EC1B                      ;
    1184:  00:EC1B                      ;       Server         = "Server" ":" 1*( product | comment )
    1185:  00:EC1B                      ;
    1186:  00:EC1B                      ;   Example:
    1187:  00:EC1B                      ;
    1188:  00:EC1B                      ;       Server: CERN/3.0 libwww/2.17
    1189:  00:EC1B                      ;
    1190:  00:EC1B                      ;   If the response is being forwarded through a proxy, the proxy
    1191:  00:EC1B                      ;   application must not add its data to the product list.
    1192:  00:EC1B                      ;
    1193:  00:EC1B                      ;      Note: Revealing the specific software version of the server may
    1194:  00:EC1B                      ;      allow the server machine to become more vulnerable to attacks
    1195:  00:EC1B                      ;      against software that is known to contain security holes. Server
    1196:  00:EC1B                      ;      implementors are encouraged to make this field a configurable
    1197:  00:EC1B                      ;      option.
    1198:  00:EC1B                      ;
    1199:  00:EC1B                      ;      Note: Some existing servers fail to restrict themselves to the
    1200:  00:EC1B                      ;      product token syntax within the Server field.
    1201:  00:EC1B                      ;
    1202:  00:EC1B                      ; 10.15  User-Agent
    1203:  00:EC1B                      ;
    1204:  00:EC1B                      ;   The User-Agent request-header field contains information about the
    1205:  00:EC1B                      ;   user agent originating the request. This is for statistical purposes,
    1206:  00:EC1B                      ;   the tracing of protocol violations, and automated recognition of user
    1207:  00:EC1B                      ;   agents for the sake of tailoring responses to avoid particular user
    1208:  00:EC1B                      ;   agent limitations. Although it is not required, user agents should
    1209:  00:EC1B                      ;   include this field with requests. The field can contain multiple
    1210:  00:EC1B                      ;   product tokens (Section 3.7) and comments identifying the agent and
    1211:  00:EC1B                      ;   any subproducts which form a significant part of the user agent. By
    1212:  00:EC1B                      ;   convention, the product tokens are listed in order of their
    1213:  00:EC1B                      ;   significance for identifying the application.
    1214:  00:EC1B                      ;
    1215:  00:EC1B                      ;       User-Agent     = "User-Agent" ":" 1*( product | comment )
    1216:  00:EC1B                      ;
    1217:  00:EC1B                      ;   Example:
    1218:  00:EC1B                      ;
    1219:  00:EC1B                      ;       User-Agent: CERN-LineMode/2.15 libwww/2.17b3
    1220:  00:EC1B                      ;
    1221:  00:EC1B                      ;       Note: Some current proxy applications append their product
    1222:  00:EC1B                      ;       information to the list in the User-Agent field. This is not
    1223:  00:EC1B                      ;       recommended, since it makes machine interpretation of these
    1224:  00:EC1B                      ;       fields ambiguous.
    1225:  00:EC1B                      ;
    1226:  00:EC1B                      ;       Note: Some existing clients fail to restrict themselves to
    1227:  00:EC1B                      ;       the product token syntax within the User-Agent field.
    1228:  00:EC1B                      ;
    1229:  00:EC1B                      ; 10.16  WWW-Authenticate
    1230:  00:EC1B                      ;
    1231:  00:EC1B                      ;   The WWW-Authenticate response-header field must be included in 401
    1232:  00:EC1B                      ;   (unauthorized) response messages. The field value consists of at
    1233:  00:EC1B                      ;   least one challenge that indicates the authentication scheme(s) and
    1234:  00:EC1B                      ;   parameters applicable to the Request-URI.
    1235:  00:EC1B                      ;
    1236:  00:EC1B                      ;       WWW-Authenticate = "WWW-Authenticate" ":" 1#challenge
    1237:  00:EC1B                      ;
    1238:  00:EC1B                      ;   The HTTP access authentication process is described in Section 11.
    1239:  00:EC1B                      ;   User agents must take special care in parsing the WWW-Authenticate
    1240:  00:EC1B                      ;   field value if it contains more than one challenge, or if more than
    1241:  00:EC1B                      ;   one WWW-Authenticate header field is provided, since the contents of
    1242:  00:EC1B                      ;   a challenge may itself contain a comma-separated list of
    1243:  00:EC1B                      ;   authentication parameters.
    1244:  00:EC1B                      				;
    1245:  00:EC1B                      				;
    1246:  00:EC1B                      				;
    1247:  00:EC1B                      ; D.  Additional Features
    1248:  00:EC1B                      ;
    1249:  00:EC1B                      ;   This appendix documents protocol elements used by some existing HTTP
    1250:  00:EC1B                      ;   implementations, but not consistently and correctly across most
    1251:  00:EC1B                      ;   HTTP/1.0 applications. Implementors should be aware of these
    1252:  00:EC1B                      ;   features, but cannot rely upon their presence in, or interoperability
    1253:  00:EC1B                      ;   with, other HTTP/1.0 applications.
    1254:  00:EC1B                      ;
    1255:  00:EC1B                      ; D.1  Additional Request Methods
    1256:  00:EC1B                      ;
    1257:  00:EC1B                      ; D.1.1 PUT
    1258:  00:EC1B                      ;
    1259:  00:EC1B                      ;   The PUT method requests that the enclosed entity be stored under the
    1260:  00:EC1B                      ;   supplied Request-URI. If the Request-URI refers to an already
    1261:  00:EC1B                      ;   existing resource, the enclosed entity should be considered as a
    1262:  00:EC1B                      ;   modified version of the one residing on the origin server. If the
    1263:  00:EC1B                      ;   Request-URI does not point to an existing resource, and that URI is
    1264:  00:EC1B                      ;   capable of being defined as a new resource by the requesting user
    1265:  00:EC1B                      ;   agent, the origin server can create the resource with that URI.
    1266:  00:EC1B                      ;
    1267:  00:EC1B                      ;   The fundamental difference between the POST and PUT requests is
    1268:  00:EC1B                      ;   reflected in the different meaning of the Request-URI. The URI in a
    1269:  00:EC1B                      ;   POST request identifies the resource that will handle the enclosed
    1270:  00:EC1B                      ;   entity as data to be processed. That resource may be a data-accepting
    1271:  00:EC1B                      ;   process, a gateway to some other protocol, or a separate entity that
    1272:  00:EC1B                      ;   accepts annotations. In contrast, the URI in a PUT request identifies
    1273:  00:EC1B                      ;   the entity enclosed with the request -- the user agent knows what URI
    1274:  00:EC1B                      ;   is intended and the server should not apply the request to some other
    1275:  00:EC1B                      ;   resource.
    1276:  00:EC1B                      ;
    1277:  00:EC1B                      ; D.1.2 DELETE
    1278:  00:EC1B                      ;
    1279:  00:EC1B                      ;   The DELETE method requests that the origin server delete the resource
    1280:  00:EC1B                      ;   identified by the Request-URI.
    1281:  00:EC1B                      ;
    1282:  00:EC1B                      ; D.1.3 LINK
    1283:  00:EC1B                      ;
    1284:  00:EC1B                      ;   The LINK method establishes one or more Link relationships between
    1285:  00:EC1B                      ;   the existing resource identified by the Request-URI and other
    1286:  00:EC1B                      ;   existing resources.
    1287:  00:EC1B                      ;
    1288:  00:EC1B                      ; D.1.4 UNLINK
    1289:  00:EC1B                      ;
    1290:  00:EC1B                      ;   The UNLINK method removes one or more Link relationships from the
    1291:  00:EC1B                      ;   existing resource identified by the Request-URI.
    1292:  00:EC1B                      ;
    1293:  00:EC1B                      ; D.2  Additional Header Field Definitions
    1294:  00:EC1B                      ;
    1295:  00:EC1B                      ; D.2.1 Accept
    1296:  00:EC1B                      ;
    1297:  00:EC1B                      ;   The Accept request-header field can be used to indicate a list of
    1298:  00:EC1B                      ;   media ranges which are acceptable as a response to the request. The
    1299:  00:EC1B                      ;   asterisk "*" character is used to group media types into ranges, with
    1300:  00:EC1B                      ;   "*/*" indicating all media types and "type/*" indicating all subtypes
    1301:  00:EC1B                      ;   of that type. The set of ranges given by the client should represent
    1302:  00:EC1B                      ;   what types are acceptable given the context of the request.
    1303:  00:EC1B                      ;
    1304:  00:EC1B                      ; D.2.2 Accept-Charset
    1305:  00:EC1B                      ;
    1306:  00:EC1B                      ;   The Accept-Charset request-header field can be used to indicate a
    1307:  00:EC1B                      ;   list of preferred character sets other than the default US-ASCII and
    1308:  00:EC1B                      ;   ISO-8859-1. This field allows clients capable of understanding more
    1309:  00:EC1B                      ;   comprehensive or special-purpose character sets to signal that
    1310:  00:EC1B                      ;   capability to a server which is capable of representing documents in
    1311:  00:EC1B                      ;   those character sets.
    1312:  00:EC1B                      ;
    1313:  00:EC1B                      ; D.2.3 Accept-Encoding
    1314:  00:EC1B                      ;
    1315:  00:EC1B                      ;   The Accept-Encoding request-header field is similar to Accept, but
    1316:  00:EC1B                      ;   restricts the content-coding values which are acceptable in the
    1317:  00:EC1B                      ;   response.
    1318:  00:EC1B                      ;
    1319:  00:EC1B                      ; D.2.4 Accept-Language
    1320:  00:EC1B                      ;
    1321:  00:EC1B                      ;   The Accept-Language request-header field is similar to Accept, but
    1322:  00:EC1B                      ;   restricts the set of natural languages that are preferred as a
    1323:  00:EC1B                      ;   response to the request.
    1324:  00:EC1B                      ;
    1325:  00:EC1B                      ; D.2.5 Content-Language
    1326:  00:EC1B                      ;
    1327:  00:EC1B                      ;   The Content-Language entity-header field describes the natural
    1328:  00:EC1B                      ;   language(s) of the intended audience for the enclosed entity. Note
    1329:  00:EC1B                      ;   that this may not be equivalent to all the languages used within the
    1330:  00:EC1B                      ;   entity.
    1331:  00:EC1B                      ;
    1332:  00:EC1B                      ; D.2.6 Link
    1333:  00:EC1B                      ;
    1334:  00:EC1B                      ;   The Link entity-header field provides a means for describing a
    1335:  00:EC1B                      ;   relationship between the entity and some other resource. An entity
    1336:  00:EC1B                      ;   may include multiple Link values. Links at the metainformation level
    1337:  00:EC1B                      ;   typically indicate relationships like hierarchical structure and
    1338:  00:EC1B                      ;   navigation paths.
    1339:  00:EC1B                      ;
    1340:  00:EC1B                      ; D.2.7 MIME-Version
    1341:  00:EC1B                      ;
    1342:  00:EC1B                      ;   HTTP messages may include a single MIME-Version general-header field
    1343:  00:EC1B                      ;   to indicate what version of the MIME protocol was used to construct
    1344:  00:EC1B                      ;   the message. Use of the MIME-Version header field, as defined by RFC
    1345:  00:EC1B                      ;   1521 [5], should indicate that the message is MIME-conformant.
    1346:  00:EC1B                      ;   Unfortunately, some older HTTP/1.0 servers send it indiscriminately,
    1347:  00:EC1B                      ;   and thus this field should be ignored.
    1348:  00:EC1B                      ;
    1349:  00:EC1B                      ; D.2.8 Retry-After
    1350:  00:EC1B                      ;
    1351:  00:EC1B                      ;   The Retry-After response-header field can be used with a 503 (service
    1352:  00:EC1B                      ;   unavailable) response to indicate how long the service is expected to
    1353:  00:EC1B                      ;   be unavailable to the requesting client. The value of this field can
    1354:  00:EC1B                      ;   be either an HTTP-date or an integer number of seconds (in decimal)
    1355:  00:EC1B                      ;   after the time of the response.
    1356:  00:EC1B                      ;
    1357:  00:EC1B                      ; D.2.9 Title
    1358:  00:EC1B                      ;
    1359:  00:EC1B                      ;   The Title entity-header field indicates the title of the entity.
    1360:  00:EC1B                      ;
    1361:  00:EC1B                      ; D.2.10 URI
    1362:  00:EC1B                      ;
    1363:  00:EC1B                      ;   The URI entity-header field may contain some or all of the Uniform
    1364:  00:EC1B                      ;   Resource Identifiers (Section 3.2) by which the Request-URI resource
    1365:  00:EC1B                      ;   can be identified. There is no guarantee that the resource can be
    1366:  00:EC1B                      ;   accessed using the URI(s) specified.
    1367:  00:EC1B                      ;
    1368:  00:EC1B                      ;==============================================================================
    1369:  00:EC1B                      ;
    1370:  00:EC1B  (00:0003)           HTTP_SOCKET	equ	3
    1371:  00:EC1B  (00:0050)           HTTP_PORT	equ	80		; Dest port always 80 for HTTP protocol
    1372:  00:EC1B                      ;
    1373:  00:EC1B                      ;
    1374:  00:EC1B                      ; This is the data kept in EXOS channel RAM.
    1375:  00:EC1B                      ;
    1376:  00:EC1B                      ; EXOS channel RAM is accessed at (ix-1), (ix-2)...etc so our data here is
    1377:  00:EC1B                      ; accessed with (ix-1-<item>) eg (ix-1-http_channel.socket)
    1378:  00:EC1B                      ;
    1379:  00:EC1B                      ; socket must be first as some of the generic device code expects it here.
    1380:  00:EC1B                      ;
    1381:  00:EC1B                      		struct	http_channel	; Variables in EXOS channel RAM
    1382:  00:EC1B                    < socket		 byte			; WIZ socket # for this channel
    1383:  00:EC1B                    < size_H		 byte			; File size
    1384:  00:EC1B                    < size_L		 byte
    1385:  00:EC1B                    < 		ends
    1386:  00:EC1B                      ;
    1387:  00:EC1B                      ;
    1388:  00:EC1B                      ;------------------------------------------------------------------------------
    1389:  00:EC1B                      ; device_open
    1390:  00:EC1B                      ;
    1391:  00:EC1B                      ; This implements the open code for the EXOS device.
    1392:  00:EC1B                      ;
    1393:  00:EC1B                      ; In:  vars.device.ip = ip address
    1394:  00:EC1B                      ;      DE->"filename", NOT null terminated
    1395:  00:EC1B                      ;       B=length of filename
    1396:  00:EC1B                      ; Out: A=EXOS error code
    1397:  00:EC1B                      ;
    1398:  00:EC1B                      device_open:
    1399:  00:EC1B  DD 36 FF 03         		ld	(ix-1-http_channel.socket),HTTP_SOCKET
    1400:  00:EC1F                      ;
    1401:  00:EC1F  FD CB 00 6E         		bit	vars.trace.http,(iy+vars._trace)
    1402:  00:EC23  28 1A               		jr	z,.donetrace
    1403:  00:EC25                      ;
    1404:  00:EC25  D5                  		push	de
    1405:  00:EC26  C5                  		push	bc
    1406:  00:EC27                      ;
    1407:  00:EC27  11 2B D3            		 ld	de,trace.http.open
    1408:  00:EC2A  CD 9D ED            		 call	trace
    1409:  00:EC2D                      ;
    1410:  00:EC2D  21 11 F0            		 ld	hl,vars.device.ip; DE->ip address
    1411:  00:EC30  CD 8C CD            		 call	io.ip
    1412:  00:EC33  3E 3A               		 ld	a,':'
    1413:  00:EC35  CD 00 CE            		 call	io.char
    1414:  00:EC38  3E 50               		 ld	a,HTTP_PORT
    1415:  00:EC3A  CD AE CD            		 call	io.short
    1416:  00:EC3D  C1                  		pop	bc
    1417:  00:EC3E  D1                  		pop	de
    1418:  00:EC3F                      ;
    1419:  00:EC3F  CD B5 CE            .donetrace:	call	status.start
    1420:  00:EC42                      
    1421:  00:EC42  D5                  		push	de
    1422:  00:EC43  C5                  		push	bc
    1423:  00:EC44  21 2A 00            		 ld	hl,42		; Source port
    1424:  00:EC47  DD 7E FF            		 ld	a,(ix-1-http_channel.socket)
    1425:  00:EC4A  11 21 EE            		 ld	de,owner_str	; Our name
    1426:  00:EC4D  CD 23 DD            		 call	tcp.open
    1427:  00:EC50  21 50 00            		 ld	hl,HTTP_PORT	; HL=dest port
    1428:  00:EC53  11 11 F0            		 ld	de,vars.device.ip; DE->ip address
    1429:  00:EC56  DD 7E FF            		 ld	a,(ix-1-http_channel.socket)
    1430:  00:EC59  D4 32 DF            		 call	nc,tcp.connect
    1431:  00:EC5C  9F                  		 sbc	a,a
    1432:  00:EC5D  E6 6B               		 and	exos.ERR_NOCON
    1433:  00:EC5F  C1                  		pop	bc
    1434:  00:EC60  D1                  		pop	de
    1435:  00:EC61  20 7B               		jr	nz,.ret
    1436:  00:EC63                      ;
    1437:  00:EC63  CD 2C ED            		call	send		; Send a "GET" request
    1438:  00:EC66  20 76               		jr	nz,.ret
    1439:  00:EC68                      ;
    1440:  00:EC68                      		; We should get an HTTP reply, which consists of a header
    1441:  00:EC68                      		; with a variable number of variable length ASCII lines ending
    1442:  00:EC68                      		; in CR,LF. The end of the header is marked by a blank line
    1443:  00:EC68                      		; (ie a double CR,LF pair). Assuming the retirn code is
    1444:  00:EC68                      		; 200 OK the file itself should follow the header.
    1445:  00:EC68  CD E4 EC            		call	readline	; Get first header line
    1446:  00:EC6B  B7                  		or	a
    1447:  00:EC6C  20 70               		jr	nz,.ret
    1448:  00:EC6E                      ;
    1449:  00:EC6E  11 C9 ED            		ld	de,http_1.0_str		; Make sure it starts with HTTP...
    1450:  00:EC71  06 08               		ld	b,http_1.0_str_len
    1451:  00:EC73  CD 34 CF            		call	util.memcmp
    1452:  00:EC76  20 2D               		jr	nz,.badpacket
    1453:  00:EC78                      ;
    1454:  00:EC78  23                  .unspace:	inc	hl
    1455:  00:EC79  7E                  		ld	a,(hl)			; Skip spaces
    1456:  00:EC7A  FE 20               		cp	' '
    1457:  00:EC7C  28 FA               		jr	z,.unspace
    1458:  00:EC7E                      ;
    1459:  00:EC7E                      		; Next should come the response code
    1460:  00:EC7E  EB                  		ex	de,hl		; DE->code in packet
    1461:  00:EC7F  CD C4 CF            		call	util.get_num16
    1462:  00:EC82  FD CB 00 6E         		bit	vars.trace.http,(iy+vars._trace)
    1463:  00:EC86  28 0B               		jr	z,.donecodetrace
    1464:  00:EC88                      ;
    1465:  00:EC88  11 3F D3            		ld	de,trace.http.code
    1466:  00:EC8B  CD 9D ED            		call	trace
    1467:  00:EC8E  E5                  		push	hl
    1468:  00:EC8F  CD B1 CD            		 call	io.int
    1469:  00:EC92  E1                  		pop	hl
    1470:  00:EC93                      ;		
    1471:  00:EC93  01 C8 00            .donecodetrace:	ld	bc,200		; Should be "200 OK"
    1472:  00:EC96  B7                  		or	a
    1473:  00:EC97  ED 42               		sbc	hl,bc
    1474:  00:EC99  28 0E               		jr	z,.nextline
    1475:  00:EC9B                      ;
    1476:  00:EC9B  B7                  		or	a
    1477:  00:EC9C  01 CC 00            		ld	bc,404-200	; 404 => not found
    1478:  00:EC9F  ED 42               		sbc	hl,bc
    1479:  00:ECA1  3E 68               		ld	a,exos.ERR_NOFIL
    1480:  00:ECA3  28 39               		jr	z,.ret
    1481:  00:ECA5                      ;
    1482:  00:ECA5  3E 64               .badpacket:	ld	a,exos.ERR_BADHTTP
    1483:  00:ECA7  18 35               		jr	.ret
    1484:  00:ECA9                      ;
    1485:  00:ECA9                      		; Now we read and discard all other lines until we reach the
    1486:  00:ECA9                      		; end of the header
    1487:  00:ECA9  CD E4 EC            .nextline:	call	readline
    1488:  00:ECAC  B7                  		or	a
    1489:  00:ECAD  20 2F               		jr	nz,.ret
    1490:  00:ECAF                      ;
    1491:  00:ECAF  7E                  		ld	a,(hl)		; See if blank line
    1492:  00:ECB0  B7                  		or	a
    1493:  00:ECB1  28 2B               		jr	z,.ret		; Finished reading header if yes
    1494:  00:ECB3                      ;
    1495:  00:ECB3  11 13 EE            		ld	de,content_length_str	; See if length field
    1496:  00:ECB6  06 0E               		ld	b,content_length_str_len
    1497:  00:ECB8  CD 34 CF            		call	util.memcmp
    1498:  00:ECBB  20 EC               		jr	nz,.nextline		; Go & read naext line if not
    1499:  00:ECBD                      ;
    1500:  00:ECBD  23                  .unspace2:	inc	hl			; Skip spaces after
    1501:  00:ECBE  7E                  		ld	a,(hl)
    1502:  00:ECBF  FE 20               		cp	' '
    1503:  00:ECC1  28 FA               		jr	z,.unspace2
    1504:  00:ECC3                      ;
    1505:  00:ECC3  EB                  		ex	de,hl			; DE->length in packet
    1506:  00:ECC4  CD C4 CF            		call	util.get_num16		; HL=size
    1507:  00:ECC7  DD 75 FD            		ld	(ix-1-http_channel.size_L),l; Save size of packet body
    1508:  00:ECCA  DD 74 FE            		ld	(ix-1-http_channel.size_H),h
    1509:  00:ECCD                      ;
    1510:  00:ECCD  FD CB 00 6E         		bit	vars.trace.http,(iy+vars._trace)
    1511:  00:ECD1  28 09               		jr	z,.donelentrace
    1512:  00:ECD3                      ;
    1513:  00:ECD3  11 45 D3            		ld	de,trace.http.size	; Print size read from packet
    1514:  00:ECD6  CD 9D ED            		call	trace
    1515:  00:ECD9  CD B1 CD            		call	io.int
    1516:  00:ECDC                      ;
    1517:  00:ECDC  18 CB               .donelentrace:	jr	.nextline		; Finish reading header
    1518:  00:ECDE                      ;
    1519:  00:ECDE  F5                  .ret:		push	af
    1520:  00:ECDF  CD A9 CE            		 call	status.stop
    1521:  00:ECE2  F1                  		pop	af
    1522:  00:ECE3  C9                  		ret
    1523:  00:ECE4                      ;
    1524:  00:ECE4                      ;
    1525:  00:ECE4                      
    1526:  00:ECE4                      ; Out: HL->vars.http.packet
    1527:  00:ECE4                      ;
    1528:  00:ECE4                      readline:
    1529:  00:ECE4  11 00 F3            		ld	de,vars.http.packet
    1530:  00:ECE7  D5                  		push	de
    1531:  00:ECE8  1B                  		 dec	de		; Compensate for initial inc de
    1532:  00:ECE9                      ;
    1533:  00:ECE9  13                  .next:		 inc	de
    1534:  00:ECEA  D5                  .ignore:	 push	de		; Save ->current byte
    1535:  00:ECEB  01 01 00            		  ld	bc,1		; Read 1 byte
    1536:  00:ECEE  DD 7E FF            		  ld	a,(ix-1-http_channel.socket)
    1537:  00:ECF1  CD 6F DD            		  call	tcp.read_block
    1538:  00:ECF4  D1                  		 pop	de		; DE->current byte
    1539:  00:ECF5  38 1E               		 jr	c,.err
    1540:  00:ECF7                      ;
    1541:  00:ECF7  1A                  		 ld	a,(de)
    1542:  00:ECF8  FE 0D               		 cp	CR		; Just ignore CRs
    1543:  00:ECFA  28 EE               		 jr	z,.ignore
    1544:  00:ECFC                      ;
    1545:  00:ECFC  D6 0A               		 sub	LF		; End of line?
    1546:  00:ECFE  20 E9               		 jr	nz,.next	; Read next char if not
    1547:  00:ED00                      ;
    1548:  00:ED00  12                  		 ld	(de),a		; Turn into a null-terminated string
    1549:  00:ED01                      ;
    1550:  00:ED01  FD CB 00 6E         		 bit	vars.trace.http,(iy+vars._trace)
    1551:  00:ED05  28 0B               		 jr	z,.donetrace
    1552:  00:ED07                      ;
    1553:  00:ED07  11 3B D3            		 ld	de,trace.http.rx
    1554:  00:ED0A  CD 9D ED            		 call	trace
    1555:  00:ED0D                      ;
    1556:  00:ED0D  D1                  		pop	de
    1557:  00:ED0E  D5                  		push	de
    1558:  00:ED0F  CD 3D CE            		 call	io.str
    1559:  00:ED12                      ;
    1560:  00:ED12  E1                  .donetrace:	pop	hl		; Return HL->line
    1561:  00:ED13  AF                  		xor	a		; No error
    1562:  00:ED14  C9                  		ret
    1563:  00:ED15                      ;
    1564:  00:ED15  E1                  .err:		pop	hl
    1565:  00:ED16                      ;
    1566:  00:ED16  FD CB 00 6E         		bit	vars.trace.http,(iy+vars._trace)
    1567:  00:ED1A  28 05               		jr	z,.donetrace3
    1568:  00:ED1C                      ;
    1569:  00:ED1C  F5                  		push	af
    1570:  00:ED1D  DC 53 D0            		 call	c,trace.error
    1571:  00:ED20  F1                  		pop	af
    1572:  00:ED21                      ;
    1573:  00:ED21                      .donetrace3:
    1574:  00:ED21  D6 02               		sub	2
    1575:  00:ED23  3E E4               		ld	a,exos.ERR_EOF
    1576:  00:ED25  F8                  		ret	m		; Code 1=>socket closed
    1577:  00:ED26                      ;
    1578:  00:ED26  3E E5               		ld	a,exos.ERR_STOP
    1579:  00:ED28  C8                  		ret	z		; Code 2=>STOP pressed
    1580:  00:ED29                      ;
    1581:  00:ED29  3E 6A               		ld	a,exos.ERR_TIMEOUT	; Code 3=>timeout
    1582:  00:ED2B  C9                  		ret
    1583:  00:ED2C                      ;
    1584:  00:ED2C                      ;
    1585:  00:ED2C                      ;------------------------------------------------------------------------------
    1586:  00:ED2C                      ; send
    1587:  00:ED2C                      ;
    1588:  00:ED2C                      ; sends an HTTP "GET" request.
    1589:  00:ED2C                      ;
    1590:  00:ED2C                      ; DE->"filename", no null
    1591:  00:ED2C                      ; B=length of filename
    1592:  00:ED2C                      ;
    1593:  00:ED2C  D5                  send:		push	de
    1594:  00:ED2D  C5                  		push	bc
    1595:  00:ED2E  11 00 F3            		 ld	de,vars.http.packet	; Build packet here
    1596:  00:ED31                      ;
    1597:  00:ED31  21 C4 ED            		 ld	hl,get_str	; "GET "
    1598:  00:ED34  01 04 00            		 ld	bc,get_str_len
    1599:  00:ED37  ED B0               		 ldir			; Copy GET to packet
    1600:  00:ED39                      ;
    1601:  00:ED39  C1                  		pop	bc		; B=URI length
    1602:  00:ED3A  E1                  		pop	hl		; HL->URI
    1603:  00:ED3B  48                  		ld	c,b		; C=URI length
    1604:  00:ED3C  AF                  		xor	a
    1605:  00:ED3D  47                  		ld	b,a		; BC=URI length
    1606:  00:ED3E  B1                  		or	c
    1607:  00:ED3F  28 02               		jr	z,.donefn	; Just in case!
    1608:  00:ED41                      ;
    1609:  00:ED41  ED B0               		ldir			; Copy filename to packet
    1610:  00:ED43  21 C8 ED            .donefn:	ld	hl,_http_header_str	; " HTTP/1.0" etc
    1611:  00:ED46  01 4B 00            		ld	bc,_http_header_str_len
    1612:  00:ED49  ED B0               		ldir			; Copy protocol etc to packet
    1613:  00:ED4B                      ;
    1614:  00:ED4B  21 53 F0            		ld	hl,vars.device.host
    1615:  00:ED4E  CD F8 CE            		call	util.copystr	; Copy host name to packet
    1616:  00:ED51                      ;
    1617:  00:ED51  EB                  		ex	de,hl		; HL->end of packet
    1618:  00:ED52                      ;
    1619:  00:ED52  FD CB 00 6E         		bit	vars.trace.http,(iy+vars._trace)
    1620:  00:ED56  28 17               		jr	z,.donetrace
    1621:  00:ED58                      ;
    1622:  00:ED58  36 00               		ld	(hl),0		; Null terminate so we can print it
    1623:  00:ED5A                      ;
    1624:  00:ED5A  11 00 F3            		ld	de,vars.http.packet
    1625:  00:ED5D  D5                  .loop:		push	de		; Save ->string in packet
    1626:  00:ED5E  11 37 D3            		 ld	de,trace.http.tx
    1627:  00:ED61  CD 9D ED            		 call	trace		; Start trace line
    1628:  00:ED64  D1                  		pop	de		; DE->string in packet
    1629:  00:ED65  CD 39 CE            		call	io.line		; Print one line
    1630:  00:ED68  1A                  		ld	a,(de)		; See if more lines
    1631:  00:ED69  B7                  		or	a
    1632:  00:ED6A  20 F1               		jr	nz,.loop	; Print if yes
    1633:  00:ED6C                      ;
    1634:  00:ED6C  CD 3C D0            		call	trace.dots
    1635:  00:ED6F                      ;
    1636:  00:ED6F  36 0D               .donetrace:	ld	(hl),CR		; Add CR,LF now we've done trace
    1637:  00:ED71  23                  		inc	hl
    1638:  00:ED72  36 0A               		ld	(hl),LF
    1639:  00:ED74  23                  		inc	hl
    1640:  00:ED75                      ;
    1641:  00:ED75  36 0D               		ld	(hl),CR		; Add final CR, LF to mark end of header
    1642:  00:ED77  23                  		inc	hl
    1643:  00:ED78  36 0A               		ld	(hl),LF
    1644:  00:ED7A  23                  		inc	hl
    1645:  00:ED7B                      ;
    1646:  00:ED7B  11 00 F3            		ld	de,vars.http.packet	; DE->start of packet
    1647:  00:ED7E  B7                  		or	a
    1648:  00:ED7F  ED 52               		sbc	hl,de		; HL=length of packet
    1649:  00:ED81  4D                  		ld	c,l
    1650:  00:ED82  44                  		ld	b,h		; BC=length of packet
    1651:  00:ED83  EB                  		ex	de,hl		; HL->packet
    1652:  00:ED84  DD 7E FF            		ld	a,(ix-1-http_channel.socket)
    1653:  00:ED87  CD 8C D9            		call	socket.write
    1654:  00:ED8A  DD 7E FF            		ld	a,(ix-1-http_channel.socket)
    1655:  00:ED8D  D4 04 DF            		call	nc,tcp.send
    1656:  00:ED90                      ;
    1657:  00:ED90  FD CB 00 6E         		bit	vars.trace.http,(iy+vars._trace)
    1658:  00:ED94  28 03               		jr	z,.dt2
    1659:  00:ED96                      ;
    1660:  00:ED96  CD 44 D0            		call	trace.is_error
    1661:  00:ED99                      ;
    1662:  00:ED99  9F                  .dt2:		sbc	a,a
    1663:  00:ED9A  E6 6A               		and	exos.ERR_TIMEOUT
    1664:  00:ED9C  C9                  		ret
    1665:  00:ED9D                      ;
    1666:  00:ED9D                      ;
    1667:  00:ED9D                      ;------------------------------------------------------------------------------
    1668:  00:ED9D                      ; trace
    1669:  00:ED9D                      ;
    1670:  00:ED9D                      ; Starts a line of trace output
    1671:  00:ED9D                      ;
    1672:  00:ED9D                      ; In:  DE->str
    1673:  00:ED9D                      ;
    1674:  00:ED9D  CD 23 CE            trace:		call	io.start
    1675:  00:EDA0  3E 48               		ld	a,'H'
    1676:  00:EDA2  CD 00 CE            		call	io.char
    1677:  00:EDA5  3E 54               		ld	a,'T'
    1678:  00:EDA7  CD 00 CE            		call	io.char
    1679:  00:EDAA  3E 54               		ld	a,'T'
    1680:  00:EDAC  CD 00 CE            		call	io.char
    1681:  00:EDAF  3E 50               		ld	a,'P'
    1682:  00:EDB1  CD 00 CE            		call	io.char
    1683:  00:EDB4  DD 7E FF            		ld	a,(ix-1-http_channel.socket)
    1684:  00:EDB7  C6 30               		add	a,'0'
    1685:  00:EDB9  CD 00 CE            		call	io.char
    1686:  00:EDBC  3E 3A               		ld	a,':'
    1687:  00:EDBE  CD 00 CE            		call	io.char
    1688:  00:EDC1  C3 3D CE            		jp	io.str
    1689:  00:EDC4                      ;
    1690:  00:EDC4                      ;
    1691:  00:EDC4  47 45 54 20         get_str:	db	"GET "
    1692:  00:EDC8  (00:0004)           get_str_len	equ	$-get_str
    1693:  00:EDC8                      ;
    1694:  00:EDC8  20                  _http_header_str:db	" "
    1695:  00:EDC9                      http_1.0_str:	db	"HTTP/1.0"
    1695:  00:EDC9  48 54 54 50 2F 31 2E 30 
    1696:  00:EDD1  (00:0008)           http_1.0_str_len equ	$-http_1.0_str
    1697:  00:EDD1  0D 0A               		db	CR,LF
    1698:  00:EDD3                      		db	"Connection: Close",CR,LF
    1698:  00:EDD3  43 6F 6E 6E 65 63 74 69 6F 6E 3A 20 43 6C 6F 73 
    1698:  00:EDE3  65 0D 0A 
    1699:  00:EDE6                      		db	"User-Agent: Z80 Enterprise EPNET/"
    1699:  00:EDE6  55 73 65 72 2D 41 67 65 6E 74 3A 20 5A 38 30 20 
    1699:  00:EDF6  45 6E 74 65 72 70 72 69 73 65 20 45 50 4E 45 54 
    1699:  00:EE06  2F 
    1700:  00:EE07  30 2E 31 31 0D 0A   		db	version.major, ".", version.minor, version.revision,CR,LF
    1701:  00:EE0D  48 6F 73 74 3A 20   		db	"Host: "
    1702:  00:EE13  (00:004B)           _http_header_str_len equ	$-_http_header_str
    1703:  00:EE13                      ;
    1704:  00:EE13                      content_length_str:	db	"Content-Length"
    1704:  00:EE13  43 6F 6E 74 65 6E 74 2D 4C 65 6E 67 74 68 
    1705:  00:EE21  (00:000E)           content_length_str_len	equ	$-content_length_str
    1706:  00:EE21                      ;
    1707:  00:EE21                      ;
    1708:  00:EE21  48 54 54 50 3A 00   owner_str:	db	"HTTP:",0
    1709:  00:EE27                      ;
    1710:  00:EE27                      ;
    1711:  00:EE27                      ;
    1712:  00:EE27                      		endmodule
     112.  00:EE27                      ;
     113.  00:EE27                      	include vars.asm
       1:  00:EE27                      ; VARS
       2:  00:EE27                      ;
       3:  00:EE27                      ; Contains all the program RAM variables
       4:  00:EE27                      ;
       5:  00:EE27                      		module	vars
       6:  00:EE27                      ;
       7:  00:EE27                      ;==============================================================================
       8:  00:EE27                      ;
       9:  00:EE27                      ; This file is part of the EPNET software
      10:  00:EE27                      ;
      11:  00:EE27                      ; Copyright (C) 2015  Bruce Tanner
      12:  00:EE27                      ;
      13:  00:EE27                      ;    This program is free software: you can redistribute it and/or modify
      14:  00:EE27                      ;    it under the terms of the GNU General Public License as published by
      15:  00:EE27                      ;    the Free Software Foundation, either version 3 of the License, or
      16:  00:EE27                      ;    (at your option) any later version.
      17:  00:EE27                      ;
      18:  00:EE27                      ;    This program is distributed in the hope that it will be useful,
      19:  00:EE27                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      20:  00:EE27                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      21:  00:EE27                      ;    GNU General Public License for more details.
      22:  00:EE27                      ;
      23:  00:EE27                      ;    You should have received a copy of the GNU General Public License
      24:  00:EE27                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      25:  00:EE27                      ;
      26:  00:EE27                      ; If you do use or modify this file, either for its original purpose or for
      27:  00:EE27                      ; something new, I'd love to hear about it! I can be contacted by email at:
      28:  00:EE27                      ;
      29:  00:EE27                      ; brucetanner@btopenworld.com
      30:  00:EE27                      ;
      31:  00:EE27                      ;==============================================================================
      32:  00:EE27                      ;
      33:  00:EE27  FF (473)            		ds	0f000h-$,0ffh
      34:  00:F000                      @vars:
      35:  00:F000                      ;
      36:  00:F000                      ;
      37:  00:F000                      ; Throughout the program, IY points to the variables and the variables can
      38:  00:F000                      ; be accessed either directly, as in LD A,(variable), or via IY as in
      39:  00:F000                      ; LD C,(IY+offset to variable). This is particularly useful for global flags
      40:  00:F000                      ; which can be tested with BIT n,(IY+offset), allowing a flag to be tested
      41:  00:F000                      ; without corrupting A (or any other registers).
      42:  00:F000                      ;
      43:  00:F000                      ;
      44:  00:F000  (00:0000)           _trace		equ	$-vars		; Offset from @vars
      45:  00:F000  00 (1)              trace		ds	1		; Trace flags, as follows:
      46:  00:F001  (00:0000)           trace.diag	equ	0		; Bits in trace
      47:  00:F001  (00:0001)           trace.socket	equ	1
      48:  00:F001  (00:0002)           trace.dhcp	equ	2
      49:  00:F001  (00:0003)           trace.ftp	equ	3
      50:  00:F001  (00:0004)           trace.ntp	equ	4
      51:  00:F001  (00:0005)           trace.http	equ	5
      52:  00:F001  (00:0007)           trace.raw	equ	7
      53:  00:F001                      ;
      54:  00:F001  (00:0001)           trace.diag_mask	equ	01h		; Above bits as bitmasks
      55:  00:F001  (00:0002)           trace.socket_mask equ	02h
      56:  00:F001  (00:0004)           trace.dhcp_mask	equ	04h
      57:  00:F001  (00:0008)           trace.ftp_mask	equ	08h
      58:  00:F001  (00:0010)           trace.ntp_mask	equ	10h
      59:  00:F001  (00:0020)           trace.http_mask	equ	20h
      60:  00:F001  (00:0080)           trace.raw_mask	equ	80h
      61:  00:F001                      ;
      62:  00:F001  (00:007E)           trace.all_mask	equ	low ~(trace.diag_mask or trace.raw_mask)
      63:  00:F001                      ;
      64:  00:F001                      ;
      65:  00:F001  (00:0001)           _io		equ	$-vars		; io as an offset from vars
      66:  00:F001  00 (1)              io:		ds	1		; Our base I/O address+2
      67:  00:F002                      ;
      68:  00:F002                      ;
      69:  00:F002  00 (1)              trace.cols	ds	1		; # cols on screen
      70:  00:F003                      ;
      71:  00:F003                      ;
      72:  00:F003  (00:0003)           _init		equ	$-vars
      73:  00:F003  00 (1)              init		ds	1		; Initialization flags
      74:  00:F004                      ;
      75:  00:F004  (00:0000)           init.wiz	equ	0		; Bits in init
      76:  00:F004  (00:0001)           init.dhcp	equ	1
      77:  00:F004  (00:0002)           init.lease	equ	2
      78:  00:F004                      ;
      79:  00:F004  (00:0001)           init.wiz_mask	equ	01h		; Above bits as bitmasks
      80:  00:F004  (00:0002)           init.dhcp_mask	equ	02h
      81:  00:F004  (00:0004)           init.lease_mask	equ	04h
      82:  00:F004                      ;
      83:  00:F004                      ;
      84:  00:F004  (00:0004)           _socket.flushing equ	$-vars
      85:  00:F004  00 (1)              socket.flushing	ds	1		;NZ=>don't dump, we're flushing (!)
      86:  00:F005                      ;
      87:  00:F005                      ;
      88:  00:F005  (00:0005)           _io.col		equ	$-vars		; Offset from vars
      89:  00:F005  00 (1)              io.col:		ds	1		; Output column
      90:  00:F006                      ;
      91:  00:F006                      ;
      92:  00:F006  00 (2)              ticks:		ds	2		; 20mS tick count
      93:  00:F008  00 (2)              dhcp.ticks:	ds	2
      94:  00:F00A  (00:0032)           @TICKS_1s	equ	50		; No. ticks in 1s
      95:  00:F00A  (00:0BB8)           @TICKS_1m	equ	TICKS_1s*60	; No ticks in 1m
      96:  00:F00A                      ;
      97:  00:F00A                      ;
      98:  00:F00A  (00:000A)           status._ticks	equ	$-vars		; Offset from vars
      99:  00:F00A  00 (1)              status.ticks:	ds	1		; Tick count for timing flashing blob
     100:  00:F00B  00 (2)              status.pos:	ds	2		; ->our position on status line
     101:  00:F00D  00 (1)              status.byte:	ds	1		; Saved byte at our pos on status line
     102:  00:F00E                      ;
     103:  00:F00E                      ;
     104:  00:F00E  (00:000E)           device._byte	equ	$-vars		; As offset from vars
     105:  00:F00E  00 (1)              device.byte	ds	1		; Single byte buffer for byte read/write
     106:  00:F00F                      ;
     107:  00:F00F                      ;
     108:  00:F00F  00 (2)              tcp.start:	ds	2		; Start tick count for timeouts
     109:  00:F011                      ;
     110:  00:F011                      ;
     111:  00:F011                      diag.buffer:	;ds	6		; Enough for a MAC address
     112:  00:F011                      					; Overlays buffer below!
     113:  00:F011                      ;
     114:  00:F011                      command.ip:
     115:  00:F011                      device.ip:
     116:  00:F011                      icmp.header:				; ICMP header overlays UDP header
     117:  00:F011                      udp.header:
     118:  00:F011                      icmp.ip:
     119:  00:F011  00 (4)              udp.ip:		ds	4		; IP address
     120:  00:F015                      icmp.size:
     121:  00:F015  00 (2)              udp.port:	ds	2		; Port #
     122:  00:F017  (00:0006)           icmp.header_size equ	$-icmp.header
     123:  00:F017                      ping.start:				; Start time for timeouts
     124:  00:F017                      tcp.header:
     125:  00:F017                      tcp.size:
     126:  00:F017  00 (2)              udp.size:	ds	2		; #bytes in body
     127:  00:F019  (00:0008)           udp.header_size equ	$-udp.header
     128:  00:F019  (00:0002)           tcp.header_size	equ	$-tcp.header
     129:  00:F019                      ;
     130:  00:F019                      ntp.timeout:
     131:  00:F019                      ping.start_ticks:
     132:  00:F019  00 (2)              dhcp.timeout:	ds	2		; Initial secs for timeout
     133:  00:F01B                      ping.end_ticks:
     134:  00:F01B                      ntp.retries:
     135:  00:F01B  00 (1)              dhcp.retries:	ds	1		; Retry count before giving up
     136:  00:F01C                      ;
     137:  00:F01C                      dhcp.values:				; Parameters obtained via DHCP
     138:  00:F01C  00 (4)              dhcp.ip:	ds	4
     139:  00:F020  00 (4)              dhcp.subnet:	ds	4
     140:  00:F024  00 (4)              dhcp.gateway:	ds	4
     141:  00:F028  00 (4)              dhcp.server:	ds	4
     142:  00:F02C  00 (4)              dhcp.dns:	ds	4
     143:  00:F030  00 (4)              dhcp.ntp:	ds	4
     144:  00:F034  00 (4)              dhcp.lease:	ds	4		; Lease duration
     145:  00:F038  00 (4)              dhcp.start:	ds	4		; Start secs of lease
     146:  00:F03C  (00:0020)           dhcp.values_size equ	$-dhcp.values
     147:  00:F03C                      ;
     148:  00:F03C                      ping.ip:				; Overlays dhcp values
     149:  00:F03C  00 (4)              dhcp.xid:		ds	4		; Our current transaction id
     150:  00:F040  (00:0004)           dhcp.xid_len		equ	$-dhcp.xid
     151:  00:F040                      ping.seq:
     152:  00:F040  00 (2)              dhcp.secs:		ds	2		; Seconds elapsed
     153:  00:F042  (00:0002)           dhcp.secs_len:		equ	$-dhcp.secs
     154:  00:F042  00 (4)              dhcp.packet_xid:	ds	4	; Transaction xid from rx packet
     155:  00:F046                      ;
     156:  00:F046                      ;
     157:  00:F046  00 (4)              ftp.ip:			ds	4
     158:  00:F04A  00 (1)              ftp.socket:		ds	1	; Socket for control session
     159:  00:F04B  00 (2)              ftp.start:		ds	2	; Starts secs fortimeout
     160:  00:F04D  00 (4)              ftp.data_ip:		ds	4	; IP address for data connection
     161:  00:F051  00 (2)              ftp.data_port:		ds	2	; Port #for data connection
     162:  00:F053                      device.host:				; Host name
     163:  00:F053  00 (256)            ftp.buffer:		ds	256	; Buffer for input line
     164:  00:F153  (00:0100)           ftp.buffer_size		equ	$-ftp.buffer
     165:  00:F153  00 (40)             ftp.user:		ds	40
     166:  00:F17B  (00:0028)           ftp.user_size		equ	$-ftp.user
     167:  00:F17B  00 (40)             ftp.pass:		ds	40
     168:  00:F1A3  (00:0028)           ftp.pass_size		equ	$-ftp.pass
     169:  00:F1A3                      ;
     170:  00:F1A3                      ;
     171:  00:F1A3                      ; Per-socket variables, must be on a 256-byte page boundary.
     172:  00:F1A3                      ; See socket.c for access methods
     173:  00:F1A3                      ;
     174:  00:F1A3  FF (93)             			ds	0f200h-$,0ffh
     175:  00:F200                      sockets:				; Per-socket variables
     176:  00:F200                      ;
     177:  00:F200  (00:0020)           socket_size		equ	20h	; Size of each per-socket variable area
     178:  00:F200                      ;
     179:  00:F200  00 (32)             socket0:		ds	socket_size
     180:  00:F220  00 (32)             socket1:		ds	socket_size
     181:  00:F240  00 (32)             socket2:		ds	socket_size
     182:  00:F260  00 (32)             socket3:		ds	socket_size
     183:  00:F280  00 (32)             socket4:		ds	socket_size
     184:  00:F2A0  00 (32)             socket5:		ds	socket_size
     185:  00:F2C0  00 (32)             socket6:		ds	socket_size
     186:  00:F2E0  00 (32)             socket7:		ds	socket_size
     187:  00:F300                      ;
     188:  00:F300                      			ASSERT	socket.vars <= socket_size
     189:  00:F300                      ;
     190:  00:F300                      ;
     191:  00:F300                      ; Packet buffer for tx/rx packets
     192:  00:F300                      ;
     193:  00:F300                      http.packet:
     194:  00:F300                      ping.packet:				; Ping packet overlays DHCP packet!
     195:  00:F300                      dhcp.packet:				; Must not go over 256-byte page!
     196:  00:F300                      ntp.packet:				; NTP packet overlays FTP buffer
     197:  00:F300                      ping.packet.type:
     198:  00:F300                      ntp.packet.livnmode:
     199:  00:F300  00 (1)              dhcp.packet.op:		ds	1	; Message type
     200:  00:F301                      ping.packet.code:
     201:  00:F301                      ntp.packet.stratum:
     202:  00:F301  00 (1)              dhcp.packet.htype:	ds	1	; Hardware address type	
     203:  00:F302                      ping.packet.csum:
     204:  00:F302                      ntp.packet.poll:
     205:  00:F302  00 (1)              dhcp.packet.hlen:	ds	1	; Hardware address length
     206:  00:F303                      ntp.packet.precision:
     207:  00:F303  00 (1)              dhcp.packet.hops:	ds	1
     208:  00:F304                      ping.packet.id:
     209:  00:F304                      ntp.packet.delay:
     210:  00:F304  00 (2)              dhcp.packet.xid:	ds	2	; Transaction id
     211:  00:F306                      ping.packet.seq:
     212:  00:F306  00 (2)              dhcp.packet.xid2:	ds	2	; Transaction id
     213:  00:F308  (00:0008)           ping.packet_size	equ	$-ping.packet
     214:  00:F308                      ntp.packet.dispersion:
     215:  00:F308  00 (2)              dhcp.packet.secs:	ds	2	; Secs elapsed since start of DHCP process
     216:  00:F30A  00 (2)              dhcp.packet.flags:	ds	2
     217:  00:F30C                      ntp.packet.identifier:
     218:  00:F30C  00 (4)              dhcp.packet.ciaddr:	ds	4	; Client IP
     219:  00:F310                      ntp.packet.reference:
     220:  00:F310  00 (4)              dhcp.packet.yiaddr:	ds	4	; Your IP (client's)
     221:  00:F314  00 (4)              dhcp.packet.siaddr:	ds	4	; Next server IP
     222:  00:F318                      ntp.packet.originate:
     223:  00:F318  00 (4)              dhcp.packet.giaddr:	ds	4	; Relay agent IP
     224:  00:F31C  00 (4)              dhcp.packet.chaddr:	ds	4	; Client hardware address (16 bytes)
     225:  00:F320  00 (8)              ntp.packet.receive:	ds	8
     226:  00:F328  00 (4)              ntp.packet.transmit:	ds	4
     227:  00:F32C                      dhcp.packet_end:
     228:  00:F32C  (00:002C)           dhcp.packet_size	equ	$-dhcp.packet
     229:  00:F32C  00 (4)              			ds	4
     230:  00:F330                      ntp.packet_end:
     231:  00:F330  (00:0030)           ntp.packet_size		equ	$-ntp.packet
     232:  00:F330                      ;
     233:  00:F330                      		ASSERT	high $ = high dhcp.packet	; Must fit in a page
     234:  00:F330                      		ASSERT dhcp.packet_size > 32	; Used as a 32 byte buffer!
     235:  00:F330                      ;
     236:  00:F330  00 (208)            			ds	256-($-http.packet)
     237:  00:F400  (00:0100)           http.packet_size	equ	$-http.packet
     238:  00:F400                      ;
     239:  00:F400                      
     240:  00:F400                      ;
     241:  00:F400                      ;
     242:  00:F400  (00:0400)           varsize		equ	$-vars
     243:  00:F400                      ;
     244:  00:F400                      
     245:  00:F400                      		endmodule
      72   00:F400                      ;
      73   00:F400  FF (3072)                           DS 65536-$,255
      74   00!0000                      ;
      75   00!0000                      ;
      76   00!0000                                      END

    LABELS
-------------------------------------------------
00:0000C00D   io
00:0000C00E   mac
00:0000C014   entry
00:0000C02A   cold_reset
00:00000030   version.major
00:00000031   version.minor
00:00000031   version.revision
00:000000B0 X ep.P0
00:000000B1   ep.P1
00:000000B2 X ep.P2
00:000000B3   ep.P3
00:0000C030   command.help
00:0000C03F   command.nothelpnet
00:0000C049   command.help_cmd
00:0000C04D   command.helpout
00:0000C053   command.specific
00:0000C060   command.nethelp
00:0000C06F   command.nethelp.helpnet
00:0000C074   command.command
00:0000C08A   command.jp_cmd
00:0000C08E   jphl
00:0000C08F   command.compare
00:0000C096   command.compare.loop
00:0000C0A1   command.compare.notequal
00:0000C0A4   command.find
00:0000C0A5   command.find.loop
00:0000C0B7   command.find.end
00:0000C0BB   command.find.gotcmd
00:0000C0C8   command.skip
00:0000C0D0   command.skip.skipinc
00:0000C0D6 X command.unspace
00:0000C0D7   command.unspace.loop
00:0000C0E0   command.unspace.setlen
00:0000C0E7   command.unspace.count
00:0000C0F2   command.unspace.ret
00:0000C0F4   command.net
00:0000C107   command.net.badnet
00:0000C10C   command.net.nonet
00:0000C115   command.net_diag
00:0000C125   command.net_start
00:0000C129   command.netstart
00:0000C12E X command.do_dhcp
00:0000C143   command.do_dhcp.chk_stop
00:0000C146   command.do_dhcp.ret
00:0000C14C   command.ftp
00:0000C16C   command.ftp.badcmd
00:0000C171   command.ftp.noftp
00:0000C178 X command.ftp.ret
00:0000C17B   command.ftp_login
00:0000C1A2   command.ftp_login.ret
00:0000C1AD   command.ftp_logout
00:0000C1BA   command.ftp_status
00:0000C1C2   command.ftp_cd
00:0000C1CA   command.ftp_md
00:0000C1D2   command.ftp_rd
00:0000C1DA   command.ftp_del
00:0000C1E2   command.ftp_ren
00:0000C1F3   command.ftp_dir
00:0000C1FB   command.ping
00:0000C224   command.ping.ret
00:0000C227   command.ping.noping
00:0000C230   command.trace
00:0000C243   command.trace.noarg
00:0000C249   command.trace.badcmd
00:0000C24E   command.trace_str_tab
00:0000C256   command.trace_value_tab
00:0000C259   command.on_str
00:0000C25D   command.off_str
00:0000C262   command.raw_str
00:0000C267   command.status
00:0000C277 X command.status.ret
00:0000C27A   command.status.badopt
00:0000C27F   command.status.doit
00:0000C2B4   command.status.loop
00:0000C2D1   command.status.doneowner
00:0000C2E2   command.status.nostr
00:0000C304   command.status.doneone
00:0000C310   command.status.easteregg_str
00:0000C325   command.status.surprise_str
00:0000C328   command.status.mac_str
00:0000C32E   command.status.ip_str
00:0000C333   command.status.subnet_str
00:0000C33C   command.status.gateway_str
00:0000C345   command.status.heading
00:0000C367   command.status.to_str
00:0000C36C   command.time
00:0000C37B   command.time.ret
00:0000C37E   command.main_tab
00:0000C386   command.main_help_tab
00:0000C38C   command.main_cmd_tab
00:0000C392   command.net_tab
00:0000C3A4   command.net_help_tab
00:0000C3B4   command.net_cmd_tab
00:0000C3C4   command.ftp_tab
00:0000C3E2   command.ftp_cmd_tab
00:0000C3FE   command.login_str
00:0000C404   command.logout_str
00:0000C40B   command.dir_str
00:0000C40F   command.cd_str
00:0000C412   command.del_str
00:0000C416   command.era_str
00:0000C41A   command.erase_str
00:0000C420   command.ren_str
00:0000C424   command.rename_str
00:0000C42B   command.md_str
00:0000C42E   command.mkdir_str
00:0000C434   command.rd_str
00:0000C437   command.rmdir_str
00:0000C43D   command.version_str
00:0000C452   command.help_help_str
00:0000C452   command.net_help_str
00:0000C58A   command.diag_help_str
00:0000C5CB   command.start_help_str
00:0000C614   command.ftp_help_str
00:0000C7FA   command.ping_help_str
00:0000C846   command.trace_help_str
00:0000C8F3   command.status_help_str
00:0000C91E   command.time_help_str
00:0000C965   command.net_str
00:00000003   command.net_str_len
00:0000C969   command.ftp_str
00:0000C96D   command.diag_str
00:0000C972   command.start_str
00:0000C978   command.ping_str
00:0000C97D   command.trace_str
00:0000C983   command.status_str
00:0000C98A   command.time_str
00:0000C98F   command.help_str
00:0000BFFF X exos.USR_P3
00:0000BFFE X exos.USR_P2
00:0000BFFD X exos.USR_P1
00:0000BFFC   exos.USR_P0
00:0000BFFA X exos.STACK_LIMIT
00:0000BFF8 X exos.RST_ADDR
00:0000BFF6   exos.ST_POINTER
00:0000BFF4 X exos.LP_POINTER
00:0000BFF3 X exos.PORTB5
00:0000BFF2   exos.FLAG_SOFT_IRQ
00:0000BFF0 X exos.SEC_COUNTER
00:0000BFEE X exos.CR_DISP
00:0000BFED X exos.USER_ISR
00:00000000 X exos.FN_RESET
00:00000001 X exos.FN_OPEN
00:00000002 X exos.FN_CREATE
00:00000003 X exos.FN_CLOSE
00:00000004 X exos.FN_DEST
00:00000005   exos.FN_RDCH
00:00000006 X exos.FN_RDBLK
00:00000007   exos.FN_WRCH
00:00000008   exos.FN_WRBLK
00:00000009 X exos.FN_RSTAT
00:0000000A X exos.FN_SSTAT
00:0000000B   exos.FN_SFUNC
00:00000010   exos.FN_EVAR
00:00000011 X exos.FN_CAPT
00:00000012 X exos.FN_REDIR
00:00000013 X exos.FN_DDEV
00:00000014 X exos.FN_SYSS
00:00000015 X exos.FN_LINK
00:00000016 X exos.FN_READB
00:00000017 X exos.FN_SETB
00:00000018 X exos.FN_ALLOC
00:00000019 X exos.FN_FREE
00:0000001A X exos.FN_ROMS
00:0000001B   exos.FN_BUFF
00:0000001C X exos.FN_ERRMSG
00:0000001D X exos.FN_LD
00:0000001E X exos.FN_REL
00:0000001F X exos.FN_STIME
00:00000020 X exos.FN_RTIME
00:00000021 X exos.FN_SDATE
00:00000022 X exos.FN_RDATE
00:000000FF X exos.ERR_IFUNC
00:000000FE X exos.ERR_ILLFN
00:000000FD X exos.ERR_INAME
00:000000FC X exos.ERR_STACK
00:000000FB X exos.ERR_ICHAN
00:000000FA X exos.ERR_NODEV
00:000000F9 X exos.ERR_CHANX
00:000000F8 X exos.ERR_NOBUF
00:000000F7 X exos.ERR_NORAM
00:000000F6 X exos.ERR_NOVID
00:000000F5 X exos.ERR_NOSEG
00:000000F4 X exos.ERR_ISEG
00:000000F3 X exos.ERR_IBOUN
00:000000F2 X exos.ERR_IVAR
00:000000F1 X exos.ERR_IDESC
00:000000F0 X exos.ERR_NOSTR
00:000000EF X exos.ERR_ASCII
00:000000EE X exos.ERR_ITYPE
00:000000ED X exos.ERR_IREL
00:000000EC X exos.ERR_NOMOD
00:000000EB X exos.ERR_ITIME
00:000000EA X exos.ERR_ISPEC
00:000000E9 X exos.ERR_CH2ND
00:000000E8 X exos.ERR_IUNIT
00:000000E7   exos.ERR_NOFN
00:000000E6 X exos.ERR_ESC
00:000000E5   exos.ERR_STOP
00:000000E4   exos.ERR_EOF
00:000000E3 X exos.ERR_PROT
00:000000E2 X exos.ERR_KFSPC
00:000000E1 X exos.ERR_SENV
00:000000E0 X exos.ERR_SENBF
00:000000DF X exos.ERR_SQFUL
00:000000DE X exos.ERR_VSIZE
00:000000DD X exos.ERR_VMODE
00:000000DC X exos.ERR_VDISP
00:000000DB X exos.ERR_VLOAD
00:000000DA X exos.ERR_VROW
00:000000D9 X exos.ERR_VCURS
00:000000D8 X exos.ERR_VBEAM
00:000000D7 X exos.ERR_SEROP
00:000000D6 X exos.ERR_NOADR
00:000000D5 X exos.ERR_NETOP
00:000000D4 X exos.ERR_EVID
00:000000D3 X exos.ERR_EKEY
00:000000D2 X exos.ERR_EDINV
00:000000D1 X exos.ERR_EDBUF
00:000000D0 X exos.ERR_CCRC
00:0000006F   exos.ERR_LAST
00:0000006F   exos.ERR_DHCP
00:0000006E   exos.ERR_NONET
00:0000006D   exos.ERR_BADIP
00:0000006C   exos.ERR_BADOPT
00:0000006B   exos.ERR_NOCON
00:0000006A   exos.ERR_TIMEOUT
00:00000069   exos.ERR_FTP
00:00000068   exos.ERR_NOFIL
00:00000067   exos.ERR_NOTIME
00:00000066   exos.ERR_DUPIP
00:00000065   exos.ERR_FTPDATA
00:00000064   exos.ERR_BADHTTP
00:00000064   exos.ERR_FIRST
00:0000007F X exos.ERR_SHARE
00:00000000 X exos.VAR_IRQ_ENABLE
00:00000001 X exos.VAR_FLAG_SIRQ
00:00000002 X exos.VAR_CODE_SIRQ
00:00000003 X exos.VAR_DEF_TYPE
00:00000004 X exos.VAR_DEF_CHAN
00:00000005 X exos.VAR_TIMER
00:00000006 X exos.VAR_LOCK_KEY
00:00000007 X exos.VAR_CLICK_KEY
00:00000008 X exos.VAR_STOP_IRQ
00:00000009 X exos.VAR_KEY_IRQ
00:0000000A X exos.VAR_RATE_KEY
00:0000000B X exos.VAR_DELAY_KEY
00:0000000C X exos.VAR_TAPE_SND
00:0000000D X exos.VAR_WAIT_SND
00:0000000E X exos.VAR_MUTE_SND
00:0000000F X exos.VAR_BUF_SND
00:00000010 X exos.VAR_BAUD_SER
00:00000011 X exos.VAR_FORM_SER
00:00000012 X exos.VAR_ADDR_NET
00:00000013 X exos.VAR_NET_IRQ
00:00000014 X exos.VAR_CHAN_NET
00:00000015 X exos.VAR_MACH_NET
00:00000016 X exos.VAR_MODE_VID
00:00000017 X exos.VAR_COLR_VID
00:00000018 X exos.VAR_X_SIZ_VID
00:00000019 X exos.VAR_Y_SIZ_VID
00:0000001A X exos.VAR_ST_FLAG
00:0000001B X exos.VAR_BORD_VID
00:0000001C X exos.VAR_BIAS_VID
00:0000001D X exos.VAR_VID_EDIT
00:0000001E X exos.VAR_KEY_EDIT
00:0000001F X exos.VAR_BUF_EDIT
00:00000020   exos.VAR_FLG_EDIT
00:00000021 X exos.VAR_SP_TAPE
00:00000022 X exos.VAR_PROTECT
00:00000023 X exos.VAR_LV_TAPE
00:00000024 X exos.VAR_REM1
00:00000025 X exos.VAR_REM2
00:00000026 X exos.VAR_SPRITE
00:00000027 X exos.VAR_RANDOM
00:00000010 X exos.INT_FKEY
00:00000020 X exos.INT_STOP
00:00000021 X exos.INT_KEY
00:00000030 X exos.INT_NET
00:00000040 X exos.INT_TIME
00:00000001 X exos.FN_VID_DISP
00:00000002   exos.FN_VID_SIZE
00:00000003 X exos.FN_VID_ADDR
00:00000004 X exos.FN_VID_FONT
00:00000008 X exos.FN_KEY_FKEY
00:00000009 X exos.FN_KEY_JOY
00:00000010 X exos.FN_NET_FLSH
00:00000011 X exos.FN_NET_CLR
00:00000018 X exos.FN_ED_MARG
00:00000019 X exos.FN_ED_CHLD
00:0000001A X exos.FN_ED_CHSV
00:00000000 X exos.ACT_NULL
00:00000001 X exos.ACT_COLD
00:00000002 X exos.ACT_STR
00:00000003 X exos.ACT_HELP
00:00000004 X exos.ACT_EVAR
00:00000005 X exos.ACT_ERR
00:00000006 X exos.ACT_LOAD
00:00000007 X exos.ACT_RAM
00:00000008 X exos.ACT_INIT
00:00000000 X exos.MOD_ASCII
00:00000001 X exos.MOD_4TH
00:00000002 X exos.MOD_REL
00:00000003 X exos.MOD_XBAS
00:00000004 X exos.MOD_BAS
00:00000005 X exos.MOD_APP
00:00000006 X exos.MOD_XABS
00:00000007 X exos.MOD_XREL
00:00000008 X exos.MOD_EDIT
00:00000009 X exos.MOD_LISP
00:0000000A X exos.MOD_EOF
00:0000000B X exos.MOD_VID
00:0000C994   exos.is_stop
00:0000C99F   exos.is_stop.scfret
00:0000C9A2   exos.check_stop
00:0000C9AB   exos.explain
00:0000C9C3   exos.messages
00:0000C9DB   exos.DHCP_str
00:00000023   exos.DHCP_str_len
00:0000C9FF   exos.NONET_str
00:0000001D   exos.NONET_str_len
00:0000CA1D   exos.BADIP_str
00:00000012   exos.BADIP_str_len
00:0000CA30   exos.BADOPT_str
00:0000000E   exos.BADOPT_str_len
00:0000CA3F   exos.NOCON_str
00:0000000E   exos.NOCON_str_len
00:0000CA4E   exos.TIMEOUT_str
00:00000017   exos.TIMEOUT_str_len
00:0000CA66   exos.FTP_str
00:00000014   exos.FTP_str_len
00:0000CA7B   exos.NOFIL_str
00:0000001F   exos.NOFIL_str_len
00:0000CA9B   exos.NOTIME_str
00:0000001F   exos.NOTIME_str_len
00:0000CABB   exos.DUPIP_str
00:0000001F   exos.DUPIP_str_len
00:0000CADB   exos.FTPDATA_str
00:0000001C   exos.FTPDATA_str_len
00:0000CAF8   exos.BADHTTP_str
00:00000018   exos.BADHTTP_str_len
00:00000000   device.channel.socket
00:00000001   device.channel
00:0000CB15   device.ftp_type
00:0000CB20   device.devices
00:0000CB20 X device.ftp_descriptor
00:0000CB21   device.ftp_entry
00:0000CB3D   device.ftp_interrupt
00:0000CB50   device.ftp_interrupt.doneticks
00:0000CB53   device.ftp_open
00:0000CB60   device.ftp_create
00:0000CB6D   device.ftp_close
00:0000CB72   device.ftp_read_byte
00:0000CB77   device.ftp_read_block
00:0000CB7C   device.ftp_write_byte
00:0000CB81   device.ftp_write_block
00:0000CB86   device.ftp_read_status
00:0000CB8F   device.tcp_type
00:0000CB9A   device.tcp_descriptor
00:0000CB9B   device.tcp_entry
00:00000002   device.TCP_SOCKET
00:0000CBB7   device.tcp_open
00:0000CBEC   device.tcp_open.ret
00:0000CBEF   device.tcp_create
00:0000CC00   device.http_type
00:0000CC0C   device.http_descriptor
00:0000CC0D   device.http_entry
00:0000CC29   device.http_open
00:0000CC3B   device.http_open.slash.loop
00:0000CC48   device.http_open.slash.done
00:0000CC50   device.http_open.host.loop
00:0000CC5C   device.http_open.host.djnz
00:0000CC5E   device.http_open.host.done
00:0000CC70   device.http_open.ret
00:0000CC73 X device.http_create
00:0000CC76   device.block
00:0000CC79   device.block.loop
00:0000CC94   device.block.bcok
00:0000CCBC   device.block.skipjphl
00:0000CCC9   device.block.ret
00:0000CCCF   device.read_byte
00:0000CCE9   device.read_block
00:0000CCF8   device.read_ret
00:0000CD0B   device.write_byte
00:0000CD2A   device.write_block
00:0000CD3F   device.writeret
00:0000CD4B   device.read_status
00:0000CD5C   device.write_status
00:0000CD5C   device.nofn
00:0000CD5F   device.special
00:0000CD62   device.init
00:0000CD67   device.moved
00:0000CD67   device.interrupt
00:0000CD68   device.close
00:0000CD7E   device.tcp_owner_str
00:0000000D   CR
00:0000000A   LF
00:0000CD82   io.mac
00:0000CD84   io.mac.loop
00:0000CD8C   io.ip
00:0000CD95   io.ip.dotnum
00:0000CD9A   io.ip.num
00:0000CDA2   io.ip_port
00:0000CDAE   io.short
00:0000CDB1   io.int
00:0000CDD0   io.int.divout
00:0000CDDA   io.int.out
00:0000CDDE   io.int.div16
00:0000CDE1   io.int.loop
00:0000CDE8   io.word
00:0000CDED   io.byte
00:0000CDF6   io.nib
00:0000CE00   io.nib.nothex
00:0000CE00   io.char
00:0000CE0D   io.char.col0
00:0000CE11   io.char.notcol0
00:0000CE1D   io.ipcrlf
00:0000CE23   io.start
00:0000CE28   io.crlf
00:0000CE31   io.space
00:0000CE35   io.tab
00:0000CE39   io.line
00:0000CE3D   io.str
00:0000CE3F   io._str
00:0000CE47   io._str.col0
00:0000CE4B   io._str.loop
00:0000CE4E   io._str.start
00:0000CE60   io._str.end
00:0000CE6A   io.cols
00:0000CE6C   io.cols.loop
00:0000CE79   io.cols.next
00:0000CE7E   io.input
00:0000CE8E   io.input.loop
00:0000CE9C X io.input.notcr
00:0000CEA6   io.input.end
00:00000027   status.STATUS_POS
00:0000001F   status.STATUS_BLOB_L
00:0000000E   status.STATUS_BLOB_S
00:00000010   status.DELAY
00:0000CEA9   status.stop
00:0000CEB5   status.start
00:0000CECA   status.waiting
00:0000CED5   status.blob
00:0000CEE2   status.blob_char
00:0000CEE9   status.activity
00:0000CEF1   status.inactivity
00:0000CEF8   util.copystr
00:0000CF00   util.copyarg
00:0000CF08   util.copyarg.loop
00:0000CF12   util.copyarg.ret
00:0000CF15   util.strlen
00:0000CF19   util.strlen.loop
00:0000CF21   util.varszero
00:0000CF27   util.memzero
00:0000CF28 X util.memset
00:0000CF32   util.ipcmp
00:0000CF34   util.memcmp
00:0000CF3C   util.upper
00:0000CF45   util.get_ip_port
00:0000CF60   util._get_port
00:0000CF63   util._get_port.loop
00:0000CF78   util.get_ip
00:0000CF82   util._get_ip
00:0000CF92   util.get_num8_dot
00:0000CFA2   util.get_num8
00:0000CFA8   util.get_num8.loop
00:0000CFBC   util.get_dig
00:0000CFBD   util.isdig
00:0000CFC4   util.get_num16
00:0000CFCB   util.get_num16.loop
00:0000CFDD   trace.diag.ok
00:0000CFE2   trace.diag.err
00:0000CFE7   trace.diag.dots
00:0000CFEC   trace.diag.startstr
00:0000CFEF   trace.diag.str
00:0000CFF7   trace.diag.start
00:0000D001 X trace.diag.crlf
00:0000D008   trace.diag.char
00:0000D010   trace.diag.byte
00:0000D018   trace.diag.word
00:0000D020   trace.diag.mac
00:0000D028   trace.diag.ip
00:0000D030   trace.bytes
00:0000D03C   trace.dots
00:0000D042   trace.is_timeout
00:0000D044   trace.is_error
00:0000D046   trace.ok
00:0000D04E   trace.timeout
00:0000D053   trace.error
00:0000D056   trace.err
00:0000D05E   trace.err.notstop
00:0000D063   trace.dumpbytes
00:0000D063   trace.dumpbytes.loop
00:0000D073   trace.dumpchars
00:0000D073   trace.dumpchars.loop
00:0000D081   trace.dumpchars.dot
00:0000D083   trace.dumpchars.ascii
00:0000D08D   trace.set_cols
00:0000D098   trace.diag.reset
00:0000D0AF   trace.diag.id
00:0000D0B8   trace.diag.writemac
00:0000D0C9   trace.diag.writeip
00:0000D0D9   trace.diag.subnet
00:0000D0EA   trace.diag.gateway
00:0000D0FF   trace.diag.errmsg
00:0000D10A   trace.diag.memory
00:0000D11D   trace.diag.memerr
00:0000D123   trace.diag.expected
00:0000D12E   trace.diag.at
00:0000D133   trace.diag.timeout
00:0000D141   trace.diag.dhcp
00:0000D163   trace.diag.ntp
00:0000D183   trace.socket.connect
00:0000D18F   trace.socket.disconnect
00:0000D19D   trace.socket.close
00:0000D1A6   trace.socket.open
00:0000D1AC   trace.socket.udp
00:0000D1B0   trace.socket.ipraw
00:0000D1B3   trace.socket.tcp
00:0000D1B7   trace.socket.unknown
00:0000D1BB   trace.socket.port
00:0000D1C2   trace.socket.by
00:0000D1C7   trace.udp.rx
00:0000D1D4   trace.udp.tx
00:0000D1DF X trace.udp.errmsg
00:0000D1EB   trace.tcp.rx
00:0000D1F2   trace.tcp.tx
00:0000D1F9   trace.ipraw.rx
00:0000D208   trace.ipraw.tx
00:0000D215   trace.dhcp.start
00:0000D223   trace.dhcp.discover
00:0000D235   trace.dhcp.request
00:0000D246   trace.dhcp.rx
00:0000D24F   trace.dhcp.gotip
00:0000D254   trace.dhcp.gotsubnet
00:0000D25D   trace.dhcp.gotgateway
00:0000D267   trace.dhcp.gotserver
00:0000D270   trace.dhcp.gotlease
00:0000D278   trace.dhcp.gotdns
00:0000D27E   trace.dhcp.gotntp
00:0000D284   trace.dhcp.offer
00:0000D28B   trace.dhcp.decline
00:0000D294   trace.dhcp.ack
00:0000D299   trace.dhcp.nak
00:0000D29E   trace.dhcp.type
00:0000D2A9   trace.dhcp.end
00:0000D2B9 X trace.dhcp.errmsg
00:0000D2C4   trace.dhcp.small
00:0000D2CE   trace.dhcp.port
00:0000D2D7   trace.dhcp.op
00:0000D2DE   trace.dhcp.addr
00:0000D2E7   trace.dhcp.xid
00:0000D2EF   trace.dhcp.cookie
00:0000D2FA   trace.dhcp.eop
00:0000D305   trace.ping.pinging
00:0000D30E   trace.ntp.tx
00:0000D321   trace.ntp.rx
00:0000D32B   trace.http.open
00:0000D337   trace.http.tx
00:0000D33B   trace.http.rx
00:0000D33F   trace.http.code
00:0000D345   trace.http.size
00:0000D34B   trace.ftp.open
00:0000D357   trace.ftp.login
00:0000D360   trace.ftp.tx
00:0000D364   trace.ftp.rx
00:0000D368 X trace.ftp.close
00:0000D36E   trace.ftp.pasv
00:0000D374   trace.ftp.code
00:0000D37A X trace.ftp.error_str
00:0000D384   trace.ok_str
00:0000D389   trace.timeout_str
00:0000D393   trace.error_str
00:0000D39B   trace.stop_str
00:0000D3A2   trace.dots_str
00:0000D3A6   trace.bytes_str
00:00000000 X w5300.MR0
00:00000001 X w5300.MR1
00:00000020   w5300.MR0_WDF2
00:00000010   w5300.MR0_WDF1
00:00000008   w5300.MR0_WDF0
00:00000080   w5300.MR1_RST
00:00000020   w5300.MR1_MT
00:00000001   w5300.MR1_IND
00:00000002 X w5300.IDM_AR0
00:00000003 X w5300.IDM_AR1
00:00000004 X w5300.IDM_DR0
00:00000005 X w5300.IDM_DR1
00:00000002   w5300.IR
00:00000002   w5300.IR0
00:00000003 X w5300.IR1
00:00000004   w5300.IMR
00:00000004 X w5300.IMR0
00:00000005 X w5300.IMR1
00:00000008   w5300.SHAR
00:00000008 X w5300.SHAR0
00:00000009 X w5300.SHAR1
00:0000000A X w5300.SHAR2
00:0000000B X w5300.SHAR3
00:0000000C X w5300.SHAR4
00:0000000D X w5300.SHAR5
00:00000010   w5300.GAR
00:00000010 X w5300.GAR0
00:00000011 X w5300.GAR1
00:00000012 X w5300.GAR2
00:00000013 X w5300.GAR3
00:00000014   w5300.SUBR
00:00000014 X w5300.SUBR0
00:00000015 X w5300.SUBR1
00:00000016 X w5300.SUBR2
00:00000017 X w5300.SUBR3
00:00000018   w5300.SIPR
00:00000018 X w5300.SIPR0
00:00000019 X w5300.SIPR1
00:0000001A X w5300.SIPR2
00:0000001B X w5300.SIPR3
00:0000001C   w5300.RTR
00:0000001C X w5300.RTR0
00:0000001D X w5300.RTR1
00:0000001F X w5300.RCR1
00:00000020   w5300.TMS01R
00:00000020 X w5300.TMSR0
00:00000021 X w5300.TMSR1
00:00000022   w5300.TMS23R
00:00000022 X w5300.TMSR2
00:00000023 X w5300.TMSR3
00:00000024   w5300.TMS45R
00:00000024 X w5300.TMSR4
00:00000025 X w5300.TMSR5
00:00000026   w5300.TMS67R
00:00000026 X w5300.TMSR6
00:00000027 X w5300.TMSR7
00:00000028   w5300.RMS01R
00:00000028 X w5300.RMSR0
00:00000029 X w5300.RMSR1
00:0000002A   w5300.RMS23R
00:0000002A X w5300.RMSR2
00:0000002B X w5300.RMSR3
00:0000002C   w5300.RMS45R
00:0000002C X w5300.RMSR4
00:0000002D X w5300.RMSR5
00:0000002E   w5300.RMS67R
00:0000002E X w5300.RMSR6
00:0000002F X w5300.RMSR7
00:00000030   w5300.MTYPER
00:00000030 X w5300.MTYPER0
00:00000031 X w5300.MTYPER1
00:00000032 X w5300.PATR0
00:00000033 X w5300.PATR1
00:00000037 X w5300.PTIMER1
00:00000038 X w5300.PMAGICR0
00:00000039 X w5300.PMAGICR1
00:0000003C X w5300.PSIDR0
00:0000003D X w5300.PSIDR1
00:00000040 X w5300.PDHAR0
00:00000041 X w5300.PHARD1
00:00000042 X w5300.PHARD2
00:00000043 X w5300.PHARD3
00:00000044 X w5300.PHARD4
00:00000045 X w5300.PHARD5
00:00000048 X w5300.UIPR0
00:00000049 X w5300.UIPR1
00:0000004A X w5300.UIPR2
00:0000004B X w5300.UIPR3
00:0000004C X w5300.UPORTR0
00:0000004D X w5300.UPORTR1
00:0000004E X w5300.FMTUR0
00:0000004F X w5300.FMTUR1
00:00000061 X w5300.P0_BRDYR1
00:00000062 X w5300.P0_BDPTHR0
00:00000063 X w5300.P0_BDPTHR1
00:00000065 X w5300.P1_BRDYR1
00:00000066 X w5300.P1_BDPTHR0
00:00000067 X w5300.P1_BDPTHR1
00:00000069 X w5300.P2_BRDYR1
00:0000006A X w5300.P2_BDPTHR0
00:0000006B X w5300.P2_BDPTHR1
00:0000006D X w5300.P3_BRDYR1
00:0000006E X w5300.P3_BDPTHR0
00:0000006F X w5300.P3_BDPTHR1
00:000000FE   w5300.IDR
00:000000FE X w5300.IDR0
00:000000FF X w5300.IDR1
00:00000200   w5300.SOCKETS
00:00000200   w5300.SOCKET0
00:00000240   w5300.SOCKET1
00:00000280   w5300.SOCKET2
00:000002C0   w5300.SOCKET3
00:00000300   w5300.SOCKET4
00:00000340   w5300.SOCKET5
00:00000380   w5300.SOCKET6
00:000003C0 X w5300.SOCKET7
00:00000000   w5300.Sn_MR
00:00000000 X w5300.Sn_MR0
00:00000001 X w5300.Sn_MR1
00:00000000 X w5300.Sn_MR_CLOSED
00:00000001   w5300.Sn_MR_TCP
00:00000002   w5300.Sn_MR_UDP
00:00000003   w5300.Sn_MR_IPRAW
00:00000004 X w5300.Sn_MR_MACRAW
00:00000005 X w5300.Sn_MR_PPPoE
00:00000020   w5300.Sn_MR_ND
00:00000002   w5300.Sn_CR
00:00000002 X w5300.Sn_CR0
00:00000003 X w5300.Sn_CR1
00:00000001   w5300.Sn_CR_OPEN
00:00000002 X w5300.Sn_CR_LISTEN
00:00000004   w5300.Sn_CR_CONNECT
00:00000008   w5300.Sn_CR_DISCON
00:00000010   w5300.Sn_CR_CLOSE
00:00000020   w5300.Sn_CR_SEND
00:00000021 X w5300.Sn_CR_SEND_MAC
00:00000022 X w5300.Sn_CR_SEND_KEEP
00:00000040   w5300.Sn_CR_RECV
00:00000004   w5300.Sn_IMR
00:00000004 X w5300.Sn_IMR0
00:00000005 X w5300.Sn_IMR1
00:00000006   w5300.Sn_IR
00:00000007 X w5300.Sn_IR1
00:00000080 X w5300.Sn_IR_PRECV
00:00000040 X w5300.Sn_IR_PFAIL
00:00000020 X w5300.Sn_IR_PNEXT
00:00000010   w5300.Sn_IR_SENDOK
00:00000008   w5300.Sn_IR_TIMEOUT
00:00000004 X w5300.Sn_IR_RECV
00:00000002 X w5300.Sn_IR_DISCON
00:00000001 X w5300.Sn_IR_CON
00:00000008   w5300.Sn_SSR
00:00000009 X w5300.Sn_SSR1
00:00000000   w5300.Sn_SSR_CLOSED
00:00000013   w5300.Sn_SSR_INIT
00:00000014   w5300.Sn_SSR_LISTEN
00:00000017   w5300.Sn_SSR_ESTAB
00:0000001C   w5300.Sn_SSR_WAIT
00:00000022   w5300.Sn_SSR_UDP
00:00000032   w5300.Sn_SSR_IPRAW
00:00000042   w5300.Sn_SSR_MACRAW
00:0000005F   w5300.Sn_SSR_PPPoE
00:00000015   w5300.Sn_SSR_SYNSENT
00:00000016   w5300.Sn_SSR_SYNRECV
00:00000018   w5300.Sn_SSR_FIN_WAIT
00:0000001B   w5300.Sn_SSR_TIME_WAIT
00:0000001D   w5300.Sn_SSR_LAST_ACK
00:00000001   w5300.Sn_SSR_ARP
00:0000000A   w5300.Sn_PORTR
00:0000000C X w5300.Sn_DHAR
00:00000012   w5300.Sn_DPORTR
00:00000014   w5300.Sn_DIPR
00:00000016   w5300.Sn_DIPR2
00:00000018 X w5300.Sn_MSSR
00:0000001A   w5300.Sn_PORTOR
00:0000001C X w5300.Sn_TOSR
00:0000001E X w5300.Sn_TTLR
00:00000020   w5300.Sn_TX_WRSR
00:00000022   w5300.Sn_TX_WRSR2
00:00000024 X w5300.Sn_TX_FSR
00:00000026   w5300.Sn_TX_FSR2
00:00000028 X w5300.Sn_RX_RSR
00:0000002A   w5300.Sn_RX_RSR2
00:0000002C X w5300.Sn_FRAGR
00:0000002E   w5300.Sn_TX_FIFOR
00:00000030   w5300.Sn_RX_FIFOR
00:00000008   wiz.SOCKETS
00:0000D3AD   wiz.read_reg
00:0000D3BC   wiz.write_reg
00:0000D3CB   wiz.write_IP
00:0000D3CF   wiz.write_MAC
00:0000D3D1   wiz.writeloop
00:0000D3E4   wiz.read_IP
00:0000D3E8   wiz.read_MAC
00:0000D3EA   wiz.readloop
00:0000D3FD   wiz.init_mem
00:0000D409   wiz.init_mem.write_x4
00:0000D40C   wiz.init_mem.write_x2
00:0000D40F   wiz.init_mem.write_x1
00:0000D415   wiz.init
00:0000D42E   wiz.init.gotio
00:0000D471   wiz.init.badid
00:0000D474   wiz.diagerr
00:0000D479   wiz.diagtimeout
00:0000D481   wiz.idok
00:0000D4C3   wiz.idok.wloop
00:0000D4DA   wiz.idok.rloop
00:0000D513   wiz.idok.rok
00:0000D51C   wiz.idok.finish
00:0000D561   wiz.idok.macloop
00:0000D56E   wiz.idok.badmac
00:0000D577   wiz.idok.macok
00:0000D57C   wiz.check_ip
00:0000D588   wiz.delay
00:0000D58D   wiz.delay.loopstart
00:0000D596   wiz.delay.loopend
00:0000D59F   wiz.wait_SSR
00:0000D5A1   wiz.wait_SSR.wait_CR
00:0000D5B3   wiz.wait_SSR.done_CR
00:0000D5B5   wiz.wait_SSR.wait_SSR
00:0000D5C6   wiz.get_MAC
00:0000D5D2   wiz.set_ip
00:0000D5DD   wiz.get_ip
00:0000D5E0   wiz.getip
00:0000D5E9   wiz.set_subnet
00:0000D5F4   wiz.get_subnet
00:0000D5F9   wiz.set_gateway
00:0000D602   wiz.setip
00:0000D61E   wiz.setip.loop
00:0000D62B   wiz.setip.badip
00:0000D634   wiz.get_gateway
00:00000000   socket.vars.owner
00:00000002   socket.vars.tcp_connected
00:00000003   socket.vars.rx_size
00:00000005   socket.vars.rx_inhand
00:00000007   socket.vars.tx_size
00:00000009   socket.vars.tx_inhand
00:0000000B   socket.vars.DPORTR
00:0000000D   socket.vars
00:0000D639   socket.read_reg
00:0000D649   socket.write_reg
00:0000D659   socket._read_FIFO
00:0000D66F   socket._read_FIFO.loop
00:0000D67E   socket._write_FIFO
00:0000D694   socket._write_FIFO.loop
00:0000D6A3 X socket.read_header_0
00:0000D6A6   socket.read_header
00:0000D6B0 X socket.read_FIFO_0
00:0000D6B3   socket.read_FIFO
00:0000D6BB   socket.rd_FIFO
00:0000D6C6   socket.dump
00:0000D6FF   socket.dump.gotcols
00:0000D709   socket.dump.ge
00:0000D71C   socket.dump.stop
00:0000D72E   socket.dump.done
00:0000D732   socket.write_FIFO
00:0000D741   socket.tomask
00:0000D748   socket.masktab
00:0000D750   socket.open
00:0000D781   socket.open.protocol
00:0000D79F   socket.open.tracedone
00:0000D7E8   socket.open.ok
00:0000D7F0   socket.connect
00:0000D80C   socket.connect.tracedone
00:0000D81F   socket.connect.error
00:0000D82A X socket.disconnect
00:0000D836   socket._disconnect
00:0000D847   socket._disconnect.donetrace
00:0000D84F X socket._disconnect.donedisc
00:0000D857   socket.write_CR
00:0000D85E   socket.write_CR.loop
00:0000D875   socket.available_0
00:0000D876   socket.available
00:0000D882   socket._available
00:0000D88A   socket.is_closed
00:0000D896   socket._is_closed
00:0000D8AB   socket.read_0
00:0000D8AC   socket.read
00:0000D8B8   socket._read
00:0000D8DD   socket._read.donesize
00:0000D8DF   socket.read_byte_0
00:0000D8E0 X socket.read_byte
00:0000D901   socket.read_byte.notgot
00:0000D923   socket.read_byte.got1
00:0000D924   socket.read_byte.okret
00:0000D925   socket.read_byte.ret
00:0000D928   socket.read_flush_0
00:0000D929 X socket.read_flush
00:0000D935   socket._read_flush
00:0000D941   socket._read_flush.loop
00:0000D953   socket._read_flush.sizeok
00:0000D95F   socket._read_flush.done
00:0000D973   socket.read_end_0
00:0000D974   socket.read_end
00:0000D980   socket._read_end
00:0000D983   socket._send_end
00:0000D98B   socket.write_0
00:0000D98C   socket.write
00:0000D998 X socket._write
00:0000D9A1 X socket._write.bigenough
00:0000D9A9   socket.add_tx_size
00:0000D9BC X socket.write_DIPR_0
00:0000D9BD   socket.write_DIPR
00:0000D9D4   socket.write_DIPR.doone
00:0000D9DC   socket.write_DPORTR
00:0000D9E8   socket.read_DIPR
00:0000D9FB   socket.read_DIPR.doone
00:0000DA07   socket.read_DPORTR
00:0000DA0C   socket.read_FSR
00:0000DA14   socket._send
00:0000DA2E   socket._send.loop
00:0000DA4D   socket._send.timeout
00:0000DA53   socket._send.sendok
00:0000DA57   socket._send.ret
00:0000DA66   socket._send.end
00:0000DA71   socket.close_0
00:0000DA72   socket.close
00:0000DAB6   socket.status
00:0000DAC7   socket.status_str
00:0000DAE2   socket.status_str.val_tab
00:0000000F   socket.status_str.val_tab_num
00:0000DAF1   socket.status_str.str_tab
00:0000DB0F   socket.status_str.str_CLOSED
00:0000DB16   socket.status_str.str_INIT
00:0000DB23   socket.status_str.str_LISTEN
00:0000DB2D   socket.status_str.str_ESTAB
00:0000DB37   socket.status_str.str_WAIT
00:0000DB3F   socket.status_str.str_UDP
00:0000DB43   socket.status_str.str_IPRAW
00:0000DB4A   socket.status_str.str_MACRAW
00:0000DB52   socket.status_str.str_PPPoE
00:0000DB58   socket.status_str.str_SYNSENT
00:0000DB61   socket.status_str.str_SYNRECV
00:0000DB6E   socket.status_str.str_FIN_WAIT
00:0000DB77   socket.status_str.str_TIME_WAIT
00:0000DB81   socket.status_str.str_LAST_ACK
00:0000DB8A   socket.status_str.str_ARP
00:0000DB96   socket.byteswapword
00:0000DB9F   socket.set_word
00:0000DBB1   socket.get_rx_size
00:0000DBBF   socket.get_word
00:0000DBCD   socket.get_owner
00:0000DBDD   socket.trace_msg
00:0000DBE5   socket.trace
00:0000DBF1   socket._trace
00:0000DC09   ipraw.open_0
00:0000DC0A X ipraw.open
00:0000DC10   ipraw.header_0
00:0000DC11 X ipraw.header
00:0000DC4F   ipraw.header.ret
00:0000DC55   ipraw.send_0
00:0000DC56 X ipraw.send
00:0000DC89   ipraw.send.notrace
00:0000DC8F   udp.open_0
00:0000DC90 X udp.open
00:0000DC96   udp.header_0
00:0000DC97 X udp.header
00:0000DC9B X udp.header.gotdata
00:0000DCD9   udp.header.ret
00:0000DCDF   udp.send_0
00:0000DCE0 X udp.send
00:0000DD14   udp.send.notrace
00:0000DD23   tcp.open
00:0000DD29   tcp.header
00:0000DD35   tcp._header
00:0000DD69   tcp._header.ret
00:0000DD6F   tcp.read_block
00:0000DD7C   tcp.read_block.loop
00:0000DD92   tcp.read_block.putbyte
00:0000DD97   tcp.read_block.no_inhand
00:0000DDB1   tcp.read_block.wait
00:0000DDDD   tcp.read_block.ret
00:0000DDE1   tcp.read_block.got_packet
00:0000DE00   tcp.read_block.all
00:0000DE1E   tcp.read_block.odd
00:0000DE45   tcp.write_block
00:0000DE76   tcp.write_block.nobuf
00:0000DE9C   tcp._write_block
00:0000DE9E   tcp._write_block.loop
00:0000DEAD   tcp._write_block.donesend
00:0000DEBB   tcp._write_block.notlast
00:0000DECF   tcp.status
00:0000DF04   tcp.send
00:0000DF10   tcp._send
00:0000DF32   tcp.connect
00:0000DF44 X tcp.disconnect
00:0000DF50   tcp._disconnect
00:0000DF62   tcp._disconnect.readall
00:0000DF73   tcp.close
00:0000DFA7   tcp.close.doneinhand
00:00000001   dhcp.DHCP_OP.BOOTREQUEST
00:00000002 X dhcp.DHCP_OP.BOOTREPLY
00:00000001   dhcp.DHCP_HTYPE.10MB
00:00000002 X dhcp.DHCP_HTYPE.100MB
00:00000006   dhcp.DHCP_HLEN.ETHERNET
00:00000000   dhcp.DHCP.HOPS
00:00008000   dhcp.DHCP_FLAGS.BROADCAST
00:00000000 X dhcp.DHCP_OPT.PAD
00:000000FF   dhcp.DHCP_OPT.END
00:00000001   dhcp.DHCP_OPT.SUBNET
00:00000003   dhcp.DHCP_OPT.ROUTER
00:00000006   dhcp.DHCP_OPT.DNS
00:0000000C   dhcp.DHCP_OPT.HOST
00:0000000F   dhcp.DHCP_OPT.DOMAIN
00:0000002A   dhcp.DHCP_OPT.NTP
00:00000032   dhcp.DHCP_OPT.IP
00:00000033   dhcp.DHCP_OPT.LEASE
00:00000035   dhcp.DHCP_OPT.TYPE
00:00000001   dhcp.DHCP_TYPE.DISCOVER
00:00000002   dhcp.DHCP_TYPE.OFFER
00:00000003   dhcp.DHCP_TYPE.REQUEST
00:00000004   dhcp.DHCP_TYPE.DECLINE
00:00000005   dhcp.DHCP_TYPE.ACK
00:00000006   dhcp.DHCP_TYPE.NAK
00:00000007 X dhcp.DHCP_TYPE.RELEASE
00:00000008 X dhcp.DHCP_TYPE.INFORM
00:00000036   dhcp.DHCP_OPT.SERVER
00:00000037   dhcp.DHCP_OPT.PARAM
00:0000003A   dhcp.DHCP_OPT.T1
00:0000003B   dhcp.DHCP_OPT.T2
00:0000003D   dhcp.DHCP_OPT.CLIENT
00:00000043   dhcp.DHCP_SERVER_PORT
00:00000044   dhcp.DHCP_CLIENT_PORT
00:0000DFD4   dhcp.init
00:0000DFE6   dhcp.init.loop
00:0000DFEB   dhcp.init.do_dhcp
00:0000E008   dhcp.init.donetrace
00:0000E01C   dhcp.restart
00:0000E021   dhcp.donetrace
00:0000E035   dhcp.init.error
00:0000E03C   dhcp.init.abort
00:0000E044   dhcp.init.startok
00:0000E04B X dhcp.start
00:0000E070   dhcp.start.donetrace
00:0000E0AF   dhcp.start.dontr2
00:0000E0EA   dhcp.send
00:0000E0F0   dhcp.send.loop
00:0000E13A   dhcp.send.writezeros
00:00000004   dhcp.send.LEN_COOKIE
00:00000003   dhcp.send.LEN_TYPE
00:00000009   dhcp.send.LEN_CLIENT
00:0000000A   dhcp.send.LEN_HOST
00:0000001A   dhcp.send.packet_size
00:0000E18A   dhcp.send.error
00:0000E192   dhcp.send.noerror
00:0000E1B1   dhcp.send.notreq
00:0000E1E3   dhcp.read
00:0000E1EB   dhcp.read.eop
00:0000E1EE   dhcp.read.badpacket
00:0000E1F5 X dhcp.read.retry
00:0000E1F8   dhcp.read.loop
00:0000E216   dhcp.read.errret
00:0000E21D   dhcp.read.gotpacket
00:0000E22C   dhcp.read.donetrace
00:0000E270   dhcp.read.xiderrnz
00:0000E28F X dhcp.read.xidok
00:0000E29C   dhcp.read.readlots
00:0000E2C8   dhcp.read.cookiebad
00:0000E2CE   dhcp.read.cookieok
00:0000E2D2   dhcp.read.ret
00:0000E2DF   dhcp.read.nextopt
00:0000E32A   dhcp.read.tracetype
00:0000E341   dhcp.read.not53
00:0000E359   dhcp.read.not1
00:0000E375   dhcp.read.not3
00:0000E38B   dhcp.read.traceip
00:0000E38F   dhcp.read.skip4
00:0000E395   dhcp.read.not6
00:0000E3AD   dhcp.read.not42
00:0000E3C6   dhcp.read.not54
00:0000E3E9   dhcp.read.not51
00:0000E3E9   dhcp.read.skipopt
00:0000E3ED   dhcp.read.skiploop
00:0000E3F5   dhcp.read.skipped
00:0000E3F8   dhcp.read_ip
00:0000E3FE   dhcp.read_ip.loop
00:0000E407   dhcp.traceip
00:0000E41C   dhcp.packet_write
00:0000E425   dhcp.packet_init
00:0000E42E   dhcp.packet_mac
00:0000E439   dhcp.packet_ip
00:0000E444   dhcp.packet_byte
00:0000E44E   dhcp.packet_nibble
00:0000E458   dhcp.packet_nibble.done
00:0000E45B   dhcp.interrupt
00:0000E47D   dhcp.interrupt.loop
00:0000E48D   dhcp.owner_str
00:00004242   ping.OUR_ID
00:0000E492   ping.init
00:0000E4B8   ping.init.loop
00:0000E4C1   ping.init.end
00:0000E4C7   ping.do_ping
00:0000E4E0   ping.do_ping.wait
00:0000E4FB   ping.do_ping.loop
00:0000E51A   ping.do_ping.timeout
00:0000E51D   ping.do_ping.okret
00:0000E521   ping.do_ping.ret
00:0000E527   ping.do_ping.gotreply
00:0000E559   ping.do_ping.rejectheader
00:0000E559 X ping.do_ping.readrest
00:0000E5A7   ping.do_ping.printmS
00:0000E5AA   ping.lt20mS_str
00:0000E5AD   ping.mS_str
00:0000E5B2   ping.build
00:0000E5DD   ping.packet
00:00000008   ping.packet_size
00:0000E5E5   ping.checksum
00:0000E5E9   ping.checksum.loop
00:0000E600   ping.owner_str
00:0000007B   ntp.NTP_CLIENT_PORT
00:0000007B   ntp.NTP_SERVER_PORT
00:0000E605   ntp.init
00:0000E61F   ntp.init.error
00:0000E626   ntp.init.abort
00:0000E62E   ntp.init.start
00:0000E642   ntp.init.loop
00:0000E669   ntp.init.badpacket
00:0000E672   ntp.init.gotpacket
00:0000E681   ntp.init.donetrace
00:0000E6BF   ntp.init.donetrace2
00:0000E6C7   ntp.send
00:0000E6D1   ntp.send.gotntp
00:0000E702   ntp.send.donetrace
00:0000E72C   ntp.broadcast_ip
00:0000E730   ntp.owner_str
00:00000015   ftp.CONTROL_DPORT
00:00000016   ftp.CONTROL_SPORT
00:0000E734   ftp.open_control
00:0000E74E   ftp.open_control.notrace
00:0000E764   ftp.open_control.done
00:0000E76C   ftp.login
00:0000E77A   ftp.login.notrace
00:0000E787   ftp.login.lenok
00:0000E7AE   ftp.login.gotuser
00:0000E7DA   ftp.login.gotpass
00:0000E7EC   ftp.anonymous_str
00:0000000A   ftp.anonymous_str_size
00:0000E7F6   ftp.localhost_str
00:0000000F   ftp.localhost_str_size
00:0000E805   ftp.userprompt_str
00:0000E81D   ftp.passprompt_str
00:0000E839   ftp.logout
00:0000E842   ftp.dir
00:0000E85D   ftp.dir.print
00:0000E87B   ftp.dir.doread
00:0000E888   ftp.dir.done
00:0000E88D   ftp.dir.timeout
00:0000E890 X ftp.dir.close
00:0000E89F   ftp.status
00:0000E8A7   ftp.chdir
00:0000E8BF   ftp.chdir.deccd
00:0000E8C0   ftp.chdir.cd
00:0000E8C5   ftp.chdir.cdup
00:0000E8CA   ftp.chdir.pwd
00:0000E8CD   ftp.issue_print
00:0000E8D6   ftp.mkdir
00:0000E8DE   ftp.rmdir
00:0000E8E6   ftp.del
00:0000E8EE   ftp.ren
00:0000E8FF   ftp.issue
00:0000E902   ftp.issue_arg
00:0000E907   ftp.is_response
00:0000E90E   ftp.get_response
00:0000E919 X ftp.get_response.noerr
00:0000E93A   ftp.get_response.donetrace
00:0000E960   ftp.open_data
00:0000E980   ftp.read
00:0000E986   ftp.read.loop
00:0000E996   ftp.read.notclosed
00:0000E9B2   ftp.read.readit
00:0000E9C0   ftp.read.doread
00:0000E9CC   ftp.read_code
00:0000E9D1   ftp.read_code.first
00:0000E9D4   ftp.read_code.nextline
00:0000E9E0   ftp.read_code.skip
00:0000E9EF   ftp.issue_cmd
00:0000EA13   ftp.issue_cmd.notrace
00:0000EA2A   ftp.crlf_str
00:0000EA2D   ftp.send_pasv
00:0000EA5A   ftp.send_pasv.gotsep
00:0000EA61   ftp.send_pasv.notsep
00:0000EA7F   ftp.findnum
00:0000EA80   ftp.findnum.loop
00:0000EA8A   ftp.trace
00:00000000   ftp.ftp_channel.socket
00:00000001   ftp.ftp_channel.data
00:00000002   ftp.ftp_channel
00:0000EAAC   ftp.device_open
00:0000EAB1   ftp.device_create
00:0000EAB4   ftp.opencreate
00:0000EAE1   ftp.opencreate.ret
00:0000EAE9   ftp.device_close
00:0000EB0B   ftp.device_read_byte
00:0000EB2B   ftp.device_read_block
00:0000EB3A   ftp.read_ret
00:0000EB48   ftp.device_write_byte
00:0000EB6B   ftp.device_write_block
00:0000EB80   ftp.device_status
00:0000EB94   ftp.ftp_to_exos
00:0000EB99   ftp.ftp_to_exos.loop
00:0000EBAB   ftp.ftp_to_exos.notintable
00:0000EBB5   ftp.responses
00:0000EBBB   ftp.cwd_str
00:0000EBC0   ftp.pwd_str
00:0000EBC4   ftp.cdup_str
00:0000EBC9   ftp.mkd_str
00:0000EBCE   ftp.rmd_str
00:0000EBD3   ftp.dele_str
00:0000EBD9   ftp.rnfr_str
00:0000EBDF   ftp.rnto_str
00:0000EBE5   ftp.user_str
00:0000EBEB   ftp.pass_str
00:0000EBF1   ftp.pasv_str
00:0000EBF6   ftp.list_str
00:0000EBFC   ftp.retr_str
00:0000EC02   ftp.stor_str
00:0000EC08   ftp.syst_str
00:0000EC0D   ftp.quit_str
00:0000EC12   ftp.owner_str
00:0000EC16   ftp.owner_data_str
00:00000003   http.HTTP_SOCKET
00:00000050   http.HTTP_PORT
00:00000000   http.http_channel.socket
00:00000001   http.http_channel.size_H
00:00000002   http.http_channel.size_L
00:00000003   http.http_channel
00:0000EC1B   http.device_open
00:0000EC3F   http.device_open.donetrace
00:0000EC78   http.device_open.unspace
00:0000EC93   http.device_open.donecodetrace
00:0000ECA5   http.device_open.badpacket
00:0000ECA9   http.device_open.nextline
00:0000ECBD   http.device_open.unspace2
00:0000ECDC   http.device_open.donelentrace
00:0000ECDE   http.device_open.ret
00:0000ECE4   http.readline
00:0000ECE9   http.readline.next
00:0000ECEA   http.readline.ignore
00:0000ED12   http.readline.donetrace
00:0000ED15   http.readline.err
00:0000ED21   http.readline.donetrace3
00:0000ED2C   http.send
00:0000ED43   http.send.donefn
00:0000ED5D   http.send.loop
00:0000ED6F   http.send.donetrace
00:0000ED99   http.send.dt2
00:0000ED9D   http.trace
00:0000EDC4   http.get_str
00:00000004   http.get_str_len
00:0000EDC8   http._http_header_str
00:0000EDC9   http.http_1.0_str
00:00000008   http.http_1.0_str_len
00:0000004B   http._http_header_str_len
00:0000EE13   http.content_length_str
00:0000000E   http.content_length_str_len
00:0000EE21   http.owner_str
00:0000F000   vars
00:00000000   vars._trace
00:0000F000   vars.trace
00:00000000   vars.trace.diag
00:00000001   vars.trace.socket
00:00000002   vars.trace.dhcp
00:00000003   vars.trace.ftp
00:00000004   vars.trace.ntp
00:00000005   vars.trace.http
00:00000007   vars.trace.raw
00:00000001   vars.trace.diag_mask
00:00000002 X vars.trace.socket_mask
00:00000004 X vars.trace.dhcp_mask
00:00000008 X vars.trace.ftp_mask
00:00000010 X vars.trace.ntp_mask
00:00000020 X vars.trace.http_mask
00:00000080   vars.trace.raw_mask
00:0000007E   vars.trace.all_mask
00:00000001   vars._io
00:0000F001   vars.io
00:0000F002   vars.trace.cols
00:00000003   vars._init
00:0000F003   vars.init
00:00000000   vars.init.wiz
00:00000001   vars.init.dhcp
00:00000002   vars.init.lease
00:00000001 X vars.init.wiz_mask
00:00000002 X vars.init.dhcp_mask
00:00000004 X vars.init.lease_mask
00:00000004   vars._socket.flushing
00:0000F004 X vars.socket.flushing
00:00000005   vars._io.col
00:0000F005   vars.io.col
00:0000F006   vars.ticks
00:0000F008   vars.dhcp.ticks
00:00000032   TICKS_1s
00:00000BB8   TICKS_1m
00:0000000A   vars.status._ticks
00:0000F00A   vars.status.ticks
00:0000F00B   vars.status.pos
00:0000F00D   vars.status.byte
00:0000000E   vars.device._byte
00:0000F00E   vars.device.byte
00:0000F00F   vars.tcp.start
00:0000F011   vars.diag.buffer
00:0000F011   vars.command.ip
00:0000F011   vars.device.ip
00:0000F011   vars.icmp.header
00:0000F011   vars.udp.header
00:0000F011   vars.icmp.ip
00:0000F011   vars.udp.ip
00:0000F015   vars.icmp.size
00:0000F015   vars.udp.port
00:00000006   vars.icmp.header_size
00:0000F017 X vars.ping.start
00:0000F017   vars.tcp.header
00:0000F017   vars.tcp.size
00:0000F017   vars.udp.size
00:00000008   vars.udp.header_size
00:00000002   vars.tcp.header_size
00:0000F019   vars.ntp.timeout
00:0000F019   vars.ping.start_ticks
00:0000F019   vars.dhcp.timeout
00:0000F01B   vars.ping.end_ticks
00:0000F01B   vars.ntp.retries
00:0000F01B   vars.dhcp.retries
00:0000F01C   vars.dhcp.values
00:0000F01C   vars.dhcp.ip
00:0000F020   vars.dhcp.subnet
00:0000F024   vars.dhcp.gateway
00:0000F028   vars.dhcp.server
00:0000F02C   vars.dhcp.dns
00:0000F030   vars.dhcp.ntp
00:0000F034   vars.dhcp.lease
00:0000F038 X vars.dhcp.start
00:00000020   vars.dhcp.values_size
00:0000F03C   vars.ping.ip
00:0000F03C   vars.dhcp.xid
00:00000004 X vars.dhcp.xid_len
00:0000F040   vars.ping.seq
00:0000F040   vars.dhcp.secs
00:00000002 X vars.dhcp.secs_len
00:0000F042   vars.dhcp.packet_xid
00:0000F046   vars.ftp.ip
00:0000F04A   vars.ftp.socket
00:0000F04B   vars.ftp.start
00:0000F04D   vars.ftp.data_ip
00:0000F051   vars.ftp.data_port
00:0000F053   vars.device.host
00:0000F053   vars.ftp.buffer
00:00000100   vars.ftp.buffer_size
00:0000F153   vars.ftp.user
00:00000028   vars.ftp.user_size
00:0000F17B   vars.ftp.pass
00:00000028   vars.ftp.pass_size
00:0000F200   vars.sockets
00:00000020   vars.socket_size
00:0000F200 X vars.socket0
00:0000F220 X vars.socket1
00:0000F240 X vars.socket2
00:0000F260 X vars.socket3
00:0000F280 X vars.socket4
00:0000F2A0 X vars.socket5
00:0000F2C0 X vars.socket6
00:0000F2E0 X vars.socket7
00:0000F300   vars.http.packet
00:0000F300   vars.ping.packet
00:0000F300   vars.dhcp.packet
00:0000F300   vars.ntp.packet
00:0000F300   vars.ping.packet.type
00:0000F300 X vars.ntp.packet.livnmode
00:0000F300   vars.dhcp.packet.op
00:0000F301   vars.ping.packet.code
00:0000F301 X vars.ntp.packet.stratum
00:0000F301 X vars.dhcp.packet.htype
00:0000F302   vars.ping.packet.csum
00:0000F302 X vars.ntp.packet.poll
00:0000F302 X vars.dhcp.packet.hlen
00:0000F303 X vars.ntp.packet.precision
00:0000F303 X vars.dhcp.packet.hops
00:0000F304   vars.ping.packet.id
00:0000F304 X vars.ntp.packet.delay
00:0000F304   vars.dhcp.packet.xid
00:0000F306   vars.ping.packet.seq
00:0000F306 X vars.dhcp.packet.xid2
00:00000008   vars.ping.packet_size
00:0000F308 X vars.ntp.packet.dispersion
00:0000F308 X vars.dhcp.packet.secs
00:0000F30A X vars.dhcp.packet.flags
00:0000F30C   vars.ntp.packet.identifier
00:0000F30C X vars.dhcp.packet.ciaddr
00:0000F310 X vars.ntp.packet.reference
00:0000F310   vars.dhcp.packet.yiaddr
00:0000F314 X vars.dhcp.packet.siaddr
00:0000F318 X vars.ntp.packet.originate
00:0000F318 X vars.dhcp.packet.giaddr
00:0000F31C   vars.dhcp.packet.chaddr
00:0000F320 X vars.ntp.packet.receive
00:0000F328   vars.ntp.packet.transmit
00:0000F32C X vars.dhcp.packet_end
00:0000002C   vars.dhcp.packet_size
00:0000F330 X vars.ntp.packet_end
00:00000030   vars.ntp.packet_size
00:00000100 X vars.http.packet_size
00:00000400   vars.varsize


 Output: ..\epnet.rom
-------------------------------------------------

 Page: 00
  Org: 0000C000  Size: *  Used: 00004000

   Address   Length Align   Label
   0000C000   16384         io
