Sjasm Z80 Assembler v0.42c - www.xl2s.tk             [2015.11.17 - 17:05:42]

rom.asm
Errors: 0

       1   00:4007                      ; ROM
       2   00:4007                      ;
       3   00:4007                      ; This is the very start of the EPNET ROM
       4   00:4007                      ;
       5   00:4007                      ;==============================================================================
       6   00:4007                      ;
       7   00:4007                      ; This file is part of the EPNET software
       8   00:4007                      ;
       9   00:4007                      ; Copyright (C) 2015  Bruce Tanner
      10   00:4007                      ;
      11   00:4007                      ;    This program is free software: you can redistribute it and/or modify
      12   00:4007                      ;    it under the terms of the GNU General Public License as published by
      13   00:4007                      ;    the Free Software Foundation, either version 3 of the License, or
      14   00:4007                      ;    (at your option) any later version.
      15   00:4007                      ;
      16   00:4007                      ;    This program is distributed in the hope that it will be useful,
      17   00:4007                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      18   00:4007                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      19   00:4007                      ;    GNU General Public License for more details.
      20   00:4007                      ;
      21   00:4007                      ;    You should have received a copy of the GNU General Public License
      22   00:4007                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      23   00:4007                      ;
      24   00:4007                      ; If you do use or modify this file, either for its original purpose or for
      25   00:4007                      ; something new, I'd love to hear about it! I can be contacted by email at:
      26   00:4007                      ;
      27   00:4007                      ; brucetanner@btopenworld.com
      28   00:4007                      ;
      29   00:4007                      ;==============================================================================
      30   00:4007                      ;
      31   00:4007                                      org	0c000h
      32   00:C000                      ;
      33   00:C000                                      db	"EXOS_ROM"		;ROM header
      33   00:C000  45 58 4F 53 5F 52 4F 4D 
      34   00:C008  61 4C                               dw	device.devices-8000h	; Page 1 pointer to device desc
      35   00:C00A  C3 14 C0            		jp	entry			; ROM entry point from EXOS
      36   00:C00D                      ;
      37   00:C00D                      ;
      38   00:C00D                      ; These locations in the ROM are non-standard, but fixed for EPNET
      39   00:C00D                      ;
      40   00:C00D                      ; Normally EPNET finds it's i/o from it's ROM segment number. But if this byte
      41   00:C00D                      ; is non-zero, it specifies the I/O to use instead
      42   00:C00D  00                  io:		db	0		; Card I/O address; 0=>use ROM/2
      43   00:C00E                      ;
      44   00:C00E                      ; The MAC address is here. It must be different for each EPNET card!
      45   00:C00E  00 00 F6 42 42 00   mac:		db	00h,00h,0f6h,42h,42h,00h	; Our MAC address
      46   00:C014                      ;
      47   00:C014                      ;
      48   00:C014                      entry:	
      49   00:C014  79                  		ld	a,c
      50   00:C015  FE 07               		cp	7		; Action code 7, RAM allocation?
      51   00:C017  28 23               		jr	z,ram_allocation; Go if yes
      52   00:C019                      ;
      53   00:C019  D9                  		exx
      54   00:C01A  0E B1               		ld	c,ep.P1		; C' always->P1
      55   00:C01C  ED 40               		in	b,(c)		; B' always=our seg
      56   00:C01E  58                  		ld	e,b		; E' always=socket seg
      57   00:C01F  50                  		ld	d,B		; d' always=tcp seg
      58   00:C020  FD 21 07 40         		ld	iy,vars		; IY always->our variables
      59   00:C024  D9                  		exx
      60   00:C025                      ;
      61   00:C025  3D                  		dec	a
      62   00:C026  28 0E               		jr	z,cold_reset	; Action code 1: cold reset
      63   00:C028                      ;
      64   00:C028  3D                  		dec	a		; Action code 2: command string
      65   00:C029  CA B3 C0                            jp	z,command.command
      66   00:C02C                      ;
      67   00:C02C  3D                  		dec	a		; Action code 3: HELP string
      68   00:C02D  CA 64 C0                            jp	z,command.help
      69   00:C030                      ;
      70   00:C030  3D                  		dec	a		; Action code 4: EXOS variable
      71   00:C031  3D                  		dec	a		; Action code 5: Explain error code
      72   00:C032  CA DA CA            		jp	z,exos.explain
      73   00:C035                      ;
      74   00:C035  C9                                  ret
      75   00:C036                      ;
      76   00:C036  CD 1A D1            cold_reset:	call	util.varszero	; Initialize private RAM area
      77   00:C039  0E 01               		ld	c,1		; Preserve 1 action code
      78   00:C03B  C9                  		ret
      79   00:C03C                      ;
      80   00:C03C                      ;
      81   00:C03C                      ;------------------------------------------------------------------------------
      82   00:C03C                      ; Here we need to get a RAM segment from EXOS for our variables. Our variables
      83   00:C03C                      ; do not need a whole segment, but they *do* need to be at a fixed address,
      84   00:C03C                      ; and the only way to guarantee this is to ask for a whole segment, otherwise
      85   00:C03C                      ; EXOS could try and share the segement with another device and our
      86   00:C03C                      ; variables could end up anywhere within the segment. We can't quite get the
      87   00:C03C                      ; entire segment though because EXOS keeps it's internal pointers etc in the
      88   00:C03C                      ; first 6 bytes.
      89   00:C03C                      ;
      90   00:C03C                      ; At this point our usual variable pointer in IY and paging vars in B'and C'
      91   00:C03C                      ; are not setup.
      92   00:C03C                      ;
      93   00:C03C  01 00 02            ram_allocation:	ld	bc,0200h	; C=0=>RAM needed; B=2=>page 1 RAM
      94   00:C03F  11 F9 3F            		ld	de,4000h-exos.DEVICE_SEG_START	; Get a whole segment
      95   00:C042  C9                  		ret
      96   00:C043                      ;
      97   00:C043                      ;
      98   00:C043                      ;------------------------------------------------------------------------------
      99   00:C043                      ;
     100   00:C043                      		; The main code
     101   00:C043                      		include	main.asm	; All the main code files
       1.  00:C043                      ; MAIN
       2.  00:C043                      ;
       3.  00:C043                      ; This is the main program file, and just includes all the other modules.
       4.  00:C043                      ;
       5.  00:C043                      ;==============================================================================
       6.  00:C043                      ;
       7.  00:C043                      ; This file is part of the EPNET software
       8.  00:C043                      ;
       9.  00:C043                      ; Copyright (C) 2015  Bruce Tanner
      10.  00:C043                      ;
      11.  00:C043                      ;    This program is free software: you can redistribute it and/or modify
      12.  00:C043                      ;    it under the terms of the GNU General Public License as published by
      13.  00:C043                      ;    the Free Software Foundation, either version 3 of the License, or
      14.  00:C043                      ;    (at your option) any later version.
      15.  00:C043                      ;
      16.  00:C043                      ;    This program is distributed in the hope that it will be useful,
      17.  00:C043                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      18.  00:C043                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      19.  00:C043                      ;    GNU General Public License for more details.
      20.  00:C043                      ;
      21.  00:C043                      ;    You should have received a copy of the GNU General Public License
      22.  00:C043                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      23.  00:C043                      ;
      24.  00:C043                      ; If you do use or modify this file, either for its original purpose or for
      25.  00:C043                      ; something new, I'd love to hear about it! I can be contacted by email at:
      26.  00:C043                      ;
      27.  00:C043                      ; brucetanner@btopenworld.com
      28.  00:C043                      ;
      29.  00:C043                      ;==============================================================================
      30.  00:C043                      ;
      31.  00:C043                      ; At the heart of the program is socket.c, which talks to the WIZ chip socket
      32.  00:C043                      ; interface. Protocol modules such as UDP, TCP and IPRAW in turn talk to
      33.  00:C043                      ; socket.c. The higher-level protocols such as DHCP, PING and FTP then talk to
      34.  00:C043                      ; the protocol modules.
      35.  00:C043                      ;                                                                               
      36.  00:C043                      ;  =============================================================               
      37.  00:C043                      ; |                               EXOS                          |               
      38.  00:C043                      ;  =============================================================                
      39.  00:C043                      ;      ^             ^                            ^                             
      40.  00:C043                      ;      |             |                            |                             
      41.  00:C043                      ;      |             v                            |                             
      42.  00:C043                      ;      |        ------------                      |                             
      43.  00:C043                      ;      |       |  rom.asm   |                     |                             
      44.  00:C043                      ;      |        -----------                       |                             
      45.  00:C043                      ;      |             ^                            |                             
      46.  00:C043                      ;      |             |                            |                             
      47.  00:C043                      ;      v             v                            v                             
      48.  00:C043                      ;  ---------------------------               -----------                        
      49.  00:C043                      ; | device.asm | command.asm  |             |   io.asm  |                       
      50.  00:C043                      ;  ---------------------------              | trace.asm |                       
      51.  00:C043                      ;      ^            ^^^                      -----------                        
      52.  00:C043                      ;      |           / | \                                                        
      53.  00:C043                      ;      |          /  |  \                                                       
      54.  00:C043                      ;      |         /   |   \                                                      
      55.  00:C043                      ;      |        /    |    \                                                     
      56.  00:C043                      ;      |       /     |     \                                                    
      57.  00:C043                      ;      |      /      |      \                                                   
      58.  00:C043                      ;      |     /       |       \                                                  
      59.  00:C043                      ;      |    /        |        \                                                 
      60.  00:C043                      ;      |   /         |         \                                                
      61.  00:C043                      ;      v  v          v          v                                               
      62.  00:C043                      ;  --------------------------------------                                       
      63.  00:C043                      ; |         |    sntp.asm   |            |                                      
      64.  00:C043                      ; | http.asm|    sntp.asm   |            |                                      
      65.  00:C043                      ; |  ftp.asm|    dhcp.asm   |  ping.asm  |                                      
      66.  00:C043                      ;  --------------------------------------                                       
      67.  00:C043                      ;      ^            ^             ^                                             
      68.  00:C043                      ;      |            |             |                                             
      69.  00:C043                      ;      v            v             v                                             
      70.  00:C043                      ;  --------------------------------------                                       
      71.  00:C043                      ; | tcp.asm |    udp.asm    |  ipraw.asm |                                      
      72.  00:C043                      ;  --------------------------------------                                       
      73.  00:C043                      ;      ^            ^             ^                                             
      74.  00:C043                      ;      |            |             |                                             
      75.  00:C043                      ;      v            v             v                                             
      76.  00:C043                      ;  --------------------------------------+----------------------                
      77.  00:C043                      ; |             socket.asm               |      wiz.asm         |               
      78.  00:C043                      ;  -------------------------------------------------------------                
      79.  00:C043                      ;                   ^                               ^                           
      80.  00:C043                      ;                   |                               |                           
      81.  00:C043                      ;                   v                               v                           
      82.  00:C043                      ;  =============================================================                
      83.  00:C043                      ; | WIZ socket registers                 | WIZ common registers |               
      84.  00:C043                      ;  =============================================================                
      85.  00:C043                      ;
      86.  00:C043                      ;
      87.  00:C043                      	include version.asm
       1:  00:C043                      ; VERSION
       2:  00:C043                      ;
       3:  00:C043                      ; This just contains the verion number of the system
       4:  00:C043                      ;
       5:  00:C043                      		module	version
       6:  00:C043                      ;
       7:  00:C043                      ;==============================================================================
       8:  00:C043                      ;
       9:  00:C043                      ; This file is part of the EPNET software
      10:  00:C043                      ;
      11:  00:C043                      ; Copyright (C) 2015  Bruce Tanner
      12:  00:C043                      ;
      13:  00:C043                      ;    This program is free software: you can redistribute it and/or modify
      14:  00:C043                      ;    it under the terms of the GNU General Public License as published by
      15:  00:C043                      ;    the Free Software Foundation, either version 3 of the License, or
      16:  00:C043                      ;    (at your option) any later version.
      17:  00:C043                      ;
      18:  00:C043                      ;    This program is distributed in the hope that it will be useful,
      19:  00:C043                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      20:  00:C043                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      21:  00:C043                      ;    GNU General Public License for more details.
      22:  00:C043                      ;
      23:  00:C043                      ;    You should have received a copy of the GNU General Public License
      24:  00:C043                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      25:  00:C043                      ;
      26:  00:C043                      ; If you do use or modify this file, either for its original purpose or for
      27:  00:C043                      ; something new, I'd love to hear about it! I can be contacted by email at:
      28:  00:C043                      ;
      29:  00:C043                      ; brucetanner@btopenworld.com
      30:  00:C043                      ;
      31:  00:C043                      ;==============================================================================
      32:  00:C043                      ;
      33:  00:C043  (00:0030)           major		equ	'0'
      34:  00:C043  (00:0031)           minor		equ	'1'
      35:  00:C043  (00:0032)           revision	equ	'2'
      36:  00:C043                      ;
      37:  00:C043                      ;
      38:  00:C043                      ; History:
      39:  00:C043                      ;
      40:  00:C043                      ; VERSION	DATE		DESCRIPTION
      41:  00:C043                      ; 0.13		ongoing
      42:  00:C043                      ; 0.12		2015-11-17	Second version on Github, vars in allocated seg
      43:  00:C043                      ; 0.11		2015-11-3	Put on Githib
      44:  00:C043                      ; 0.10		unknown		Sent to lgb for JSEP
      45:  00:C043                      ;
      46:  00:C043                      ;
      47:  00:C043                      		endmodule
      88.  00:C043                      	include	debug.asm
       1:  00:C043                      ; DEBUG
       2:  00:C043                      ;
       3:  00:C043                      ; Some useful macros for debugging. Comment out the fo0llowing line to
       4:  00:C043                      ; assemble a non-debugging version:
       5:  00:C043                      ;
       6:  00:C043                      		define	DEBUG
       7:  00:C043                      ;
       8:  00:C043                      ;==============================================================================
       9:  00:C043                      ;
      10:  00:C043                      ; This file is part of the EPNET software
      11:  00:C043                      ;
      12:  00:C043                      ; Copyright (C) 2015  Bruce Tanner
      13:  00:C043                      ;
      14:  00:C043                      ;    This program is free software: you can redistribute it and/or modify
      15:  00:C043                      ;    it under the terms of the GNU General Public License as published by
      16:  00:C043                      ;    the Free Software Foundation, either version 3 of the License, or
      17:  00:C043                      ;    (at your option) any later version.
      18:  00:C043                      ;
      19:  00:C043                      ;    This program is distributed in the hope that it will be useful,
      20:  00:C043                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      21:  00:C043                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      22:  00:C043                      ;    GNU General Public License for more details.
      23:  00:C043                      ;
      24:  00:C043                      ;    You should have received a copy of the GNU General Public License
      25:  00:C043                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      26:  00:C043                      ;
      27:  00:C043                      ; If you do use or modify this file, either for its original purpose or for
      28:  00:C043                      ; something new, I'd love to hear about it! I can be contacted by email at:
      29:  00:C043                      ;
      30:  00:C043                      ; brucetanner@btopenworld.com
      31:  00:C043                      ;
      32:  00:C043                      ;==============================================================================
      33:  00:C043                      ;
      34:  00:C043                      		ifdef	DEBUG
      35:  00:C043  F5                  byte:		 push	af
      36:  00:C044  0F                  		  rrca
      37:  00:C045  0F                  		  rrca
      38:  00:C046  0F                  		  rrca
      39:  00:C047  0F                  		  rrca
      40:  00:C048  CD 4C C0            		  call	nib
      41:  00:C04B  F1                  		 pop	af
      42:  00:C04C                      ;
      43:  00:C04C  E6 0F               nib:		 and	0fh
      44:  00:C04E  C6 30               		 add	a,'0'
      45:  00:C050  FE 3A               		 cp	'9'+1
      46:  00:C052  38 02               		 jr	c,char
      47:  00:C054  C6 07               		 add	a,'A'-'9'-1
      48:  00:C056  F5                  char:		 push	af
      49:  00:C057  C5                  		 push	bc
      50:  00:C058  D5                  		 push	de
      51:  00:C059  E5                  		 push	hl
      52:  00:C05A  47                  		  ld	b,a
      53:  00:C05B  3E FF               		  ld	a,0ffh
      54:  00:C05D  F7                  		  rst	30h
      55:  00:C05E  07                  		  db	exos.FN_WRCH
      56:  00:C05F  E1                  		 pop	hl
      57:  00:C060  D1                  		 pop	de
      58:  00:C061  C1                  		 pop	bc
      59:  00:C062  F1                  		 pop	af
      60:  00:C063  C9                  		 ret
      61:  00:C064                      		endif
      62:  00:C064                      ;		
      63:  00:C064                      		macro POKE ch
      64:  00:C064                    < 		 ifdef	DEBUG
      65:  00:C064                    < 		  push	af
      66:  00:C064                    < 		  ld	a,ch
      67:  00:C064                    < 		  call	char
      68:  00:C064                    < 		  pop	af
      69:  00:C064                    < 		 endif
      70:  00:C064                    < 		endm
      71:  00:C064                      ;
      72:  00:C064                      		macro POKEcc cond,ch
      73:  00:C064                    < 		 ifdef DEBUG
      74:  00:C064                    < 		  push	af
      75:  00:C064                    < 		  ld	a,ch
      76:  00:C064                    < 		  call	cond,char
      77:  00:C064                    < 		  pop	af
      78:  00:C064                    < 		 endif
      79:  00:C064                    < 		endm
      80:  00:C064                      ;
      81:  00:C064                      		macro POKEBYTE reg
      82:  00:C064                    < 		 ifdef	DEBUG
      83:  00:C064                    < 		  push	af
      84:  00:C064                    < 		  ld	a,reg
      85:  00:C064                    < 		  call	byte
      86:  00:C064                    < 		  pop	af
      87:  00:C064                    < 		 endif
      88:  00:C064                    < 		endm
      89:  00:C064                      ;
      90:  00:C064                      		macro POKEBYTEcc cond, reg
      91:  00:C064                    < 		 ifdef	DEBUG
      92:  00:C064                    < 		  push	af
      93:  00:C064                    < 		  ld	a,reg
      94:  00:C064                    < 		  call	cond,io.byte
      95:  00:C064                    < 		  pop	af
      96:  00:C064                    < 		 endif
      97:  00:C064                    < 		endm
      89.  00:C064                      ;
      90.  00:C064                      	include	ep.asm
       1:  00:C064                      ; EP
       2:  00:C064                      ;
       3:  00:C064                      ; This module contains various Enterprise hardware constants (i/o ports etc)
       4:  00:C064                      ;
       5:  00:C064                      		module	ep
       6:  00:C064                      ;
       7:  00:C064                      ;==============================================================================
       8:  00:C064                      ;
       9:  00:C064                      ; This file is part of the EPNET software
      10:  00:C064                      ;
      11:  00:C064                      ; Copyright (C) 2015  Bruce Tanner
      12:  00:C064                      ;
      13:  00:C064                      ;    This program is free software: you can redistribute it and/or modify
      14:  00:C064                      ;    it under the terms of the GNU General Public License as published by
      15:  00:C064                      ;    the Free Software Foundation, either version 3 of the License, or
      16:  00:C064                      ;    (at your option) any later version.
      17:  00:C064                      ;
      18:  00:C064                      ;    This program is distributed in the hope that it will be useful,
      19:  00:C064                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      20:  00:C064                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      21:  00:C064                      ;    GNU General Public License for more details.
      22:  00:C064                      ;
      23:  00:C064                      ;    You should have received a copy of the GNU General Public License
      24:  00:C064                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      25:  00:C064                      ;
      26:  00:C064                      ; If you do use or modify this file, either for its original purpose or for
      27:  00:C064                      ; something new, I'd love to hear about it! I can be contacted by email at:
      28:  00:C064                      ;
      29:  00:C064                      ; brucetanner@btopenworld.com
      30:  00:C064                      ;
      31:  00:C064                      ;==============================================================================
      32:  00:C064                      ;
      33:  00:C064  (00:00B0)           P0	equ	0b0h	; Page 0 register
      34:  00:C064  (00:00B1)           P1	equ	0b1h	; Page 1 register
      35:  00:C064  (00:00B2)           P2	equ	0b2h	; Page 2 register
      36:  00:C064  (00:00B3)           P3	equ	0b3h	; Page 3 register
      37:  00:C064                      ;
      38:  00:C064                      ;
      39:  00:C064                      ;
      40:  00:C064                      		endmodule
      91.  00:C064                      ;
      92.  00:C064                      	include command.asm
       1:  00:C064                      ; COMMAND
       2:  00:C064                      ;
       3:  00:C064                      ; This module implements the EXOS commands
       4:  00:C064                      ;
       5:  00:C064                      		module command
       6:  00:C064                      ;
       7:  00:C064                      ;==============================================================================
       8:  00:C064                      ;
       9:  00:C064                      ; This file is part of the EPNET software
      10:  00:C064                      ;
      11:  00:C064                      ; Copyright (C) 2015  Bruce Tanner
      12:  00:C064                      ;
      13:  00:C064                      ;    This program is free software: you can redistribute it and/or modify
      14:  00:C064                      ;    it under the terms of the GNU General Public License as published by
      15:  00:C064                      ;    the Free Software Foundation, either version 3 of the License, or
      16:  00:C064                      ;    (at your option) any later version.
      17:  00:C064                      ;
      18:  00:C064                      ;    This program is distributed in the hope that it will be useful,
      19:  00:C064                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      20:  00:C064                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      21:  00:C064                      ;    GNU General Public License for more details.
      22:  00:C064                      ;
      23:  00:C064                      ;    You should have received a copy of the GNU General Public License
      24:  00:C064                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      25:  00:C064                      ;
      26:  00:C064                      ; If you do use or modify this file, either for its original purpose or for
      27:  00:C064                      ; something new, I'd love to hear about it! I can be contacted by email at:
      28:  00:C064                      ;
      29:  00:C064                      ; brucetanner@btopenworld.com
      30:  00:C064                      ;
      31:  00:C064                      ;==============================================================================
      32:  00:C064                      ; help
      33:  00:C064                      ;
      34:  00:C064                      ; Passed a command at (DE), looks to see if it is one of our commands and
      35:  00:C064                      ; prints help text if it is.
      36:  00:C064                      ;
      37:  00:C064                      ; Most of our commands are of the form :NET <cmd>, so we have to deal with
      38:  00:C064                      ; these sub-commands. eg. :NET STATUS. But some of our commands are also "top
      39:  00:C064                      ; level" commands, eg :FTP, :PING so we have to cope with these too.
      40:  00:C064                      ;
      41:  00:C064                      ; :HELP			prints a general help line
      42:  00:C064                      ; :HELP NET		prints a help page showing all the :NET commands
      43:  00:C064                      ; :HELP NET <cmd>	prints specific help for :NET <cmd>
      44:  00:C064                      ; :HELP <cmd>		prints specific help for top-level command <cmd>
      45:  00:C064                      ;
      46:  00:C064                      ; The top-level commands are also :NET commands eg :NET FTP, :NET PING work
      47:  00:C064                      ;
      48:  00:C064                      ; But there is also a :NET HELP command! This works the same way eg
      49:  00:C064                      ;
      50:  00:C064                      ; :NET HELP		same as :HELP NET
      51:  00:C064                      ; :NET HELP <cmd>	same as :HELP NET <cmd>
      52:  00:C064                      ;
      53:  00:C064                      ; and, yes, you can also go :NET HELP NET <cmd> but it must print out the help
      54:  00:C064                      ; for <cmd> assuming <cmd> is a :NET command, not a top level command.
      55:  00:C064                      ; 
      56:  00:C064                      ; In:  B=length. 0 if it's general help ie. just :HELP rather than :HELP <cmd>
      57:  00:C064                      ;     DE->command
      58:  00:C064                      ;
      59:  00:C064                      help:
      60:  00:C064  78                  		ld	a,b		; See if it's general or specific HELP
      61:  00:C065  B7                  		or	a
      62:  00:C066  21 76 C0            		ld	hl,.nothelpnet	; :HELP <not-net-cmd> goes to here
      63:  00:C069  20 29               		jr	nz,specific
      64:  00:C06B                      ;
      65:  00:C06B  D5                  		push	de		; General help so just print message
      66:  00:C06C  C5                  		push	bc
      67:  00:C06D  11 92 C4            		 ld	de,version_str
      68:  00:C070  CD 36 D0            		 call	io.str
      69:  00:C073  C1                  		pop	bc
      70:  00:C074  D1                  		pop	de
      71:  00:C075  C9                  		ret			; Preserving DE and B
      72:  00:C076                      ;		
      73:  00:C076                      .nothelpnet:	; Not :HELP NET (eg. :HELP FTP or :HELP PING) 
      74:  00:C076  21 CD C3            		ld	hl,main_tab	; Find command in our command table
      75:  00:C079  CD E3 C0            		call	find		; HL=offset into command table
      76:  00:C07C  D8                  		ret	c		; Cy=>Not found
      77:  00:C07D                      ;
      78:  00:C07D                      ;
      79:  00:C07D  11 D7 C3            		ld	de,main_help_tab; Find help text ptr in help table
      80:  00:C080  19                  get_help:	add	hl,de
      81:  00:C081  5E                  		ld	e,(hl)		; Get pointer to command help text
      82:  00:C082  23                  		inc	hl
      83:  00:C083  56                  		ld	d,(hl)
      84:  00:C084  18 03               		jr	helpout		; Just print general NET help
      85:  00:C086                      ;
      86:  00:C086  11 A7 C4            helpnet:	ld	de,net_help_str	; HELP NET with no extra commands
      87:  00:C089  CD 36 D0            helpout:	CALL	io.str
      88:  00:C08C  AF                  		xor	a
      89:  00:C08D  4F                                  ld	c,a		; C=0 => recognized
      90:  00:C08E  C9                                  ret
      91:  00:C08F                      ;
      92:  00:C08F                      nethelp:	; This is :NET HELP
      93:  00:C08F  28 F5               		jr	z,helpnet	; :NET HELP => :HELP NET!
      94:  00:C091                      ;
      95:  00:C091  21 A6 C0            		ld	hl,notnethelpnet; :NET HELP <cmd> goes to here
      96:  00:C094                      ;
      97:  00:C094                      specific:	; :HELP <cmd> searches the top level commands for <cmd>
      98:  00:C094                      		; :NET HELP <cmd> searches the NET command table
      99:  00:C094                      		; :HELP NET <cmd> and :NET HELP NET <cmd> both do the same
     100:  00:C094                      		; so here HL->action if the next word is not NET
     101:  00:C094  E5                  		push	hl
     102:  00:C095  21 8D CA            		 ld	hl,net_str	; :HELP NET or :NET HELP NET?
     103:  00:C098  CD CE C0                             call	compare
     104:  00:C09B  E1                  		pop	hl
     105:  00:C09C  C2 CD C0            		jp	nz,jphl		; Go & check for other commands if not
     106:  00:C09F                      ;
     107:  00:C09F  06 03               		ld 	b,net_str_len	; Skip NET to find sub-command
     108:  00:C0A1  CD 07 C1            		call	skip
     109:  00:C0A4                      ;
     110:  00:C0A4  28 E0               		jr	z,helpnet	; Go if none
     111:  00:C0A6                      ;
     112:  00:C0A6  21 E7 C3            notnethelpnet:	ld	hl,net_tab	; Find command in our command table
     113:  00:C0A9  CD E3 C0            		call	find		; HL=offset into command table
     114:  00:C0AC  38 D8               		jr	c,helpnet	; Go if not found
     115:  00:C0AE                      ;
     116:  00:C0AE  11 F9 C3            		ld	de,net_help_tab	; Find help text ptr in help table
     117:  00:C0B1  18 CD               		jr	get_help
     118:  00:C0B3                      ;
     119:  00:C0B3                      ;
     120:  00:C0B3                      ;------------------------------------------------------------------------------
     121:  00:C0B3                      ; command
     122:  00:C0B3                      ;
     123:  00:C0B3                      ; Passed a command at (DE), looks to see if it one of ours and executes it if so.
     124:  00:C0B3                      ;
     125:  00:C0B3                      ; In:  B=length
     126:  00:C0B3                      ;     DE->command
     127:  00:C0B3                      ; Out: C=0 and A=error code if command recognised, else B & DE preserved
     128:  00:C0B3                      ;
     129:  00:C0B3                      command:
     130:  00:C0B3  21 CD C3            		ld	hl,main_tab	; Find command in our command table
     131:  00:C0B6  CD E3 C0            		call	find		; HL=offset into command table
     132:  00:C0B9  D8                  		ret	c		; Cy=>Not found
     133:  00:C0BA                      ;
     134:  00:C0BA  F5                  		push	af		; Save flags from find
     135:  00:C0BB  3A 07 40            		 ld	a,(vars.trace)	; If tracing is on set up _tab video cols
     136:  00:C0BE  B7                  		 or	a		;   before jumping to command
     137:  00:C0BF  C4 94 D2            		 call	nz,trace.set_cols
     138:  00:C0C2  F1                  		pop	af		; F=result from find
     139:  00:C0C3                      ;
     140:  00:C0C3  D5                  		push	de
     141:  00:C0C4  11 DF C3            		 ld	de,main_cmd_tab
     142:  00:C0C7  19                  		 add	hl,de
     143:  00:C0C8  D1                  		pop	de
     144:  00:C0C9  7E                  jp_cmd:		ld	a,(hl)		; Get poointer to command routine
     145:  00:C0CA  23                  		inc	hl
     146:  00:C0CB  66                  		ld	h,(hl)
     147:  00:C0CC  6F                  		ld	l,a
     148:  00:C0CD  E9                  @jphl:		jp	(hl)		; Jump to command
     149:  00:C0CE                      ;
     150:  00:C0CE                      ;
     151:  00:C0CE                      ;------------------------------------------------------------------------------
     152:  00:C0CE                      ; compare
     153:  00:C0CE                      ;
     154:  00:C0CE                      ; Checks to see if the command at (DE) is the same as that at (HL).
     155:  00:C0CE                      ; (HL) is length byte first; B is the length of the user's command
     156:  00:C0CE                      ; In:  DE->user's command, length byte first
     157:  00:C0CE                      ;       B=length of user's command (ie. first word)
     158:  00:C0CE                      ;      HL->Command string in upper case, length byte first
     159:  00:C0CE                      ;       Z=>command matches
     160:  00:C0CE                      ;
     161:  00:C0CE                      compare:
     162:  00:C0CE  78                   		ld	 a,b		; Compare length first
     163:  00:C0CF  BE                                  cp	 (hl)
     164:  00:C0D0  C0                                  ret	 nz		; Not the same so command does not match
     165:  00:C0D1                      ;
     166:  00:C0D1  C5                                  push	 bc		; Save length of command word
     167:  00:C0D2  D5                                  push	 de		; And -> start of command
     168:  00:C0D3  13                                   inc	 de
     169:  00:C0D4  23                                   inc	 hl
     170:  00:C0D5  1A                  .loop          	 ld	 a,(de)
     171:  00:C0D6  CD 35 D1            		 call	 util.upper
     172:  00:C0D9  96                                   sub	 (hl)		; See if chars the same
     173:  00:C0DA  20 04                                jr	 nz,.notequal	; Go with NZ if not
     174:  00:C0DC                      ;
     175:  00:C0DC  23                                   inc	 hl		; Else compare next char
     176:  00:C0DD  13                                   inc	 de
     177:  00:C0DE  10 F5                                djnz	 .loop		; Still Z when end
     178:  00:C0E0                      ;
     179:  00:C0E0  D1                  .notequal       pop	 de		; Return DE->command
     180:  00:C0E1  C1                                  pop	 bc		; B=length
     181:  00:C0E2  C9                                  ret
     182:  00:C0E3                      ;
     183:  00:C0E3                      ;
     184:  00:C0E3                      ;------------------------------------------------------------------------------
     185:  00:C0E3                      ; find
     186:  00:C0E3                      ;
     187:  00:C0E3                      ; Finds a command in table of commands that we understand
     188:  00:C0E3                      ; 
     189:  00:C0E3                      ; In:  DE->command
     190:  00:C0E3                      ;       B=length of command (up to first space)
     191:  00:C0E3                      ;      HL->table of command strings
     192:  00:C0E3                      ; Out: DE not corrupted
     193:  00:C0E3                      ;      BC not corrupted, except B=length of next word if found
     194:  00:C0E3                      ;      Cy=>not found, else Z according to B
     195:  00:C0E3                      ;      NZ=>not found
     196:  00:C0E3                      ;      HL=offset into table if found
     197:  00:C0E3                      ;
     198:  00:C0E3                      find:
     199:  00:C0E3  E5                  		push	hl		; Save start of table
     200:  00:C0E4                      ;
     201:  00:C0E4  E5                  .loop:		 push	hl		; Save current entry pointer
     202:  00:C0E5                      ;
     203:  00:C0E5  7E                  		  ld	a,(hl)		; Get pointer to string from table in HL
     204:  00:C0E6  23                  		  inc	hl
     205:  00:C0E7  66                  		  ld	h,(hl)
     206:  00:C0E8  6F                  		  ld	l,a
     207:  00:C0E9  B4                  		  or	h
     208:  00:C0EA  28 0A               		  jr	z,.end		; 0 => end of table, A=0
     209:  00:C0EC                      ;
     210:  00:C0EC  CD CE C0            		  call	compare		; See if string = command
     211:  00:C0EF  E1                  		 pop	hl		; HL->back to table entry
     212:  00:C0F0  28 08               		 jr	z,.gotcmd	; Got match
     213:  00:C0F2                      ;
     214:  00:C0F2  23                  		 inc	hl		; Point to next table entry
     215:  00:C0F3  23                  		 inc	hl
     216:  00:C0F4  18 EE               		 jr	.loop		; Try next command in table
     217:  00:C0F6                      
     218:  00:C0F6  E1                  .end:		 pop	hl		; Drop current table pointer
     219:  00:C0F7  E1                  		pop	hl		; Drop start of table pointer
     220:  00:C0F8  37                  		scf			; Cy=>not found
     221:  00:C0F9  C9                  		ret
     222:  00:C0FA                      ;
     223:  00:C0FA  EB                  .gotcmd:	 ex	de,hl		; HL->command, DE->table entry
     224:  00:C0FB  E3                  		 ex	(sp),hl		; (SP)->command, HL->start of table
     225:  00:C0FC  EB                  		 ex	de,hl		; HL->table entry, DE->start of table
     226:  00:C0FD  B7                  		 or	a
     227:  00:C0FE  ED 52               		 sbc	hl,de		; HL=offset into table
     228:  00:C100                      ;
     229:  00:C100  D1                  		pop	de		; DE->command
     230:  00:C101                      ;
     231:  00:C101  E5                  		push	hl
     232:  00:C102  CD 07 C1            		 call	skip
     233:  00:C105  E1                  		pop	hl
     234:  00:C106                      ;
     235:  00:C106  C9                  		ret
     236:  00:C107                      ;
     237:  00:C107                      ;
     238:  00:C107                      ;------------------------------------------------------------------------------
     239:  00:C107                      ; skip
     240:  00:C107                      ;
     241:  00:C107                      ; Takes an EXOS command string at (DE) and skips B chars, returning the length
     242:  00:C107                      ; of the next word in B in EXOS-compatible manner.
     243:  00:C107                      ;
     244:  00:C107                      ; In:  DE->length byte of a command and is adjusted to skip B bytes
     245:  00:C107                      ;       B=number of chars to skip
     246:  00:C107                      ; Out: DE adjusted
     247:  00:C107                      ;       B=length of the next word
     248:  00:C107                      ;      AF=flags set according to B (ie. Z if no more command) and NC
     249:  00:C107                      ;
     250:  00:C107                      skip:
     251:  00:C107  EB                  		ex	de,hl		; HL->command
     252:  00:C108  E5                  		push	hl		; Save start of command
     253:  00:C109  7D                  		 ld	a,l		; Add on B bytes
     254:  00:C10A  80                  		 add	a,b
     255:  00:C10B  6F                  		 ld	l,a
     256:  00:C10C  30 01               		 jr	nc,.skipinc
     257:  00:C10E                      ;
     258:  00:C10E  24                  		 inc	h
     259:  00:C10F                      .skipinc:
     260:  00:C10F  E3                  		 ex	(sp),hl		; (SP)=adjusted command ptr, HL->start
     261:  00:C110  7E                  		 ld	a,(hl)		; Get and adjust length byte
     262:  00:C111  90                  		 sub	b
     263:  00:C112  47                  		 ld	b,a
     264:  00:C113  E1                  		pop	hl		; HL=adjusted command ptr
     265:  00:C114  EB                  		ex	de,hl		; Back in DE
     266:  00:C115                      		    ;
     267:  00:C115                      		    ;
     268:  00:C115                      		    ;
     269:  00:C115                      ;
     270:  00:C115                      ;------------------------------------------------------------------------------
     271:  00:C115                      ; unspace
     272:  00:C115                      ;
     273:  00:C115                      ; Skips leading spaces from a command at (DE)
     274:  00:C115                      ;
     275:  00:C115                      ; In:  DE->buffer length byte of command but the length is actually in B
     276:  00:C115                      ;       B=length of command
     277:  00:C115                      ; Out: DE may have been incremented but a new length byte is at (DE)
     278:  00:C115                      ;       B=length of the next word
     279:  00:C115                      ;      AF=flags set according to B (ie. Z if no more command) and NC
     280:  00:C115                      ;
     281:  00:C115                      unspace:
     282:  00:C115  04                  		inc	b		; Adjust for first time round loop
     283:  00:C116  13                  .loop:		inc	de		; Next char in command
     284:  00:C117  05                  		dec	b		; Dec length
     285:  00:C118  28 05               		jr	z,.setlen
     286:  00:C11A  1A                  		ld	a,(de)
     287:  00:C11B  FE 20               		cp	' '
     288:  00:C11D  28 F7               		jr	z,.loop		; Skip if space
     289:  00:C11F                      ;
     290:  00:C11F  1B                  .setlen:	dec	de		; DE->length byte
     291:  00:C120  78                  		ld	a,b
     292:  00:C121  12                  		ld	(de),a		; New length byte
     293:  00:C122                      
     294:  00:C122                      ; To make it EXOS compatible we need the length of the first command in B
     295:  00:C122  6B                  		ld	l,e		; HL->length byte of command
     296:  00:C123  62                  		ld	h,d
     297:  00:C124  06 FF               		ld	b,-1		; Count of chars in first word
     298:  00:C126  23                  .count:  	inc	hl
     299:  00:C127  04                  		inc	b		; B == length byte => end of line
     300:  00:C128  1A                  		ld	a,(de)
     301:  00:C129  90                  		sub	b
     302:  00:C12A  28 05               		jr	z,.ret		; A=0
     303:  00:C12C                      ;
     304:  00:C12C  7E                  		ld	a,(hl)
     305:  00:C12D  D6 20               		sub	' '
     306:  00:C12F  20 F5               		jr	nz,.count
     307:  00:C131                      ;
     308:  00:C131  B0                  .ret:		or	b		; NC
     309:  00:C132  C9                  		ret
     310:  00:C133                      ;
     311:  00:C133                      ;
     312:  00:C133                      ;==============================================================================
     313:  00:C133                      ; NET command
     314:  00:C133                      ;
     315:  00:C133  28 16               net:		jr	z,.nonet
     316:  00:C135                      ;
     317:  00:C135  21 E7 C3            		ld	hl,net_tab	; Find command in our command table
     318:  00:C138  CD E3 C0            		call	find		; HL=offset into command table
     319:  00:C13B  38 09               		jr	c,.badnet	; Go if not found
     320:  00:C13D                      ;
     321:  00:C13D  D5                  		push	de
     322:  00:C13E  11 09 C4            		 ld	de,net_cmd_tab
     323:  00:C141  19                  		 add	hl,de
     324:  00:C142  D1                  		pop	de
     325:  00:C143  C3 C9 C0            		jp	jp_cmd		; Jump to command code
     326:  00:C146                      ;
     327:  00:C146                      ;
     328:  00:C146  3E 6C               .badnet:	ld	a,exos.ERR_BADOPT
     329:  00:C148  0E 00               		ld	c,0
     330:  00:C14A  C9                  		ret
     331:  00:C14B                      ;
     332:  00:C14B  11 A7 C4            .nonet:		ld	de,net_help_str
     333:  00:C14E  CD 36 D0            		call	io.str
     334:  00:C151  AF                  		xor	a
     335:  00:C152  4F                  		ld	c,a
     336:  00:C153  C9                  		ret
     337:  00:C154                      ;
     338:  00:C154                      ;
     339:  00:C154                      ;------------------------------------------------------------------------------
     340:  00:C154                      ; NET START and NET DIAG commands
     341:  00:C154                      ;
     342:  00:C154                      ; NET DIAG is exactly the same as NET START except that it enables diagnostic
     343:  00:C154                      ; tracing.
     344:  00:C154                      ;
     345:  00:C154                      net_diag:
     346:  00:C154  FD 6E 00            		ld	l,(iy+vars._trace)
     347:  00:C157  E5                  		push	hl		; Save trace flags
     348:  00:C158  FD CB 00 C6         		 set	vars.trace.diag,(iy+vars._trace); Trace mode for diag
     349:  00:C15C  CD 64 C1            		 call	net_start	; Otherwise as :NET START
     350:  00:C15F  E1                  		pop	hl		; L=saved trace flags
     351:  00:C160  FD 75 00            		ld	(iy+vars._trace),l	; Restore trace flags
     352:  00:C163  C9                  		ret
     353:  00:C164                      ;
     354:  00:C164                      ;
     355:  00:C164  FD CB 03 86         net_start:	res	vars.init.wiz,(iy+vars._init)	; Pretend not started
     356:  00:C168                      		    ;
     357:  00:C168                      		    ;
     358:  00:C168                      		    ;
     359:  00:C168                      ;
     360:  00:C168                      ;
     361:  00:C168                      ; This is like net_start but is called from most other commands to make sure
     362:  00:C168                      ; the network is started.
     363:  00:C168                      ;
     364:  00:C168                      ; Preserves DE and B.
     365:  00:C168                      ; Returns C=0.
     366:  00:C168                      ;
     367:  00:C168  D5                  netstart:	push	de
     368:  00:C169  C5                  		push	bc
     369:  00:C16A  CD 1C D6            		 call	wiz.init	; Attempt to initialise WIZ module
     370:  00:C16D                      ;
     371:  00:C16D  9F                  do_dhcp:	 sbc	a,a		; NC=>0, Cy=>ff
     372:  00:C16E  E6 6E               		 and	exos.ERR_NONET	; 0 or .ERR_NONET
     373:  00:C170  20 10               		 jr	nz,.chk_stop	; Go if couldn't start
     374:  00:C172                      
     375:  00:C172  CD 83 D7            		 call	wiz.check_ip	; Check for duplicate IP address
     376:  00:C175  9F                  		 sbc	a,a
     377:  00:C176  E6 66               		 and	exos.ERR_DUPIP
     378:  00:C178  20 0B               		 jr	nz,.ret
     379:  00:C17A                      ;	 
     380:  00:C17A  CD 32 E2            		 call	dhcp.init	; Attempt to initilaise DHCP
     381:  00:C17D  9F                  		 sbc	a,a		; A=0 if NC (& still NC)
     382:  00:C17E  E6 6F               		 and	exos.ERR_DHCP	; 0 or .ERR_DHCP
     383:  00:C180  28 03               		 jr	z,.ret		; Go if no error
     384:  00:C182                      ;
     385:  00:C182                      .chk_stop:	 ; An error was returned - see if due to the STOP key
     386:  00:C182  CD D1 CA            		 call	exos.check_stop
     387:  00:C185  C1                  .ret:		pop	bc
     388:  00:C186  D1                  		pop	de
     389:  00:C187  0E 00               		ld	c,0		; Command recognised
     390:  00:C189  B7                  		or	a		; Z or NZ according to error
     391:  00:C18A  C9                  		ret
     392:  00:C18B                      ;
     393:  00:C18B                      ;
     394:  00:C18B                      ;------------------------------------------------------------------------------
     395:  00:C18B                      ; FTP command
     396:  00:C18B                      ;
     397:  00:C18B                      ; Syntax:
     398:  00:C18B                      ;
     399:  00:C18B                      ;	:FTP
     400:  00:C18B                      ;	:FTP <ip> or <url>
     401:  00:C18B                      ;	:FTP DIR, :FTP CD etc etc
     402:  00:C18B                      ;
     403:  00:C18B  28 23               ftp:		jr	z,.noftp
     404:  00:C18D                      ;
     405:  00:C18D  CD 68 C1            		call	netstart	; Make sure the net is started
     406:  00:C190  C0                  		ret	nz		; Return if couldn't
     407:  00:C191                      ;		
     408:  00:C191  CD AE D0            		call	status.start	; Start waiting indicator
     409:  00:C194                      ;
     410:  00:C194  21 19 C4            		ld	hl,ftp_tab	; Find FTP command in command table
     411:  00:C197  CD E3 C0            		call	find		; HL=offset into command table
     412:  00:C19A  38 0F               		jr	c,.badcmd	; Go if not found
     413:  00:C19C                      ;
     414:  00:C19C  D5                  		push	de		; Save command ptr
     415:  00:C19D  11 37 C4            		 ld	de,ftp_cmd_tab
     416:  00:C1A0  19                  		 add	hl,de
     417:  00:C1A1  D1                  		pop	de
     418:  00:C1A2  CD C9 C0            		call	jp_cmd
     419:  00:C1A5                      ;
     420:  00:C1A5  F5                  		push	af
     421:  00:C1A6  CD A2 D0            		call	status.stop	; Stop waiting indicator
     422:  00:C1A9  F1                  		pop	af
     423:  00:C1AA  C9                  		ret
     424:  00:C1AB                      ;
     425:  00:C1AB  3E 6C               .badcmd:	ld	a,exos.ERR_BADOPT
     426:  00:C1AD  0E 00               		ld	c,0
     427:  00:C1AF  C9                  		ret
     428:  00:C1B0                      ;
     429:  00:C1B0  11 EF C6            .noftp:		ld	de,ftp_help_str
     430:  00:C1B3  CD 36 D0            		call	io.str
     431:  00:C1B6  AF                  		xor	a
     432:  00:C1B7  0E 00               .ret:		ld	c,0
     433:  00:C1B9  C9                  		ret
     434:  00:C1BA                      ;
     435:  00:C1BA                      ftp_login:
     436:  00:C1BA                      					; ftp pathname
     437:  00:C1BA  21 53 40            		ld	hl,vars.ftp.ip
     438:  00:C1BD  D5                  		push	de
     439:  00:C1BE  C5                  		push	bc
     440:  00:C1BF  CD 71 D1            		 call	util.get_ip
     441:  00:C1C2  C1                  		pop	bc
     442:  00:C1C3  D1                  		pop	de
     443:  00:C1C4                      ;
     444:  00:C1C4  3E 6D               		ld	a,exos.ERR_BADIP	; Error if bad IP address
     445:  00:C1C6  38 19               		jr	c,.ret
     446:  00:C1C8                      ;
     447:  00:C1C8  CD 07 C1            		call	skip		; DE->next arg
     448:  00:C1CB                      ;
     449:  00:C1CB  21 53 40            		ld	hl,vars.ftp.ip
     450:  00:C1CE  3E 01               		ld	a,1		; Always use socket 1
     451:  00:C1D0  D5                  		push	de
     452:  00:C1D1  CD 91 E9            		 call	ftp.open_control
     453:  00:C1D4  D1                  		pop	de
     454:  00:C1D5  3E 6B               		ld	a,exos.ERR_NOCON
     455:  00:C1D7  38 08               		jr	c,.ret
     456:  00:C1D9                      ;
     457:  00:C1D9  CD C9 E9            		call	ftp.login
     458:  00:C1DC  3E 6B               		ld	a,exos.ERR_NOCON
     459:  00:C1DE  38 01               		jr	c,.ret
     460:  00:C1E0                      
     461:  00:C1E0                      
     462:  00:C1E0  AF                  		xor	a
     463:  00:C1E1  F5                  .ret:		push	af
     464:  00:C1E2  B7                  		or	a
     465:  00:C1E3  3E 01               		ld	a,1
     466:  00:C1E5  C4 D1 E1            		call	nz,tcp.close	; Close if we're returning an error
     467:  00:C1E8  F1                  		pop	af
     468:  00:C1E9  0E 00               		ld	c,0
     469:  00:C1EB  C9                  		ret
     470:  00:C1EC                      ;
     471:  00:C1EC                      ;
     472:  00:C1EC  3E 01               ftp_logout:	ld	a,1
     473:  00:C1EE  CD 96 EA            		call	ftp.logout
     474:  00:C1F1  3E 01               		ld	a,1
     475:  00:C1F3  CD D1 E1            		call	tcp.close
     476:  00:C1F6  AF                  		xor	a
     477:  00:C1F7  4F                  		ld	c,a
     478:  00:C1F8  C9                  		ret
     479:  00:C1F9                      ;
     480:  00:C1F9  3E 01               ftp_status:	ld	a,1
     481:  00:C1FB  CD FC EA            		call	ftp.status
     482:  00:C1FE  0E 00               		ld	c,0
     483:  00:C200  C9                  		ret
     484:  00:C201                      ;
     485:  00:C201  3E 01               ftp_cd:		ld	a,1
     486:  00:C203  CD 04 EB            		call	ftp.chdir
     487:  00:C206  0E 00               		ld	c,0
     488:  00:C208  C9                  		ret
     489:  00:C209                      ;
     490:  00:C209                      ftp_md:
     491:  00:C209  3E 01               		ld	a,1
     492:  00:C20B  CD 33 EB            		call	ftp.mkdir
     493:  00:C20E  0E 00               		ld	c,0
     494:  00:C210  C9                  		ret
     495:  00:C211                      ;
     496:  00:C211                      ftp_rd:
     497:  00:C211  3E 01               		ld	a,1
     498:  00:C213  CD 3B EB            		call	ftp.rmdir
     499:  00:C216  0E 00               		ld	c,0
     500:  00:C218  C9                  		ret
     501:  00:C219                      ;
     502:  00:C219                      ftp_del:
     503:  00:C219  3E 01               		ld	a,1
     504:  00:C21B  CD 43 EB            		call	ftp.del
     505:  00:C21E  0E 00               		ld	c,0
     506:  00:C220  C9                  		ret
     507:  00:C221                      ;
     508:  00:C221                      ;
     509:  00:C221                      ftp_ren:
     510:  00:C221  D5                  		push	de		; Save ->first arg
     511:  00:C222  C5                  		push	bc		; Save first arg length
     512:  00:C223  CD 07 C1            		 call	skip
     513:  00:C226  C1                  		pop	bc		; B=first arg length
     514:  00:C227  E1                  		pop	hl		; HL->first arg
     515:  00:C228  70                  		ld	(hl),b		; Set proper length
     516:  00:C229                      ;
     517:  00:C229  EB                  		ex	de,hl		; DE->first arg, HL->second arg
     518:  00:C22A  3E 01               		ld	a,1
     519:  00:C22C  CD 4B EB            		call	ftp.ren
     520:  00:C22F  0E 00               		ld	c,0
     521:  00:C231  C9                  		ret
     522:  00:C232                      ;
     523:  00:C232  3E 01               ftp_dir:	ld	a,1
     524:  00:C234  CD 9F EA            		call	ftp.dir
     525:  00:C237  0E 00               		ld	c,0
     526:  00:C239  C9                  		ret
     527:  00:C23A                      ;
     528:  00:C23A                      ;
     529:  00:C23A                      ;------------------------------------------------------------------------------
     530:  00:C23A                      ; PING command
     531:  00:C23A                      ;
     532:  00:C23A                      ; eg. :NET PING 192.168.1.64
     533:  00:C23A                      ;
     534:  00:C23A                      ping:
     535:  00:C23A  28 2A               		jr	z,.noping	; No args - just print help text
     536:  00:C23C                      ;
     537:  00:C23C  CD 68 C1            		call	netstart	; Make sure the network is started
     538:  00:C23F  C0                  		ret	nz		; Ret if error starting
     539:  00:C240                      ;
     540:  00:C240  C5                  		push	bc
     541:  00:C241  D5                  		push	de
     542:  00:C242  21 49 40            		 ld	hl,vars.ping.ip
     543:  00:C245  CD 71 D1            		 call	util.get_ip	; Read IP address from command line
     544:  00:C248  D1                  		pop	de
     545:  00:C249  C1                  		pop	bc
     546:  00:C24A                      ;
     547:  00:C24A  3E 6D               		ld	a,exos.ERR_BADIP
     548:  00:C24C  38 15               		jr	c,.ret		; Go if invalid
     549:  00:C24E                      ;
     550:  00:C24E  CD 07 C1            		call	skip		; Make sure nothing following
     551:  00:C251  3E 6D               		ld	a,exos.ERR_BADIP
     552:  00:C253  20 0E               		jr	nz,.ret		; Go if there was
     553:  00:C255                      ;
     554:  00:C255  21 49 40            		ld	hl,vars.ping.ip
     555:  00:C258  CD EF E6            		call	ping.init	; Do ping
     556:  00:C25B  9F                  		sbc	a,a		; A=0 if NC (& still NC)
     557:  00:C25C  30 05               		jr	nc,.ret
     558:  00:C25E                      ;
     559:  00:C25E  3E 6E               		ld	a,exos.ERR_NONET
     560:  00:C260  CD D1 CA            		call	exos.check_stop
     561:  00:C263  0E 00               .ret:		ld	c,0
     562:  00:C265  C9                  		ret
     563:  00:C266                      ;
     564:  00:C266  11 F0 C8            .noping:	ld	de,ping_help_str
     565:  00:C269  CD 36 D0            		call	io.str
     566:  00:C26C  AF                  		xor	a
     567:  00:C26D  4F                  		ld	c,a
     568:  00:C26E  C9                  		ret
     569:  00:C26F                      ;
     570:  00:C26F                      ;
     571:  00:C26F                      ;------------------------------------------------------------------------------
     572:  00:C26F                      ; TRACE command
     573:  00:C26F                      ;
     574:  00:C26F                      ; Use: TRACE [ON|RAW|OFF]* 
     575:  00:C26F                      ;
     576:  00:C26F                      ; eg. :NET TRACE		- Same as :NET TRACE ON
     577:  00:C26F                      ;     :NET TRACE ON		- Turns on protocol and socket tracing
     578:  00:C26F                      ;     :NET TRACE RAW		- As n:TRACE ON but additionally raw bytes
     579:  00:C26F                      ;     :NET TRACE OFF		- All tracing off
     580:  00:C26F                      ;
     581:  00:C26F                      ; So it is not possible to just have raw bytes.
     582:  00:C26F                      ;
     583:  00:C26F                      ; Currently all the EPNET code allows each protocol to be enabled separately,
     584:  00:C26F                      ; but this is over complicated for the user command so we just have ON and RAW.
     585:  00:C26F                      ;
     586:  00:C26F  3E 7E               trace:		ld	a,vars.trace.all_mask; ON (all but raw & diag)
     587:  00:C271  28 0F               		jr	z,.noarg	; Default to ON if no args
     588:  00:C273                      ;
     589:  00:C273  21 8D C2            		ld	hl,trace_str_tab; Find trace command in command table
     590:  00:C276  CD E3 C0            		call	find		; HL=offset into command table
     591:  00:C279  38 0D               		jr	c,.badcmd	; Go if not found
     592:  00:C27B                      ;
     593:  00:C27B  11 95 C2            		ld	de,trace_value_tab
     594:  00:C27E  CB 3D               		srl	l		; /2 cos 1-byte table
     595:  00:C280  19                  		add	hl,de
     596:  00:C281  7E                  		ld	a,(hl)
     597:  00:C282  32 07 40            .noarg:		ld	(vars.trace),a
     598:  00:C285  AF                  		xor	a		; No error
     599:  00:C286  4F                  		ld	c,a		; Command recognized
     600:  00:C287  C9                  		ret
     601:  00:C288                      ;
     602:  00:C288  3E 6C               .badcmd:	ld	a,exos.ERR_BADOPT
     603:  00:C28A  0E 00               		ld	c,0
     604:  00:C28C  C9                  		ret
     605:  00:C28D                      ;
     606:  00:C28D                      ;
     607:  00:C28D  98 C2               trace_str_tab:	dw	 on_str		; :TRACE <opt>
     608:  00:C28F  9C C2               		dw	off_str
     609:  00:C291  A1 C2               		dw	raw_str
     610:  00:C293  00 00               		dw	0
     611:  00:C295                      ;
     612:  00:C295  7F                  trace_value_tab:db	low ~vars.trace.raw_mask; ON => all but raw bit on
     613:  00:C296  00                  		db	0			; 0  => all off
     614:  00:C297  FF                  		db	0ffh			; RAW=> all on
     615:  00:C298                      ;
     616:  00:C298                      ;
     617:  00:C298                      ; These need length bytes (for command table) AND terminating nulls (for
     618:  00:C298                      ; printing)!
     619:  00:C298                      ;
     620:  00:C298  02 4F 4E 00         on_str:		db	2,"ON",0
     621:  00:C29C  03 4F 46 46 00      off_str:	db	3,"OFF",0
     622:  00:C2A1  03 52 41 57 00      raw_str:	db	3,"RAW",0
     623:  00:C2A6                      ;
     624:  00:C2A6                      ;
     625:  00:C2A6                      ;------------------------------------------------------------------------------
     626:  00:C2A6                      ; STATUS command
     627:  00:C2A6                      ;
     628:  00:C2A6                      ; The NET STATUS command. Prints out current IP address etc
     629:  00:C2A6                      ;
     630:  00:C2A6  28 16               status:		jr	z,.doit
     631:  00:C2A8                      ;
     632:  00:C2A8  21 64 C3            		ld	hl,.surprise_str
     633:  00:C2AB  CD CE C0            		call	compare
     634:  00:C2AE  20 09               		jr	nz,.badopt
     635:  00:C2B0                      ;
     636:  00:C2B0  11 4F C3            		ld	de,.easteregg_str
     637:  00:C2B3  CD 36 D0            		call	io.str
     638:  00:C2B6                      ;
     639:  00:C2B6  AF                  .ret:		xor	a
     640:  00:C2B7  4F                  		ld	c,a
     641:  00:C2B8  C9                  		ret
     642:  00:C2B9                      ;
     643:  00:C2B9  3E 6C               .badopt:	ld	a,exos.ERR_BADOPT
     644:  00:C2BB  0E 00               		ld	c,0
     645:  00:C2BD  C9                  		ret
     646:  00:C2BE                      
     647:  00:C2BE  CD 68 C1            .doit:		call	netstart	; Make sure EPNET has started
     648:  00:C2C1  C0                  		ret	nz		; Return if error starting
     649:  00:C2C2                      ;
     650:  00:C2C2  CD CD D7            		call	wiz.get_MAC	; Print MAC address
     651:  00:C2C5  11 67 C3            		ld	de,.mac_str
     652:  00:C2C8  CD 36 D0            		call	io.str
     653:  00:C2CB  CD 7B CF            		call	io.mac
     654:  00:C2CE  CD 21 D0            		call	io.crlf
     655:  00:C2D1                      ;
     656:  00:C2D1  CD E4 D7            		call	wiz.get_ip	; Print IP address
     657:  00:C2D4  11 6D C3            		ld	de,.ip_str
     658:  00:C2D7  CD 16 D0            		call	io.ipcrlf
     659:  00:C2DA                      ;
     660:  00:C2DA  CD FB D7            		call	wiz.get_subnet	; Print subnet mask
     661:  00:C2DD  11 72 C3            		ld	de,.subnet_str
     662:  00:C2E0  CD 16 D0            		call	io.ipcrlf
     663:  00:C2E3                      ;
     664:  00:C2E3  CD 3B D8            		call	wiz.get_gateway	; Print gateway
     665:  00:C2E6  11 7B C3            		ld	de,.gateway_str
     666:  00:C2E9  CD 16 D0            		call	io.ipcrlf
     667:  00:C2EC                      ;
     668:  00:C2EC                      		; Print each socket status
     669:  00:C2EC  11 84 C3            		ld	de,.heading
     670:  00:C2EF  CD 36 D0            		call	io.str
     671:  00:C2F2  AF                  		xor	a		; Start with socket 0
     672:  00:C2F3  F5                  .loop:		push	af		; Save socket number
     673:  00:C2F4  CD A7 CF            		 call	io.short	; Print socket number
     674:  00:C2F7  CD 2A D0            		 call	io.space
     675:  00:C2FA  F1                  		pop	af		; A=socket number
     676:  00:C2FB                      ;
     677:  00:C2FB  F5                  		push	af		; Save socket number
     678:  00:C2FC  CD 01 DD            		 call	socket.status	; HL=Sn_SSR value
     679:  00:C2FF  4D                  		 ld	c,l		; Save status
     680:  00:C300  7D                  		 ld	a,l		; A=Sn_SSR value, high byte ignored
     681:  00:C301  FE 00               		 cp	w5300.Sn_SSR_CLOSED
     682:  00:C303  28 0B               		 jr	z,.doneowner	; Don't print owner if closed
     683:  00:C305                      ;
     684:  00:C305  F1                  		pop	af		; A=socket number
     685:  00:C306  F5                  		push	af		; Save socket number
     686:  00:C307  C5                  		 push	bc		; Save status in C
     687:  00:C308  CD 18 DE            		  call	socket.get_owner; HL->owner string
     688:  00:C30B  EB                  		  ex	de,hl		; DE->owner
     689:  00:C30C  CD 36 D0            		  call	io.str		; Print owner
     690:  00:C30F  C1                  		 pop	bc		; C=socket status
     691:  00:C310                      ;
     692:  00:C310  CD 2E D0            .doneowner:	 call	io.tab
     693:  00:C313  F1                  		pop	af		; A=socket number
     694:  00:C314                      ;
     695:  00:C314  F5                  		push	af		; Save socket number
     696:  00:C315  79                  		 ld	a,c		; A=status value
     697:  00:C316  F5                  		 push	af		; Save status value
     698:  00:C317  CD 12 DD            		  call	socket.status_str	; HL->descriptive string
     699:  00:C31A  38 05               		  jr	c,.nostr	; Go with Cy if not found
     700:  00:C31C                      ;
     701:  00:C31C  EB                  		  ex	de,hl		; DE->string
     702:  00:C31D  CD 36 D0            		  call	io.str		; Print status description
     703:  00:C320  B7                  		  or	a		; NC
     704:  00:C321  DC E6 CF            .nostr:		  call	c,io.byte	; No string so print number
     705:  00:C324  F1                  		 pop	af		; Get status value
     706:  00:C325  FE 17               		 cp	w5300.Sn_SSR_ESTAB
     707:  00:C327  20 1A               		 jr	nz,.doneone	; Go if not TCP ESTABLISHED state
     708:  00:C329                      ;
     709:  00:C329  F1                  		pop	af		; A=socket number
     710:  00:C32A  F5                  		push	af		; Save socket number
     711:  00:C32B  21 1E 40            		 ld	hl,vars.command.ip	; HL->buffer for IP
     712:  00:C32E  E5                  		 push	hl		; Save->buffer for IP
     713:  00:C32F  CD 1F DC            		  call	socket.read_DIPR	; Read IP
     714:  00:C332  CD 3E DC            		  call	socket.read_DPORTR	; HL=DPORTR
     715:  00:C335  4D                  		  ld	c,l
     716:  00:C336  44                  		  ld	b,h		; BC=port number
     717:  00:C337  E1                  		 pop	hl		; HL->ip address
     718:  00:C338                      ;
     719:  00:C338  C5                  		 push	bc		; Save port
     720:  00:C339  11 A6 C3            		  ld	de,.to_str	; Print " to "
     721:  00:C33C  CD 36 D0            		  call	io.str
     722:  00:C33F  C1                  		 pop	bc		; BC=port
     723:  00:C340  CD 9B CF            		 call	io.ip_port	; Print IP and port
     724:  00:C343  CD 21 D0            .doneone:	 call	io.crlf
     725:  00:C346  F1                  		pop	af		; A=socket number
     726:  00:C347  3C                  		inc	a		; Next socket
     727:  00:C348  FE 08               		cp	wiz.SOCKETS	; Done all?
     728:  00:C34A  38 A7               		jr	c,.loop		; Do next if not
     729:  00:C34C                      ;
     730:  00:C34C  AF                  		xor	a		; No error
     731:  00:C34D  4F                  		ld	c,a		; Command recognised
     732:  00:C34E  C9                  		ret
     733:  00:C34F                      ;
     734:  00:C34F                      .easteregg_str:	db	"Written by BT 2015",CR,LF,0
     734:  00:C34F  57 72 69 74 74 65 6E 20 62 79 20 42 54 20 32 30 
     734:  00:C35F  31 35 0D 0A 00 
     735:  00:C364                      ;
     736:  00:C364  02 34 32            .surprise_str:	db	2,"42"
     737:  00:C367                      ;
     738:  00:C367  4D 41 43 3A 09 00   .mac_str:	db	"MAC:\t",0
     739:  00:C36D  49 50 3A 09 00      .ip_str:	db	"IP:\t",0
     740:  00:C372                      .subnet_str:	db	"Subnet:\t",0
     740:  00:C372  53 75 62 6E 65 74 3A 09 00 
     741:  00:C37B                      .gateway_str:	db	"Gateway:",0
     741:  00:C37B  47 61 74 65 77 61 79 3A 00 
     742:  00:C384                      ;
     743:  00:C384  0D 0A               .heading:	db	CR,LF
     744:  00:C386                      		db	"S OWNER\tSTATE",CR,LF
     744:  00:C386  53 20 4F 57 4E 45 52 09 53 54 41 54 45 0D 0A 
     745:  00:C395                      		db	"--------------",CR,LF
     745:  00:C395  2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 2D 0D 0A 
     746:  00:C3A5  00                  		db	0
     747:  00:C3A6                      ;
     748:  00:C3A6  20 74 6F 20 00      .to_str:	db	" to ",0
     749:  00:C3AB                      ;
     750:  00:C3AB                      ;
     751:  00:C3AB                      ;------------------------------------------------------------------------------
     752:  00:C3AB                      ; TIME command
     753:  00:C3AB                      ;
     754:  00:C3AB                      ; The NET TIME command. Gets the time and date from the network
     755:  00:C3AB                      ;
     756:  00:C3AB  CD 68 C1            time:		call	netstart
     757:  00:C3AE  C0                  		ret	nz
     758:  00:C3AF                      ;		
     759:  00:C3AF  CD 62 E8            		call	ntp.init
     760:  00:C3B2  9F                  		sbc	a,a		; A=0 if NC (& still NC)
     761:  00:C3B3  30 05               		jr	nc,.ret
     762:  00:C3B5                      ;
     763:  00:C3B5  3E 67               		ld	a,exos.ERR_NOTIME
     764:  00:C3B7  CD D1 CA            		call	exos.check_stop
     765:  00:C3BA                      ;
     766:  00:C3BA  0E 00               .ret:		ld	c,0		; Command recognised
     767:  00:C3BC  C9                  		ret
     768:  00:C3BD                      ;
     769:  00:C3BD                      ;
     770:  00:C3BD                      ;------------------------------------------------------------------------------
     771:  00:C3BD                      ; special
     772:  00:C3BD                      ;
     773:  00:C3BD                      ; This is a special command that cannot be typed by the user. It is used by
     774:  00:C3BD                      ; our ROM devices to find out our variable's RAM segment. This is allocated
     775:  00:C3BD                      ; by this EXOS extension so EXOS tells us about it here, in fact pages it in
     776:  00:C3BD                      ; to page 1 for us, but does not tell the devices about it, hence this call.
     777:  00:C3BD                      ;
     778:  00:C3BD                      ; Out:  B=RAM segment no.
     779:  00:C3BD                      ;       C=I/O base address
     780:  00:C3BD                      ;
     781:  00:C3BD  DB B1               special:	in	a,(ep.P1)	; Get RAM segment
     782:  00:C3BF  47                  		ld	b,a		; Return in B
     783:  00:C3C0                      ;
     784:  00:C3C0  3A 0D C0            		ld	a,(io)		; Get fixed ROM i/o address byte
     785:  00:C3C3  B7                  		or	a		; Using fixed i/o?
     786:  00:C3C4  20 03               		jr	nz,.gotio	; <>0 => yes
     787:  00:C3C6                      ;
     788:  00:C3C6  DB B3               		in	a,(ep.P3)	; Else get our ROM seg no
     789:  00:C3C8  0F                  		rrca			; /2 gives i/o base address
     790:  00:C3C9  5F                  .gotio:		ld	e,a		; Return I/O in E
     791:  00:C3CA  AF                  		xor	a
     792:  00:C3CB  4F                  		ld	c,a
     793:  00:C3CC  C9                  		ret
     794:  00:C3CD                      ;
     795:  00:C3CD                      ;
     796:  00:C3CD                      ;------------------------------------------------------------------------------
     797:  00:C3CD                      ; main commands - string table, help string table and jump table in same order!
     798:  00:C3CD                      ;
     799:  00:C3CD  8D CA               main_tab:	dw	    net_str
     800:  00:C3CF  91 CA               		dw	    ftp_str
     801:  00:C3D1  A0 CA               		dw	   ping_str
     802:  00:C3D3  BC CA               		dw	special_str
     803:  00:C3D5  00 00               		dw	0
     804:  00:C3D7                      ;
     805:  00:C3D7  A7 C4               main_help_tab:	dw	    net_help_str	; Same order as above
     806:  00:C3D9  EF C6               		dw	    ftp_help_str
     807:  00:C3DB  F0 C8               		dw	   ping_help_str
     808:  00:C3DD  A6 C4               		dw	special_help_str
     809:  00:C3DF                      ;
     810:  00:C3DF  33 C1               main_cmd_tab:	dw	net		; Same order as above
     811:  00:C3E1  8B C1               		dw	ftp
     812:  00:C3E3  3A C2               		dw	ping
     813:  00:C3E5  BD C3               		dw	special
     814:  00:C3E7                      ;
     815:  00:C3E7                      ;
     816:  00:C3E7                      ;------------------------------------------------------------------------------
     817:  00:C3E7                      ; NET sub-commands - string table, help string table and jump table in same order!
     818:  00:C3E7                      ;
     819:  00:C3E7  9A CA               net_tab:	dw	 start_str
     820:  00:C3E9  95 CA               		dw	  diag_str
     821:  00:C3EB  91 CA               		dw	   ftp_str
     822:  00:C3ED  A5 CA               		dw	 trace_str
     823:  00:C3EF  A0 CA               		dw	  ping_str
     824:  00:C3F1  AB CA               		dw	status_str
     825:  00:C3F3  B2 CA               		dw	  time_str
     826:  00:C3F5  B7 CA               		dw	  help_str
     827:  00:C3F7  00 00               		dw	0
     828:  00:C3F9                      ;
     829:  00:C3F9  A8 C6               net_help_tab:	dw	 start_help_str	; Same order as above
     830:  00:C3FB  67 C6               		dw	  diag_help_str
     831:  00:C3FD  EF C6               		dw	   ftp_help_str
     832:  00:C3FF  55 C9               		dw	 trace_help_str
     833:  00:C401  F0 C8               		dw	  ping_help_str
     834:  00:C403  04 CA               		dw	status_help_str
     835:  00:C405  46 CA               		dw	  time_help_str
     836:  00:C407  A7 C4               		dw	  help_help_str
     837:  00:C409                      ;
     838:  00:C409  64 C1               net_cmd_tab:	dw	net_start	; Same order as above
     839:  00:C40B  54 C1               		dw	net_diag
     840:  00:C40D  8B C1               		dw	ftp
     841:  00:C40F  6F C2               		dw	trace
     842:  00:C411  3A C2               		dw	ping
     843:  00:C413  A6 C2               		dw	status
     844:  00:C415  AB C3               		dw	time
     845:  00:C417  8F C0               		dw	nethelp
     846:  00:C419                      ;
     847:  00:C419                      ;
     848:  00:C419                      ;------------------------------------------------------------------------------
     849:  00:C419                      ; FTP sub-commands - string table and jump table, in same order!
     850:  00:C419                      ;
     851:  00:C419  53 C4               ftp_tab:	dw	login_str
     852:  00:C41B  59 C4               		dw	logout_str
     853:  00:C41D  AB CA               		dw	status_str
     854:  00:C41F  60 C4               		dw	dir_str
     855:  00:C421  64 C4               		dw	cd_str
     856:  00:C423  67 C4               		dw	del_str
     857:  00:C425  6B C4               		dw	era_str
     858:  00:C427  6F C4               		dw	erase_str
     859:  00:C429  75 C4               		dw	ren_str
     860:  00:C42B  79 C4               		dw	rename_str
     861:  00:C42D  80 C4               		dw	md_str
     862:  00:C42F  83 C4               		dw	mkdir_str
     863:  00:C431  89 C4               		dw	rd_str
     864:  00:C433  8C C4               		dw	rmdir_str
     865:  00:C435  00 00               		dw	0
     866:  00:C437                      ;
     867:  00:C437  BA C1               ftp_cmd_tab:	dw	ftp_login	; :FTP LOGIN
     868:  00:C439  EC C1               		dw	ftp_logout	; :FTP LOGOUT
     869:  00:C43B  F9 C1               		dw	ftp_status	; :FTP STATUS
     870:  00:C43D  32 C2               		dw	ftp_dir		; :FTP DIR
     871:  00:C43F  01 C2               		dw	ftp_cd		; :FTP CD
     872:  00:C441  19 C2               		dw	ftp_del		; :FTP DEL
     873:  00:C443  19 C2               		dw	ftp_del		; :FTP ERA
     874:  00:C445  19 C2               		dw	ftp_del		; :FTP_ERASE
     875:  00:C447  21 C2               		dw	ftp_ren		; :FTP REN
     876:  00:C449  21 C2               		dw	ftp_ren		; :FTP RENAME
     877:  00:C44B  09 C2               		dw	ftp_md		; :FTP MD
     878:  00:C44D  09 C2               		dw	ftp_md		; :FTP MKDIR
     879:  00:C44F  11 C2               		dw	ftp_rd		; :FTP RD
     880:  00:C451  11 C2               		dw	ftp_rd		; :FTP RMDIR
     881:  00:C453                      ;
     882:  00:C453                      ;
     883:  00:C453                      ;
     884:  00:C453  05 4C 4F 47 49 4E   login_str:	db	5,"LOGIN"
     885:  00:C459                      logout_str:	db	6,"LOGOUT"
     885:  00:C459  06 4C 4F 47 4F 55 54 
     886:  00:C460  03 44 49 52         dir_str:	db	3,"DIR"
     887:  00:C464  02 43 44            cd_str:		db	2,"CD"
     888:  00:C467  03 44 45 4C         del_str:	db	3,"DEL"
     889:  00:C46B  03 45 52 41         era_str:	db	3,"ERA"
     890:  00:C46F  05 45 52 41 53 45   erase_str:	db	5,"ERASE"
     891:  00:C475  03 52 45 4E         ren_str:	db	3,"REN"
     892:  00:C479                      rename_str:	db	6,"RENAME"
     892:  00:C479  06 52 45 4E 41 4D 45 
     893:  00:C480  02 4D 44            md_str:		db	2,"MD"
     894:  00:C483  05 4D 4B 44 49 52   mkdir_str:	db	5,"MKDIR"
     895:  00:C489  02 52 44            rd_str:		db	2,"RD"
     896:  00:C48C  05 52 4D 44 49 52   rmdir_str:	db	5,"RMDIR"
     897:  00:C492                      ;
     898:  00:C492                      ;------------------------------------------------------------------------------
     899:  00:C492                      ; HELP text
     900:  00:C492                      ;
     901:  00:C492                      version_str:	db	"NET   version "
     901:  00:C492  4E 45 54 20 20 20 76 65 72 73 69 6F 6E 20 
     902:  00:C4A0  30 2E 31 32 0D 0A   		db	version.major, ".", version.minor, version.revision,CR,LF
     903:  00:C4A6  00                  special_help_str: db	0
     904:  00:C4A7                      ;
     905:  00:C4A7                      ;
     906:  00:C4A7                      ; All the help text below is designed to look OK on both a 40 and 80 column
     907:  00:C4A7                      ; screen
     908:  00:C4A7                      ;
     909:  00:C4A7                      ; 40 col screen limit:	 |........|.........|.........|.........|
     910:  00:C4A7                      ;
     911:  00:C4A7                      help_help_str:
     912:  00:C4A7                      net_help_str	db	"Available :NET commands:",CR,LF
     912:  00:C4A7  41 76 61 69 6C 61 62 6C 65 20 3A 4E 45 54 20 63 
     912:  00:C4B7  6F 6D 6D 61 6E 64 73 3A 0D 0A 
     913:  00:C4C1  0D 0A               		db	CR,LF
     914:  00:C4C3                      		db	"NET START  starts the network", CR,LF
     914:  00:C4C3  4E 45 54 20 53 54 41 52 54 20 20 73 74 61 72 74 
     914:  00:C4D3  73 20 74 68 65 20 6E 65 74 77 6F 72 6B 0D 0A 
     915:  00:C4E2                      		db	"NET DIAG   helps diagnose problems",CR,LF
     915:  00:C4E2  4E 45 54 20 44 49 41 47 20 20 20 68 65 6C 70 73 
     915:  00:C4F2  20 64 69 61 67 6E 6F 73 65 20 70 72 6F 62 6C 65 
     915:  00:C502  6D 73 0D 0A 
     916:  00:C506                      		db	"NET FTP    FTP commands",CR,LF
     916:  00:C506  4E 45 54 20 46 54 50 20 20 20 20 46 54 50 20 63 
     916:  00:C516  6F 6D 6D 61 6E 64 73 0D 0A 
     917:  00:C51F                      		db	"NET PING   tests network communication",CR,LF
     917:  00:C51F  4E 45 54 20 50 49 4E 47 20 20 20 74 65 73 74 73 
     917:  00:C52F  20 6E 65 74 77 6F 72 6B 20 63 6F 6D 6D 75 6E 69 
     917:  00:C53F  63 61 74 69 6F 6E 0D 0A 
     918:  00:C547                      		db	"NET TRACE  sets diagnostic tracing",CR,LF
     918:  00:C547  4E 45 54 20 54 52 41 43 45 20 20 73 65 74 73 20 
     918:  00:C557  64 69 61 67 6E 6F 73 74 69 63 20 74 72 61 63 69 
     918:  00:C567  6E 67 0D 0A 
     919:  00:C56B                      		db	"NET STATUS shows network status",CR,LF
     919:  00:C56B  4E 45 54 20 53 54 41 54 55 53 20 73 68 6F 77 73 
     919:  00:C57B  20 6E 65 74 77 6F 72 6B 20 73 74 61 74 75 73 0D 
     919:  00:C58B  0A 
     920:  00:C58C                      		db	"NET TIME   sets the system time & date",CR,LF
     920:  00:C58C  4E 45 54 20 54 49 4D 45 20 20 20 73 65 74 73 20 
     920:  00:C59C  74 68 65 20 73 79 73 74 65 6D 20 74 69 6D 65 20 
     920:  00:C5AC  26 20 64 61 74 65 0D 0A 
     921:  00:C5B4  0D 0A               		db	CR,LF
     922:  00:C5B6                      		db	"Type :HELP NET <cmd> for specific help",CR,LF
     922:  00:C5B6  54 79 70 65 20 3A 48 45 4C 50 20 4E 45 54 20 3C 
     922:  00:C5C6  63 6D 64 3E 20 66 6F 72 20 73 70 65 63 69 66 69 
     922:  00:C5D6  63 20 68 65 6C 70 0D 0A 
     923:  00:C5DE  0D 0A               		db	CR,LF
     924:  00:C5E0                      		db	"Several EXOS devices are available",CR,LF
     924:  00:C5E0  53 65 76 65 72 61 6C 20 45 58 4F 53 20 64 65 76 
     924:  00:C5F0  69 63 65 73 20 61 72 65 20 61 76 61 69 6C 61 62 
     924:  00:C600  6C 65 0D 0A 
     925:  00:C604                      		db	"eg. load \"HTTP:192.168.1.1/demo.bas\"",CR,LF
     925:  00:C604  65 67 2E 20 6C 6F 61 64 20 22 48 54 54 50 3A 31 
     925:  00:C614  39 32 2E 31 36 38 2E 31 2E 31 2F 64 65 6D 6F 2E 
     925:  00:C624  62 61 73 22 0D 0A 
     926:  00:C62A                      		db	"    load \"FTP:demo.bas\"",CR,LF
     926:  00:C62A  20 20 20 20 6C 6F 61 64 20 22 46 54 50 3A 64 65 
     926:  00:C63A  6D 6F 2E 62 61 73 22 0D 0A 
     927:  00:C643                      		db	"    open #1:\"TCP:192.168.1.64-80\"",CR,LF
     927:  00:C643  20 20 20 20 6F 70 65 6E 20 23 31 3A 22 54 43 50 
     927:  00:C653  3A 31 39 32 2E 31 36 38 2E 31 2E 36 34 2D 38 30 
     927:  00:C663  22 0D 0A 
     928:  00:C666  00                  		db	0
     929:  00:C667                      ;
     930:  00:C667                      diag_help_str	db	"NET DIAG is the same as NET START "
     930:  00:C667  4E 45 54 20 44 49 41 47 20 69 73 20 74 68 65 20 
     930:  00:C677  73 61 6D 65 20 61 73 20 4E 45 54 20 53 54 41 52 
     930:  00:C687  54 20 
     931:  00:C689                      		db	"but with diagnostic messages",CR,LF,0
     931:  00:C689  62 75 74 20 77 69 74 68 20 64 69 61 67 6E 6F 73 
     931:  00:C699  74 69 63 20 6D 65 73 73 61 67 65 73 0D 0A 00 
     932:  00:C6A8                      ;
     933:  00:C6A8                      start_help_str	db	"NET START starts the network and "
     933:  00:C6A8  4E 45 54 20 53 54 41 52 54 20 73 74 61 72 74 73 
     933:  00:C6B8  20 74 68 65 20 6E 65 74 77 6F 72 6B 20 61 6E 64 
     933:  00:C6C8  20 
     934:  00:C6C9                      		db	"gets the IP address etc. using DHCP",CR,LF
     934:  00:C6C9  67 65 74 73 20 74 68 65 20 49 50 20 61 64 64 72 
     934:  00:C6D9  65 73 73 20 65 74 63 2E 20 75 73 69 6E 67 20 44 
     934:  00:C6E9  48 43 50 0D 0A 
     935:  00:C6EE  00                  		db	0
     936:  00:C6EF                      ;
     937:  00:C6EF                      ftp_help_str	db	"NET FTP connects to a remote FTP server "
     937:  00:C6EF  4E 45 54 20 46 54 50 20 63 6F 6E 6E 65 63 74 73 
     937:  00:C6FF  20 74 6F 20 61 20 72 65 6D 6F 74 65 20 46 54 50 
     937:  00:C70F  20 73 65 72 76 65 72 20 
     938:  00:C717                      		db	"and provides various commands:",CR,LF
     938:  00:C717  61 6E 64 20 70 72 6F 76 69 64 65 73 20 76 61 72 
     938:  00:C727  69 6F 75 73 20 63 6F 6D 6D 61 6E 64 73 3A 0D 0A 
     939:  00:C737  0D 0A               		db	CR,LF
     940:  00:C739                      		db	"FTP LOGIN <host> connects to a server",CR,LF
     940:  00:C739  46 54 50 20 4C 4F 47 49 4E 20 3C 68 6F 73 74 3E 
     940:  00:C749  20 63 6F 6E 6E 65 63 74 73 20 74 6F 20 61 20 73 
     940:  00:C759  65 72 76 65 72 0D 0A 
     941:  00:C760                      		db	"FTP LOGOUT disconnects from a server",CR,LF
     941:  00:C760  46 54 50 20 4C 4F 47 4F 55 54 20 64 69 73 63 6F 
     941:  00:C770  6E 6E 65 63 74 73 20 66 72 6F 6D 20 61 20 73 65 
     941:  00:C780  72 76 65 72 0D 0A 
     942:  00:C786                      		db	"FTP STATUS displays server information",CR,LF
     942:  00:C786  46 54 50 20 53 54 41 54 55 53 20 64 69 73 70 6C 
     942:  00:C796  61 79 73 20 73 65 72 76 65 72 20 69 6E 66 6F 72 
     942:  00:C7A6  6D 61 74 69 6F 6E 0D 0A 
     943:  00:C7AE                      		db	"FTP DIR    lists remote directory",CR,LF
     943:  00:C7AE  46 54 50 20 44 49 52 20 20 20 20 6C 69 73 74 73 
     943:  00:C7BE  20 72 65 6D 6F 74 65 20 64 69 72 65 63 74 6F 72 
     943:  00:C7CE  79 0D 0A 
     944:  00:C7D1                      		db	"FTP CD     changes remote directory",CR,LF
     944:  00:C7D1  46 54 50 20 43 44 20 20 20 20 20 63 68 61 6E 67 
     944:  00:C7E1  65 73 20 72 65 6D 6F 74 65 20 64 69 72 65 63 74 
     944:  00:C7F1  6F 72 79 0D 0A 
     945:  00:C7F6                      		db	"FTP DEL    deletes remote files",CR,LF
     945:  00:C7F6  46 54 50 20 44 45 4C 20 20 20 20 64 65 6C 65 74 
     945:  00:C806  65 73 20 72 65 6D 6F 74 65 20 66 69 6C 65 73 0D 
     945:  00:C816  0A 
     946:  00:C817                      		db	"FTP REN    renames remote file",CR,LF
     946:  00:C817  46 54 50 20 52 45 4E 20 20 20 20 72 65 6E 61 6D 
     946:  00:C827  65 73 20 72 65 6D 6F 74 65 20 66 69 6C 65 0D 0A 
     947:  00:C837                      		db	"FTP MD     makes remote directory",CR,LF
     947:  00:C837  46 54 50 20 4D 44 20 20 20 20 20 6D 61 6B 65 73 
     947:  00:C847  20 72 65 6D 6F 74 65 20 64 69 72 65 63 74 6F 72 
     947:  00:C857  79 0D 0A 
     948:  00:C85A                      		db	"FTP RD     removes remote directory",CR,LF
     948:  00:C85A  46 54 50 20 52 44 20 20 20 20 20 72 65 6D 6F 76 
     948:  00:C86A  65 73 20 72 65 6D 6F 74 65 20 64 69 72 65 63 74 
     948:  00:C87A  6F 72 79 0D 0A 
     949:  00:C87F  0D 0A               		db	CR,LF
     950:  00:C881                      		db	"After using :FTP LOGIN the EXOS FTP: "
     950:  00:C881  41 66 74 65 72 20 75 73 69 6E 67 20 3A 46 54 50 
     950:  00:C891  20 4C 4F 47 49 4E 20 74 68 65 20 45 58 4F 53 20 
     950:  00:C8A1  46 54 50 3A 20 
     951:  00:C8A6                      		db	"device can be used",CR,LF
     951:  00:C8A6  64 65 76 69 63 65 20 63 61 6E 20 62 65 20 75 73 
     951:  00:C8B6  65 64 0D 0A 
     952:  00:C8BA                      		db	"eg. :FTP LOGIN 192.168.1.1",CR,LF
     952:  00:C8BA  65 67 2E 20 3A 46 54 50 20 4C 4F 47 49 4E 20 31 
     952:  00:C8CA  39 32 2E 31 36 38 2E 31 2E 31 0D 0A 
     953:  00:C8D6                      		db	"    LOAD \"ftp:demo.bas\"",CR,LF 
     953:  00:C8D6  20 20 20 20 4C 4F 41 44 20 22 66 74 70 3A 64 65 
     953:  00:C8E6  6D 6F 2E 62 61 73 22 0D 0A 
     954:  00:C8EF  00                  		db	0
     955:  00:C8F0                      ;
     956:  00:C8F0                      ping_help_str	db	"NET PING <host> tests communication "
     956:  00:C8F0  4E 45 54 20 50 49 4E 47 20 3C 68 6F 73 74 3E 20 
     956:  00:C900  74 65 73 74 73 20 63 6F 6D 6D 75 6E 69 63 61 74 
     956:  00:C910  69 6F 6E 20 
     957:  00:C914                      		db	"with other computers on the network",CR,LF
     957:  00:C914  77 69 74 68 20 6F 74 68 65 72 20 63 6F 6D 70 75 
     957:  00:C924  74 65 72 73 20 6F 6E 20 74 68 65 20 6E 65 74 77 
     957:  00:C934  6F 72 6B 0D 0A 
     958:  00:C939                      		db	"eg. :NET PING 192.168.1.1",CR,LF
     958:  00:C939  65 67 2E 20 3A 4E 45 54 20 50 49 4E 47 20 31 39 
     958:  00:C949  32 2E 31 36 38 2E 31 2E 31 0D 0A 
     959:  00:C954  00                  		db	0
     960:  00:C955                      ;
     961:  00:C955                      trace_help_str	db	"NET TRACE [ON|RAW|OFF] sets diagnostic "
     961:  00:C955  4E 45 54 20 54 52 41 43 45 20 5B 4F 4E 7C 52 41 
     961:  00:C965  57 7C 4F 46 46 5D 20 73 65 74 73 20 64 69 61 67 
     961:  00:C975  6E 6F 73 74 69 63 20 
     962:  00:C97C                      		db	"network trace options:",CR,LF
     962:  00:C97C  6E 65 74 77 6F 72 6B 20 74 72 61 63 65 20 6F 70 
     962:  00:C98C  74 69 6F 6E 73 3A 0D 0A 
     963:  00:C994  0D 0A               		db	CR,LF
     964:  00:C996                      		db	"NET TRACE     Turns tracing on",CR,LF
     964:  00:C996  4E 45 54 20 54 52 41 43 45 20 20 20 20 20 54 75 
     964:  00:C9A6  72 6E 73 20 74 72 61 63 69 6E 67 20 6F 6E 0D 0A 
     965:  00:C9B6                      		db	"NET TRACE RAW As ON but also raw bytes",CR,LF
     965:  00:C9B6  4E 45 54 20 54 52 41 43 45 20 52 41 57 20 41 73 
     965:  00:C9C6  20 4F 4E 20 62 75 74 20 61 6C 73 6F 20 72 61 77 
     965:  00:C9D6  20 62 79 74 65 73 0D 0A 
     966:  00:C9DE                      		db	"NET TRACE OFF Turns off all tracing",CR,LF
     966:  00:C9DE  4E 45 54 20 54 52 41 43 45 20 4F 46 46 20 54 75 
     966:  00:C9EE  72 6E 73 20 6F 66 66 20 61 6C 6C 20 74 72 61 63 
     966:  00:C9FE  69 6E 67 0D 0A 
     967:  00:CA03  00                  		db	0
     968:  00:CA04                      ;
     969:  00:CA04                      status_help_str:db	"NET STATUS shows MAC and IP addresses "
     969:  00:CA04  4E 45 54 20 53 54 41 54 55 53 20 73 68 6F 77 73 
     969:  00:CA14  20 4D 41 43 20 61 6E 64 20 49 50 20 61 64 64 72 
     969:  00:CA24  65 73 73 65 73 20 
     970:  00:CA2A                      		db	"and status of all sockets",CR,LF
     970:  00:CA2A  61 6E 64 20 73 74 61 74 75 73 20 6F 66 20 61 6C 
     970:  00:CA3A  6C 20 73 6F 63 6B 65 74 73 0D 0A 
     971:  00:CA45  00                  		db	0
     972:  00:CA46                      ;
     973:  00:CA46                      time_help_str:	db	"NET TIME updates the system time and "
     973:  00:CA46  4E 45 54 20 54 49 4D 45 20 75 70 64 61 74 65 73 
     973:  00:CA56  20 74 68 65 20 73 79 73 74 65 6D 20 74 69 6D 65 
     973:  00:CA66  20 61 6E 64 20 
     974:  00:CA6B                      		db	"date from the network using NTP",CR,LF
     974:  00:CA6B  64 61 74 65 20 66 72 6F 6D 20 74 68 65 20 6E 65 
     974:  00:CA7B  74 77 6F 72 6B 20 75 73 69 6E 67 20 4E 54 50 0D 
     974:  00:CA8B  0A 
     975:  00:CA8C  00                  		db	0
     976:  00:CA8D                      ;
     977:  00:CA8D  03 4E 45 54         net_str		db	3,"NET"
     978:  00:CA91  (00:0003)           net_str_len	equ	$-net_str-1
     979:  00:CA91  03 46 54 50         ftp_str		db	3,"FTP"
     980:  00:CA95  04 44 49 41 47      diag_str:	db	4,"DIAG"
     981:  00:CA9A  05 53 54 41 52 54   start_str:	db	5,"START"
     982:  00:CAA0  04 50 49 4E 47      ping_str:	db	4,"PING"
     983:  00:CAA5  05 54 52 41 43 45   trace_str:	db	5,"TRACE"
     984:  00:CAAB                      status_str:	db	6,"STATUS"
     984:  00:CAAB  06 53 54 41 54 55 53 
     985:  00:CAB2  04 54 49 4D 45      time_str:	db	4,"TIME"
     986:  00:CAB7  04 48 45 4C 50      help_str:	db	4,"HELP"
     987:  00:CABC                      ;
     988:  00:CABC                      special_str:	db	6,"EPNET",0ffh
     988:  00:CABC  06 45 50 4E 45 54 FF 
     989:  00:CAC3                      ;
     990:  00:CAC3                      ;
     991:  00:CAC3                      ;
     992:  00:CAC3                      		endmodule
      93.  00:CAC3                      ;
      94.  00:CAC3                      	include	exos.asm
       1:  00:CAC3                      ; EXOS
       2:  00:CAC3                      ;
       3:  00:CAC3                      ; This module contains EXOS-specific things
       4:  00:CAC3                      ;
       5:  00:CAC3                      ;==============================================================================
       6:  00:CAC3                      ;
       7:  00:CAC3                      ; This file is part of the EPNET software
       8:  00:CAC3                      ;
       9:  00:CAC3                      ; Copyright (C) 2015  Bruce Tanner
      10:  00:CAC3                      ;
      11:  00:CAC3                      ;    This program is free software: you can redistribute it and/or modify
      12:  00:CAC3                      ;    it under the terms of the GNU General Public License as published by
      13:  00:CAC3                      ;    the Free Software Foundation, either version 3 of the License, or
      14:  00:CAC3                      ;    (at your option) any later version.
      15:  00:CAC3                      ;
      16:  00:CAC3                      ;    This program is distributed in the hope that it will be useful,
      17:  00:CAC3                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      18:  00:CAC3                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      19:  00:CAC3                      ;    GNU General Public License for more details.
      20:  00:CAC3                      ;
      21:  00:CAC3                      ;    You should have received a copy of the GNU General Public License
      22:  00:CAC3                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      23:  00:CAC3                      ;
      24:  00:CAC3                      ; If you do use or modify this file, either for its original purpose or for
      25:  00:CAC3                      ; something new, I'd love to hear about it! I can be contacted by email at:
      26:  00:CAC3                      ;
      27:  00:CAC3                      ; brucetanner@btopenworld.com
      28:  00:CAC3                      ;
      29:  00:CAC3                      ;==============================================================================
      30:  00:CAC3                      ;
      31:  00:CAC3                      		macro EXOS n
      32:  00:CAC3                    < 		 rst 30H
      33:  00:CAC3                    < 		 db  n
      34:  00:CAC3                    < 		endm
      35:  00:CAC3                      ;
      36:  00:CAC3                      		module	exos
      37:  00:CAC3                      ;
      38:  00:CAC3                      ;------------------------------------------------------------------------------
      39:  00:CAC3                      ;
      40:  00:CAC3                      ;		        EXOS FIXED VARIABLES
      41:  00:CAC3                      ;		      ========================
      42:  00:CAC3                      ;
      43:  00:CAC3                      ;
      44:  00:CAC3  (00:BFFF)           USR_P3		equ	0BFFFh	;Four segments which were in Z-80 space
      45:  00:CAC3  (00:BFFE)           USR_P2		equ	0BFFEh	; when EXOS was last called.
      46:  00:CAC3  (00:BFFD)           USR_P1		equ	0BFFDh
      47:  00:CAC3  (00:BFFC)           USR_P0		equ	0BFFCh
      48:  00:CAC3                      
      49:  00:CAC3  (00:BFFA)           STACK_LIMIT	equ	0BFFAh	;Bottom limit of stack for devices.
      50:  00:CAC3                      
      51:  00:CAC3  (00:BFF8)           RST_ADDR	equ	0BFF8h	;Warm reset address
      52:  00:CAC3                      
      53:  00:CAC3  (00:BFF6)           ST_POINTER	equ	0BFF6h	;Address of status line RAM
      54:  00:CAC3  (00:BFF4)           LP_POINTER	equ	0BFF4h	;Address of start of video LPT.
      55:  00:CAC3                      
      56:  00:CAC3  (00:BFF3)           PORTB5		equ	0BFF3h	;Current contents of Z-80 port 0B5h.
      57:  00:CAC3                      
      58:  00:CAC3  (00:BFF2)           FLAG_SOFT_IRQ	equ	0BFF2h	;Flag <>0 to cause software interrupt.
      59:  00:CAC3                      
      60:  00:CAC3  (00:BFF0)           SEC_COUNTER	equ	0BFF0h	;16-bit second counter
      61:  00:CAC3                      
      62:  00:CAC3  (00:BFEE)           CR_DISP		equ	0BFEEh	;Flag <>0 to supress signon display
      63:  00:CAC3                      
      64:  00:CAC3  (00:BFED)           USER_ISR	equ	0BFEDh	;User's interrupt routine address.
      65:  00:CAC3                      ;
      66:  00:CAC3                      ;
      67:  00:CAC3                      ;------------------------------------------------------------------------------
      68:  00:CAC3                      ;
      69:  00:CAC3                      ;			FUNCTION CODES
      70:  00:CAC3                      ;		      ==================
      71:  00:CAC3                      ;
      72:  00:CAC3                      ;
      73:  00:CAC3  (00:0000)           FN_RESET	equ	0		; Reset system
      74:  00:CAC3  (00:0001)           FN_OPEN		equ	1		; Open channel
      75:  00:CAC3  (00:0002)           FN_CREATE	equ	2		; Create channel
      76:  00:CAC3  (00:0003)           FN_CLOSE	equ	3		; Close channel
      77:  00:CAC3  (00:0004)           FN_DEST		equ	4		; Destroy channel
      78:  00:CAC3  (00:0005)           FN_RDCH		equ	5		; Read character
      79:  00:CAC3  (00:0006)           FN_RDBLK	equ	6		; Read block
      80:  00:CAC3  (00:0007)           FN_WRCH		equ	7		; Write character
      81:  00:CAC3  (00:0008)           FN_WRBLK	equ	8		; Write block
      82:  00:CAC3  (00:0009)           FN_RSTAT	equ	9		; Read status
      83:  00:CAC3  (00:000A)           FN_SSTAT	equ	10		; Set channel status 
      84:  00:CAC3  (00:000B)           FN_SFUNC	equ	11		; Special function
      85:  00:CAC3  (00:0010)           FN_EVAR		equ	16		; Set/read/toggle EXOS variable
      86:  00:CAC3  (00:0011)           FN_CAPT		equ	17		; Capture channel
      87:  00:CAC3  (00:0012)           FN_REDIR	equ	18		; Re-direct channel
      88:  00:CAC3  (00:0013)           FN_DDEV		equ	19		; Set default device
      89:  00:CAC3  (00:0014)           FN_SYSS		equ	20		; Return system status
      90:  00:CAC3  (00:0015)           FN_LINK		equ	21		; Link device
      91:  00:CAC3  (00:0016)           FN_READB	equ	22		; Read EXOS boundary
      92:  00:CAC3  (00:0017)           FN_SETB		equ	23		; Set USER boundary
      93:  00:CAC3  (00:0018)           FN_ALLOC	equ	24		; Allocate segment
      94:  00:CAC3  (00:0019)           FN_FREE		equ	25		; Free segment
      95:  00:CAC3  (00:001A)           FN_ROMS		equ	26		; Locate ROMs
      96:  00:CAC3  (00:001B)           FN_BUFF		equ	27		; Allocate channel buffer
      97:  00:CAC3  (00:001C)           FN_ERRMSG	equ	28		; Return error message.
      98:  00:CAC3  (00:001D)           FN_LD		equ	29		; Load module
      99:  00:CAC3  (00:001E)           FN_REL		equ	30		; Load relocatable module
     100:  00:CAC3  (00:001F)           FN_STIME	equ	31		; Set time
     101:  00:CAC3  (00:0020)           FN_RTIME	equ	32		; Read time
     102:  00:CAC3  (00:0021)           FN_SDATE	equ	33		; Set date
     103:  00:CAC3  (00:0022)           FN_RDATE	equ	34		; Read date
     104:  00:CAC3                      
     105:  00:CAC3                      
     106:  00:CAC3                      
     107:  00:CAC3                      
     108:  00:CAC3                      ;******************************************************************************
     109:  00:CAC3                      ;
     110:  00:CAC3                      ;
     111:  00:CAC3                      ;			ERROR CODES
     112:  00:CAC3                      ;		     =================
     113:  00:CAC3                      ;
     114:  00:CAC3                      ;
     115:  00:CAC3                      ;	General errors returned by the EXOS kernel 
     116:  00:CAC3                      ;
     117:  00:CAC3  (00:00FF)           ERR_IFUNC	equ	0FFh	;Invalid function code
     118:  00:CAC3  (00:00FE)           ERR_ILLFN	equ	0FEh	;EXOS function call not allowed
     119:  00:CAC3  (00:00FD)           ERR_INAME	equ	0FDh	;Invalid name string
     120:  00:CAC3  (00:00FC)           ERR_STACK	equ	0FCh	;Insufficient stack
     121:  00:CAC3                      ;
     122:  00:CAC3  (00:00FB)           ERR_ICHAN	equ	0FBh	;Channel does not exist.
     123:  00:CAC3  (00:00FA)           ERR_NODEV	equ	0FAh	;Device does not exist  (OPEN/CREATE)
     124:  00:CAC3  (00:00F9)           ERR_CHANX	equ	0F9h	;Channel already exists (OPEN/CREATE)
     125:  00:CAC3  (00:00F8)           ERR_NOBUF	equ	0F8h	;No ALLOCATE BUFFER call made (OPEN/CREATE)
     126:  00:CAC3  (00:00F7)           ERR_NORAM	equ	0F7h	;Insufficient RAM for buffer.
     127:  00:CAC3  (00:00F6)           ERR_NOVID	equ	0F6h	;Insufficient video RAM.
     128:  00:CAC3                      ;
     129:  00:CAC3  (00:00F5)           ERR_NOSEG	equ	0F5h	;No free segments (ALLOCATE SEG)
     130:  00:CAC3  (00:00F4)           ERR_ISEG	equ	0F4h	;Invalid segment (FREE SEGequ SET BOUNDARY)
     131:  00:CAC3  (00:00F3)           ERR_IBOUN	equ	0F3h	;Invalid user boundary (SET USER BOUND)
     132:  00:CAC3  (00:00F2)           ERR_IVAR	equ	0F2h	;Invalid EXOS variable number 
     133:  00:CAC3  (00:00F1)           ERR_IDESC	equ	0F1h	;Invalid device descriptor type (LINK DEV)
     134:  00:CAC3                      ;
     135:  00:CAC3  (00:00F0)           ERR_NOSTR	equ	0F0h	;String not recognized by ROMs.
     136:  00:CAC3  (00:00EF)           ERR_ASCII	equ	0EFh	;Not a valid enterprise module header
     137:  00:CAC3  (00:00EE)           ERR_ITYPE	equ	0EEh	;Un-recognized module type
     138:  00:CAC3  (00:00ED)           ERR_IREL	equ	0EDh	;Invalid relocatable file 
     139:  00:CAC3  (00:00EC)           ERR_NOMOD	equ	0ECh	;End of file module found
     140:  00:CAC3                      ;
     141:  00:CAC3  (00:00EB)           ERR_ITIME	equ	0EBh	;Invalid time or date 
     142:  00:CAC3                      ;               
     143:  00:CAC3                      ;               
     144:  00:CAC3                      ;               
     145:  00:CAC3                      ;	errors rturned by various devices
     146:  00:CAC3                      ;              
     147:  00:CAC3  (00:00EA)           ERR_ISPEC	equ	0EAh	;Invalid special function code
     148:  00:CAC3  (00:00E9)           ERR_CH2ND	equ	0E9h	;Attempt to open second channel
     149:  00:CAC3  (00:00E8)           ERR_IUNIT	equ	0E8h	;Invalid unit number specified for OPEN/CRTE
     150:  00:CAC3  (00:00E7)           ERR_NOFN	equ	0E7h	;Function not supported
     151:  00:CAC3  (00:00E6)           ERR_ESC	equ	0E6h	;Invalid escape character
     152:  00:CAC3  (00:00E5)           ERR_STOP	equ	0E5h	;Stop key pressed
     153:  00:CAC3  (00:00E4)           ERR_EOF	equ	0E4h	;Unexpected end of file
     154:  00:CAC3  (00:00E3)           ERR_PROT	equ	0E3h	;Protection violation
     155:  00:CAC3                      ;
     156:  00:CAC3                      ;
     157:  00:CAC3                      ;
     158:  00:CAC3                      ;	Keyboard errors
     159:  00:CAC3                      
     160:  00:CAC3  (00:00E2)           ERR_KFSPC	equ	0E2h	;Run out of function key space
     161:  00:CAC3                      ;                               
     162:  00:CAC3                      ;                               
     163:  00:CAC3                      ;                               
     164:  00:CAC3                      ;	Sound errors            
     165:  00:CAC3                      ;                               
     166:  00:CAC3  (00:00E1)           ERR_SENV	equ	0E1h	;Envelope is too big or number 255.
     167:  00:CAC3  (00:00E0)           ERR_SENBF	equ	0E0h	;Not enough room to define envelope
     168:  00:CAC3  (00:00DF)           ERR_SQFUL	equ	0DFh	;Sound queue is full (and WAIT_SND <> 0)
     169:  00:CAC3                      ;                               
     170:  00:CAC3                      ;                               
     171:  00:CAC3                      ;                               
     172:  00:CAC3                      ;	Video errors            
     173:  00:CAC3                      ;                               
     174:  00:CAC3  (00:00DE)           ERR_VSIZE	equ	0DEh	;Invalid X or Y size to OPEN
     175:  00:CAC3  (00:00DD)           ERR_VMODE	equ	0DDh	;Invalid video mode to OPEN
     176:  00:CAC3  (00:00DC)           ERR_VDISP	equ	0DCh	;Naff parameter to DISPLAY
     177:  00:CAC3  (00:00DB)           ERR_VLOAD	equ	0DBh	;Invalid file to LOAD
     178:  00:CAC3                      ;        
     179:  00:CAC3  (00:00DA)           ERR_VROW	equ	0DAh	;Invalid row number to scroll
     180:  00:CAC3  (00:00D9)           ERR_VCURS	equ	0D9h	;Attempt to move cursor off page
     181:  00:CAC3  (00:00D8)           ERR_VBEAM	equ	0D8h	;Attept to move beam off page
     182:  00:CAC3                      ;                               
     183:  00:CAC3                      ;                               
     184:  00:CAC3                      ;                               
     185:  00:CAC3                      ;	Serial/Network erors
     186:  00:CAC3                      ;                               
     187:  00:CAC3  (00:00D7)           ERR_SEROP	equ	0D7h	;Serial device open - cannot use network
     188:  00:CAC3  (00:00D6)           ERR_NOADR	equ	0D6h	;ADDR_NET not set up
     189:  00:CAC3  (00:00D5)           ERR_NETOP	equ	0D5h	;Network link already exists
     190:  00:CAC3                      ;                               
     191:  00:CAC3                      ;                               
     192:  00:CAC3                      ;                               
     193:  00:CAC3                      ;	Editor errors           
     194:  00:CAC3                      ;                               
     195:  00:CAC3  (00:00D4)           ERR_EVID	equ	0D4h	;Video channel error
     196:  00:CAC3  (00:00D3)           ERR_EKEY	equ	0D3h	;Keyboard channel error
     197:  00:CAC3  (00:00D2)           ERR_EDINV	equ	0D2h	;Editor - invalid LOAD file
     198:  00:CAC3  (00:00D1)           ERR_EDBUF	equ	0D1h	;Editor - Buffer full in LOAD
     199:  00:CAC3                      ;                               
     200:  00:CAC3                      ;                               
     201:  00:CAC3                      ;                               
     202:  00:CAC3                      ;	Cassette errors         
     203:  00:CAC3                      ;                               
     204:  00:CAC3  (00:00D0)           ERR_CCRC	equ	0D0h	;CRC error from cassette driver
     205:  00:CAC3                      ;
     206:  00:CAC3                      ;
     207:  00:CAC3                      ;
     208:  00:CAC3                      ;	EPNET errors
     209:  00:CAC3                      ;
     210:  00:CAC3  (00:006F)           ERR_LAST	equ	06fh		;Last EPNET error code number
     211:  00:CAC3                      ;
     212:  00:CAC3  (00:006F)           ERR_DHCP	equ	ERR_LAST-0	;Timeout trying to get IP values via DHCP
     213:  00:CAC3  (00:006E)           ERR_NONET	equ	ERR_LAST-1	;Cannot communicate with WIZ chip
     214:  00:CAC3  (00:006D)           ERR_BADIP	equ	ERR_LAST-2	;Invalid IP address
     215:  00:CAC3  (00:006C)           ERR_BADOPT	equ	ERR_LAST-3	;Invalid command option
     216:  00:CAC3  (00:006B)           ERR_NOCON	equ	ERR_LAST-4	;Cannot open connection
     217:  00:CAC3  (00:006A)           ERR_TIMEOUT	equ	ERR_LAST-5	;No response from server
     218:  00:CAC3  (00:0069)           ERR_FTP		equ	ERR_LAST-6	;Unexpected FTP error
     219:  00:CAC3  (00:0068)           ERR_NOFIL	equ	ERR_LAST-7	;File not found
     220:  00:CAC3  (00:0067)           ERR_NOTIME	equ	ERR_LAST-8	;Cannot get time
     221:  00:CAC3  (00:0066)           ERR_DUPIP	equ	ERR_LAST-9	;Duplicate IP address on network
     222:  00:CAC3  (00:0065)           ERR_FTPDATA	equ	ERR_LAST-10	;Cannot open data connection
     223:  00:CAC3  (00:0064)           ERR_BADHTTP	equ	ERR_LAST-11	;Invalid HTTP response
     224:  00:CAC3  (00:0063)           ERR_SOCK	equ	ERR_LAST-12	;No free sockets
     225:  00:CAC3                      ;
     226:  00:CAC3  (00:0063)           ERR_FIRST	equ	ERR_LAST-12
     227:  00:CAC3                      ;
     228:  00:CAC3                      ;
     229:  00:CAC3                      ;------------------------------------------------------------------------------
     230:  00:CAC3                      ;
     231:  00:CAC3                      ;		  WARNING CODES
     232:  00:CAC3                      ;		=================
     233:  00:CAC3                      ;
     234:  00:CAC3  (00:007F)           ERR_SHARE	equ	07Fh		;Shared segment allocated
     235:  00:CAC3                      ;
     236:  00:CAC3                      ;
     237:  00:CAC3                      ;
     238:  00:CAC3                      ;******************************************************************************
     239:  00:CAC3                      ;
     240:  00:CAC3                      ;
     241:  00:CAC3                      ;			  EXOS VARIABLE NUMBERS
     242:  00:CAC3                      ;			=========================
     243:  00:CAC3                      ;
     244:  00:CAC3                      ;
     245:  00:CAC3                      ;
     246:  00:CAC3                      ;
     247:  00:CAC3  (00:0000)           VAR_IRQ_ENABLE	equ	0	; Interrupt enable bits.
     248:  00:CAC3                      ;
     249:  00:CAC3  (00:0001)           VAR_FLAG_SIRQ	equ	1	; Flag to cause a software interrupt.
     250:  00:CAC3  (00:0002)           VAR_CODE_SIRQ	equ	2	; Software Interrupt code.
     251:  00:CAC3                      ;
     252:  00:CAC3  (00:0003)           VAR_DEF_TYPE	equ	3	; Type of default device.
     253:  00:CAC3  (00:0004)           VAR_DEF_CHAN	equ	4	; Default channel number.
     254:  00:CAC3                      ;
     255:  00:CAC3  (00:0005)           VAR_TIMER	equ	5	; 1Hz down counter.
     256:  00:CAC3                      ;
     257:  00:CAC3  (00:0006)           VAR_LOCK_KEY	equ	6	; Keyboard lock status.
     258:  00:CAC3  (00:0007)           VAR_CLICK_KEY	equ	7	; Key click enable/disable.
     259:  00:CAC3  (00:0008)           VAR_STOP_IRQ	equ	8	; Software interrupt on STOP key.
     260:  00:CAC3  (00:0009)           VAR_KEY_IRQ	equ	9	; Software interrupt on any key press.
     261:  00:CAC3  (00:000A)           VAR_RATE_KEY	equ	10	; Keyboard auto-repeat rate.
     262:  00:CAC3  (00:000B)           VAR_DELAY_KEY	equ	11	; Delay before auto-repeat starts.
     263:  00:CAC3                      ;
     264:  00:CAC3  (00:000C)           VAR_TAPE_SND	equ	12	; Tape sound enable/dispable.
     265:  00:CAC3                      ;
     266:  00:CAC3  (00:000D)           VAR_WAIT_SND	equ	13	; Sound driver waiting if buffer full
     267:  00:CAC3  (00:000E)           VAR_MUTE_SND	equ	14	; Sound mute enable/disable.
     268:  00:CAC3  (00:000F)           VAR_BUF_SND	equ	15	; Sound envelope storage size.
     269:  00:CAC3                      ;
     270:  00:CAC3  (00:0010)           VAR_BAUD_SER	equ	16	; Serial baud rate.
     271:  00:CAC3  (00:0011)           VAR_FORM_SER	equ	17	; Serial word format.
     272:  00:CAC3  (00:0012)           VAR_ADDR_NET	equ	18	; Network address of this machine
     273:  00:CAC3  (00:0013)           VAR_NET_IRQ	equ	19	; Software interrupt on network.
     274:  00:CAC3  (00:0014)           VAR_CHAN_NET	equ	20	; Channel for network block.
     275:  00:CAC3  (00:0015)           VAR_MACH_NET	equ	21	; Source machine for network block.
     276:  00:CAC3                      ;
     277:  00:CAC3  (00:0016)           VAR_MODE_VID	equ	22	; Video mode.
     278:  00:CAC3  (00:0017)           VAR_COLR_VID	equ	23	; Video colour mode.
     279:  00:CAC3  (00:0018)           VAR_X_SIZ_VID	equ	24	; Video X page size.
     280:  00:CAC3  (00:0019)           VAR_Y_SIZ_VID	equ	25	; Video Y page size.
     281:  00:CAC3                      ;
     282:  00:CAC3  (00:001A)           VAR_ST_FLAG	equ	26	; Status line displayed flag.
     283:  00:CAC3  (00:001B)           VAR_BORD_VID	equ	27	; Border colour.
     284:  00:CAC3  (00:001C)           VAR_BIAS_VID	equ	28	; Fixed bias colour.
     285:  00:CAC3                      ;
     286:  00:CAC3  (00:001D)           VAR_VID_EDIT	equ	29	; Video channel number.
     287:  00:CAC3  (00:001E)           VAR_KEY_EDIT	equ	30	; Keyboard channel number.
     288:  00:CAC3  (00:001F)           VAR_BUF_EDIT	equ	31	; Size of edit buffer.
     289:  00:CAC3  (00:0020)           VAR_FLG_EDIT	equ	32	; Editor control flags
     290:  00:CAC3                      ;
     291:  00:CAC3  (00:0021)           VAR_SP_TAPE	equ	33	; Cassette I/O speed.
     292:  00:CAC3  (00:0022)           VAR_PROTECT	equ	34	; Cassette protection control
     293:  00:CAC3  (00:0023)           VAR_LV_TAPE	equ	35	; Cassette level control
     294:  00:CAC3  (00:0024)           VAR_REM1	equ	36	; Cassette remote 1
     295:  00:CAC3  (00:0025)           VAR_REM2	equ	37	; Cassette remote 2
     296:  00:CAC3                      ;
     297:  00:CAC3  (00:0026)           VAR_SPRITE	equ	38	; Sprite colour priority
     298:  00:CAC3                      ;
     299:  00:CAC3  (00:0027)           VAR_RANDOM	equ	39	; Random interrupt counter
     300:  00:CAC3                      ;
     301:  00:CAC3                      ;
     302:  00:CAC3                      ;
     303:  00:CAC3                      ;******************************************************************************
     304:  00:CAC3                      ;
     305:  00:CAC3                      ;
     306:  00:CAC3                      ;		SOFTWARE INTERRUPT CODES
     307:  00:CAC3                      ;	      ============================
     308:  00:CAC3                      ;
     309:  00:CAC3                      ;
     310:  00:CAC3  (00:0010)           INT_FKEY	equ	10h		;Function keys 10h...1Fh
     311:  00:CAC3  (00:0020)           INT_STOP	equ	20h		;Stop key
     312:  00:CAC3  (00:0021)           INT_KEY		equ	21h		;'any key' 21h
     313:  00:CAC3                      ;
     314:  00:CAC3  (00:0030)           INT_NET		equ	30h		;Network data received.
     315:  00:CAC3                      ;
     316:  00:CAC3  (00:0040)           INT_TIME	equ	40h		;TIMER reached zero
     317:  00:CAC3                      ;
     318:  00:CAC3                      ;
     319:  00:CAC3                      ;
     320:  00:CAC3                      ;------------------------------------------------------------------------------
     321:  00:CAC3                      ;
     322:  00:CAC3                      ;
     323:  00:CAC3                      ;		SPECIAL FUNCTION CODES
     324:  00:CAC3                      ;	      ==========================
     325:  00:CAC3                      ;
     326:  00:CAC3                      ;
     327:  00:CAC3  (00:0001)           FN_VID_DISP	equ	01h		; VIDEO - Display page
     328:  00:CAC3  (00:0002)           FN_VID_SIZE	equ	02h		; VIDEO - Return page size & mode
     329:  00:CAC3  (00:0003)           FN_VID_ADDR	equ	03h		; VIDEO - Return page address
     330:  00:CAC3  (00:0004)           FN_VID_FONT	equ	04h		; VIDEO - Initialise character font
     331:  00:CAC3                      ;
     332:  00:CAC3  (00:0008)           FN_KEY_FKEY	equ	08h		; KEYBOARD - Program function key
     333:  00:CAC3  (00:0009)           FN_KEY_JOY	equ	09h		; KEYBOARD - Read joystick
     334:  00:CAC3                      ;
     335:  00:CAC3  (00:0010)           FN_NET_FLSH	equ	10h		; NETWORK  - Flush buffer
     336:  00:CAC3  (00:0011)           FN_NET_CLR	equ	11h		; NETWORK  - Clear buffers
     337:  00:CAC3                      ;
     338:  00:CAC3  (00:0018)           FN_ED_MARG	equ	18h 		; EDITOR   - Set margins
     339:  00:CAC3  (00:0019)           FN_ED_CHLD	equ	19h		; EDITOR   - Load document file
     340:  00:CAC3  (00:001A)           FN_ED_CHSV	equ	1Ah		; EDITOR   - Save document file
     341:  00:CAC3                      ;
     342:  00:CAC3                      ;
     343:  00:CAC3  (00:0020)           FN_MEM_SEG	equ	20h		; MEM: - Get buffer segment
     344:  00:CAC3                      ;
     345:  00:CAC3                      ;
     346:  00:CAC3                      ;
     347:  00:CAC3                      ;------------------------------------------------------------------------------
     348:  00:CAC3                      ;
     349:  00:CAC3                      ;
     350:  00:CAC3                      ;		ROM ACTION CODES
     351:  00:CAC3                      ;	      ====================
     352:  00:CAC3                      ;
     353:  00:CAC3                      ;
     354:  00:CAC3  (00:0000)           ACT_NULL	equ	00h		;Do nothing.
     355:  00:CAC3  (00:0001)           ACT_COLD	equ	01h		;Cold restart.
     356:  00:CAC3  (00:0002)           ACT_STR		equ	02h		;Pass user string
     357:  00:CAC3  (00:0003)           ACT_HELP	equ	03h		;Help string
     358:  00:CAC3  (00:0004)           ACT_EVAR	equ	04h		;Unknown EXOS variable
     359:  00:CAC3  (00:0005)           ACT_ERR		equ	05h		;Explain error code
     360:  00:CAC3  (00:0006)           ACT_LOAD	equ	06h		;Load module of given type
     361:  00:CAC3  (00:0007)           ACT_RAM		equ	07h		;Claim RAM 
     362:  00:CAC3  (00:0008)           ACT_INIT	equ	08h		;Initialise ROM
     363:  00:CAC3                      ;
     364:  00:CAC3                      ;
     365:  00:CAC3                      ;
     366:  00:CAC3                      ;------------------------------------------------------------------------------
     367:  00:CAC3                      ;
     368:  00:CAC3                      ;
     369:  00:CAC3                      ;		LOAD MODULE HEADER TYPES
     370:  00:CAC3                      ;	      ============================
     371:  00:CAC3                      ;
     372:  00:CAC3                      ;
     373:  00:CAC3  (00:0000)           MOD_ASCII	equ	00h		;ASCII file 
     374:  00:CAC3  (00:0001)           MOD_4TH		equ	01h		;FORTH
     375:  00:CAC3  (00:0002)           MOD_REL		equ	02h		;Relocatable module
     376:  00:CAC3  (00:0003)           MOD_XBAS	equ	03h		;Multiple BASIC program
     377:  00:CAC3  (00:0004)           MOD_BAS		equ	04h		;Single BASIC program
     378:  00:CAC3  (00:0005)           MOD_APP		equ	05h		;New applications program
     379:  00:CAC3  (00:0006)           MOD_XABS	equ	06h		;Absolute system extension
     380:  00:CAC3  (00:0007)           MOD_XREL	equ	07h		;Relocatable system extension
     381:  00:CAC3  (00:0008)           MOD_EDIT	equ	08h		;Editor document file
     382:  00:CAC3  (00:0009)           MOD_LISP	equ	09h		;Lisp memory image
     383:  00:CAC3  (00:000A)           MOD_EOF		equ	0Ah		;End of file module 
     384:  00:CAC3  (00:000B)           MOD_VID		equ	0Bh		;Video page file.
     385:  00:CAC3                      ;
     386:  00:CAC3                      ;
     387:  00:CAC3                      ;==============================================================================
     388:  00:CAC3                      ;
     389:  00:CAC3                      ; When an EXOS extension allocates device memory, EXOS allows "nearly all" of
     390:  00:CAC3                      ; a segment to be allocated - the first few bytes it keeps pointers etc in.
     391:  00:CAC3                      ; We need our variables to start at a fixed address so we allocate as much
     392:  00:CAC3                      ; of a segment as possible. This is the first address EXOS allocates in a
     393:  00:CAC3                      ; device segment:
     394:  00:CAC3                      ;
     395:  00:CAC3  (00:0007)           DEVICE_SEG_START	equ	7
     396:  00:CAC3                      ;
     397:  00:CAC3                      ;
     398:  00:CAC3                      ;------------------------------------------------------------------------------
     399:  00:CAC3                      ; is_stop
     400:  00:CAC3                      ;
     401:  00:CAC3                      ; Returns with Cy set if the stop key is pressed. Nothing else corrupted.
     402:  00:CAC3                      ;
     403:  00:CAC3  F5                  is_stop:	push	af
     404:  00:CAC4  3A F2 BF            		ld	a,(exos.FLAG_SOFT_IRQ)
     405:  00:CAC7  FE 20               		cp	20h		; STOP key
     406:  00:CAC9  28 03               		jr	z,.scfret
     407:  00:CACB                      ;
     408:  00:CACB  F1                  		pop	af
     409:  00:CACC  B7                  		or	a
     410:  00:CACD  C9                  		ret
     411:  00:CACE                      
     412:  00:CACE  F1                  .scfret:	pop	af
     413:  00:CACF  37                  		scf
     414:  00:CAD0  C9                  		ret
     415:  00:CAD1                      ;
     416:  00:CAD1                      ;
     417:  00:CAD1                      ; check_stop
     418:  00:CAD1                      ;
     419:  00:CAD1                      ; Called with an error code in A, returns ERR_STOP instead (and Cy) if the stop ; key has been pressed.
     420:  00:CAD1                      ;
     421:  00:CAD1  CD C3 CA            check_stop:	call	is_stop
     422:  00:CAD4  3F                  		ccf
     423:  00:CAD5  D8                  		ret	c
     424:  00:CAD6                      ;
     425:  00:CAD6  3E E5               		ld	a,ERR_STOP
     426:  00:CAD8  37                  		scf
     427:  00:CAD9  C9                  		ret
     428:  00:CADA                      ;
     429:  00:CADA                      ;
     430:  00:CADA                      ;------------------------------------------------------------------------------
     431:  00:CADA                      ;
     432:  00:CADA                      explain:
     433:  00:CADA  78                  		ld	a,b
     434:  00:CADB                      ;
     435:  00:CADB  D6 63               		sub	ERR_FIRST	; A=0-based error code if ours
     436:  00:CADD  D8                  		ret	c		; Ret if error code < our lowest
     437:  00:CADE                      ;
     438:  00:CADE  FE 0D               		cp	ERR_LAST-ERR_FIRST+1
     439:  00:CAE0  D0                  		ret	nc		; Ret if erro code > our highest
     440:  00:CAE1                      ;
     441:  00:CAE1  21 F2 CA            		ld	hl,messages	; HL->table of message addresses
     442:  00:CAE4  5F                  		ld	e,a
     443:  00:CAE5  16 00               		ld	d,0		; DE=offset into table
     444:  00:CAE7  19                  		add	hl,de
     445:  00:CAE8  19                  		add	hl,de		; HL->message for error code
     446:  00:CAE9  5E                  		ld	e,(hl)
     447:  00:CAEA  23                  		inc	hl
     448:  00:CAEB  56                  		ld	d,(hl)		; DE->message
     449:  00:CAEC                      ;
     450:  00:CAEC  DB B3               		in	a,(ep.P3)	; Get page containing message
     451:  00:CAEE  47                  		ld	b,a		; B=page, DE->message
     452:  00:CAEF  0E 00               		ld	c,0		; C=0=>explained
     453:  00:CAF1  C9                  		ret
     454:  00:CAF2                      ;
     455:  00:CAF2                      
     456:  00:CAF2                      messages:				; Same order as error codes, lowest first!
     457:  00:CAF2  0C CB               		dw	SOCK_str
     458:  00:CAF4  39 CC               		dw	BADHTTP_str
     459:  00:CAF6  1C CC               		dw	FTPDATA_str
     460:  00:CAF8  FC CB               		dw	DUPIP_str
     461:  00:CAFA  DC CB               		dw	NOTIME_str
     462:  00:CAFC  BC CB               		dw	NOFIL_str
     463:  00:CAFE  A7 CB               		dw	FTP_str
     464:  00:CB00  8F CB               		dw	TIMEOUT_str
     465:  00:CB02  80 CB               		dw	NOCON_str
     466:  00:CB04  71 CB               		dw	BADOPT_str
     467:  00:CB06  5E CB               		dw	BADIP_str
     468:  00:CB08  40 CB               		dw	NONET_str
     469:  00:CB0A  1C CB               		dw	DHCP_str
     470:  00:CB0C                      ;
     471:  00:CB0C                      ;                                             1         2         3         4
     472:  00:CB0C                      ;                    screen col:     1        0         0         0         0
     473:  00:CB0C                      ;                                    |--------|---------|---------|---------|
     474:  00:CB0C                      ;                                    *** 
     475:  00:CB0C                      SOCK_str	db	SOCK_str_len,	"No free sockets"
     475:  00:CB0C  0F 4E 6F 20 66 72 65 65 20 73 6F 63 6B 65 74 73 
     476:  00:CB1C  (00:000F)           SOCK_str_len	equ	$-SOCK_str-1	; -1 to exclude length byte itself
     477:  00:CB1C                      ;
     478:  00:CB1C                      DHCP_str:	db	DHCP_str_len,	"Cannot get IP address etc with DHCP"
     478:  00:CB1C  23 43 61 6E 6E 6F 74 20 67 65 74 20 49 50 20 61 
     478:  00:CB2C  64 64 72 65 73 73 20 65 74 63 20 77 69 74 68 20 
     478:  00:CB3C  44 48 43 50 
     479:  00:CB40  (00:0023)           DHCP_str_len	equ	$-DHCP_str-1	; -1 to exclude length byte itself
     480:  00:CB40                      ;
     481:  00:CB40                      NONET_str:	db	NONET_str_len,	"Cannot communicate with EPNET"
     481:  00:CB40  1D 43 61 6E 6E 6F 74 20 63 6F 6D 6D 75 6E 69 63 
     481:  00:CB50  61 74 65 20 77 69 74 68 20 45 50 4E 45 54 
     482:  00:CB5E  (00:001D)           NONET_str_len	equ	$-NONET_str-1	; -1 to exclude length byte itself
     483:  00:CB5E                      ;
     484:  00:CB5E                      BADIP_str:	db	BADIP_str_len,	"Invalid IP address"
     484:  00:CB5E  12 49 6E 76 61 6C 69 64 20 49 50 20 61 64 64 72 
     484:  00:CB6E  65 73 73 
     485:  00:CB71  (00:0012)           BADIP_str_len	equ	$-BADIP_str-1	; -1 to exclude length byte itself
     486:  00:CB71                      ;
     487:  00:CB71                      BADOPT_str:	db	BADOPT_str_len,	"Invalid option"
     487:  00:CB71  0E 49 6E 76 61 6C 69 64 20 6F 70 74 69 6F 6E 
     488:  00:CB80  (00:000E)           BADOPT_str_len	equ	$-BADOPT_str-1	; -1 to exclude length byte itself
     489:  00:CB80                      ;
     490:  00:CB80                      NOCON_str:	db	NOCON_str_len,	"Cannot connect"
     490:  00:CB80  0E 43 61 6E 6E 6F 74 20 63 6F 6E 6E 65 63 74 
     491:  00:CB8F  (00:000E)           NOCON_str_len	equ	$-NOCON_str-1	; -1 to exclude length byte itself
     492:  00:CB8F                      ;
     493:  00:CB8F                      TIMEOUT_str:	db	TIMEOUT_str_len,"No response from server"
     493:  00:CB8F  17 4E 6F 20 72 65 73 70 6F 6E 73 65 20 66 72 6F 
     493:  00:CB9F  6D 20 73 65 72 76 65 72 
     494:  00:CBA7  (00:0017)           TIMEOUT_str_len	equ	$-TIMEOUT_str-1	; -1 to exclude length byte itself
     495:  00:CBA7                      ;
     496:  00:CBA7                      FTP_str:	db	FTP_str_len,	"Unexpected FTP error"
     496:  00:CBA7  14 55 6E 65 78 70 65 63 74 65 64 20 46 54 50 20 
     496:  00:CBB7  65 72 72 6F 72 
     497:  00:CBBC  (00:0014)           FTP_str_len	equ	$-FTP_str-1	; -1 to exclude length byte itself
     498:  00:CBBC                      ;
     499:  00:CBBC                      NOFIL_str:	db	NOFIL_str_len,	"File not found or access denied"
     499:  00:CBBC  1F 46 69 6C 65 20 6E 6F 74 20 66 6F 75 6E 64 20 
     499:  00:CBCC  6F 72 20 61 63 63 65 73 73 20 64 65 6E 69 65 64 
     500:  00:CBDC  (00:001F)           NOFIL_str_len	equ	$-NOFIL_str-1	; -1 to exclude length byte itself
     501:  00:CBDC                      ;
     502:  00:CBDC                      NOTIME_str:	db	NOTIME_str_len,	"Cannot get time & date with NTP"
     502:  00:CBDC  1F 43 61 6E 6E 6F 74 20 67 65 74 20 74 69 6D 65 
     502:  00:CBEC  20 26 20 64 61 74 65 20 77 69 74 68 20 4E 54 50 
     503:  00:CBFC  (00:001F)           NOTIME_str_len	equ	$-NOTIME_str-1	; -1 to exclude length byte itself
     504:  00:CBFC                      ;
     505:  00:CBFC                      DUPIP_str:	db	DUPIP_str_len,	"Duplicate IP address on network"
     505:  00:CBFC  1F 44 75 70 6C 69 63 61 74 65 20 49 50 20 61 64 
     505:  00:CC0C  64 72 65 73 73 20 6F 6E 20 6E 65 74 77 6F 72 6B 
     506:  00:CC1C  (00:001F)           DUPIP_str_len	equ	$-DUPIP_str-1	; -1 to exclude length byte itself
     507:  00:CC1C                      ;
     508:  00:CC1C                      FTPDATA_str:	db	FTPDATA_str_len, "Cannot open FTP data session"
     508:  00:CC1C  1C 43 61 6E 6E 6F 74 20 6F 70 65 6E 20 46 54 50 
     508:  00:CC2C  20 64 61 74 61 20 73 65 73 73 69 6F 6E 
     509:  00:CC39  (00:001C)           FTPDATA_str_len	equ	$-FTPDATA_str-1	; -1 to exclude length byte itself
     510:  00:CC39                      ;
     511:  00:CC39                      BADHTTP_str	db	BADHTTP_str_len, "Unexpected HTTP response"
     511:  00:CC39  18 55 6E 65 78 70 65 63 74 65 64 20 48 54 54 50 
     511:  00:CC49  20 72 65 73 70 6F 6E 73 65 
     512:  00:CC52  (00:0018)           BADHTTP_str_len	equ	$-BADHTTP_str-1	; -1 to exclude length byte itself
     513:  00:CC52                      ;
     514:  00:CC52                      ;
     515:  00:CC52                      ;
     516:  00:CC52                      		endmodule
      95.  00:CC52                      	include	device.asm
       1:  00:CC52                      ; DEVICE
       2:  00:CC52                      ; DEVICE
       3:  00:CC52                      ;
       4:  00:CC52                      ; This module contains the EXOS device drivers
       5:  00:CC52                      ;
       6:  00:CC52                      		module	device
       7:  00:CC52                      ;
       8:  00:CC52                      ;==============================================================================
       9:  00:CC52                      ;
      10:  00:CC52                      ; This file is part of the EPNET software
      11:  00:CC52                      ;
      12:  00:CC52                      ; Copyright (C) 2015  Bruce Tanner
      13:  00:CC52                      ;
      14:  00:CC52                      ;    This program is free software: you can redistribute it and/or modify
      15:  00:CC52                      ;    it under the terms of the GNU General Public License as published by
      16:  00:CC52                      ;    the Free Software Foundation, either version 3 of the License, or
      17:  00:CC52                      ;    (at your option) any later version.
      18:  00:CC52                      ;
      19:  00:CC52                      ;    This program is distributed in the hope that it will be useful,
      20:  00:CC52                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      21:  00:CC52                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      22:  00:CC52                      ;    GNU General Public License for more details.
      23:  00:CC52                      ;
      24:  00:CC52                      ;    You should have received a copy of the GNU General Public License
      25:  00:CC52                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      26:  00:CC52                      ;
      27:  00:CC52                      ; If you do use or modify this file, either for its original purpose or for
      28:  00:CC52                      ; something new, I'd love to hear about it! I can be contacted by email at:
      29:  00:CC52                      ;
      30:  00:CC52                      ; brucetanner@btopenworld.com
      31:  00:CC52                      ;
      32:  00:CC52                      ;==============================================================================
      33:  00:CC52                      ;
      34:  00:CC52                      ; This is the data kept in EXOS device RAM.
      35:  00:CC52                      ;
      36:  00:CC52                      ; EXOS device RAM is accessed at (iy-4), (iy-5)...etc so our data here
      37:  00:CC52                      ; is accessed with (iy-4-<item>) eg (iy-4-device.seg)
      38:  00:CC52                      ;
      39:  00:CC52                      		struct	device		; Variables in EXOS device RAM
      40:  00:CC52                    < seg		 byte			; Segment no. of our variables
      41:  00:CC52                    < 		ends
      42:  00:CC52                      ;
      43:  00:CC52                      ;
      44:  00:CC52                      ; This is the data kept in EXOS channel RAM.
      45:  00:CC52                      ;
      46:  00:CC52                      ; EXOS channel RAM is accessed at (ix-1), (ix-2)...etc so our data here is
      47:  00:CC52                      ; accessed with (ix-1-<item>) eg (ix-1-channel.socket)
      48:  00:CC52                      ;
      49:  00:CC52                      ; Other devices (eg. FTP:, HTTP: may need to keep other information in channel
      50:  00:CC52                      ; RAM but they all start with this so that common code can be used.
      51:  00:CC52                      ;
      52:  00:CC52                      		struct	channel		; Variables in EXOS channel RAM
      53:  00:CC52                    < socket		 byte			; WIZ socket # for this channel
      54:  00:CC52                    < 		ends
      55:  00:CC52                      ;
      56:  00:CC52                      ;
      57:  00:CC52                      ; FTP DEVICE
      58:  00:CC52                      ;
      59:  00:CC52                      ; The FTP device allows an EXOS user to open an EXOS channel to "FTP:xxx" and
      60:  00:CC52                      ; then to read and write to a file.
      61:  00:CC52                      ;
      62:  00:CC52  49 4D               		dw	tcp_descriptor-8000h	; XX_NEXT Next device in P1
      63:  00:CC54  FD FF               		dw	-2-device	; XX_RAM
      64:  00:CC56  00                  ftp_type:	db	0		; DD_TYPE
      65:  00:CC57  20                  		db	20h		; DD_IRQFLAG (50Hz)
      66:  00:CC58  00                  		db	0		; DD_FLAGS
      67:  00:CC59  62 4C               		dw	ftp_entry-8000h	; DD_TAB in page 1
      68:  00:CC5B  00                  		db	0		; DD_TAB_SEG
      69:  00:CC5C  00                  		db	0		; DD_UNIT_COUNT
      70:  00:CC5D  03 46 54 50         		db	3,"FTP"		; DD_NAME
      71:  00:CC61                      devices:
      72:  00:CC61  0B                  ftp_descriptor:	db	$-ftp_type	; XX_SIZE
      73:  00:CC62                      ;
      74:  00:CC62  7E CC               ftp_entry:	dw	ftp_interrupt
      75:  00:CC64  A0 CC               		dw	ftp_open
      76:  00:CC66  B6 CC               		dw	ftp_create
      77:  00:CC68  CC CC               		dw	ftp_close
      78:  00:CC6A  CC CC               		dw	ftp_close	; destroy
      79:  00:CC6C  E1 CC               		dw	ftp_read_byte
      80:  00:CC6E  F6 CC               		dw	ftp_read_block
      81:  00:CC70  07 CD               		dw	ftp_write_byte
      82:  00:CC72  18 CD               		dw	ftp_write_block
      83:  00:CC74  29 CD               		dw	ftp_read_status
      84:  00:CC76  EE CE               		dw	write_status
      85:  00:CC78  F1 CE               		dw	special
      86:  00:CC7A  60 CF               		dw	init
      87:  00:CC7C  76 CF               		dw	moved
      88:  00:CC7E                      ;
      89:  00:CC7E                      ;------------------------------------------------------------------------------
      90:  00:CC7E                      ; ftp_interrupt
      91:  00:CC7E                      ;
      92:  00:CC7E                      ; The device driver interrupt routine
      93:  00:CC7E                      ;
      94:  00:CC7E  FD 7E FC            ftp_interrupt:	ld	a,(iy-4-device.seg)	; Get our variable's segment
      95:  00:CC81  B7                  		or	a
      96:  00:CC82  C8                  		ret	z
      97:  00:CC83                      ;
      98:  00:CC83  D3 B1               		out	(ep.P1),a		; Page it in
      99:  00:CC85  FD E5               		push	iy
     100:  00:CC87  FD 21 07 40         		 ld	iy,vars			; Point IY at variables as usual
     101:  00:CC8B                      ;
     102:  00:CC8B  2A 0E 40            		 ld	hl,(vars.ticks)
     103:  00:CC8E  23                  		 inc	hl
     104:  00:CC8F  22 0E 40            		 ld	(vars.ticks),hl
     105:  00:CC92                      ;
     106:  00:CC92  21 12 40            		 ld	hl,vars.status.ticks
     107:  00:CC95  34                  		 inc	(hl)
     108:  00:CC96  20 02               		 jr	nz,.doneticks
     109:  00:CC98                      ;
     110:  00:CC98  36 10               		 ld	(hl),status.DELAY
     111:  00:CC9A                      .doneticks:
     112:  00:CC9A                      ;
     113:  00:CC9A  CD B8 E6            		 call	dhcp.interrupt
     114:  00:CC9D  FD E1               		pop	iy
     115:  00:CC9F  C9                  		ret
     116:  00:CCA0                      ;
     117:  00:CCA0                      ;
     118:  00:CCA0                      ;------------------------------------------------------------------------------
     119:  00:CCA0                      ; ftp_open
     120:  00:CCA0                      ;
     121:  00:CCA0                      ; In:  DE->filename, length byte first. Could be zero length. Uppercase.
     122:  00:CCA0                      ;       C=unit number
     123:  00:CCA0                      ;
     124:  00:CCA0                      ftp_open:
     125:  00:CCA0  21 02 00            		ld	hl,ftp.ftp_channel	; Allocate our channel RAM
     126:  00:CCA3  AF                  		xor	a		; No value for channel.socket yet
     127:  00:CCA4  CD 26 CE            		call	opencreate
     128:  00:CCA7  C0                  		ret	nz
     129:  00:CCA8                      ;
     130:  00:CCA8  FD E5               		push	iy
     131:  00:CCAA  FD 21 07 40         		 ld	iy,vars		; Point IY at variables as usual
     132:  00:CCAE                      ;
     133:  00:CCAE  3E 01               		 ld	a,1		; Socket 1
     134:  00:CCB0  CD 09 ED            		 call	ftp.device_open
     135:  00:CCB3                      ;
     136:  00:CCB3  FD E1               		pop	iy
     137:  00:CCB5  C9                  		ret
     138:  00:CCB6                      ;
     139:  00:CCB6                      ;
     140:  00:CCB6                      ;------------------------------------------------------------------------------
     141:  00:CCB6                      ; ftp_create
     142:  00:CCB6                      ;
     143:  00:CCB6                      ; In:  DE->filename, length byte first. Could be zero length. Uppercase.
     144:  00:CCB6                      ;       C=unit number
     145:  00:CCB6                      ;
     146:  00:CCB6                      ftp_create:
     147:  00:CCB6  21 02 00            		ld	hl,ftp.ftp_channel	; Allocate our channel RAM
     148:  00:CCB9  AF                  		xor	a		; No value for channel.socket yet
     149:  00:CCBA  CD 26 CE            		call	opencreate
     150:  00:CCBD  C0                  		ret	nz
     151:  00:CCBE                      ;
     152:  00:CCBE  FD E5               		push	iy
     153:  00:CCC0  FD 21 07 40         		 ld	iy,vars		; Point IY at variables as usual
     154:  00:CCC4                      ;
     155:  00:CCC4  3E 01               		 ld	a,1		; Socket 1
     156:  00:CCC6  CD 0E ED            		 call	ftp.device_create
     157:  00:CCC9                      ;
     158:  00:CCC9  FD E1               		pop	iy
     159:  00:CCCB  C9                  		ret
     160:  00:CCCC                      ;
     161:  00:CCCC                      ;
     162:  00:CCCC                      ;------------------------------------------------------------------------------
     163:  00:CCCC                      ; ftp_close
     164:  00:CCCC                      ;
     165:  00:CCCC                      ftp_close:
     166:  00:CCCC  CD 41 CE            		call	entry
     167:  00:CCCF                      ;
     168:  00:CCCF  FD E5               		push	iy
     169:  00:CCD1  FD 21 07 40         		 ld	iy,vars		; Point IY at variables as usual
     170:  00:CCD5                      ;
     171:  00:CCD5  3E 01               		 ld	a,1		; Socket 1
     172:  00:CCD7  CD 48 ED            		 call	ftp.device_close
     173:  00:CCDA                      ;
     174:  00:CCDA  D9                  		exx
     175:  00:CCDB  ED 69               		out	(c),l		; Restore EXOS's paging
     176:  00:CCDD  D9                  		exx
     177:  00:CCDE                      ;
     178:  00:CCDE  FD E1               		pop	iy
     179:  00:CCE0  C9                  		ret
     180:  00:CCE1                      ;
     181:  00:CCE1                      ;
     182:  00:CCE1                      ;------------------------------------------------------------------------------
     183:  00:CCE1                      ; ftp_read_byte
     184:  00:CCE1                      ;
     185:  00:CCE1                      ftp_read_byte:
     186:  00:CCE1  CD 41 CE            		call	entry
     187:  00:CCE4                      ;
     188:  00:CCE4  FD E5               		push	iy
     189:  00:CCE6  FD 21 07 40         		 ld	iy,vars		; Point IY at variables as usual
     190:  00:CCEA                      ;
     191:  00:CCEA  3E 01               		 ld	a,1		; Socket 1
     192:  00:CCEC  CD 6E ED            		 call	ftp.device_read_byte
     193:  00:CCEF                      ;
     194:  00:CCEF  D9                  		exx
     195:  00:CCF0  ED 69               		out	(c),l		; Restore EXOS's paging
     196:  00:CCF2  D9                  		exx
     197:  00:CCF3                      ;
     198:  00:CCF3  FD E1               		pop	iy
     199:  00:CCF5  C9                  		ret
     200:  00:CCF6                      ;
     201:  00:CCF6                      ;
     202:  00:CCF6                      ;------------------------------------------------------------------------------
     203:  00:CCF6                      ; read_block
     204:  00:CCF6                      ;
     205:  00:CCF6                      ; In:  DE->buffer within user's paging
     206:  00:CCF6                      ;      BC=byte count, could be 0
     207:  00:CCF6                      ; Out: 
     208:  00:CCF6                      ;
     209:  00:CCF6                      ftp_read_block:
     210:  00:CCF6  CD 41 CE            		call	entry
     211:  00:CCF9                      ;
     212:  00:CCF9  FD E5               		push	iy
     213:  00:CCFB  FD 21 07 40         		 ld	iy,vars		; Point IY at variables as usual
     214:  00:CCFF                      ;
     215:  00:CCFF  3E 01               		 ld	a,1		; Socket 1
     216:  00:CD01  CD 8B ED            		 call	ftp.device_read_block
     217:  00:CD04                      ;
     218:  00:CD04  FD E1               		pop	iy
     219:  00:CD06  C9                  		ret
     220:  00:CD07                      ;
     221:  00:CD07                      ;
     222:  00:CD07                      ;------------------------------------------------------------------------------
     223:  00:CD07                      ; write_byte
     224:  00:CD07                      ;
     225:  00:CD07                      ftp_write_byte:
     226:  00:CD07  CD 41 CE            		call	entry
     227:  00:CD0A                      ;
     228:  00:CD0A  FD E5               		push	iy
     229:  00:CD0C  FD 21 07 40         		 ld	iy,vars		; Point IY at variables as usual
     230:  00:CD10                      ;
     231:  00:CD10  3E 01               		 ld	a,1		; Socket 1
     232:  00:CD12  CD A1 ED            		 call	ftp.device_write_byte
     233:  00:CD15                      ;
     234:  00:CD15  FD E1               		pop	iy
     235:  00:CD17  C9                  		ret
     236:  00:CD18                      ;
     237:  00:CD18                      ;
     238:  00:CD18                      ;------------------------------------------------------------------------------
     239:  00:CD18                      ; write_block
     240:  00:CD18                      ;
     241:  00:CD18                      ; In:  DE->buffer within user's paging
     242:  00:CD18                      ;      BC=byte count, could be 0
     243:  00:CD18                      ;
     244:  00:CD18                      ftp_write_block:
     245:  00:CD18  CD 41 CE            		call	entry
     246:  00:CD1B                      ;
     247:  00:CD1B  FD E5               		push	iy
     248:  00:CD1D  FD 21 07 40         		 ld	iy,vars		; Point IY at variables as usual
     249:  00:CD21                      ;
     250:  00:CD21  3E 01               		 ld	a,1		; Socket 1
     251:  00:CD23  CD BF ED            		 call	ftp.device_write_block
     252:  00:CD26                      ;
     253:  00:CD26  FD E1               		pop	iy
     254:  00:CD28  C9                  		ret
     255:  00:CD29                      ;
     256:  00:CD29                      ;
     257:  00:CD29                      ;------------------------------------------------------------------------------
     258:  00:CD29                      ; read_status
     259:  00:CD29                      ;
     260:  00:CD29                      ftp_read_status:
     261:  00:CD29  CD 41 CE            		call	entry
     262:  00:CD2C                      ;
     263:  00:CD2C  FD E5               		push	iy
     264:  00:CD2E  FD 21 07 40         		 ld	iy,vars		; Point IY at variables as usual
     265:  00:CD32                      ;
     266:  00:CD32  3E 01               		 ld	a,1		; Socket 1
     267:  00:CD34  CD CD ED            		 call	ftp.device_status
     268:  00:CD37                      ;
     269:  00:CD37  FD E1               		pop	iy
     270:  00:CD39  C9                  		ret
     271:  00:CD3A                      ;
     272:  00:CD3A                      ;
     273:  00:CD3A                      ;==============================================================================
     274:  00:CD3A                      ; TCP DEVICE
     275:  00:CD3A                      ;
     276:  00:CD3A                      ; The TCP device allows an EXOS user to eg OPEN #42:"TCP:192.168.1.100:666"
     277:  00:CD3A                      ; to open a TCP link to the specified IP address and port.
     278:  00:CD3A                      ;
     279:  00:CD3A  C0 4D               		dw	http_descriptor-8000h	; XX_NEXT Next device in P1
     280:  00:CD3C  FD FF               		dw	-2-device	; XX_RAM
     281:  00:CD3E  00                  tcp_type:	db	0		; DD_TYPE
     282:  00:CD3F  00                  		db	0		; DD_IRQFLAG
     283:  00:CD40  00                  		db	0		; DD_FLAGS
     284:  00:CD41  4A 4D               		dw	tcp_entry-8000h	; DD_TAB in page 1
     285:  00:CD43  00                  		db	0		; DD_TAB_SEG
     286:  00:CD44  00                  		db	0		; DD_UNIT_COUNT
     287:  00:CD45  03 54 43 50         		db	3,"TCP"		; DD_NAME
     288:  00:CD49  0B                  tcp_descriptor:	db	$-tcp_type	; XX_SIZE
     289:  00:CD4A                      ;
     290:  00:CD4A  76 CF               tcp_entry:	dw	interrupt
     291:  00:CD4C  66 CD               		dw	tcp_open
     292:  00:CD4E  9B CD               		dw	tcp_create
     293:  00:CD50  F4 CE               		dw	close
     294:  00:CD52  F4 CE               		dw	close		; destroy
     295:  00:CD54  53 CE               		dw	read_byte
     296:  00:CD56  6F CE               		dw	read_block
     297:  00:CD58  96 CE               		dw	write_byte
     298:  00:CD5A  B7 CE               		dw	write_block
     299:  00:CD5C  DD CE               		dw	read_status
     300:  00:CD5E  EE CE               		dw	write_status
     301:  00:CD60  F1 CE               		dw	special
     302:  00:CD62  60 CF               		dw	init
     303:  00:CD64  76 CF               		dw	moved
     304:  00:CD66                      ;
     305:  00:CD66                      ;
     306:  00:CD66  (00:0002)           TCP_SOCKET	equ	2
     307:  00:CD66                      ;
     308:  00:CD66                      ;
     309:  00:CD66                      ;------------------------------------------------------------------------------
     310:  00:CD66                      ;
     311:  00:CD66                      ; tcp_open
     312:  00:CD66                      ;
     313:  00:CD66                      ; In:  DE->filename, length byte first. Could be zero length. Uppercase.
     314:  00:CD66                      ;       C=unit number
     315:  00:CD66                      ;
     316:  00:CD66                      tcp_open:
     317:  00:CD66  21 01 00            		ld	hl,channel	; Channel RAM required
     318:  00:CD69  3E 02               		ld	a,TCP_SOCKET	; Value for channel.socket
     319:  00:CD6B  CD 26 CE            		call	opencreate
     320:  00:CD6E  C0                  		ret	nz
     321:  00:CD6F                      ;
     322:  00:CD6F  FD E5               		push	iy
     323:  00:CD71  FD 21 07 40         		 ld	iy,vars		; Point IY at variables as usual
     324:  00:CD75                      ;
     325:  00:CD75  21 1E 40            		 ld	hl,vars.device.ip
     326:  00:CD78  CD 3E D1            		 call	util.get_ip_port; HL=port, vars.device.ip filled in
     327:  00:CD7B  9F                  		 sbc	a,a
     328:  00:CD7C  E6 6D               		 and	exos.ERR_BADIP
     329:  00:CD7E  20 18               		 jr	nz,.ret
     330:  00:CD80                      ;
     331:  00:CD80  E5                  		 push	hl		; Save dest port
     332:  00:CD81  3E 02               		  ld	a,TCP_SOCKET
     333:  00:CD83  21 2A 00            		  ld	hl,42		; Source port
     334:  00:CD86  11 77 CF            		  ld	de,tcp_owner_str; Our name
     335:  00:CD89  CD 6E DF            		  call	tcp.open
     336:  00:CD8C  E1                  		 pop	hl		; HL=dest port
     337:  00:CD8D  11 1E 40            		 ld	de,vars.device.ip; DE->ip address
     338:  00:CD90  3E 02               		 ld	a,TCP_SOCKET
     339:  00:CD92  D4 8E E1            		 call	nc,tcp.connect
     340:  00:CD95  9F                  		 sbc	a,a
     341:  00:CD96  E6 6B               		 and	exos.ERR_NOCON
     342:  00:CD98                      ;
     343:  00:CD98  FD E1               .ret:		pop	iy
     344:  00:CD9A  C9                  		ret
     345:  00:CD9B                      ;
     346:  00:CD9B                      ;
     347:  00:CD9B                      ;------------------------------------------------------------------------------
     348:  00:CD9B                      ; tcp_create
     349:  00:CD9B                      ;
     350:  00:CD9B                      ; In:  DE->filename, length byte first. Could be zero length. Uppercase.
     351:  00:CD9B                      ;       C=unit number
     352:  00:CD9B                      tcp_create:
     353:  00:CD9B  21 01 00            		ld	hl,channel	; Channel RAM required
     354:  00:CD9E  3E 02               		ld	a,TCP_SOCKET	; Value for channel.socket
     355:  00:CDA0  CD 26 CE            		call	opencreate
     356:  00:CDA3  C0                  		ret	nz
     357:  00:CDA4                      ;
     358:  00:CDA4  FD E5               		push	iy
     359:  00:CDA6  FD 21 07 40         		 ld	iy,vars		; Point IY at variables as usual
     360:  00:CDAA                      ;
     361:  00:CDAA                      		; !!! Code for create here ? !!!!
     362:  00:CDAA  3E 01                ld a,1
     363:  00:CDAC                      
     364:  00:CDAC  AF                  		xor	a
     365:  00:CDAD  FD E1               		pop	iy
     366:  00:CDAF  C9                  		ret
     367:  00:CDB0                      ;
     368:  00:CDB0                      ;
     369:  00:CDB0                      ;==============================================================================
     370:  00:CDB0                      ; HTTP DEVICE
     371:  00:CDB0                      ;
     372:  00:CDB0                      ; The HTTP device allows an EXOS user to eg OPEN #42:"HTTP:192.168.1.100/file"
     373:  00:CDB0                      ; to open a TCP link to the specified IP address and read the file.
     374:  00:CDB0                      ;
     375:  00:CDB0  00 00                DW 0
     376:  00:CDB2                      ;		dw	mem_descriptor-8000h; XX_NEXT 0=>no more devices in ROM
     377:  00:CDB2  FD FF               		dw	-2-device	; XX_RAM
     378:  00:CDB4  00                  http_type:	db	0		; DD_TYPE
     379:  00:CDB5  00                  		db	0		; DD_IRQFLAG
     380:  00:CDB6  00                  		db	0		; DD_FLAGS
     381:  00:CDB7  C1 4D               		dw	http_entry-8000h; DD_TAB in page 1
     382:  00:CDB9  00                  		db	0		; DD_TAB_SEG
     383:  00:CDBA  00                  		db	0		; DD_UNIT_COUNT
     384:  00:CDBB  04 48 54 54 50      		db	4,"HTTP"	; DD_NAME
     385:  00:CDC0  0C                  http_descriptor:db	$-http_type	; XX_SIZE
     386:  00:CDC1                      ;
     387:  00:CDC1  76 CF               http_entry:	dw	interrupt
     388:  00:CDC3  DD CD               		dw	http_open
     389:  00:CDC5  EE CE               		dw	nofn		; Create
     390:  00:CDC7  F4 CE               		dw	close
     391:  00:CDC9  F4 CE               		dw	close		; Destroy
     392:  00:CDCB  53 CE               		dw	read_byte
     393:  00:CDCD  6F CE               		dw	read_block
     394:  00:CDCF  EE CE               		dw	nofn		; write_byte
     395:  00:CDD1  EE CE               		dw	nofn		; write_block
     396:  00:CDD3  DD CE               		dw	read_status
     397:  00:CDD5  EE CE               		dw	write_status
     398:  00:CDD7  F1 CE               		dw	special
     399:  00:CDD9  60 CF               		dw	init
     400:  00:CDDB  76 CF               		dw	moved
     401:  00:CDDD                      ;
     402:  00:CDDD                      ;
     403:  00:CDDD                      ;------------------------------------------------------------------------------
     404:  00:CDDD                      ;
     405:  00:CDDD                      ; http_open
     406:  00:CDDD                      ;
     407:  00:CDDD                      ; In:  DE->filename, length byte first. Could be zero length. Uppercase.
     408:  00:CDDD                      ;       C=unit number
     409:  00:CDDD                      http_open:
     410:  00:CDDD  21 03 00            		ld	hl,http.http_channel	; Channel RAM required
     411:  00:CDE0  CD 26 CE            		call	opencreate
     412:  00:CDE3  C0                  		ret	nz
     413:  00:CDE4                      ;
     414:  00:CDE4  FD E5               		push	iy
     415:  00:CDE6  FD 21 07 40         		 ld	iy,vars		; Point IY at variables as usual
     416:  00:CDEA                      ;
     417:  00:CDEA                      		 ; First skip leading /s to allow HTTP://...
     418:  00:CDEA  1A                  		 ld	a,(de)		; Get length byte
     419:  00:CDEB  47                  		 ld	b,a		; B=length byte
     420:  00:CDEC  04                  		 inc	b		; To skip initial dec b
     421:  00:CDED  05                  .slash.loop:	 dec	b
     422:  00:CDEE  28 0A               		 jr	z,.slash.done
     423:  00:CDF0                      ;
     424:  00:CDF0  13                  		 inc	de
     425:  00:CDF1  1A                  		 ld	a,(de)
     426:  00:CDF2  FE 2F               		 cp	'/'
     427:  00:CDF4  28 F7               		 jr	z,.slash.loop
     428:  00:CDF6  FE 5C               		 cp	"\\"
     429:  00:CDF8  28 F3               		 jr	z,.slash.loop
     430:  00:CDFA                      ;
     431:  00:CDFA                      		 ; Save host name in vars.device.host
     432:  00:CDFA  D5                  .slash.done:	 push	de		; Save->host/filename name
     433:  00:CDFB  C5                  		 push	bc		; Save length in B
     434:  00:CDFC  21 60 40            		  ld	hl,vars.device.host	; Copy host name to here
     435:  00:CDFF  04                  		  inc	b
     436:  00:CE00  18 0C               		  jr	.host.djnz
     437:  00:CE02                      
     438:  00:CE02  1A                  .host.loop:	  ld	a,(de)
     439:  00:CE03  13                  		  inc	de
     440:  00:CE04  FE 2F               		  cp	'/'
     441:  00:CE06  28 08               		  jr	z,.host.done
     442:  00:CE08  FE 5C               		  cp	"\\"
     443:  00:CE0A  28 04               		  jr	z,.host.done
     444:  00:CE0C                      ;
     445:  00:CE0C  77                  		  ld	(hl),a
     446:  00:CE0D  23                  		  inc	hl
     447:  00:CE0E  10 F2               .host.djnz:	  djnz	.host.loop
     448:  00:CE10                      ;
     449:  00:CE10                      		  ;inc	b
     450:  00:CE10                      .host.done:	  ;dec	b		; Skip /
     451:  00:CE10  36 00               		  ld	(hl),0		; Null-terminate host name
     452:  00:CE12  C1                  		 pop	bc		; B=length of host/filename
     453:  00:CE13  D1                  		 pop	de		; DE->host/filename
     454:  00:CE14                      ;
     455:  00:CE14  21 1E 40            		 ld	hl,vars.device.ip	; Read IP address to here
     456:  00:CE17  CD 7B D1            		 call	util._get_ip	; vars.device.ip=IP; DE->filename, B=len
     457:  00:CE1A  9F                  		 sbc	a,a
     458:  00:CE1B  E6 6D               		 and	exos.ERR_BADIP
     459:  00:CE1D  CC 60 EE            		 call	z,http.device_open
     460:  00:CE20                      ;
     461:  00:CE20  FD E1               		pop	iy
     462:  00:CE22  C9                  		ret
     463:  00:CE23                      ;
     464:  00:CE23                      ;
     465:  00:CE23                      ;------------------------------------------------------------------------------
     466:  00:CE23                      ; http_create
     467:  00:CE23                      ;
     468:  00:CE23                      ; In:  DE->filename, length byte first. Could be zero length. Uppercase.
     469:  00:CE23                      ;       C=unit number
     470:  00:CE23                      http_create:
     471:  00:CE23  3E E7               		ld	a,exos.ERR_NOFN
     472:  00:CE25  C9                  		ret
     473:  00:CE26                      ;
     474:  00:CE26                      ;
     475:  00:CE26                      /*
     476:  00:CE26                    ~ ;==============================================================================
     477:  00:CE26                    ~ ; MEM DEVICE
     478:  00:CE26                    ~ ;
     479:  00:CE26                    ~ ; The MEM: device allows temporary buffering in memory.
     480:  00:CE26                    ~ ;
     481:  00:CE26                    ~ ; The "filename" during create is the buffer size which is then allocated.
     482:  00:CE26                    ~ ; Writes then just go to the allocated memory
     483:  00:CE26                    ~ ; Open opens the memory file for reading
     484:  00:CE26                    ~ ; Close closes it but does not free the memory - it can be opened again
     485:  00:CE26                    ~ ; Destroy or a create filename of 0 frees the memory
     486:  00:CE26                    ~ ;
     487:  00:CE26                    ~ 		dw	0		; XX_NEXT Next device in P1
     488:  00:CE26                    ~ 		dw	-2-device	; XX_RAM
     489:  00:CE26                    ~ mem_type:	db	0		; DD_TYPE
     490:  00:CE26                    ~ 		db	0		; DD_IRQFLAG
     491:  00:CE26                    ~ 		db	0		; DD_FLAGS
     492:  00:CE26                    ~ 		dw	mem_entry-8000h	; DD_TAB in page 1
     493:  00:CE26                    ~ 		db	0		; DD_TAB_SEG
     494:  00:CE26                    ~ 		db	0		; DD_UNIT_COUNT
     495:  00:CE26                    ~ 		db	3,"MEM"		; DD_NAME
     496:  00:CE26                    ~ mem_descriptor:	db	$-mem_type	; XX_SIZE
     497:  00:CE26                    ~ ;
     498:  00:CE26                    ~ mem_entry:	dw	interrupt
     499:  00:CE26                    ~ 		dw	mem_open
     500:  00:CE26                    ~ 		dw	mem_create
     501:  00:CE26                    ~ 		dw	mem_close
     502:  00:CE26                    ~ 		dw	mem_destroy	; destroy
     503:  00:CE26                    ~ 		dw	mem_read_byte
     504:  00:CE26                    ~ 		dw	mem_read_block
     505:  00:CE26                    ~ 		dw	mem_write_byte
     506:  00:CE26                    ~ 		dw	mem_write_block
     507:  00:CE26                    ~ 		dw	mem_read_status
     508:  00:CE26                    ~ 		dw	write_status
     509:  00:CE26                    ~ 		dw	mem_special
     510:  00:CE26                    ~ 		dw	init
     511:  00:CE26                    ~ 		dw	moved
     512:  00:CE26                    ~ ;
     513:  00:CE26                    ~ ;
     514:  00:CE26                    ~ ;------------------------------------------------------------------------------
     515:  00:CE26                    ~ ;
     516:  00:CE26                    ~ ; mem_open
     517:  00:CE26                    ~ ;
     518:  00:CE26                    ~ ; In:  DE->filename, length byte first. Could be zero length. Uppercase.
     519:  00:CE26                    ~ ;       C=unit number
     520:  00:CE26                    ~ ;
     521:  00:CE26                    ~ mem_open:
     522:  00:CE26                    ~ 		ld	a,(iy-4-device.seg)	; Get our variable's segment
     523:  00:CE26                    ~ 		out	(ep.P1),a		; Page it in
     524:  00:CE26                    ~ ;
     525:  00:CE26                    ~ 		push	iy
     526:  00:CE26                    ~ 		 ld	iy,vars			; Point IY at variables as usual
     527:  00:CE26                    ~ ;
     528:  00:CE26                    ~ 		 or	a
     529:  00:CE26                    ~ 		 sbc	hl,hl		; HL=0
     530:  00:CE26                    ~ 		 ld	(vars.mem.rd),hl; Initial read pos = 0
     531:  00:CE26                    ~ ;
     532:  00:CE26                    ~ 		 ex	de,hl		; DE=0 (no channel RAM required)
     533:  00:CE26                    ~ 		 EXOS	exos.FN_BUFF
     534:  00:CE26                    ~ ;
     535:  00:CE26                    ~ .ret:		pop	iy
     536:  00:CE26                    ~ 		ret
     537:  00:CE26                    ~ ;
     538:  00:CE26                    ~ ;
     539:  00:CE26                    ~ ;------------------------------------------------------------------------------
     540:  00:CE26                    ~ ; mem_create
     541:  00:CE26                    ~ ;
     542:  00:CE26                    ~ ; In:  DE->filename, length byte first. Could be zero length. Uppercase.
     543:  00:CE26                    ~ ;       C=unit number
     544:  00:CE26                    ~ ;
     545:  00:CE26                    ~ mem_create:
     546:  00:CE26                    ~ 		ld	a,(iy-4-device.seg)	; Get our variable's segment
     547:  00:CE26                    ~ 		out	(ep.P1),a		; Page it in
     548:  00:CE26                    ~ ;
     549:  00:CE26                    ~ 		push	iy
     550:  00:CE26                    ~ 		 ld	iy,vars			; Point IY at variables as usual
     551:  00:CE26                    ~ ;
     552:  00:CE26                    ~ 		 call	free_seg
     553:  00:CE26                    ~ 		 jr	nz,.ret
     554:  00:CE26                    ~ ;
     555:  00:CE26                    ~ 		 EXOS	exos.FN_ALLOC	; Allocate a segment
     556:  00:CE26                    ~ 		 jr	nz,.ret		; Go if error
     557:  00:CE26                    ~ ;
     558:  00:CE26                    ~ .gotseg:	 ld	a,c		; A=allocated segment
     559:  00:CE26                    ~ 		 ld	(vars.mem.seg),a; Save it
     560:  00:CE26                    ~ 		 or	a
     561:  00:CE26                    ~ 		 sbc	hl,hl		; HL=0
     562:  00:CE26                    ~ 		 ld	(vars.mem.rd),hl; Initial pos = 0
     563:  00:CE26                    ~ 		 ld	(vars.mem.wr),hl; Initial pos = 0
     564:  00:CE26                    ~ ;
     565:  00:CE26                    ~ .ret:		pop	iy
     566:  00:CE26                    ~ 		ret
     567:  00:CE26                    ~ ;
     568:  00:CE26                    ~ ;
     569:  00:CE26                    ~ ;------------------------------------------------------------------------------
     570:  00:CE26                    ~ ; mem_close
     571:  00:CE26                    ~ ;
     572:  00:CE26                    ~ ; If it's been open for writing, we don't free up our buffer memory.
     573:  00:CE26                    ~ ; But if it's been open for reading, we do.
     574:  00:CE26                    ~ ;
     575:  00:CE26                    ~ mem_close:
     576:  00:CE26                    ~ 		ld	a,(iy-4-device.seg)	; Get our variable's segment
     577:  00:CE26                    ~ 		out	(ep.P1),a		; Page it in
     578:  00:CE26                    ~ ;
     579:  00:CE26                    ~ 		push	iy
     580:  00:CE26                    ~ 		 ld	iy,vars			; Point IY at variables as usual
     581:  00:CE26                    ~ ;
     582:  00:CE26                    ~ 		 ld	hl,(vars.mem.rd); See if read pos is non-zero
     583:  00:CE26                    ~ 		 ld	a,h
     584:  00:CE26                    ~ 		 or	l
     585:  00:CE26                    ~ 		 call	nz,free_seg	; Free seg once it's been read
     586:  00:CE26                    ~ ;
     587:  00:CE26                    ~ 		pop	iy
     588:  00:CE26                    ~ 		ret
     589:  00:CE26                    ~ ;
     590:  00:CE26                    ~ ;
     591:  00:CE26                    ~ ;------------------------------------------------------------------------------
     592:  00:CE26                    ~ ; mem_destroy
     593:  00:CE26                    ~ ;
     594:  00:CE26                    ~ mem_destroy:
     595:  00:CE26                    ~ 		ld	a,(iy-4-device.seg)	; Get our variable's segment
     596:  00:CE26                    ~ 		out	(ep.P1),a		; Page it in
     597:  00:CE26                    ~ ;
     598:  00:CE26                    ~ 		push	iy
     599:  00:CE26                    ~ 		 ld	iy,vars			; Point IY at variables as usual
     600:  00:CE26                    ~ ;
     601:  00:CE26                    ~ 		 ld	a,(vars.mem.seg); See if any currently allocated seg
     602:  00:CE26                    ~ 		 or	a
     603:  00:CE26                    ~ 		 jr	z,.ret		; Go with A=0 if not
     604:  00:CE26                    ~ ;
     605:  00:CE26                    ~ 		 ld	c,a		; C=segment to free
     606:  00:CE26                    ~ 		 EXOS	exos.FN_FREE	; Free it
     607:  00:CE26                    ~ 
     608:  00:CE26                    ~ .ret:		pop	iy
     609:  00:CE26                    ~ 		ret
     610:  00:CE26                    ~ ;
     611:  00:CE26                    ~ ;
     612:  00:CE26                    ~ ;------------------------------------------------------------------------------
     613:  00:CE26                    ~ ; mem_read_byte
     614:  00:CE26                    ~ ;
     615:  00:CE26                    ~ mem_read_byte:
     616:  00:CE26                    ~ 		ld	a,(iy-4-device.seg)	; Get our variable's segment
     617:  00:CE26                    ~ 		out	(ep.P1),a		; Page it in
     618:  00:CE26                    ~ ;
     619:  00:CE26                    ~ 		push	iy
     620:  00:CE26                    ~ 		 ld	iy,vars			; Point IY at variables as usual
     621:  00:CE26                    ~ ;
     622:  00:CE26                    ~ 		 call	have_seg		; See if we have a seg allocated
     623:  00:CE26                    ~ 		 jr	nz,.ret			; Return error if not
     624:  00:CE26                    ~ ;
     625:  00:CE26                    ~ 		 call	next_read		; HL->current read pos
     626:  00:CE26                    ~ 		 jr	nc,.ret			; Return if no more to read
     627:  00:CE26                    ~ ;
     628:  00:CE26                    ~ 		 set	6,h			; Make P1 pointer
     629:  00:CE26                    ~ 		 ld	a,(vars.mem.seg)	; Get our segment
     630:  00:CE26                    ~ 		 out	(ep.P1),a		; Put in page 1
     631:  00:CE26                    ~ 		 ld	b,(hl)			; Get byte
     632:  00:CE26                    ~ 		 xor 	a			; No error
     633:  00:CE26                    ~ ;
     634:  00:CE26                    ~ .ret:		pop	iy
     635:  00:CE26                    ~ 		ret
     636:  00:CE26                    ~ ;
     637:  00:CE26                    ~ ;
     638:  00:CE26                    ~ ;------------------------------------------------------------------------------
     639:  00:CE26                    ~ ; mem_read_block
     640:  00:CE26                    ~ ;
     641:  00:CE26                    ~ mem_read_block:
     642:  00:CE26                    ~ 		ld	a,(iy-4-device.seg)	; Get our variable's segment
     643:  00:CE26                    ~ 		out	(ep.P1),a		; Page it in
     644:  00:CE26                    ~ ;
     645:  00:CE26                    ~ 		push	iy
     646:  00:CE26                    ~ 		 ld	iy,vars			; Point IY at variables as usual
     647:  00:CE26                    ~ ;
     648:  00:CE26                    ~ 		 call	have_seg		; See if we have a seg allocated
     649:  00:CE26                    ~ 		 jr	nz,.ret			; Return error if not
     650:  00:CE26                    ~ ;
     651:  00:CE26                    ~ 		 jr	.ztest
     652:  00:CE26                    ~ ;
     653:  00:CE26                    ~ .loop:		 push	de			; Save -> user buffer
     654:  00:CE26                    ~ 		  call	next_read		; HL->current read pos
     655:  00:CE26                    ~ 		 pop	de			; DE->user's buffer
     656:  00:CE26                    ~ 		 jr	nc,.ret			; Go if no more to read
     657:  00:CE26                    ~ ;
     658:  00:CE26                    ~ 		 ld	a,(vars.mem.seg)	; Get our segment
     659:  00:CE26                    ~ 		 out	(ep.P1),a		; Page it in to page 1
     660:  00:CE26                    ~ 		 set	6,h			; Turn into P1 pointer
     661:  00:CE26                    ~ 		 ld	a,(hl)			; A=byte from mem buffer
     662:  00:CE26                    ~ ;
     663:  00:CE26                    ~ 		 push	de			; Save -> user's buffer
     664:  00:CE26                    ~ 		  push	af			; Save byte from mem buffer
     665:  00:CE26                    ~ 		   call	users_page
     666:  00:CE26                    ~ 		  pop	af			; A=byte from mem buffer
     667:  00:CE26                    ~ 		  ld	(de),a			; Write to user's buffer
     668:  00:CE26                    ~ 		 pop	de			; DE->user's buffer
     669:  00:CE26                    ~ 		 inc	de			; Next buffer pos next time
     670:  00:CE26                    ~ 		 dec	bc			; Done another byte
     671:  00:CE26                    ~ .ztest:		 ld	a,b			; Any more to do?
     672:  00:CE26                    ~ 		 or	c
     673:  00:CE26                    ~ 		 jr	nz,.loop		; Repeat if yes
     674:  00:CE26                    ~ ;
     675:  00:CE26                    ~ .ret:		pop	iy
     676:  00:CE26                    ~ 		ret
     677:  00:CE26                    ~ ;
     678:  00:CE26                    ~ ;
     679:  00:CE26                    ~ ;------------------------------------------------------------------------------
     680:  00:CE26                    ~ ; mem_write_byte
     681:  00:CE26                    ~ ;
     682:  00:CE26                    ~ mem_write_byte:
     683:  00:CE26                    ~ 		ld	a,(iy-4-device.seg)	; Get our variable's segment
     684:  00:CE26                    ~ 		out	(ep.P1),a		; Page it in
     685:  00:CE26                    ~ ;
     686:  00:CE26                    ~ 		push	iy
     687:  00:CE26                    ~ 		 ld	iy,vars			; Point IY at variables as usual
     688:  00:CE26                    ~ ;
     689:  00:CE26                    ~ 		 call	have_seg		; See if we have a seg allocated
     690:  00:CE26                    ~ 		 jr	nz,.ret			; Return error if not
     691:  00:CE26                    ~ ;
     692:  00:CE26                    ~ 		 call	next_write
     693:  00:CE26                    ~ 		 jr	nz,.ret
     694:  00:CE26                    ~ ;
     695:  00:CE26                    ~ 		 set	6,h			; Make a P1 pointer
     696:  00:CE26                    ~ 		 ld	a,(vars.mem.seg)	; Get our segment
     697:  00:CE26                    ~ 		 out	(ep.P1),a		; Page it in
     698:  00:CE26                    ~ 		 ld	(hl),b			; Write byte
     699:  00:CE26                    ~ 		 xor 	a			; No error
     700:  00:CE26                    ~ ;
     701:  00:CE26                    ~ .ret:		pop	iy
     702:  00:CE26                    ~ 		ret
     703:  00:CE26                    ~ ;
     704:  00:CE26                    ~ ;
     705:  00:CE26                    ~ ;------------------------------------------------------------------------------
     706:  00:CE26                    ~ ; mem_write_block
     707:  00:CE26                    ~ ;
     708:  00:CE26                    ~ mem_write_block:
     709:  00:CE26                    ~ 		ld	a,(iy-4-device.seg)	; Get our variable's segment
     710:  00:CE26                    ~ 		out	(ep.P1),a		; Page it in
     711:  00:CE26                    ~ ;
     712:  00:CE26                    ~ 		push	iy
     713:  00:CE26                    ~ 		 ld	iy,vars			; Point IY at variables as usual
     714:  00:CE26                    ~ ;
     715:  00:CE26                    ~ 		 call	have_seg		; See if we have a seg allocated
     716:  00:CE26                    ~ 		 jr	nz,.ret			; Return error if not
     717:  00:CE26                    ~ 
     718:  00:CE26                    ~ 		 jr	.ztest
     719:  00:CE26                    ~ ;
     720:  00:CE26                    ~ .loop:		 call	next_write
     721:  00:CE26                    ~ 		 jr	nz,.ret			; Return with error if yes
     722:  00:CE26                    ~ ;
     723:  00:CE26                    ~ 		 push	de			; Save -> user's buffer
     724:  00:CE26                    ~ 		 push	hl			; Save -> our buffer
     725:  00:CE26                    ~ 		  call	users_page
     726:  00:CE26                    ~ 		  ld	a,(de)			; A=byte from user's buffer
     727:  00:CE26                    ~ 		 pop	hl			; HL->our buffer
     728:  00:CE26                    ~ 		 pop	de			; DE->user's buffer
     729:  00:CE26                    ~ 		 inc	de			; Next pos next time
     730:  00:CE26                    ~ ;
     731:  00:CE26                    ~ 		 push	af			; Save byte from user's buffer
     732:  00:CE26                    ~ 		  ld	a,(vars.mem.seg)	; Get our segment
     733:  00:CE26                    ~ 		  out	(ep.P1),a		; Page it in to page 1
     734:  00:CE26                    ~ 		  set	6,h			; Turn into P1 pointer
     735:  00:CE26                    ~ 		 pop	af			; A=byte from user's buffer
     736:  00:CE26                    ~ 		 ld	(hl),a			; Put in our buffer
     737:  00:CE26                    ~ ;
     738:  00:CE26                    ~ 		 dec	bc			; Done another byte
     739:  00:CE26                    ~ .ztest:		 ld	a,b			; Any more to do?
     740:  00:CE26                    ~ 		 or	c
     741:  00:CE26                    ~ 		 jr	nz,.loop		; Repeat if yes
     742:  00:CE26                    ~ ;
     743:  00:CE26                    ~ 		push	de
     744:  00:CE26                    ~ .popret:	pop	de
     745:  00:CE26                    ~ .ret:
     746:  00:CE26                    ~ popiyret:	pop	iy
     747:  00:CE26                    ~ 		ret
     748:  00:CE26                    ~ ;
     749:  00:CE26                    ~ ;
     750:  00:CE26                    ~ ;------------------------------------------------------------------------------
     751:  00:CE26                    ~ ; mem_read_status
     752:  00:CE26                    ~ ;
     753:  00:CE26                    ~ mem_read_status:
     754:  00:CE26                    ~ 		ld	a,(iy-4-device.seg)	; Get our variable's segment
     755:  00:CE26                    ~ 		out	(ep.P1),a		; Page it in
     756:  00:CE26                    ~ ;
     757:  00:CE26                    ~ 		push	iy
     758:  00:CE26                    ~ 		 ld	iy,vars			; Point IY at variables as usual
     759:  00:CE26                    ~ ;
     760:  00:CE26                    ~ 		 call	have_seg		; See if we have a seg allocated
     761:  00:CE26                    ~ 		 jr	nz,popiyret		; Return error if not
     762:  00:CE26                    ~ ;
     763:  00:CE26                    ~ 		 ld	de,(vars.mem.wr)	; DE->end of buffer
     764:  00:CE26                    ~ 		 ld	hl,(vars.mem.rd)	; HL->current read pos
     765:  00:CE26                    ~ 		 inc	hl			; Next pos
     766:  00:CE26                    ~ 		 xor	a
     767:  00:CE26                    ~ 		 sbc	hl,de			; NC=>next pos = buffer end
     768:  00:CE26                    ~ 		 ccf				; Cy=>next pos = buffer end
     769:  00:CE26                    ~ 		 sbc	a,a			; FF=>next pos = end, else 0
     770:  00:CE26                    ~ 		 ld	c,a			; C=ff => end of file, 0=>ready
     771:  00:CE26                    ~ ;
     772:  00:CE26                    ~ 		pop	iy
     773:  00:CE26                    ~ 		ret
     774:  00:CE26                    ~ ;
     775:  00:CE26                    ~ ;
     776:  00:CE26                    ~ ;------------------------------------------------------------------------------
     777:  00:CE26                    ~ ; mem_special
     778:  00:CE26                    ~ ;
     779:  00:CE26                    ~ mem_special:
     780:  00:CE26                    ~ 		ld	a,(iy-4-device.seg)	; Get our variable's segment
     781:  00:CE26                    ~ 		out	(ep.P1),a		; Page it in
     782:  00:CE26                    ~ ;
     783:  00:CE26                    ~ 		push	iy
     784:  00:CE26                    ~ 		 ld	iy,vars			; Point IY at variables as usual
     785:  00:CE26                    ~ ;
     786:  00:CE26                    ~ 		 ld	a,b		; Get sub-function
     787:  00:CE26                    ~ 		 cp	exos.FN_MEM_SEG	; Our get segment fn?
     788:  00:CE26                    ~ 		 ld	a,exos.ERR_ISPEC
     789:  00:CE26                    ~ 		 jr	nz,.ret		; Return with error if not
     790:  00:CE26                    ~ ;
     791:  00:CE26                    ~ 		 ld	a,(vars.mem.seg); Get segment
     792:  00:CE26                    ~ 		 ld	c,a		; Return in C
     793:  00:CE26                    ~ 		 ld	de,(vars.mem.rd); Return DE->current read pos
     794:  00:CE26                    ~ ;
     795:  00:CE26                    ~ 		 xor	a		; No error
     796:  00:CE26                    ~ ;
     797:  00:CE26                    ~ .ret:		pop	iy
     798:  00:CE26                    ~ 		ret
     799:  00:CE26                    ~ ;
     800:  00:CE26                    ~ ;
     801:  00:CE26                    ~ ;-----------------------------------------------
     802:  00:CE26                    ~ ; users_page
     803:  00:CE26                    ~ ;
     804:  00:CE26                    ~ ; Takes a user's pointer in DE and turns it into a page 1 pointer with the
     805:  00:CE26                    ~ ; currect page paged into page 1
     806:  00:CE26                    ~ ;
     807:  00:CE26                    ~ ; In:  DE->user's buffer anyhere in Z80 space
     808:  00:CE26                    ~ ; Out: DE->page 1
     809:  00:CE26                    ~ ;      P1=user's segment corresponding to original DE
     810:  00:CE26                    ~ ;
     811:  00:CE26                    ~ users_page:
     812:  00:CE26                    ~ 		ld	a,d			; A=high byte of user's buffer
     813:  00:CE26                    ~ 		rlca
     814:  00:CE26                    ~ 		rlca
     815:  00:CE26                    ~ 		and	3			; A=Z80 page 0-3
     816:  00:CE26                    ~ 		add	a,LOW exos.USR_P0
     817:  00:CE26                    ~ 		ld	l,a
     818:  00:CE26                    ~ 		ld	h,HIGH exos.USR_P0	; HL->user's page in EXOS var
     819:  00:CE26                    ~ 		ld	a,(hl)			; Get user's segment
     820:  00:CE26                    ~ 		out	(ep.P1),a		; Page it into page 1
     821:  00:CE26                    ~ 		res	7,d			; Adjust user's pointer to P1
     822:  00:CE26                    ~ 		set	6,d
     823:  00:CE26                    ~ 		ret
     824:  00:CE26                    ~ ;
     825:  00:CE26                    ~ ;
     826:  00:CE26                    ~ ;-----------------------------------------------
     827:  00:CE26                    ~ ; Returns NC and error code in A if there's no more to read, else
     828:  00:CE26                    ~ ; vars.mem.read has been updated and HL->current byte
     829:  00:CE26                    ~ ;
     830:  00:CE26                    ~ next_read:	ld	de,(vars.mem.wr)	; DE->end of buffer
     831:  00:CE26                    ~ 		ld	hl,(vars.mem.rd)	; HL->current read pos
     832:  00:CE26                    ~ 		inc	hl			; Next pos
     833:  00:CE26                    ~ 		or	a
     834:  00:CE26                    ~ 		sbc	hl,de			; See if next pos = buffer end
     835:  00:CE26                    ~ 		ld	a,exos.ERR_EOF
     836:  00:CE26                    ~ 		ret	nc
     837:  00:CE26                    ~ ;
     838:  00:CE26                    ~ 		add	hl,de			; HL->next read pos
     839:  00:CE26                    ~ 		ld	(vars.mem.rd),hl	; Save for next time
     840:  00:CE26                    ~ 		dec	hl			; HL->back to current read pos
     841:  00:CE26                    ~ 		scf				; No error
     842:  00:CE26                    ~ 		ret
     843:  00:CE26                    ~ ;
     844:  00:CE26                    ~ ;
     845:  00:CE26                    ~ ;-----------------------------------------------
     846:  00:CE26                    ~ ; Increments the write pos but returns NZ and error code in A if no more
     847:  00:CE26                    ~ ; room in buffer
     848:  00:CE26                    ~ ;
     849:  00:CE26                    ~ next_write:
     850:  00:CE26                    ~ 		ld	hl,(vars.mem.wr)	; HL->current end of buffer
     851:  00:CE26                    ~ 		inc	hl			; HL->next pos
     852:  00:CE26                    ~ 		bit	6,h			; See if overflowed segment
     853:  00:CE26                    ~ 		ld	a,exos.ERR_MEMFULL
     854:  00:CE26                    ~ 		ret	nz			; Return with error if yes
     855:  00:CE26                    ~ ;
     856:  00:CE26                    ~ 		ld	(vars.mem.wr),hl	; Save new pos
     857:  00:CE26                    ~ 		dec	hl			; HL->back to current pos
     858:  00:CE26                    ~ 		xor	a
     859:  00:CE26                    ~ 		ret
     860:  00:CE26                    ~ ;
     861:  00:CE26                    ~ ;
     862:  00:CE26                    ~ ;-----------------------------------------------
     863:  00:CE26                    ~ have_seg:
     864:  00:CE26                    ~ 		ld	a,(vars.mem.seg); See if any currently allocated seg
     865:  00:CE26                    ~ 		sub	1		; Cy=>was 0, else NC
     866:  00:CE26                    ~ 		sbc	a,a		; FF=>was 0, else 0
     867:  00:CE26                    ~ 		and	exos.ERR_NOMEM	; Error code or 0, NZ or Z
     868:  00:CE26                    ~ 		ret
     869:  00:CE26                    ~ ;
     870:  00:CE26                    ~ ;
     871:  00:CE26                    ~ ;-----------------------------------------------
     872:  00:CE26                    ~ free_seg:	ld	hl,vars.mem.seg
     873:  00:CE26                    ~ 		ld	a,(hl)		; A=segment to free
     874:  00:CE26                    ~ 		or	a
     875:  00:CE26                    ~ 		ret	z		; Ret if we didn't have a seg
     876:  00:CE26                    ~ ;		 
     877:  00:CE26                    ~ 		ld	c,a		; C=segment to free
     878:  00:CE26                    ~ 		ld	(hl),0		; Haven't got a seg any more
     879:  00:CE26                    ~ 		EXOS	exos.FN_FREE	; Free it
     880:  00:CE26                    ~ 		ret
     881:  00:CE26                    ~ ;
     882:  00:CE26                    ~ */
     883:  00:CE26                      ;
     884:  00:CE26                      ;
     885:  00:CE26                      ;==============================================================================
     886:  00:CE26                      ; GENERAL DEVICE ROUTINES
     887:  00:CE26                      ;
     888:  00:CE26                      ; The follwoing routines are general EXOS device routines suitable for most
     889:  00:CE26                      ; of the EXOS devices we implement. But some devices may require different
     890:  00:CE26                      ; routines eg. FTP: close closes the FTP data channel, not the control channel.
     891:  00:CE26                      ;
     892:  00:CE26                      ; The socket number is saved in the first byte of channel RAM at (ix-1) which
     893:  00:CE26                      ; allows different devies to use common same code.
     894:  00:CE26                      ;
     895:  00:CE26                      ;
     896:  00:CE26                      ;------------------------------------------------------------------------------
     897:  00:CE26                      ; opencreate
     898:  00:CE26                      ;
     899:  00:CE26                      ; This is called from the devices's open and create. It allocates the channel
     900:  00:CE26                      ; RAM and sets up the paging registers appropriately.
     901:  00:CE26                      ;
     902:  00:CE26                      ; In:  HL=amount of channel RAM required
     903:  00:CE26                      ;      DE->filename, as per EXOS entry point
     904:  00:CE26                      ;       A=value for channel.socket once RAM allocated
     905:  00:CE26                      ; Out: NZ=>error
     906:  00:CE26                      ;
     907:  00:CE26                      opencreate:
     908:  00:CE26  F5                  		push	af		; Save channel.socket value
     909:  00:CE27  FD 7E FC            		 ld	a,(iy-4-device.seg)	; Get our variable's segment
     910:  00:CE2A                      ;
     911:  00:CE2A  D9                  		 exx
     912:  00:CE2B  47                  		 ld	b,a		; B' always=our RAM seg
     913:  00:CE2C  5F                  		 ld	e,a		; socket.asm seg
     914:  00:CE2D  57                  		 ld	d,a		; tcp.asm seg
     915:  00:CE2E  0E B1               		 ld	c,ep.P1		; C' always ->P1
     916:  00:CE30  D9                  		 exx
     917:  00:CE31                      ;
     918:  00:CE31  EB                  		 ex	de,hl		; DE=channel RAM required; HL->filename
     919:  00:CE32                      		 EXOS	exos.FN_BUFF
     919:  00:CE32  F7                >    rst 30H
     919:  00:CE33  1B                >    db  n
     920:  00:CE34  EB                  		 ex	de,hl		; DE->filename
     921:  00:CE35                      ;
     922:  00:CE35  C1                  		pop	bc		; B=channel.socket value
     923:  00:CE36  DD 70 FF            		ld	(ix-1-channel.socket),b	; Save socket while paged in
     924:  00:CE39                      ;
     925:  00:CE39  D9                  		exx
     926:  00:CE3A  ED 68               		in	l,(c)		; Get our channel RAM page
     927:  00:CE3C  ED 41               		out	(c),b		; Page in our variables seg
     928:  00:CE3E  D9                  		exx
     929:  00:CE3F  B7                  		or	a		; Set Z according to error
     930:  00:CE40  C9                  		ret
     931:  00:CE41                      ;
     932:  00:CE41                      ;
     933:  00:CE41                      ;------------------------------------------------------------------------------
     934:  00:CE41                      ; entry
     935:  00:CE41                      ;
     936:  00:CE41                      ; This is called from all the devices's entry points except open/create. It
     937:  00:CE41                      ; sets up the paging registers appropriately.
     938:  00:CE41                      ;
     939:  00:CE41                      ; In:  As per EXOS entry registers
     940:  00:CE41                      ; Out: A=channel.socket
     941:  00:CE41                      ;
     942:  00:CE41                      entry:
     943:  00:CE41  FD 7E FC            		ld	a,(iy-4-device.seg)	; Get our variable's segment
     944:  00:CE44                      ;
     945:  00:CE44  D9                  		exx
     946:  00:CE45  47                  		ld	b,a		; B' always=our RAM seg
     947:  00:CE46  0E B1               		ld	c,ep.P1		; C' always ->P1
     948:  00:CE48  DD 7E FF            		ld	a,(ix-1-channel.socket); Get socket while paged in
     949:  00:CE4B  ED 68               		in	l,(c)		; L' always channel RAM page
     950:  00:CE4D  ED 41               		out	(c),b		; Page in our seg
     951:  00:CE4F  58                  		ld	e,b		; socket.asm seg
     952:  00:CE50  50                  		ld	d,b		; tcp.asm seg
     953:  00:CE51  D9                  		exx
     954:  00:CE52  C9                  		ret
     955:  00:CE53                      ;
     956:  00:CE53                      ;
     957:  00:CE53                      ;------------------------------------------------------------------------------
     958:  00:CE53                      ; read_byte
     959:  00:CE53                      ;
     960:  00:CE53                      read_byte:
     961:  00:CE53  CD 41 CE            		call	entry
     962:  00:CE56                      ;		
     963:  00:CE56  FD E5               		push	iy
     964:  00:CE58  FD 21 07 40         		 ld	iy,vars			; Point IY at variables as usual
     965:  00:CE5C                      ;
     966:  00:CE5C  F5                  		 push	af			; Save socket #
     967:  00:CE5D  CD AE D0            		  call	status.start		; Start activity indicator
     968:  00:CE60  F1                  		 pop	af			; A=socket number
     969:  00:CE61                      ;
     970:  00:CE61  11 16 40            		 ld	de,vars.device.byte	; 1 byte buffer
     971:  00:CE64  01 01 00            		 ld	bc,1			; Read 1 byte
     972:  00:CE67  CD BA DF            		 call	tcp.read_block		; Read 1 byte
     973:  00:CE6A  FD 46 0F            		 ld	b,(iy+vars.device._byte); Return 1 byte in B
     974:  00:CE6D                      ;
     975:  00:CE6D  18 14               		 jr	read_ret
     976:  00:CE6F                      ;
     977:  00:CE6F                      ;
     978:  00:CE6F                      ;------------------------------------------------------------------------------
     979:  00:CE6F                      ; read_block
     980:  00:CE6F                      ;
     981:  00:CE6F                      ; In:  DE->buffer within user's paging
     982:  00:CE6F                      ;      BC=byte count, could be 0
     983:  00:CE6F                      ; Out: 
     984:  00:CE6F                      read_block:
     985:  00:CE6F  CD 41 CE            		call	entry
     986:  00:CE72                      ;
     987:  00:CE72  FD E5               		push	iy
     988:  00:CE74  FD 21 07 40         		 ld	iy,vars			; Point IY at variables as usual
     989:  00:CE78                      ;
     990:  00:CE78  F5                  		 push	af			; Save socket number
     991:  00:CE79  CD AE D0            		  call	status.start		; Start activity indicator
     992:  00:CE7C  F1                  		 pop	af			; A=socket number
     993:  00:CE7D                      ;
     994:  00:CE7D  21 BA DF            		 ld	hl,tcp.read_block
     995:  00:CE80  CD 0C CF            		 call	block
     996:  00:CE83                      ;
     997:  00:CE83  F5                  read_ret:	 push	af
     998:  00:CE84  CD A2 D0            	 	  call	status.stop		; Stop activity indicator
     999:  00:CE87  F1                  		 pop	af
    1000:  00:CE88                      ;
    1001:  00:CE88  FD E1               		pop	iy
    1002:  00:CE8A  D0                  		ret	nc
    1003:  00:CE8B                      ;
    1004:  00:CE8B  D6 02               		sub	2
    1005:  00:CE8D  3E E4               		ld	a,exos.ERR_EOF
    1006:  00:CE8F  F8                  		ret	m		; Code 1=>socket closed
    1007:  00:CE90                      ;
    1008:  00:CE90  3E E5               		ld	a,exos.ERR_STOP
    1009:  00:CE92  C8                  		ret	z		; Code 2=>STOP pressed
    1010:  00:CE93                      ;
    1011:  00:CE93  3E 6A               		ld	a,exos.ERR_TIMEOUT	; Code 3=>timeout
    1012:  00:CE95  C9                  		ret
    1013:  00:CE96                      ;;
    1014:  00:CE96                      ;
    1015:  00:CE96                      ;------------------------------------------------------------------------------
    1016:  00:CE96                      ; write_byte
    1017:  00:CE96                      ;
    1018:  00:CE96                      write_byte:
    1019:  00:CE96  CD 41 CE            		call	entry
    1020:  00:CE99                      ;
    1021:  00:CE99  FD E5               		push	iy
    1022:  00:CE9B  FD 21 07 40         		 ld	iy,vars			; Point IY at variables as usual
    1023:  00:CE9F                      ;
    1024:  00:CE9F  F5                  		 push	af			; Save socket number
    1025:  00:CEA0  CD AE D0            		  call	status.start		; Start activity indicator
    1026:  00:CEA3                      ;
    1027:  00:CEA3  11 16 40            		  ld	de,vars.device.byte	; 1 byte buffer
    1028:  00:CEA6  78                  		  ld	a,b
    1029:  00:CEA7  12                  		  ld	(de),a
    1030:  00:CEA8  01 01 00            		  ld	bc,1
    1031:  00:CEAB  F1                  		 pop	af			; Get socket #
    1032:  00:CEAC                      ;
    1033:  00:CEAC  F5                  		 push	af			; Save socket # again
    1034:  00:CEAD  CD 9B E0            		  call	tcp.write_block		; Write 1 byte
    1035:  00:CEB0  C1                  		 pop	bc			; B=socket number
    1036:  00:CEB1  78                  		 ld	a,b			; A=socket number but F unchnaged
    1037:  00:CEB2                      ;
    1038:  00:CEB2  D4 60 E1            		 call	nc,tcp.send
    1039:  00:CEB5  18 1A               		 jr	writeret
    1040:  00:CEB7                      ;;
    1041:  00:CEB7                      ;
    1042:  00:CEB7                      ;------------------------------------------------------------------------------
    1043:  00:CEB7                      ; write_block
    1044:  00:CEB7                      ;
    1045:  00:CEB7                      ; In:  DE->buffer within user's paging
    1046:  00:CEB7                      ;      BC=byte count, could be 0
    1047:  00:CEB7                      write_block:
    1048:  00:CEB7  CD 41 CE            		call	entry
    1049:  00:CEBA                      ;
    1050:  00:CEBA  FD E5               		push	iy
    1051:  00:CEBC  FD 21 07 40         		 ld	iy,vars			; Point IY at variables as usual
    1052:  00:CEC0                      ;
    1053:  00:CEC0  F5                  		 push	af			; Save socket number
    1054:  00:CEC1  CD AE D0            		  call	status.start		; Start activity indicator
    1055:  00:CEC4  F1                  		 pop	af			; A=soclet number
    1056:  00:CEC5                      ;
    1057:  00:CEC5  F5                  		 push	af			; Save socket number
    1058:  00:CEC6  21 9B E0            		  ld	hl,tcp.write_block
    1059:  00:CEC9  CD 0C CF            		  call	block
    1060:  00:CECC  C1                  		 pop	bc			; B=socket number
    1061:  00:CECD  78                  		 ld	a,b			; A=socket number, F unchanged
    1062:  00:CECE                      ;
    1063:  00:CECE  D4 60 E1            		 call	nc,tcp.send
    1064:  00:CED1                      ;
    1065:  00:CED1  9F                  writeret:	 sbc	a,a			; Cy->FF, NC->0
    1066:  00:CED2  E6 6A               		 and	exos.ERR_TIMEOUT	; Cy->error code, 0 if no error
    1067:  00:CED4  C0                  		 ret	nz
    1068:  00:CED5                      ;
    1069:  00:CED5  F5                  		 push	af
    1070:  00:CED6  CD A2 D0            	 	  call	status.stop		; Stop activity indicator
    1071:  00:CED9  F1                  		 pop	af
    1072:  00:CEDA  FD E1               		pop	iy
    1073:  00:CEDC  C9                  		ret
    1074:  00:CEDD                      ;
    1075:  00:CEDD                      ;
    1076:  00:CEDD                      ;------------------------------------------------------------------------------
    1077:  00:CEDD                      ; read_status
    1078:  00:CEDD                      ;
    1079:  00:CEDD                      read_status:
    1080:  00:CEDD  CD 41 CE            		call	entry
    1081:  00:CEE0                      ;
    1082:  00:CEE0  FD E5               		push	iy
    1083:  00:CEE2  FD 21 07 40         		 ld	iy,vars			; Point IY at variables as usual
    1084:  00:CEE6                      ;
    1085:  00:CEE6  CD 2B E1            		 call	tcp.status
    1086:  00:CEE9  4F                  		 ld	c,a		; 0=>char ready, FF=>EOF, 1=>no char
    1087:  00:CEEA  AF                  		 xor	a		; No error
    1088:  00:CEEB  FD E1               		pop	iy
    1089:  00:CEED  C9                  		ret
    1090:  00:CEEE                      ;
    1091:  00:CEEE                      ;
    1092:  00:CEEE                      ;------------------------------------------------------------------------------
    1093:  00:CEEE                      ; write_status
    1094:  00:CEEE                      ;
    1095:  00:CEEE                      write_status:
    1096:  00:CEEE                      nofn:
    1097:  00:CEEE  3E E7               		ld	a,exos.ERR_NOFN
    1098:  00:CEF0  C9                  		ret
    1099:  00:CEF1                      ;
    1100:  00:CEF1                      ;
    1101:  00:CEF1                      ;------------------------------------------------------------------------------
    1102:  00:CEF1                      ; special
    1103:  00:CEF1                      ;
    1104:  00:CEF1                      special:
    1105:  00:CEF1  3E E7               		ld	a,exos.ERR_NOFN
    1106:  00:CEF3  C9                  		ret
    1107:  00:CEF4                      ;
    1108:  00:CEF4                      ;
    1109:  00:CEF4                      ;------------------------------------------------------------------------------
    1110:  00:CEF4                      ; close
    1111:  00:CEF4                      ;
    1112:  00:CEF4                      close:
    1113:  00:CEF4  CD 41 CE            		call	entry
    1114:  00:CEF7                      ;
    1115:  00:CEF7  FD E5               		push	iy
    1116:  00:CEF9  FD 21 07 40         		 ld	iy,vars			; Point IY at variables as usual
    1117:  00:CEFD                      ;
    1118:  00:CEFD  F5                  		 push	af			; Save socket number
    1119:  00:CEFE  CD AE D0            		  call	status.start		; Start activity indicator
    1120:  00:CF01  F1                  		 pop	af			; A=socket number
    1121:  00:CF02                      ;
    1122:  00:CF02  CD D1 E1            		 call	tcp.close	; Close it
    1123:  00:CF05                      ;
    1124:  00:CF05  CD A2 D0            		 call	status.stop
    1125:  00:CF08                      ;
    1126:  00:CF08  AF                  		 xor	a		; No error
    1127:  00:CF09  FD E1               		pop	iy
    1128:  00:CF0B  C9                  		ret
    1129:  00:CF0C                      ;
    1130:  00:CF0C                      ;
    1131:  00:CF0C                      ;------------------------------------------------------------------------------
    1132:  00:CF0C                      ; block
    1133:  00:CF0C                      ;
    1134:  00:CF0C                      ; This routine implements a device's read_block and write_block.
    1135:  00:CF0C                      ;	
    1136:  00:CF0C                      ; DE points to the user's buffer. The buffer could cross segment boundaries so
    1137:  00:CF0C                      ; we must split the read/write up into chunks and use the user's paging which is
    1138:  00:CF0C                      ; stored in EXOS's variable area. It could also be an odd number of bytes
    1139:  00:CF0C                      ; in length which is a pain for the 16-bit WIZ chip. In fact even if it's
    1140:  00:CF0C                      ; even in length, it could be an odd number of bytes to the end of the segment.
    1141:  00:CF0C                      ;
    1142:  00:CF0C                      ; Here the main loop just does the splitting up of the block into
    1143:  00:CF0C                      ; single-segment reads/writes. We leave it to the TCP code to handle odd
    1144:  00:CF0C                      ; lengths, multiple TCP fragments and flushing any final odd byte.
    1145:  00:CF0C                      ;
    1146:  00:CF0C                      ; In:  HL->tcp.read_block or tcp.write block
    1147:  00:CF0C                      ;      DE->user's buffer
    1148:  00:CF0C                      ;      BC=byte count
    1149:  00:CF0C                      ;       A=socket number
    1150:  00:CF0C                      ; Out: Cy=>error, A=return code (see tcp.read_block/tcb.write_block)
    1151:  00:CF0C                      ;
    1152:  00:CF0C                      block:
    1153:  00:CF0C  08                  		ex	af,af		; Save socket in A'
    1154:  00:CF0D  CD AE D0            		call	status.start	; Start activity indicator
    1155:  00:CF10                      ;
    1156:  00:CF10                      .loop:
    1157:  00:CF10  78                  		ld	a,b	; See if byte count=0
    1158:  00:CF11  B1                  		or	c
    1159:  00:CF12  28 46               		jr	z,.ret	; All done!
    1160:  00:CF14                      ;
    1161:  00:CF14  E5                  		push	hl	; Save read/write func
    1162:  00:CF15                      
    1163:  00:CF15  69                  		 ld	l,c
    1164:  00:CF16  60                  		 ld	h,b	; HL=user's byte count
    1165:  00:CF17                      		 ; Negating (2s-complement) a segment offset gives us the
    1166:  00:CF17                      		 ; remaining bytes to ffff; anding with 3f then gives us the
    1167:  00:CF17                      		 ; remaining bytes to end of segment
    1168:  00:CF17  7B                  		 ld	a,e
    1169:  00:CF18  2F                  		 cpl
    1170:  00:CF19  4F                  		 ld	c,a
    1171:  00:CF1A  7A                  		 ld	a,d
    1172:  00:CF1B  2F                  		 cpl
    1173:  00:CF1C  E6 3F               		 and	3fh	; Turn pointer into seg offset
    1174:  00:CF1E  47                  		 ld	b,a
    1175:  00:CF1F  03                  		 inc	bc	; BC=amount left in segment, ie propsed read
    1176:  00:CF20                      ;
    1177:  00:CF20  B7                  		 or	a	; So deduct from user's total byte count
    1178:  00:CF21  ED 42               		 sbc	hl,bc	; HL=updated user's byte count after read
    1179:  00:CF23  30 06               		 jr	nc,.bcok
    1180:  00:CF25                      ;
    1181:  00:CF25  09                  		 add	hl,bc	; Oops it went -ve so get back user's remainder
    1182:  00:CF26  4D                  		 ld	c,l
    1183:  00:CF27  44                  		 ld	b,h	; BC=user's remainder size to read
    1184:  00:CF28  B7                  		 or	a
    1185:  00:CF29  ED 62               		 sbc	hl,hl	; User's byte count now 0
    1186:  00:CF2B                      .bcok:
    1187:  00:CF2B                      		; So now:
    1188:  00:CF2B                      		; HL=updated user's byte count, 0 if none left to read
    1189:  00:CF2B                      		; DE=user's buffer pointer not yet updated
    1190:  00:CF2B                      		; BC=read size
    1191:  00:CF2B                      		; (sp)=read/write func
    1192:  00:CF2B  E3                  		ex	(sp),hl	; HL->read/write function, (SP)=updated  count
    1193:  00:CF2C  D5                  		 push	de	; Save user's current pointer
    1194:  00:CF2D  C5                  		 push	bc	; Save amount we're about to read/write
    1195:  00:CF2E                      ;
    1196:  00:CF2E  E5                  		  push	hl	; Save read/write func
    1197:  00:CF2F  7A                  		   ld	a,d	; Get user's buffer Hi
    1198:  00:CF30  07                  		   rlca
    1199:  00:CF31  07                  		   rlca
    1200:  00:CF32  E6 03               		   and	3	; A=z80 page 0-3
    1201:  00:CF34  C6 FC               		   add	a,LOW exos.USR_P0
    1202:  00:CF36  6F                  		   ld	l,a
    1203:  00:CF37  26 BF               		   ld	h,HIGH exos.USR_P0	; HL->user's seg in EXOS var
    1204:  00:CF39  7E                  		   ld	a,(hl)	; Get user's seg
    1205:  00:CF3A  D9                  		   exx
    1206:  00:CF3B  57                  		   ld	d,a	; Save user's seg for tcp.xxx routine
    1207:  00:CF3C  D9                  		   exx
    1208:  00:CF3D  7A                  		   ld	a,d	; Adjust user's pointer to be a P1 pointer
    1209:  00:CF3E  E6 3F               		   and	3fh
    1210:  00:CF40  F6 40               		   or	40h
    1211:  00:CF42  57                  		   ld	d,a
    1212:  00:CF43  E1                  		  pop	hl	; HL->read or write func
    1213:  00:CF44                      ;
    1214:  00:CF44                      		  ; So now:
    1215:  00:CF44                      		  ; A'=socket number
    1216:  00:CF44                      		  ; D'=user's segment
    1217:  00:CF44                      		  ; DE->user's buffer adjusted to point in page 1
    1218:  00:CF44                      		  ; BC=amount to read
    1219:  00:CF44                      		  ; HL->read/write func to call
    1220:  00:CF44  78                  		  ld	a,b
    1221:  00:CF45  B1                  		  or	c
    1222:  00:CF46  E5                  		  push	hl	; Save read/write func
    1223:  00:CF47  28 07               		   jr	z,.skipjphl
    1224:  00:CF49  08                  		   ex	af,af	; Get back socket in A
    1225:  00:CF4A  F5                  		   push	af
    1226:  00:CF4B  08                  		   ex	af,af	; Save socket in A' again
    1227:  00:CF4C  F1                  		   pop	af	; A=socket number
    1228:  00:CF4D  CD CD C0            		   call jphl	; Read/write it; AF=error code/flag
    1229:  00:CF50  D1                  .skipjphl:	  pop	de	; DE=read/write func
    1230:  00:CF51  C1                  		 pop	bc	; BC=amount just read
    1231:  00:CF52  E1                  		 pop	hl	; HL=user's buffer
    1232:  00:CF53                      ;
    1233:  00:CF53  F5                  		 push	af	; Save error flag around add,hl,bc
    1234:  00:CF54  09                  		  add	hl,bc	; Update user's pointer
    1235:  00:CF55  F1                  		 pop	af	; AF=error code/flag
    1236:  00:CF56  EB                  		 ex	de,hl	; DE=updated user's buffer, HL=read/write func
    1237:  00:CF57  C1                  		pop	bc	; BC=updated user's byte count
    1238:  00:CF58  30 B6               		jr	nc,.loop
    1239:  00:CF5A                      ;
    1240:  00:CF5A  F5                  .ret:		push	af
    1241:  00:CF5B  CD A2 D0            	 	 call	status.stop		; Stop activity indicator
    1242:  00:CF5E  F1                  		pop	af
    1243:  00:CF5F  C9                  		ret
    1244:  00:CF60                      ;
    1245:  00:CF60                      ;
    1246:  00:CF60                      ;------------------------------------------------------------------------------
    1247:  00:CF60                      ; init
    1248:  00:CF60                      ;
    1249:  00:CF60                      ; All the devices have this initialisation routine. If we do not know our
    1250:  00:CF60                      ; RAM varaiables segment it must query the EXOS extension with a special
    1251:  00:CF60                      ; : command to get it and store it in device RAM.
    1252:  00:CF60                      ;
    1253:  00:CF60                      ; EXOS enters here with IY pointing to our device descriptor.
    1254:  00:CF60                      ;
    1255:  00:CF60                      init:
    1256:  00:CF60  FD 7E FC            		ld	a,(iy-4-device.seg)	; Get our variables segment
    1257:  00:CF63  B7                  		or	a
    1258:  00:CF64  C0                  		ret	nz			; Return if we've already got it
    1259:  00:CF65                      ;
    1260:  00:CF65  11 BC CA            		ld	de,command.special_str	; Issue special command
    1261:  00:CF68                      		EXOS	exos.FN_ROMS
    1261:  00:CF68  F7                >    rst 30H
    1261:  00:CF69  1A                >    db  n
    1262:  00:CF6A  C0                  		ret	nz			; Oh no - error!
    1263:  00:CF6B                      		
    1264:  00:CF6B  FD 70 FC            		ld	(iy-4-device.seg),b	; Save variables seg
    1265:  00:CF6E                      ;
    1266:  00:CF6E  78                  		ld	a,b
    1267:  00:CF6F  D3 B1               		out	(ep.P1),a		; Page our variables in
    1268:  00:CF71                      ;
    1269:  00:CF71  AF                  		xor	a
    1270:  00:CF72  32 0A 40            		ld	(vars.init),a		; Not initialised
    1271:  00:CF75                      ;
    1272:  00:CF75  C9                  		ret
    1273:  00:CF76                      ;
    1274:  00:CF76                      ;
    1275:  00:CF76                      ;------------------------------------------------------------------------------
    1276:  00:CF76                      ; moved
    1277:  00:CF76                      ;
    1278:  00:CF76                      moved:
    1279:  00:CF76                      interrupt:
    1280:  00:CF76  C9                  		ret
    1281:  00:CF77                      ;
    1282:  00:CF77                      ;
    1283:  00:CF77  54 43 50 3A         tcp_owner_str:	db	"TCP:"
    1284:  00:CF7B                      ;
    1285:  00:CF7B                      ;
    1286:  00:CF7B                      ;
    1287:  00:CF7B                      		endmodule
      96.  00:CF7B                      	include io.asm
       1:  00:CF7B                      ; IO
       2:  00:CF7B                      ;
       3:  00:CF7B                      ; Various utillity functions to do I/O
       4:  00:CF7B                      ;
       5:  00:CF7B                      		module io
       6:  00:CF7B                      ;
       7:  00:CF7B                      ;==============================================================================
       8:  00:CF7B                      ;
       9:  00:CF7B                      ; This file is part of the EPNET software
      10:  00:CF7B                      ;
      11:  00:CF7B                      ; Copyright (C) 2015  Bruce Tanner
      12:  00:CF7B                      ;
      13:  00:CF7B                      ;    This program is free software: you can redistribute it and/or modify
      14:  00:CF7B                      ;    it under the terms of the GNU General Public License as published by
      15:  00:CF7B                      ;    the Free Software Foundation, either version 3 of the License, or
      16:  00:CF7B                      ;    (at your option) any later version.
      17:  00:CF7B                      ;
      18:  00:CF7B                      ;    This program is distributed in the hope that it will be useful,
      19:  00:CF7B                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      20:  00:CF7B                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      21:  00:CF7B                      ;    GNU General Public License for more details.
      22:  00:CF7B                      ;
      23:  00:CF7B                      ;    You should have received a copy of the GNU General Public License
      24:  00:CF7B                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      25:  00:CF7B                      ;
      26:  00:CF7B                      ; If you do use or modify this file, either for its original purpose or for
      27:  00:CF7B                      ; something new, I'd love to hear about it! I can be contacted by email at:
      28:  00:CF7B                      ;
      29:  00:CF7B                      ; brucetanner@btopenworld.com
      30:  00:CF7B                      ;
      31:  00:CF7B                      ;==============================================================================
      32:  00:CF7B                      ;
      33:  00:CF7B  (00:000D)           @CR		equ	13
      34:  00:CF7B  (00:000A)           @LF		equ	10
      35:  00:CF7B                      ;
      36:  00:CF7B                      ;
      37:  00:CF7B                      ;------------------------------------------------------------------------------
      38:  00:CF7B                      ; mac
      39:  00:CF7B                      ;
      40:  00:CF7B                      ; Outputs a MAC address at (HL) in ASCII
      41:  00:CF7B                      ;
      42:  00:CF7B  06 06               mac:		ld	b,6
      43:  00:CF7D                      ;
      44:  00:CF7D  7E                  .loop:		ld	a,(HL)
      45:  00:CF7E  23                  		inc	hl
      46:  00:CF7F  CD E6 CF            		call	io.byte
      47:  00:CF82  10 F9               		djnz	.loop
      48:  00:CF84                      ;
      49:  00:CF84  C9                  		ret
      50:  00:CF85                      ;
      51:  00:CF85                      ;
      52:  00:CF85                      ;------------------------------------------------------------------------------
      53:  00:CF85                      ; ip
      54:  00:CF85                      ;
      55:  00:CF85                      ; Outputs an IP address
      56:  00:CF85                      ;
      57:  00:CF85                      ; In:  HL->IP address
      58:  00:CF85                      ;
      59:  00:CF85  CD 93 CF            ip:		call	.num
      60:  00:CF88  CD 8E CF            		call	.dotnum
      61:  00:CF8B  CD 8E CF            		call	.dotnum
      62:  00:CF8E  3E 2E               .dotnum:	ld	a,'.'
      63:  00:CF90  CD F9 CF            		call	io.char
      64:  00:CF93  7E                  .num:		ld	a,(hl)
      65:  00:CF94  23                  		inc	hl
      66:  00:CF95  E5                  		push	hl
      67:  00:CF96  CD A7 CF            		 call	io.short
      68:  00:CF99  E1                  		pop	hl
      69:  00:CF9A  C9                  		ret
      70:  00:CF9B                      ;
      71:  00:CF9B                      ;
      72:  00:CF9B                      ;------------------------------------------------------------------------------
      73:  00:CF9B                      ; ip_port
      74:  00:CF9B                      ;
      75:  00:CF9B                      ; Outputs an IP address and port number
      76:  00:CF9B                      ;
      77:  00:CF9B                      ; In:  HL->IP address
      78:  00:CF9B                      ;      BC=port no
      79:  00:CF9B                      ;
      80:  00:CF9B  C5                  ip_port:	push	bc		; Save port #
      81:  00:CF9C  CD 85 CF            		 call	ip		; Output IP address
      82:  00:CF9F  3E 3A               		 ld	a,':'
      83:  00:CFA1  CD F9 CF            		 call	char
      84:  00:CFA4  E1                  		pop	hl		; HL=port #
      85:  00:CFA5  18 03               		jr	int		; Output it
      86:  00:CFA7                      ;
      87:  00:CFA7                      ;
      88:  00:CFA7                      ;------------------------------------------------------------------------------
      89:  00:CFA7                      ; short, int
      90:  00:CFA7                      ;
      91:  00:CFA7                      ; Outputs a byte or a word in decimal
      92:  00:CFA7                      ;
      93:  00:CFA7                      ; In:  short: A=byte to output; int: HL=word to output
      94:  00:CFA7                      ; Out: B preserved, HL, DE, C, AF corrupted
      95:  00:CFA7                      ;
      96:  00:CFA7  6F                  short:		ld	l,a	; Just convert to 16-bit value in HL
      97:  00:CFA8  26 00               		ld	h,0
      98:  00:CFAA                      ;
      99:  00:CFAA  CB 81               int:		res	0,c	; 0=>no output yet (for leading 0 supression)
     100:  00:CFAC  11 10 27            		ld	de,10000
     101:  00:CFAF  CD C9 CF            		call	.divout	; Output 10,000s
     102:  00:CFB2  11 E8 03            		ld	de,1000
     103:  00:CFB5  CD C9 CF            		call	.divout	; Output 1,000s
     104:  00:CFB8  11 64 00            		ld	de,100
     105:  00:CFBB  CD C9 CF            		call	.divout	; Output 100s
     106:  00:CFBE  11 0A 00            		ld	de,10
     107:  00:CFC1  CD C9 CF            		call	.divout	; Output 10s
     108:  00:CFC4  11 01 00            		ld	de,1
     109:  00:CFC7  CB C1               		set	0,c	; Output 1s with leading 0s in case first 0
     110:  00:CFC9  CD D7 CF            .divout:	call	.div16	; C=ASCII dividend, HL=remainder
     111:  00:CFCC  FE 30               		cp	'0'
     112:  00:CFCE  20 03               		jr	nz,.out	; Always output if not 0
     113:  00:CFD0                      ;
     114:  00:CFD0  CB 41               		bit	0,c	; Else only output if not first digit
     115:  00:CFD2  C8                  		ret	z
     116:  00:CFD3                      ;
     117:  00:CFD3  CB C1               .out:		set	0,c	; Output a digit so don't supress 0s now
     118:  00:CFD5  18 22               		jr	char
     119:  00:CFD7                      ;
     120:  00:CFD7                      ;
     121:  00:CFD7                      ;
     122:  00:CFD7                      ; HL<-remainder of HL/DE, A<-quotient in ASCII
     123:  00:CFD7  3E 2F               .div16:		ld	a,'0'-1		; -1 for first time round loop
     124:  00:CFD9  B7                  		or	a		; Loop operates with NC
     125:  00:CFDA  3C                  .loop:		inc	a
     126:  00:CFDB  ED 52               		sbc	hl,de
     127:  00:CFDD  30 FB               		jr	nc,.loop
     128:  00:CFDF                      ;
     129:  00:CFDF  19                  		add	hl,de		; Restore value from last iteration
     130:  00:CFE0  C9                  		ret
     131:  00:CFE1                      ;
     132:  00:CFE1                      ;
     133:  00:CFE1                      ;------------------------------------------------------------------------------
     134:  00:CFE1                      ; word, byte, char
     135:  00:CFE1                      ;
     136:  00:CFE1                      ; Outputs HL in hex, A in hex and A as a character respectively. Only AF
     137:  00:CFE1                      ; corrupted
     138:  00:CFE1                      ;
     139:  00:CFE1  7C                  word:		ld	a,h
     140:  00:CFE2  CD E6 CF            		call	byte
     141:  00:CFE5  7D                  		ld	a,l
     142:  00:CFE6                      		    ;
     143:  00:CFE6                      		    ;
     144:  00:CFE6                      		    ;
     145:  00:CFE6                      ;
     146:  00:CFE6  F5                  byte:		push	af
     147:  00:CFE7  0F                  		rrca
     148:  00:CFE8  0F                  		rrca
     149:  00:CFE9  0F                  		rrca
     150:  00:CFEA  0F                  		rrca
     151:  00:CFEB  CD EF CF            		call	nib
     152:  00:CFEE  F1                  		pop	af
     153:  00:CFEF                      		   ;
     154:  00:CFEF                      		   ;
     155:  00:CFEF                      		   ;
     156:  00:CFEF                      ;
     157:  00:CFEF  E6 0F               nib:		and	0fh
     158:  00:CFF1  C6 30               		add	a,'0'
     159:  00:CFF3  FE 3A               		cp	'9'+1
     160:  00:CFF5  38 02               		jr	c,.nothex
     161:  00:CFF7                      ;
     162:  00:CFF7  C6 07               		add	a,'A'-'9'-1
     163:  00:CFF9                      .nothex:
     164:  00:CFF9                      		    ;
     165:  00:CFF9                      		    ;
     166:  00:CFF9                      		    ;
     167:  00:CFF9                      ;
     168:  00:CFF9  F5                  char:		push	af
     169:  00:CFFA  C5                  		push	bc
     170:  00:CFFB  D5                  		push	de
     171:  00:CFFC  E5                  		push	hl
     172:  00:CFFD  47                  		 ld	b,a
     173:  00:CFFE  FE 0D               		 cp	CR
     174:  00:D000  28 04               		 jr	z,.col0
     175:  00:D002                      ;
     176:  00:D002  FE 0A               		 cp	LF
     177:  00:D004  20 04               		 jr	nz,.notcol0
     178:  00:D006                      ;
     179:  00:D006  FD 36 06 FF         .col0:		 ld	(iy+vars._io.col),-1	; Will inc to 0		
     180:  00:D00A  FD 34 06            .notcol0:	 inc	(iy+vars._io.col)	; Next column
     181:  00:D00D  3E FF               		 ld	a,0ffh	; Default channel
     182:  00:D00F                      		 EXOS	exos.FN_WRCH
     182:  00:D00F  F7                >    rst 30H
     182:  00:D010  07                >    db  n
     183:  00:D011  E1                  		pop	hl
     184:  00:D012  D1                  		pop	de
     185:  00:D013  C1                  		pop	bc
     186:  00:D014  F1                  		pop	af
     187:  00:D015  C9                  		ret
     188:  00:D016                      ;
     189:  00:D016                      ;
     190:  00:D016                      ;------------------------------------------------------------------------------
     191:  00:D016                      ;
     192:  00:D016  CD 36 D0            ipcrlf:		call	str
     193:  00:D019  CD 85 CF            		call	ip
     194:  00:D01C                      ;
     195:  00:D01C  3A 0D 40            start:		ld	a,(vars.io.col)
     196:  00:D01F  B7                  		or	a
     197:  00:D020  C8                  		ret	z
     198:  00:D021                      ;
     199:  00:D021  3E 0D               crlf:		ld	a,CR
     200:  00:D023  CD F9 CF            		call	char
     201:  00:D026  3E 0A               		ld	a,LF
     202:  00:D028  18 CF               		jr	char
     203:  00:D02A                      ;
     204:  00:D02A                      ;
     205:  00:D02A  3E 20               space:		ld	a,' '
     206:  00:D02C  18 CB               		jr	char
     207:  00:D02E                      ;
     208:  00:D02E                      ;
     209:  00:D02E  3E 09               tab:		ld	a,"\t"
     210:  00:D030  18 C7               		jr	char
     211:  00:D032                      ;
     212:  00:D032                      ;
     213:  00:D032                      ;------------------------------------------------------------------------------
     214:  00:D032                      ; str
     215:  00:D032                      ;
     216:  00:D032                      ; Outputs a null-terminated string at (DE).
     217:  00:D032                      ;
     218:  00:D032                      ; line
     219:  00:D032                      ;
     220:  00:D032                      ; Outputs a LF-terminated string at (DE).
     221:  00:D032                      ;
     222:  00:D032                      ; In:  DE->string
     223:  00:D032                      ; Out: DE->next string (if LF-terminated) or null
     224:  00:D032                      ;      BC and AF corrupted.
     225:  00:D032                      ;      HL preserved
     226:  00:D032                      ;
     227:  00:D032  06 0A               line:		ld	b,LF		; Stop at LF
     228:  00:D034  18 02               		jr	_str
     229:  00:D036                      
     230:  00:D036  06 00               str:		ld	b,0
     231:  00:D038  E5                  _str:		push	hl
     232:  00:D039  D5                  		push	de		; Save ->start of string
     233:  00:D03A  68                  		 ld	l,b		; L=string terminator
     234:  00:D03B  01 FF FF            		 ld	bc,-1		; Zero length counter
     235:  00:D03E  18 07               		 jr	.start
     236:  00:D040                      ;
     237:  00:D040  FD 36 06 FF         .col0:		 ld	(iy+vars._io.col),-1	; Will inc to 0		
     238:  00:D044  FD 34 06            .loop:		 inc	(iy+vars._io.col)	; Next column
     239:  00:D047  1A                  .start:		 ld	a,(de)
     240:  00:D048  13                  		 inc	de
     241:  00:D049  03                  		 inc	bc
     242:  00:D04A  FE 0D               		 cp	CR
     243:  00:D04C  28 F2               		 jr	z,.col0
     244:  00:D04E                      ;
     245:  00:D04E  BD                  		 cp	l
     246:  00:D04F  28 08               		 jr	z,.end
     247:  00:D051                      ;
     248:  00:D051  FE 0A               		 cp	LF
     249:  00:D053  28 EB               		 jr	z,.col0
     250:  00:D055                      ;
     251:  00:D055  B7                  		 or	a
     252:  00:D056  20 EC               		 jr	nz,.loop
     253:  00:D058                      ;
     254:  00:D058  1B                  		 dec	de		; Point back to null
     255:  00:D059  EB                  .end:		 ex	de,hl		; HL->end of string, DE=caller's HL
     256:  00:D05A  E3                  		ex	(sp),hl		; (SP)->end of string, HL->start
     257:  00:D05B  EB                  		 ex	de,hl		; DE->start of string, HL->caller's HL
     258:  00:D05C                      ;
     259:  00:D05C  3E FF               		 ld	a,0ffh		; Default EXOS channel
     260:  00:D05E                      		 EXOS	exos.FN_WRBLK
     260:  00:D05E  F7                >    rst 30H
     260:  00:D05F  08                >    db  n
     261:  00:D060                      ;
     262:  00:D060  D1                  		pop	de		; DE->end of string
     263:  00:D061  E1                  		pop	hl
     264:  00:D062  C9                  		ret
     265:  00:D063                      ;
     266:  00:D063                      ;
     267:  00:D063                      ;------------------------------------------------------------------------------
     268:  00:D063                      ; cols
     269:  00:D063                      ;
     270:  00:D063                      ; Returns the number of display cols 
     271:  00:D063                      ;
     272:  00:D063                      ; We only output to the default channel so to find the number of cols we do a
     273:  00:D063                      ; video "special function" call to each channel in turn until we get a non-error
     274:  00:D063                      ; return, and assume this is the correct answer!
     275:  00:D063                      ;
     276:  00:D063                      ; Obviously this is a relatively time consuming process so the caller should
     277:  00:D063                      ; do it once (or at least infrequently) and save the result.
     278:  00:D063                      ;
     279:  00:D063                      ; It's not a 100% reliable method as there could be multiple video channels
     280:  00:D063                      ; which may or may not be actually displayed. But iof we find *any* 80 column
     281:  00:D063                      ; channels then we assume 80, otherwise 40.
     282:  00:D063                      ;
     283:  00:D063                      ; Out:  A=number of cols on display
     284:  00:D063                      ;      HL preserved
     285:  00:D063                      ;
     286:  00:D063  06 00               cols:		ld	b,0		; B=initial channel #
     287:  00:D065  78                  .loop:		ld	a,b		; Get channel
     288:  00:D066  C5                  		push	bc		; Save channel
     289:  00:D067  06 02               		 ld	b,exos.FN_VID_SIZE	; Return video: page size & mode
     290:  00:D069                      		 EXOS	exos.FN_SFUNC
     290:  00:D069  F7                >    rst 30H
     290:  00:D06A  0B                >    db  n
     291:  00:D06B  78                  		 ld	a,b		; A=# cols
     292:  00:D06C  C1                  		pop	bc		; B=channel
     293:  00:D06D  20 03               		jr	nz,.next	; Go if error (no a video channel)
     294:  00:D06F                      ;
     295:  00:D06F  FE 50               		cp	80		; No error, so we've found a vid chan
     296:  00:D071  D0                  		ret	nc		; Return if 80 (or above!) cols
     297:  00:D072                      ;
     298:  00:D072  10 F1               .next:		djnz	.loop		; Try next channel
     299:  00:D074                      ;
     300:  00:D074  3E 28               		ld	a,40		; Default to 40 if no 80 col channels
     301:  00:D076  C9                  		ret
     302:  00:D077                      ;
     303:  00:D077                      ;
     304:  00:D077                      ;------------------------------------------------------------------------------
     305:  00:D077                      ; input
     306:  00:D077                      ;
     307:  00:D077                      ; Gets a line of input from the user.
     308:  00:D077                      ;
     309:  00:D077                      ; In:  DE->prompt string
     310:  00:D077                      ;      HL->buffer for input
     311:  00:D077                      ;       C=max length
     312:  00:D077                      ; Out: Cy if error
     313:  00:D077                      ;          buffer contains input, length byte first
     314:  00:D077                      ;
     315:  00:D077                      input:
     316:  00:D077  C5                  		push	bc	; Save max length
     317:  00:D078  CD 36 D0            		 call	str	; Print prompt
     318:  00:D07B                      ;
     319:  00:D07B                      		 ; Set EXOS editor flags to not return the prompt
     320:  00:D07B  01 20 01            		 ld	bc,1*256+exos.VAR_FLG_EDIT	; B=1=>write, C=var no.
     321:  00:D07E  16 18               		 ld	d,18h	; D= flags (NO_SOFT, NO_PROMPT)
     322:  00:D080                      		 EXOS	exos.FN_EVAR
     322:  00:D080  F7                >    rst 30H
     322:  00:D081  10                >    db  n
     323:  00:D082                      ;
     324:  00:D082  C1                  		pop	bc	; C=max length
     325:  00:D083  06 00               		ld	b,0	; B=current length
     326:  00:D085                      ;
     327:  00:D085  E5                  		push	hl	; Save -> start of buffer
     328:  00:D086  23                  		 inc	hl	; Point passed length byte
     329:  00:D087  3E FF               .loop:		 ld	a,0ffh	; Read a char from EXOS default channel
     330:  00:D089  C5                  		 push	bc
     331:  00:D08A                      		  EXOS	exos.FN_RDCH
     331:  00:D08A  F7                >    rst 30H
     331:  00:D08B  05                >    db  n
     332:  00:D08C  78                  		  ld	a,b	; Get char
     333:  00:D08D  C1                  		 pop	bc	; BC=count and limit
     334:  00:D08E  37                  		 scf
     335:  00:D08F  20 0E               		 jr	nz,.end	; Error
     336:  00:D091                      ;
     337:  00:D091  FE 0D               		 cp	CR	; End of input line?
     338:  00:D093  28 0A               		 jr	z,.end	; Go if yes
     339:  00:D095                      ;
     340:  00:D095  77                  .notcr:		 ld	(hl),a	; Save char
     341:  00:D096  78                  		 ld	a,b
     342:  00:D097  3C                  		 inc	a
     343:  00:D098  B9                  		 cp	c	; Max chars reached?
     344:  00:D099  28 EC               		 jr	z,.loop	; Ignore char if yes
     345:  00:D09B                      ;
     346:  00:D09B  47                  		 ld	b,a	; Save inc'd length
     347:  00:D09C  23                  		 inc	hl	; Next buffer pos next time
     348:  00:D09D  18 E8               		 jr	.loop
     349:  00:D09F                      ;
     350:  00:D09F  E1                  .end:		pop	hl	; HL-> start of buffer
     351:  00:D0A0  70                  		ld	(hl),b	; Length byte
     352:  00:D0A1  C9                  		ret
     353:  00:D0A2                      ;
     354:  00:D0A2                      ;
     355:  00:D0A2                      		endmodule
      97.  00:D0A2                      	include status.asm
       1:  00:D0A2                      ; STATUS
       2:  00:D0A2                      ;
       3:  00:D0A2                      ; This module provides routines for controlling the status line activity 
       4:  00:D0A2                      ; display.
       5:  00:D0A2                      ;
       6:  00:D0A2                      		module	status
       7:  00:D0A2                      ;
       8:  00:D0A2                      ;==============================================================================
       9:  00:D0A2                      ;
      10:  00:D0A2                      ; This file is part of the EPNET software
      11:  00:D0A2                      ;
      12:  00:D0A2                      ; Copyright (C) 2015  Bruce Tanner
      13:  00:D0A2                      ;
      14:  00:D0A2                      ;    This program is free software: you can redistribute it and/or modify
      15:  00:D0A2                      ;    it under the terms of the GNU General Public License as published by
      16:  00:D0A2                      ;    the Free Software Foundation, either version 3 of the License, or
      17:  00:D0A2                      ;    (at your option) any later version.
      18:  00:D0A2                      ;
      19:  00:D0A2                      ;    This program is distributed in the hope that it will be useful,
      20:  00:D0A2                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      21:  00:D0A2                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      22:  00:D0A2                      ;    GNU General Public License for more details.
      23:  00:D0A2                      ;
      24:  00:D0A2                      ;    You should have received a copy of the GNU General Public License
      25:  00:D0A2                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      26:  00:D0A2                      ;
      27:  00:D0A2                      ; If you do use or modify this file, either for its original purpose or for
      28:  00:D0A2                      ; something new, I'd love to hear about it! I can be contacted by email at:
      29:  00:D0A2                      ;
      30:  00:D0A2                      ; brucetanner@btopenworld.com
      31:  00:D0A2                      ;
      32:  00:D0A2                      ;==============================================================================
      33:  00:D0A2                      ;
      34:  00:D0A2                      ; "waiting" is indicated by an alternating large and small blue blob.
      35:  00:D0A2                      ; Network "activity" is indicated by the blob turning red.
      36:  00:D0A2                      ;
      37:  00:D0A2  (00:0027)           STATUS_POS	equ	39		; Position on status line of indicator
      38:  00:D0A2                      ;
      39:  00:D0A2  (00:001F)           STATUS_BLOB_L	equ	1fh		; Char used for big blob
      40:  00:D0A2  (00:000E)           STATUS_BLOB_S	equ	0eh		; Char used for small blob
      41:  00:D0A2                      ;
      42:  00:D0A2  (00:0010)           DELAY		equ	16		; Time in ticks before status flashing
      43:  00:D0A2                      ;
      44:  00:D0A2                      ;
      45:  00:D0A2                      ;------------------------------------------------------------------------------
      46:  00:D0A2                      ; start & stop
      47:  00:D0A2                      ;
      48:  00:D0A2                      ; Starts & stops the status line display. (Saves the current char on the
      49:  00:D0A2                      ; bit of the status line we use)
      50:  00:D0A2                      ;
      51:  00:D0A2                      ;  stop: restores the status line under the blob immediately.
      52:  00:D0A2                      ; start: starts the flashing blob but after a shot delay. This rtesults in a
      53:  00:D0A2                      ;        cleaner display, and brief operations do not even show a blob.
      54:  00:D0A2                      ;
      55:  00:D0A2                      ; Out:  Only AF corrupted
      56:  00:D0A2                      ;
      57:  00:D0A2                      stop:
      58:  00:D0A2  E5                  		push	hl			; Save caller's HL
      59:  00:D0A3  21 15 40            		 ld	hl,vars.status.byte	; HL->saved status line char
      60:  00:D0A6  7E                  		 ld	a,(hl)			; Get saved byte
      61:  00:D0A7  36 00               		 ld	(hl),0			; Not waiting now
      62:  00:D0A9  E1                  		pop	hl			; HL=caller's HL
      63:  00:D0AA  B7                  		or	a
      64:  00:D0AB  20 21               		jr	nz,blob			; Put it back
      65:  00:D0AD                      ;
      66:  00:D0AD  C9                  		ret
      67:  00:D0AE                      ;
      68:  00:D0AE                      start:
      69:  00:D0AE  E5                  		push	hl			; Save caller's HL
      70:  00:D0AF  2A F6 BF            		 ld	hl,(exos.ST_POINTER)	; HL->status line
      71:  00:D0B2  7D                  		 ld	a,l
      72:  00:D0B3  C6 27               		 add	a,STATUS_POS
      73:  00:D0B5  6F                  		 ld	l,a			; HL->our position on status line
      74:  00:D0B6  22 13 40            		 ld	(vars.status.pos),hl	; Save it for efficiency
      75:  00:D0B9                      ;
      76:  00:D0B9  7E                  		 ld	a,(hl)			; Get current char there
      77:  00:D0BA  32 15 40            		 ld	(vars.status.byte),a	; Save it
      78:  00:D0BD                      ;
      79:  00:D0BD  FD 36 0B 00         		 ld	(iy+vars.status._ticks),0; Zero ticks so blob does
      80:  00:D0C1  E1                  		pop	hl			;   not show initially
      81:  00:D0C2  C9                  		ret
      82:  00:D0C3                      ;
      83:  00:D0C3                      ;
      84:  00:D0C3                      ; waiting
      85:  00:D0C3                      ;
      86:  00:D0C3                      ; Shows the "waiting" indicator on the status line. (blue blob).
      87:  00:D0C3                      ;
      88:  00:D0C3                      ; This is called repeatedly in wait loops, and uses the interrupt tick counter
      89:  00:D0C3                      ; to alternate the blue blob between small and large blob.
      90:  00:D0C3                      ;
      91:  00:D0C3                      ; Out:  Only AF corrupted
      92:  00:D0C3                      ;
      93:  00:D0C3                      waiting:
      94:  00:D0C3  3A 15 40            		ld	a,(vars.status.byte)	; See if status.start called
      95:  00:D0C6  B7                  		or	a
      96:  00:D0C7  C8                  		ret	z			; Do nothing if not
      97:  00:D0C8                      ;
      98:  00:D0C8  3A 12 40            		ld	a,(vars.status.ticks)	; A=interrupt tick count
      99:  00:D0CB  FE 10               		cp	DELAY			; Time to flash blob?
     100:  00:D0CD  D8                  		ret	c			; Return if not
     101:  00:D0CE                      ;
     102:  00:D0CE                      		; Here Cy=>red, NC=>blue blob
     103:  00:D0CE  9F                  blob:		sbc	a,a			; A= Cy=>FF, NC=>0
     104:  00:D0CF  E6 80               		and	80h			; A=80h (red) or 0 (blue)
     105:  00:D0D1  F6 0E               		or	STATUS_BLOB_S		; Assume small blob
     106:  00:D0D3  FD CB 0B 5E         		bit	3,(iy+vars.status._ticks); Time for big blob? (~1/4 sec)
     107:  00:D0D7  20 02               		jr	nz,blob_char		; Go with A=small blob if not
     108:  00:D0D9                      ;
     109:  00:D0D9  EE 11               		xor	STATUS_BLOB_L xor STATUS_BLOB_S	; Toggle to big blob
     110:  00:D0DB  E5                  blob_char:	push	hl			; Save caller's HL
     111:  00:D0DC  2A 13 40            		 ld	hl,(vars.status.pos)	; HL->our position on status line
     112:  00:D0DF  77                  		 ld	(hl),a			; Put big or small blob there
     113:  00:D0E0  E1                  		pop	hl			; HL=caller's HL
     114:  00:D0E1  C9                  		ret
     115:  00:D0E2                      ;
     116:  00:D0E2                      ;
     117:  00:D0E2                      ; activity
     118:  00:D0E2                      ;
     119:  00:D0E2                      ; Shows the "activity" indicator on the status line. (Red blob).
     120:  00:D0E2                      ;
     121:  00:D0E2                      ; It is called at the start of the low-level WIZ FIFO reading and writing loops
     122:  00:D0E2                      ; and displays a red blob immediately. It might be thus called without
     123:  00:D0E2                      ; status.start being called first, in which case it does nothing.
     124:  00:D0E2                      ;
     125:  00:D0E2                      ; Out:  Only AF corrupted
     126:  00:D0E2                      ;
     127:  00:D0E2                      activity:
     128:  00:D0E2  3A 15 40            		ld	a,(vars.status.byte)	; See if status.start called
     129:  00:D0E5  B7                  		or	a
     130:  00:D0E6  C8                  		ret	z			; Do nothing if not
     131:  00:D0E7                      ;
     132:  00:D0E7  37                  		scf				; Cy=>red blob
     133:  00:D0E8  18 E4               		jr	blob
     134:  00:D0EA                      ;
     135:  00:D0EA                      ;
     136:  00:D0EA                      inactivity:
     137:  00:D0EA  3A 15 40            		ld	a,(vars.status.byte)	; See if status.start called
     138:  00:D0ED  B7                  		or	a
     139:  00:D0EE  C8                  		ret	z			; Do nothing if not
     140:  00:D0EF                      ;
     141:  00:D0EF  18 D2               		jr	waiting			; Remove red blob
     142:  00:D0F1                      ;
     143:  00:D0F1                      ;
     144:  00:D0F1                      ;
     145:  00:D0F1                      		endmodule
      98.  00:D0F1                      	include	util.asm
       1:  00:D0F1                      ; UTIL
       2:  00:D0F1                      ;
       3:  00:D0F1                      ; Various little utility functions
       4:  00:D0F1                      ;
       5:  00:D0F1                      		module	util
       6:  00:D0F1                      ;
       7:  00:D0F1                      ;==============================================================================
       8:  00:D0F1                      ;
       9:  00:D0F1                      ; This file is part of the EPNET software
      10:  00:D0F1                      ;
      11:  00:D0F1                      ; Copyright (C) 2015  Bruce Tanner
      12:  00:D0F1                      ;
      13:  00:D0F1                      ;    This program is free software: you can redistribute it and/or modify
      14:  00:D0F1                      ;    it under the terms of the GNU General Public License as published by
      15:  00:D0F1                      ;    the Free Software Foundation, either version 3 of the License, or
      16:  00:D0F1                      ;    (at your option) any later version.
      17:  00:D0F1                      ;
      18:  00:D0F1                      ;    This program is distributed in the hope that it will be useful,
      19:  00:D0F1                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      20:  00:D0F1                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      21:  00:D0F1                      ;    GNU General Public License for more details.
      22:  00:D0F1                      ;
      23:  00:D0F1                      ;    You should have received a copy of the GNU General Public License
      24:  00:D0F1                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      25:  00:D0F1                      ;
      26:  00:D0F1                      ; If you do use or modify this file, either for its original purpose or for
      27:  00:D0F1                      ; something new, I'd love to hear about it! I can be contacted by email at:
      28:  00:D0F1                      ;
      29:  00:D0F1                      ; brucetanner@btopenworld.com
      30:  00:D0F1                      ;
      31:  00:D0F1                      ;==============================================================================
      32:  00:D0F1                      ; copystr
      33:  00:D0F1                      ;
      34:  00:D0F1                      ; Copies one null-terminated string to a buffer
      35:  00:D0F1                      ;
      36:  00:D0F1                      ; In:  HL->str to be copied, null terminated
      37:  00:D0F1                      ;      DE->buffer
      38:  00:D0F1                      ; Out: Corrupts BC too!
      39:  00:D0F1                      ;      DE->terminating null
      40:  00:D0F1                      ;
      41:  00:D0F1  7E                  copystr:	ld	a,(hl)
      42:  00:D0F2  ED A0               		ldi
      43:  00:D0F4  B7                  		or	a
      44:  00:D0F5  20 FA               		jr	nz,copystr
      45:  00:D0F7                      ;
      46:  00:D0F7  1B                  		dec	de		; Point back to null
      47:  00:D0F8  C9                  		ret
      48:  00:D0F9                      ;
      49:  00:D0F9                      ;
      50:  00:D0F9                      ;------------------------------------------------------------------------------
      51:  00:D0F9                      ; copyarg
      52:  00:D0F9                      ;
      53:  00:D0F9                      ; Copies a length-byte-first string to a buffer, turning it into a null-
      54:  00:D0F9                      ; terminated stirng. Only copies up to the first space
      55:  00:D0F9                      ;
      56:  00:D0F9                      ; In:  HL->arg to be copied, length byte first
      57:  00:D0F9                      ;      DE->buffer
      58:  00:D0F9                      ; Out: Corrupts BC too!
      59:  00:D0F9                      ;      DE->terminating null
      60:  00:D0F9                      ;
      61:  00:D0F9  7E                  copyarg:	ld	a,(hl)		; Get length
      62:  00:D0FA  B7                  		or	a
      63:  00:D0FB  28 0E               		jr	z,.ret
      64:  00:D0FD                      ;
      65:  00:D0FD  23                  		inc	hl		; Point pased length byte
      66:  00:D0FE  4F                  		ld	c,a
      67:  00:D0FF  06 00               		ld	b,0		; BC=byte count
      68:  00:D101  7E                  .loop:		ld	a,(hl)		; Only copy up to space if there is one
      69:  00:D102  FE 20               		cp	' '
      70:  00:D104  28 05               		jr	z,.ret		; Stop if space found
      71:  00:D106                      ;
      72:  00:D106  ED A0               		ldi			; Copy byte, inc HL & DE, dec & test BC
      73:  00:D108  EA 01 D1            		jp	pe,.loop
      74:  00:D10B                      ;
      75:  00:D10B  AF                  .ret:		xor	a
      76:  00:D10C  12                  		ld	(de),a		; Null terminate it
      77:  00:D10D                      ;
      78:  00:D10D  C9                  		ret
      79:  00:D10E                      ;
      80:  00:D10E                      ;
      81:  00:D10E                      ;------------------------------------------------------------------------------
      82:  00:D10E                      ; strlen
      83:  00:D10E                      ;
      84:  00:D10E                      ; Returns in BC the length of the string at (HL)
      85:  00:D10E                      ;
      86:  00:D10E  01 FF FF            strlen:		ld	bc,-1
      87:  00:D111  E5                  		push	hl
      88:  00:D112                      ;
      89:  00:D112  7E                  .loop:		ld	a,(hl)
      90:  00:D113  23                  		inc	hl
      91:  00:D114  03                  		inc	bc
      92:  00:D115  B7                  		or	a
      93:  00:D116  20 FA               		jr	nz,.loop
      94:  00:D118                      ;
      95:  00:D118  E1                  		pop	hl
      96:  00:D119  C9                  		ret
      97:  00:D11A                      ;
      98:  00:D11A                      ;
      99:  00:D11A                      ;------------------------------------------------------------------------------
     100:  00:D11A                      ; memset
     101:  00:D11A                      ;
     102:  00:D11A                      ; In:  HL->buffer
     103:  00:D11A                      ;      BC=#bytes (must be >1!)
     104:  00:D11A                      ;      A=fill value
     105:  00:D11A                      ; Out: HL->buffer
     106:  00:D11A                      ;
     107:  00:D11A  21 07 40            varszero:	ld	hl,vars
     108:  00:D11D  01 F9 03            		ld	bc,vars.varsize
     109:  00:D120                      ;
     110:  00:D120  AF                  memzero:	xor	a
     111:  00:D121                      ;
     112:  00:D121                      memset:		
     113:  00:D121  E5                  		push	hl
     114:  00:D122  54                  		ld	d,h
     115:  00:D123  5D                  		ld	e,l
     116:  00:D124  13                  		inc	de
     117:  00:D125  77                  		ld	(hl),a
     118:  00:D126  0B                  		dec	bc	; We've just done the first byte!
     119:  00:D127  ED B0               		ldir
     120:  00:D129  E1                  		pop	hl
     121:  00:D12A                      ;
     122:  00:D12A  C9                  		ret
     123:  00:D12B                      ;
     124:  00:D12B                      ;------------------------------------------------------------------------------
     125:  00:D12B                      ; memcmp
     126:  00:D12B                      ;
     127:  00:D12B                      ; Compares two blocks of memory
     128:  00:D12B                      ;
     129:  00:D12B                      ; Out: Z if (HL) = (DE) for B bytes
     130:  00:D12B                      ;
     131:  00:D12B  06 04               ipcmp:		ld	b,4
     132:  00:D12D  1A                  memcmp:		ld	a,(de)
     133:  00:D12E  BE                  		cp	(hl)
     134:  00:D12F  C0                  		ret	nz
     135:  00:D130                      ;
     136:  00:D130  13                  		inc	de
     137:  00:D131  23                  		inc	hl
     138:  00:D132  10 F9               		djnz	memcmp
     139:  00:D134                      ;
     140:  00:D134  C9                  		ret
     141:  00:D135                      ;
     142:  00:D135                      ;------------------------------------------------------------------------------
     143:  00:D135                      ; upper
     144:  00:D135                      ;
     145:  00:D135                      ; Upper cases A
     146:  00:D135                      ;
     147:  00:D135  FE 61               upper:		cp	'a'
     148:  00:D137  D8                  		ret	c
     149:  00:D138                      ;
     150:  00:D138  FE 7B               		cp	'z'+1
     151:  00:D13A  D0                  		ret	nc
     152:  00:D13B                      ;
     153:  00:D13B  D6 20               		sub	'a'-'A'
     154:  00:D13D  C9                  		ret
     155:  00:D13E                      ;
     156:  00:D13E                      ;
     157:  00:D13E                      ;------------------------------------------------------------------------------
     158:  00:D13E                      ; get_ip_port
     159:  00:D13E                      ;
     160:  00:D13E                      ; Reads an ASCII IP address and port number at (DE) to a 4-byte buffer at (HL)
     161:  00:D13E                      ; and a 16-bit port number in HL. The format is aaa.bbb.ccc.ddd:ppppp
     162:  00:D13E                      ;
     163:  00:D13E                      ; In:  HL->buffer for ip
     164:  00:D13E                      ;      DE->command line, length first
     165:  00:D13E                      ; Out: Cy=>not a valid IP address
     166:  00:D13E                      ;      HL=port number
     167:  00:D13E                      ;
     168:  00:D13E  1A                  get_ip_port:	ld	a,(de)
     169:  00:D13F  47                  		ld	b,a
     170:  00:D140  13                  		inc	de
     171:  00:D141  CD 7B D1            		call	_get_ip
     172:  00:D144  D8                  		ret	c
     173:  00:D145                      ;
     174:  00:D145  78                  		ld	a,b		; Must be at least :<digit> following
     175:  00:D146  D6 02               		sub	2
     176:  00:D148  37                  		scf
     177:  00:D149  F8                  		ret	m
     178:  00:D14A                      ;
     179:  00:D14A  05                  		dec	b
     180:  00:D14B  1A                  		ld	a,(de)
     181:  00:D14C  13                  		inc	de
     182:  00:D14D  FE 2D               		cp	'-'
     183:  00:D14F  37                  		scf
     184:  00:D150  C0                  		ret	nz
     185:  00:D151                      ;
     186:  00:D151  CD 59 D1            		call	_get_port
     187:  00:D154                      ;
     188:  00:D154  78                  		ld	a,b		; Make sure nothing following
     189:  00:D155  B7                  		or	a
     190:  00:D156  C8                  		ret	z
     191:  00:D157                      ;
     192:  00:D157  37                  		scf
     193:  00:D158  C9                  		ret
     194:  00:D159                      ;
     195:  00:D159                      ;
     196:  00:D159  B7                  _get_port:	or	a
     197:  00:D15A  ED 62               		sbc	hl,hl		; HL=0 (16-bit accumulator)
     198:  00:D15C                      
     199:  00:D15C  CD B6 D1            .loop:		call	get_dig
     200:  00:D15F  3F                  		ccf
     201:  00:D160  D0                  		ret	nc		; End of number, NC=>no error
     202:  00:D161                      		
     203:  00:D161  13                  		inc	de		; Digit ok - point to next
     204:  00:D162  C5                  		push	bc
     205:  00:D163                      		 ; 16-bit accululator *= 10
     206:  00:D163  29                  		 add	hl,hl		; *2
     207:  00:D164  4D                  		 ld	c,l
     208:  00:D165  44                  		 ld	b,h		; Save *2
     209:  00:D166  29                  		 add	hl,hl		; *4
     210:  00:D167  29                  		 add	hl,hl		; *8
     211:  00:D168  09                  		 add	hl,bc		; *10
     212:  00:D169  4F                  		 ld	c,a
     213:  00:D16A  06 00               		 ld	b,0
     214:  00:D16C  09                  		 add	hl,bc		; Add on digit
     215:  00:D16D  C1                  		pop	bc
     216:  00:D16E  10 EC               		djnz	.loop
     217:  00:D170                      ;
     218:  00:D170  C9                  		ret
     219:  00:D171                      ;
     220:  00:D171                      ;
     221:  00:D171                      ;------------------------------------------------------------------------------
     222:  00:D171                      ; get_ip
     223:  00:D171                      ;
     224:  00:D171                      ; Reads an ASCII IP address at (DE) to a 4-byte buffer at (HL).
     225:  00:D171                      ;
     226:  00:D171                      ; In:  HL->buffer for ip
     227:  00:D171                      ;      DE->command line, length first (length not used - see B)
     228:  00:D171                      ;      B=length
     229:  00:D171                      ; Out: Cy=>not a valid IP address
     230:  00:D171                      ;
     231:  00:D171  13                  get_ip:		inc	de		; Skip length byte (use B instead)
     232:  00:D172  CD 7B D1            		call	_get_ip
     233:  00:D175  D8                  		ret	c
     234:  00:D176                      ;
     235:  00:D176  78                  		ld	a,b		; Make sure nothing following
     236:  00:D177  B7                  		or	a
     237:  00:D178  C8                  		ret	z
     238:  00:D179                      ;
     239:  00:D179  37                  		scf
     240:  00:D17A  C9                  		ret
     241:  00:D17B                      ;
     242:  00:D17B                      ;
     243:  00:D17B  CD 8A D1            _get_ip:	call	get_num8_dot
     244:  00:D17E  D4 89 D1            		call	nc,inc_get_num8_dot
     245:  00:D181  D4 89 D1            		call	nc,inc_get_num8_dot
     246:  00:D184  D4 9B D1            		call	nc,inc_get_num8
     247:  00:D187  71                  		ld	(hl),c		; Save it to IP
     248:  00:D188  C9                  		ret
     249:  00:D189                      ;
     250:  00:D189  23                  inc_get_num8_dot:inc	hl
     251:  00:D18A  CD 9C D1            get_num8_dot:	call	get_num8	; Read number
     252:  00:D18D  71                  		ld	(hl),c		; Save it to IP
     253:  00:D18E                      ;
     254:  00:D18E  05                  		dec	b		; Allow for following .
     255:  00:D18F  37                  		scf
     256:  00:D190  F8                  		ret	m		; Ret with Cy if no char following
     257:  00:D191                      ;
     258:  00:D191  1A                  		ld	a,(de)		; Get char following
     259:  00:D192  13                  		inc	de		; DE->next char from string
     260:  00:D193  FE 2E               		cp	'.'		; Make sure it's a .
     261:  00:D195  C8                  		ret	z		; With NC if it is
     262:  00:D196                      ;
     263:  00:D196  FE 2C               		cp	','		; Also allow , for parsing FTP responses
     264:  00:D198  C8                  		ret	z
     265:  00:D199                      
     266:  00:D199  37                  		scf			; Invalid char following number
     267:  00:D19A  C9                  		ret
     268:  00:D19B                      ;
     269:  00:D19B                      ;
     270:  00:D19B                      ;------------------------------------------------------------------------------
     271:  00:D19B                      ; get_num8
     272:  00:D19B                      ;
     273:  00:D19B                      ; Reads an ASCII 8-bit number from a length-byte string
     274:  00:D19B                      ;
     275:  00:D19B                      ; In:  DE->string
     276:  00:D19B                      ;       B=length of data at (DE)
     277:  00:D19B                      ; Out: DE->first non-numeric character
     278:  00:D19B                      ;       C=>number
     279:  00:D19B                      ;       B updated
     280:  00:D19B                      ;      HL preserved
     281:  00:D19B                      ;      Cy=>bad number
     282:  00:D19B                      ;
     283:  00:D19B  23                  inc_get_num8:	inc	hl
     284:  00:D19C  CD B6 D1            get_num8:	call	get_dig		; Check at least one digit
     285:  00:D19F  D8                  		ret	c		; Error if not
     286:  00:D1A0                      ;
     287:  00:D1A0  0E 00               		ld	c,0		; Zero accumulator
     288:  00:D1A2  CD B6 D1            .loop:		call	get_dig		; Get digit from number
     289:  00:D1A5  3F                  		ccf
     290:  00:D1A6  D0                  		ret	nc		; Return with NC if end of number
     291:  00:D1A7                      ;
     292:  00:D1A7  13                  		inc	de		; DE->next digit for next time
     293:  00:D1A8  F5                  		push	af		; Save digit
     294:  00:D1A9  79                  		ld	a,c		; A=accumulator
     295:  00:D1AA  87                  		add	a,a		; A=acc*2
     296:  00:D1AB  4F                  		ld	c,a		; C=acc*2
     297:  00:D1AC  87                  		add	a,a		; A=acc*4
     298:  00:D1AD  87                  		add	a,a		; A=acc*8
     299:  00:D1AE  81                  		add	a,c		; A=acc*10
     300:  00:D1AF  4F                  		ld	c,a		; C=acc*10
     301:  00:D1B0  F1                  		pop	af		; A=digit
     302:  00:D1B1  81                  		add	a,c		; A=acc*10+digit
     303:  00:D1B2  4F                  		ld	c,a		; C=new accumulator value
     304:  00:D1B3  10 ED               		djnz	.loop		; Do rest of digits
     305:  00:D1B5                      ;
     306:  00:D1B5  C9                  		ret			; End of string, still NC
     307:  00:D1B6                      ;
     308:  00:D1B6                      ;
     309:  00:D1B6                      get_dig:
     310:  00:D1B6  1A                  		ld	a,(de)
     311:  00:D1B7  D6 30               isdig:		sub	'0'
     312:  00:D1B9  D8                  		ret	c
     313:  00:D1BA  FE 0A               		cp	10
     314:  00:D1BC  3F                  		ccf
     315:  00:D1BD  C9                  		ret
     316:  00:D1BE                      ;
     317:  00:D1BE                      ;
     318:  00:D1BE                      ;------------------------------------------------------------------------------
     319:  00:D1BE                      ; get_num16
     320:  00:D1BE                      ;
     321:  00:D1BE                      ; Reads an ASCII 16-bit number from a null-terminated string
     322:  00:D1BE                      ;
     323:  00:D1BE                      ; In:  DE->number
     324:  00:D1BE                      ; Out: DE->first non-numeric character
     325:  00:D1BE                      ;      HL=number
     326:  00:D1BE                      ;      Cy=>bad number
     327:  00:D1BE                      ;
     328:  00:D1BE                      get_num16:
     329:  00:D1BE  CD B6 D1            		call	get_dig		; Must be at least 1 digit!
     330:  00:D1C1  D8                  		ret	c		; C=>error
     331:  00:D1C2                      ;
     332:  00:D1C2  B7                  		or	a
     333:  00:D1C3  ED 62               		sbc	hl,hl		; HL=0 (16-bit accumulator)
     334:  00:D1C5                      
     335:  00:D1C5  CD B6 D1            .loop:		call	get_dig
     336:  00:D1C8  3F                  		ccf
     337:  00:D1C9  D0                  		ret	nc		; End of number, NC=>no error
     338:  00:D1CA                      		
     339:  00:D1CA  13                  		inc	de		; Digit ok - point to next
     340:  00:D1CB                      		; 16-bit accululator *= 10
     341:  00:D1CB  29                  		add	hl,hl		; *2
     342:  00:D1CC  4D                  		ld	c,l
     343:  00:D1CD  44                  		ld	b,h		; Save *2
     344:  00:D1CE  29                  		add	hl,hl		; *4
     345:  00:D1CF  29                  		add	hl,hl		; *8
     346:  00:D1D0  09                  		add	hl,bc		; *10
     347:  00:D1D1  4F                  		ld	c,a
     348:  00:D1D2  06 00               		ld	b,0
     349:  00:D1D4  09                  		add	hl,bc		; Add on digit
     350:  00:D1D5  18 EE               		jr	.loop
     351:  00:D1D7                      ;
     352:  00:D1D7                      ;
     353:  00:D1D7                      ;
     354:  00:D1D7                      		endmodule
      99.  00:D1D7                      	include trace.asm
       1:  00:D1D7                      ; TRACE
       2:  00:D1D7                      ;
       3:  00:D1D7                      ; Provides routines for outputting diagnostic info when in trace mode
       4:  00:D1D7                      ;
       5:  00:D1D7                      		module	trace
       6:  00:D1D7                      ;
       7:  00:D1D7                      ;==============================================================================
       8:  00:D1D7                      ;
       9:  00:D1D7                      ; This file is part of the EPNET software
      10:  00:D1D7                      ;
      11:  00:D1D7                      ; Copyright (C) 2015  Bruce Tanner
      12:  00:D1D7                      ;
      13:  00:D1D7                      ;    This program is free software: you can redistribute it and/or modify
      14:  00:D1D7                      ;    it under the terms of the GNU General Public License as published by
      15:  00:D1D7                      ;    the Free Software Foundation, either version 3 of the License, or
      16:  00:D1D7                      ;    (at your option) any later version.
      17:  00:D1D7                      ;
      18:  00:D1D7                      ;    This program is distributed in the hope that it will be useful,
      19:  00:D1D7                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      20:  00:D1D7                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      21:  00:D1D7                      ;    GNU General Public License for more details.
      22:  00:D1D7                      ;
      23:  00:D1D7                      ;    You should have received a copy of the GNU General Public License
      24:  00:D1D7                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      25:  00:D1D7                      ;
      26:  00:D1D7                      ; If you do use or modify this file, either for its original purpose or for
      27:  00:D1D7                      ; something new, I'd love to hear about it! I can be contacted by email at:
      28:  00:D1D7                      ;
      29:  00:D1D7                      ; brucetanner@btopenworld.com
      30:  00:D1D7                      ;
      31:  00:D1D7                      ;==============================================================================
      32:  00:D1D7                      ; diag.str
      33:  00:D1D7                      ;
      34:  00:D1D7                      ; Outputs a string if in diag trace mode
      35:  00:D1D7                      ;
      36:  00:D1D7                      ; In:  DE->string, null-terminated. First byte is trace module
      37:  00:D1D7                      ;
      38:  00:D1D7  11 8B D5            diag.ok:	ld	de,ok_str
      39:  00:D1DA  18 0D               		jr	diag.str
      40:  00:D1DC                      ;
      41:  00:D1DC  11 06 D3            diag.err:	ld	de,diag.errmsg
      42:  00:D1DF  18 08               		jr	diag.str
      43:  00:D1E1                      ;
      44:  00:D1E1  11 A9 D5            diag.dots:	ld	de,dots_str
      45:  00:D1E4  18 03               		jr	diag.str
      46:  00:D1E6                      ;
      47:  00:D1E6  CD F1 D1            diag.startstr:	call	diag.start
      48:  00:D1E9  FD CB 00 46         diag.str:	bit	vars.trace.diag,(iy+vars._trace)
      49:  00:D1ED  C8                  		ret	z		; Trace not on for this module
      50:  00:D1EE                      ;
      51:  00:D1EE  C3 36 D0            		jp	io.str
      52:  00:D1F1                      ;
      53:  00:D1F1                      ;
      54:  00:D1F1                      ; diag.start
      55:  00:D1F1                      ;
      56:  00:D1F1                      ; If in trace mode, outputs a CR, LF if we are not at the start of the line
      57:  00:D1F1  FD CB 00 46         diag.start:	bit	vars.trace.diag,(iy+vars._trace)
      58:  00:D1F5  C8                  		ret	z
      59:  00:D1F6                      ;
      60:  00:D1F6  3A 0D 40            		ld	a,(vars.io.col)
      61:  00:D1F9  B7                  		or	a
      62:  00:D1FA  C8                  		ret	z
      63:  00:D1FB                      		    ;
      64:  00:D1FB                      		    ;
      65:  00:D1FB                      		    ;
      66:  00:D1FB                      ;
      67:  00:D1FB                      ;
      68:  00:D1FB                      ; diag.crlf
      69:  00:D1FB                      ;
      70:  00:D1FB                      ; Outputs a CR and LFif in diag trace mode
      71:  00:D1FB                      ;
      72:  00:D1FB  3E 0D               diag.crlf:	ld	a,CR
      73:  00:D1FD  CD 02 D2            		call	diag.char
      74:  00:D200  3E 0A               		ld	a,LF
      75:  00:D202                      		    ;
      76:  00:D202                      		    ;
      77:  00:D202                      		    ;
      78:  00:D202                      ;
      79:  00:D202                      ;
      80:  00:D202                      ; diag.char
      81:  00:D202                      ;
      82:  00:D202                      ; Outputs a hex byte if in diag trace mode
      83:  00:D202                      ;
      84:  00:D202                      ; In: A = byte
      85:  00:D202  FD CB 00 46         diag.char:	bit	vars.trace.diag,(iy+vars._trace)
      86:  00:D206  C8                  		ret	z
      87:  00:D207                      ;
      88:  00:D207  C3 F9 CF            		jp	io.char
      89:  00:D20A                      
      90:  00:D20A                      ;
      91:  00:D20A                      ;
      92:  00:D20A                      ; diag.byte
      93:  00:D20A                      ;
      94:  00:D20A                      ; Outputs a hex byte if in diag trace mode
      95:  00:D20A                      ;
      96:  00:D20A                      ; In: A = byte
      97:  00:D20A  FD CB 00 46         diag.byte:	bit	vars.trace.diag,(iy+vars._trace)
      98:  00:D20E  C8                  		ret	z
      99:  00:D20F                      ;
     100:  00:D20F  C3 E6 CF            		jp	io.byte
     101:  00:D212                      
     102:  00:D212                      ;
     103:  00:D212                      ;
     104:  00:D212                      ; diag.word
     105:  00:D212                      ;
     106:  00:D212                      ; Outputs a hex byte if in diag trace mode
     107:  00:D212                      ;
     108:  00:D212                      ; In: HL = byte
     109:  00:D212  FD CB 00 46         diag.word:	bit	vars.trace.diag,(iy+vars._trace)
     110:  00:D216  C8                  		ret	z
     111:  00:D217                      ;
     112:  00:D217  C3 E1 CF            		jp	io.word
     113:  00:D21A                      ;
     114:  00:D21A                      ;
     115:  00:D21A                      ; diag.mac
     116:  00:D21A                      ;
     117:  00:D21A                      ; Outputs a MAC address if in diag trace mode
     118:  00:D21A                      ;
     119:  00:D21A                      ; In: HL->MAC address
     120:  00:D21A  FD CB 00 46         diag.mac:	bit	vars.trace.diag,(iy+vars._trace)
     121:  00:D21E  C8                  		ret	z
     122:  00:D21F                      ;
     123:  00:D21F  C3 7B CF            		jp	io.mac
     124:  00:D222                      ;
     125:  00:D222                      ;
     126:  00:D222                      ; diag.ip
     127:  00:D222                      ;
     128:  00:D222                      ; Outputs an IP address if in diag trace mode
     129:  00:D222                      ;
     130:  00:D222                      ; In: HL->IP address
     131:  00:D222  FD CB 00 46         diag.ip:	bit	vars.trace.diag,(iy+vars._trace)
     132:  00:D226  C8                  		ret	z
     133:  00:D227                      ;
     134:  00:D227  C3 85 CF            		jp	io.ip
     135:  00:D22A                      ;
     136:  00:D22A                      ;
     137:  00:D22A                      ;------------------------------------------------------------------------------
     138:  00:D22A                      ; Various little I/O routines called when in trace mode
     139:  00:D22A                      ;
     140:  00:D22A  CD 2A D0            bytes:		call	io.space
     141:  00:D22D  CD AA CF            		call	io.int
     142:  00:D230  11 AD D5            		ld	de,bytes_str
     143:  00:D233  C3 36 D0            		jp	io.str
     144:  00:D236                      ;
     145:  00:D236  11 A9 D5            dots:		ld	de,dots_str
     146:  00:D239  C3 36 D0            		jp	io.str
     147:  00:D23C                      ;
     148:  00:D23C                      
     149:  00:D23C  38 0A               is_timeout:	jr	c,timeout
     150:  00:D23E  38 0D               is_error:	jr	c,error
     151:  00:D240  11 8B D5            ok:		ld	de,ok_str
     152:  00:D243  CD 36 D0            		call	io.str
     153:  00:D246  B7                  		or	a
     154:  00:D247  C9                  		ret
     155:  00:D248                      ;
     156:  00:D248                      ;
     157:  00:D248  11 90 D5            timeout:	ld	de,timeout_str
     158:  00:D24B  18 03               		jr	err
     159:  00:D24D  11 9A D5            error:		ld	de,error_str
     160:  00:D250  CD C3 CA            err:		call	exos.is_stop
     161:  00:D253  30 03               		jr	nc,.notstop
     162:  00:D255                      ;
     163:  00:D255  11 A2 D5            		ld	de,stop_str
     164:  00:D258  CD 36 D0            .notstop:	call	io.str
     165:  00:D25B  37                  		scf
     166:  00:D25C  C9                  		ret
     167:  00:D25D                      ;
     168:  00:D25D                      ;
     169:  00:D25D                      ;------------------------------------------------------------------------------
     170:  00:D25D                      ; dumpbytes, dumpchars
     171:  00:D25D                      ;
     172:  00:D25D                      ; In:  E':HL->memory to dump
     173:  00:D25D                      ;          B=number of bytes
     174:  00:D25D                      ;          C'->P1
     175:  00:D25D                      ;          B'=our segment
     176:  00:D25D                      ;
     177:  00:D25D                      dumpbytes:
     178:  00:D25D  CD C3 CA            .loop:		call	exos.is_stop
     179:  00:D260  D8                  		ret	c		; Return with Cy if STOP key presed
     180:  00:D261                      ;
     181:  00:D261  D9                  		exx
     182:  00:D262  ED 59               		out	(c),e		; Page in data segment
     183:  00:D264  D9                  		exx
     184:  00:D265  7E                  		ld	a,(hl)		; Get byte
     185:  00:D266  D9                  		exx
     186:  00:D267  ED 41               		out	(c),b		; Page our seg back in
     187:  00:D269  D9                  		exx
     188:  00:D26A  23                  		inc	hl
     189:  00:D26B  CD E6 CF            		call	io.byte		; Print it
     190:  00:D26E  CD 2A D0            		call	io.space	; Followed by a space
     191:  00:D271  10 EA               		djnz	.loop
     192:  00:D273                      ;
     193:  00:D273  B7                  		or	a		; NC=>STOP not pressed
     194:  00:D274  C9                  		ret
     195:  00:D275                      ;
     196:  00:D275                      ;
     197:  00:D275                      dumpchars:
     198:  00:D275  CD C3 CA            .loop:		call	exos.is_stop
     199:  00:D278  D8                  		ret	c		; Return with Cy if STOP key presed
     200:  00:D279                      ;
     201:  00:D279  D9                  		exx
     202:  00:D27A  ED 59               		out	(c),e		; Page in data seg
     203:  00:D27C  D9                  		exx
     204:  00:D27D  7E                  		ld	a,(hl)		; Get byte
     205:  00:D27E  D9                  		exx
     206:  00:D27F  ED 41               		out	(c),b		; Page our seg back in
     207:  00:D281  D9                  		exx
     208:  00:D282  23                  		inc	hl
     209:  00:D283  FE A0               		cp	0a0h		; Chars >=A0 are editor control chars
     210:  00:D285  30 04               		jr	nc,.dot
     211:  00:D287                      ;
     212:  00:D287  FE 20               		cp	' '		; Chars < space are control chars
     213:  00:D289  30 02               		jr	nc,.ascii
     214:  00:D28B                      ;
     215:  00:D28B  3E 2E               .dot:		ld	a,'.'		; Turn control chars into .
     216:  00:D28D  CD F9 CF            .ascii:		call	io.char
     217:  00:D290  10 E3               		djnz	.loop
     218:  00:D292                      ;
     219:  00:D292  B7                  		or	a		; NC=>STOP not pressed
     220:  00:D293  C9                  		ret
     221:  00:D294                      ;
     222:  00:D294                      ;
     223:  00:D294                      ;------------------------------------------------------------------------------
     224:  00:D294                      ; set_cols
     225:  00:D294                      ;
     226:  00:D294                      ; Sets the number of output columns. This is a relatively time
     227:  00:D294                      ; consuming process so we don't do it frequently
     228:  00:D294                      ;
     229:  00:D294                      ; Out: Preserved HL, DE, BC
     230:  00:D294                      ;
     231:  00:D294                      set_cols:
     232:  00:D294  D5                  		push	de
     233:  00:D295  C5                  		push	bc
     234:  00:D296  CD 63 D0            		call	io.cols		; Find & save # output cols
     235:  00:D299  C1                  		pop	bc
     236:  00:D29A  D1                  		pop	de
     237:  00:D29B  32 09 40            		ld	(vars.trace.cols),a
     238:  00:D29E  C9                  		ret
     239:  00:D29F                      ;
     240:  00:D29F                      ;
     241:  00:D29F                      ; Trace strings - strings output during trace
     242:  00:D29F                      ;
     243:  00:D29F                      ; diag
     244:  00:D29F                      diag.reset		db	"Reset WIZ at I/O port ",0
     244:  00:D29F  52 65 73 65 74 20 57 49 5A 20 61 74 20 49 2F 4F 
     244:  00:D2AF  20 70 6F 72 74 20 00 
     245:  00:D2B6                      diag.id			db	"Read ID ",0
     245:  00:D2B6  52 65 61 64 20 49 44 20 00 
     246:  00:D2BF                      diag.writemac		db	"Set MAC address ",0
     246:  00:D2BF  53 65 74 20 4D 41 43 20 61 64 64 72 65 73 73 20 
     246:  00:D2CF  00 
     247:  00:D2D0                      diag.writeip		db	"Set IP address ",0
     247:  00:D2D0  53 65 74 20 49 50 20 61 64 64 72 65 73 73 20 00 
     248:  00:D2E0                      diag.subnet		db	"Set Subnet mask ",0
     248:  00:D2E0  53 65 74 20 53 75 62 6E 65 74 20 6D 61 73 6B 20 
     248:  00:D2F0  00 
     249:  00:D2F1                      diag.gateway		db	"Set Default Gateway ",0
     249:  00:D2F1  53 65 74 20 44 65 66 61 75 6C 74 20 47 61 74 65 
     249:  00:D301  77 61 79 20 00 
     250:  00:D306                      diag.errmsg:		db	"DIAG ERROR",0
     250:  00:D306  44 49 41 47 20 45 52 52 4F 52 00 
     251:  00:D311                      diag.memory:		db	"Test WIZ memory...",0
     251:  00:D311  54 65 73 74 20 57 49 5A 20 6D 65 6D 6F 72 79 2E 
     251:  00:D321  2E 2E 00 
     252:  00:D324  72 65 61 64 20 00   diag.memerr:		db	"read ",0
     253:  00:D32A                      diag.expected:		db	" expected ",0
     253:  00:D32A  20 65 78 70 65 63 74 65 64 20 00 
     254:  00:D335  20 61 74 20 00      diag.at:		db	" at ",0
     255:  00:D33A                      diag.timeout:		db	"TIMEOUT ERROR",0
     255:  00:D33A  54 49 4D 45 4F 55 54 20 45 52 52 4F 52 00 
     256:  00:D348                      diag.dhcp:		db	"Getting IP parameters via DHCP...",0
     256:  00:D348  47 65 74 74 69 6E 67 20 49 50 20 70 61 72 61 6D 
     256:  00:D358  65 74 65 72 73 20 76 69 61 20 44 48 43 50 2E 2E 
     256:  00:D368  2E 00 
     257:  00:D36A                      diag.ntp:		db	"Getting current time via NTP...",0
     257:  00:D36A  47 65 74 74 69 6E 67 20 63 75 72 72 65 6E 74 20 
     257:  00:D37A  74 69 6D 65 20 76 69 61 20 4E 54 50 2E 2E 2E 00 
     258:  00:D38A                      ;
     259:  00:D38A                      socket.connect:		db	"Connect to ",0
     259:  00:D38A  43 6F 6E 6E 65 63 74 20 74 6F 20 00 
     260:  00:D396                      socket.disconnect:	db	"Disconnect...",0
     260:  00:D396  44 69 73 63 6F 6E 6E 65 63 74 2E 2E 2E 00 
     261:  00:D3A4                      socket.close:		db	"Close...",0
     261:  00:D3A4  43 6C 6F 73 65 2E 2E 2E 00 
     262:  00:D3AD  4F 70 65 6E 20 00   socket.open:		db	"Open ",0
     263:  00:D3B3  55 44 50 00         socket.udp:		db	"UDP",0
     264:  00:D3B7  49 50 00            socket.ipraw:		db	"IP",0
     265:  00:D3BA  54 43 50 00         socket.tcp:		db	"TCP",0
     266:  00:D3BE  3F 3F 3F 00         socket.unknown:		db	"???",0
     267:  00:D3C2                      socket.port:		db	" port ",0
     267:  00:D3C2  20 70 6F 72 74 20 00 
     268:  00:D3C9  20 62 79 20 00      socket.by:		db	" by ",0
     269:  00:D3CE                      ;
     270:  00:D3CE                      udp.rx:			db	"UDP rx from ",0
     270:  00:D3CE  55 44 50 20 72 78 20 66 72 6F 6D 20 00 
     271:  00:D3DB                      udp.tx:			db	"UDP tx to ",0
     271:  00:D3DB  55 44 50 20 74 78 20 74 6F 20 00 
     272:  00:D3E6                      udp.errmsg:		db	"UDP ERROR",CR,LF,0
     272:  00:D3E6  55 44 50 20 45 52 52 4F 52 0D 0A 00 
     273:  00:D3F2                      ;
     274:  00:D3F2                      tcp.rx:			db	"TCP rx",0
     274:  00:D3F2  54 43 50 20 72 78 00 
     275:  00:D3F9                      tcp.tx:			db	"TCP tx",0
     275:  00:D3F9  54 43 50 20 74 78 00 
     276:  00:D400                      ;
     277:  00:D400                      ipraw.rx:		db	"IPRAW rx from ",0
     277:  00:D400  49 50 52 41 57 20 72 78 20 66 72 6F 6D 20 00 
     278:  00:D40F                      ipraw.tx:		db	"IPRAW tx to ",0
     278:  00:D40F  49 50 52 41 57 20 74 78 20 74 6F 20 00 
     279:  00:D41C                      ;
     280:  00:D41C                      ;
     281:  00:D41C                      dhcp.start:		db	"DHCP:start...",0
     281:  00:D41C  44 48 43 50 3A 73 74 61 72 74 2E 2E 2E 00 
     282:  00:D42A                      dhcp.discover:		db	"DHCP:tx Discover ",0
     282:  00:D42A  44 48 43 50 3A 74 78 20 44 69 73 63 6F 76 65 72 
     282:  00:D43A  20 00 
     283:  00:D43C                      dhcp.request:		db	"DHCP:tx Request ",0
     283:  00:D43C  44 48 43 50 3A 74 78 20 52 65 71 75 65 73 74 20 
     283:  00:D44C  00 
     284:  00:D44D                      dhcp.rx:		db	"DHCP:rx ",0
     284:  00:D44D  44 48 43 50 3A 72 78 20 00 
     285:  00:D456  20 49 50 3D 00      dhcp.gotip:		db	" IP=",0
     286:  00:D45B                      dhcp.gotsubnet:		db	" subnet=",0
     286:  00:D45B  20 73 75 62 6E 65 74 3D 00 
     287:  00:D464                      dhcp.gotgateway:	db	" gateway=",0
     287:  00:D464  20 67 61 74 65 77 61 79 3D 00 
     288:  00:D46E                      dhcp.gotserver:		db	" server=",0
     288:  00:D46E  20 73 65 72 76 65 72 3D 00 
     289:  00:D477                      dhcp.gotlease:		db	" lease=",0
     289:  00:D477  20 6C 65 61 73 65 3D 00 
     290:  00:D47F  20 44 4E 53 3D 00   dhcp.gotdns:		db	" DNS=",0
     291:  00:D485  20 4E 54 50 3D 00   dhcp.gotntp:		db	" NTP=",0
     292:  00:D48B                      ;
     293:  00:D48B                      dhcp.offer:		db	"Offer ",0
     293:  00:D48B  4F 66 66 65 72 20 00 
     294:  00:D492                      dhcp.decline:		db	"Decline ",0
     294:  00:D492  44 65 63 6C 69 6E 65 20 00 
     295:  00:D49B  41 63 6B 20 00      dhcp.ack:		db	"Ack ",0
     296:  00:D4A0  4E 61 6B 20 00      dhcp.nak:		db	"Nak ",0
     297:  00:D4A5                      dhcp.type:		db	" bad Type ",0
     297:  00:D4A5  20 62 61 64 20 54 79 70 65 20 00 
     298:  00:D4B0                      dhcp.end:		db	"DHCP:finished",CR,LF,0
     298:  00:D4B0  44 48 43 50 3A 66 69 6E 69 73 68 65 64 0D 0A 00 
     299:  00:D4C0                      dhcp.errmsg:		db	"DHCP ERROR",0
     299:  00:D4C0  44 48 43 50 20 45 52 52 4F 52 00 
     300:  00:D4CB                      dhcp.small:		db	"TOO SMALL",0
     300:  00:D4CB  54 4F 4F 20 53 4D 41 4C 4C 00 
     301:  00:D4D5                      dhcp.port:		db	"BAD PORT",0
     301:  00:D4D5  42 41 44 20 50 4F 52 54 00 
     302:  00:D4DE                      dhcp.op:		db	"BAD OP",0
     302:  00:D4DE  42 41 44 20 4F 50 00 
     303:  00:D4E5                      dhcp.addr:		db	"BAD ADDR",0
     303:  00:D4E5  42 41 44 20 41 44 44 52 00 
     304:  00:D4EE                      dhcp.xid:		db	"BAD XID",0
     304:  00:D4EE  42 41 44 20 58 49 44 00 
     305:  00:D4F6                      dhcp.cookie:		db	"BAD COOKIE",0
     305:  00:D4F6  42 41 44 20 43 4F 4F 4B 49 45 00 
     306:  00:D501                      dhcp.eop:		db	"BAD PACKET",0
     306:  00:D501  42 41 44 20 50 41 43 4B 45 54 00 
     307:  00:D50C                      ;
     308:  00:D50C                      ping.pinging:		db	"Pinging ",0
     308:  00:D50C  50 69 6E 67 69 6E 67 20 00 
     309:  00:D515                      ;
     310:  00:D515                      ntp.tx:			db	"NTP:tx request to ",0
     310:  00:D515  4E 54 50 3A 74 78 20 72 65 71 75 65 73 74 20 74 
     310:  00:D525  6F 20 00 
     311:  00:D528                      ntp.rx:			db	"NTP:rx...",0
     311:  00:D528  4E 54 50 3A 72 78 2E 2E 2E 00 
     312:  00:D532                      ;
     313:  00:D532                      ;
     314:  00:D532                      http.open:		db	"Connect to ",0
     314:  00:D532  43 6F 6E 6E 65 63 74 20 74 6F 20 00 
     315:  00:D53E  54 78 20 00         http.tx:		db	"Tx ",0
     316:  00:D542  52 78 20 00         http.rx:		db	"Rx ",0
     317:  00:D546  43 6F 64 65 3D 00   http.code:		db	"Code=",0
     318:  00:D54C  53 69 7A 65 3D 00   http.size:		db	"Size=",0
     319:  00:D552                      ;
     320:  00:D552                      ;
     321:  00:D552                      ftp.open:		db	"Connect to ",0
     321:  00:D552  43 6F 6E 6E 65 63 74 20 74 6F 20 00 
     322:  00:D55E                      ftp.login:		db	"Login...",0
     322:  00:D55E  4C 6F 67 69 6E 2E 2E 2E 00 
     323:  00:D567  54 78 20 00         ftp.tx:			db	"Tx ",0
     324:  00:D56B  52 78 20 00         ftp.rx:			db	"Rx ",0
     325:  00:D56F  43 6C 6F 73 65 00   ftp.close:		db	"Close",0
     326:  00:D575  70 61 73 76 3D 00   ftp.pasv:		db	"pasv=",0
     327:  00:D57B  63 6F 64 65 3D 00   ftp.code:		db	"code=",0
     328:  00:D581                      ftp.error_str:		db	"FTP ERROR",0
     328:  00:D581  46 54 50 20 45 52 52 4F 52 00 
     329:  00:D58B                      ;
     330:  00:D58B                      ;
     331:  00:D58B  4F 4B 0D 0A 00      ok_str:			db	"OK",CR,LF,0
     332:  00:D590                      timeout_str:		db	"TIMEOUT",CR,LF,0
     332:  00:D590  54 49 4D 45 4F 55 54 0D 0A 00 
     333:  00:D59A                      error_str:		db	"ERROR",CR,LF,0
     333:  00:D59A  45 52 52 4F 52 0D 0A 00 
     334:  00:D5A2                      stop_str:		db	"STOP",CR,LF,0
     334:  00:D5A2  53 54 4F 50 0D 0A 00 
     335:  00:D5A9  2E 2E 2E 00         dots_str:		db	"...",0
     336:  00:D5AD                      bytes_str:		db	" bytes",0
     336:  00:D5AD  20 62 79 74 65 73 00 
     337:  00:D5B4                      ;
     338:  00:D5B4                      
     339:  00:D5B4                      
     340:  00:D5B4                      
     341:  00:D5B4                      		endmodule
     100.  00:D5B4                      ;
     101.  00:D5B4                      	include w5300.asm
       1:  00:D5B4                      ; W5300
       2:  00:D5B4                      ;
       3:  00:D5B4                      ; All the constants required for using the WIZ W5300 chip
       4:  00:D5B4                      ;
       5:  00:D5B4                      		module w5300
       6:  00:D5B4                      ;
       7:  00:D5B4                      ;==============================================================================
       8:  00:D5B4                      ;
       9:  00:D5B4                      ; This file is part of the EPNET software
      10:  00:D5B4                      ;
      11:  00:D5B4                      ; Copyright (C) 2015  Bruce Tanner
      12:  00:D5B4                      ;
      13:  00:D5B4                      ;    This program is free software: you can redistribute it and/or modify
      14:  00:D5B4                      ;    it under the terms of the GNU General Public License as published by
      15:  00:D5B4                      ;    the Free Software Foundation, either version 3 of the License, or
      16:  00:D5B4                      ;    (at your option) any later version.
      17:  00:D5B4                      ;
      18:  00:D5B4                      ;    This program is distributed in the hope that it will be useful,
      19:  00:D5B4                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      20:  00:D5B4                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      21:  00:D5B4                      ;    GNU General Public License for more details.
      22:  00:D5B4                      ;
      23:  00:D5B4                      ;    You should have received a copy of the GNU General Public License
      24:  00:D5B4                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      25:  00:D5B4                      ;
      26:  00:D5B4                      ; If you do use or modify this file, either for its original purpose or for
      27:  00:D5B4                      ; something new, I'd love to hear about it! I can be contacted by email at:
      28:  00:D5B4                      ;
      29:  00:D5B4                      ; brucetanner@btopenworld.com
      30:  00:D5B4                      ;
      31:  00:D5B4                      ;==============================================================================
      32:  00:D5B4                      ;
      33:  00:D5B4                      ; Main directly-accessed registers
      34:  00:D5B4                      ;
      35:  00:D5B4  (00:0000)           MR0		equ	0		;Mode Register
      36:  00:D5B4  (00:0001)           MR1		equ	1
      37:  00:D5B4                      ;
      38:  00:D5B4  (00:0020)           MR0_WDF2	equ	20h		; Write Data Fetch time
      39:  00:D5B4  (00:0010)           MR0_WDF1	equ	10h
      40:  00:D5B4  (00:0008)           MR0_WDF0	equ	08h
      41:  00:D5B4                      ;
      42:  00:D5B4  (00:0080)           MR1_RST		equ	80h		; Reset
      43:  00:D5B4  (00:0020)           MR1_MT		equ	20h		; Memory test mode
      44:  00:D5B4  (00:0001)           MR1_IND		equ	01h		; Indirect Bus I/F Mode
      45:  00:D5B4                      ;
      46:  00:D5B4                      ;
      47:  00:D5B4  (00:0002)           IDM_AR0		equ	2		; Indirect Mode Address Register
      48:  00:D5B4  (00:0003)           IDM_AR1		equ	3
      49:  00:D5B4                      ;
      50:  00:D5B4  (00:0004)           IDM_DR0		equ	4		; Indirect Mode Data Register
      51:  00:D5B4  (00:0005)           IDM_DR1		equ	5
      52:  00:D5B4                      ;
      53:  00:D5B4                      ;
      54:  00:D5B4                      ;------------------------------------------------------------------------------
      55:  00:D5B4                      ; In Indirect Mode which EPNET uses, these are all accessed via AR and DR above
      56:  00:D5B4                      ;
      57:  00:D5B4                      ; COMMON registers
      58:  00:D5B4                      ;
      59:  00:D5B4  (00:0002)           IR		equ	02h
      60:  00:D5B4  (00:0002)           IR0		equ	IR+0		; Interrupt Register
      61:  00:D5B4  (00:0003)           IR1		equ	IR+1
      62:  00:D5B4                      ;
      63:  00:D5B4  (00:0004)           IMR		equ	04h
      64:  00:D5B4  (00:0004)           IMR0		equ	IMR+0		; Interrupt Mask Register
      65:  00:D5B4  (00:0005)           IMR1		equ	IMR+1
      66:  00:D5B4                      ;
      67:  00:D5B4  (00:0008)           SHAR	  	equ	08h		; Source Hardware Address Register (MAC!)
      68:  00:D5B4  (00:0008)           SHAR0		equ	SHAR+0
      69:  00:D5B4  (00:0009)           SHAR1		equ	SHAR+1
      70:  00:D5B4  (00:000A)           SHAR2		equ	SHAR+2
      71:  00:D5B4  (00:000B)           SHAR3		equ	SHAR+3
      72:  00:D5B4  (00:000C)           SHAR4		equ	SHAR+4
      73:  00:D5B4  (00:000D)           SHAR5		equ	SHAR+5
      74:  00:D5B4                      
      75:  00:D5B4  (00:0010)           GAR		equ	10h 		; Gateway Address Register
      76:  00:D5B4  (00:0010)           GAR0		equ	GAR+0
      77:  00:D5B4  (00:0011)           GAR1		equ	GAR+1
      78:  00:D5B4  (00:0012)           GAR2		equ	GAR+2
      79:  00:D5B4  (00:0013)           GAR3		equ	GAR+3
      80:  00:D5B4                      
      81:  00:D5B4  (00:0014)           SUBR		equ	14h		; Subnet Mask Register
      82:  00:D5B4  (00:0014)           SUBR0		equ	SUBR+0
      83:  00:D5B4  (00:0015)           SUBR1		equ	SUBR+1
      84:  00:D5B4  (00:0016)           SUBR2		equ	SUBR+2
      85:  00:D5B4  (00:0017)           SUBR3		equ	SUBR+3
      86:  00:D5B4                      
      87:  00:D5B4  (00:0018)           SIPR		equ	18h		; Source IP Address Register
      88:  00:D5B4  (00:0018)           SIPR0		equ	SIPR+0
      89:  00:D5B4  (00:0019)           SIPR1		equ	SIPR+1
      90:  00:D5B4  (00:001A)           SIPR2		equ	SIPR+2
      91:  00:D5B4  (00:001B)           SIPR3		equ	SIPR+3
      92:  00:D5B4                      
      93:  00:D5B4  (00:001C)           RTR		equ	1ch		; Retransmission Timeout-value Register
      94:  00:D5B4  (00:001C)           RTR0		equ	RTR+0
      95:  00:D5B4  (00:001D)           RTR1		equ	RTR+1
      96:  00:D5B4                      
      97:  00:D5B4  (00:001F)           RCR1		equ	1fh		; Retransmission Retry-count Register (RCR0 "reserved")
      98:  00:D5B4                      
      99:  00:D5B4  (00:0020)           TMS01R		equ	20h
     100:  00:D5B4  (00:0020)           TMSR0		equ	TMS01R+0	; Transmit Memory Size Register Socket 0
     101:  00:D5B4  (00:0021)           TMSR1		equ	TMS01R+1	; Transmit Memory Size Register Socket 1
     102:  00:D5B4  (00:0022)           TMS23R		equ	TMS01R+2
     103:  00:D5B4  (00:0022)           TMSR2		equ	TMS23R+0	; Transmit Memory Size Register Socket 2
     104:  00:D5B4  (00:0023)           TMSR3		equ	TMS23R+1	; Transmit Memory Size Register Socket 3
     105:  00:D5B4  (00:0024)           TMS45R		equ	TMS23R+2
     106:  00:D5B4  (00:0024)           TMSR4		equ	TMS45R+0	; Transmit Memory Size Register Socket 4
     107:  00:D5B4  (00:0025)           TMSR5		equ	TMS45R+1	; Transmit Memory Size Register Socket 5
     108:  00:D5B4  (00:0026)           TMS67R		equ	TMS45R+2
     109:  00:D5B4  (00:0026)           TMSR6		equ	TMS67R+0	; Transmit Memory Size Register Socket 6
     110:  00:D5B4  (00:0027)           TMSR7		equ	TMS67R+1	; Transmit Memory Size Register Socket 7
     111:  00:D5B4                      
     112:  00:D5B4  (00:0028)           RMS01R		equ	28h
     113:  00:D5B4  (00:0028)           RMSR0		equ	RMS01R+0	; Receive Memory Size Register Socket 0
     114:  00:D5B4  (00:0029)           RMSR1		equ	RMS01R+1	; Receive Memory Size Register Socket 1
     115:  00:D5B4  (00:002A)           RMS23R		equ	RMS01R+2
     116:  00:D5B4  (00:002A)           RMSR2		equ	RMS23R+0	; Receive Memory Size Register Socket 2
     117:  00:D5B4  (00:002B)           RMSR3		equ	RMS23R+1	; Receive Memory Size Register Socket 3
     118:  00:D5B4  (00:002C)           RMS45R		equ	RMS23R+2
     119:  00:D5B4  (00:002C)           RMSR4		equ	RMS45R+0	; Receive Memory Size Register Socket 4
     120:  00:D5B4  (00:002D)           RMSR5		equ	RMS45R+1	; Receive Memory Size Register Socket 5
     121:  00:D5B4  (00:002E)           RMS67R		equ	RMS45R+2
     122:  00:D5B4  (00:002E)           RMSR6		equ	RMS67R+0	; Receive Memory Size Register Socket 6
     123:  00:D5B4  (00:002F)           RMSR7		equ	RMS67R+1	; Receive Memory Size Register Socket 7
     124:  00:D5B4                      
     125:  00:D5B4  (00:0030)           MTYPER  	equ	30h		; Memory Block Type Register
     126:  00:D5B4  (00:0030)           MTYPER0		equ	MTYPER+0
     127:  00:D5B4  (00:0031)           MTYPER1		equ	MTYPER+1
     128:  00:D5B4                      
     129:  00:D5B4  (00:0032)           PATR0		equ	32h		; PPPoE Authentication Register
     130:  00:D5B4  (00:0033)           PATR1		equ	33h
     131:  00:D5B4                      
     132:  00:D5B4  (00:0037)           PTIMER1		equ	37h		; PPP LCP Request Time Register
     133:  00:D5B4                      
     134:  00:D5B4  (00:0038)           PMAGICR0	equ	38h		; PPP LCP Magic Number Register
     135:  00:D5B4  (00:0039)           PMAGICR1	equ	39h
     136:  00:D5B4                      
     137:  00:D5B4  (00:003C)           PSIDR0		equ	3ch		; PPP Session ID Register
     138:  00:D5B4  (00:003D)           PSIDR1		equ	3dh
     139:  00:D5B4                      
     140:  00:D5B4  (00:0040)           PDHAR0		equ	40h		; PPP Dest Hardware Address Register
     141:  00:D5B4  (00:0041)           PHARD1		equ	41h
     142:  00:D5B4  (00:0042)           PHARD2		equ	42h
     143:  00:D5B4  (00:0043)           PHARD3		equ	43h
     144:  00:D5B4  (00:0044)           PHARD4		equ	44h
     145:  00:D5B4  (00:0045)           PHARD5		equ	45h
     146:  00:D5B4                      
     147:  00:D5B4  (00:0048)           UIPR0		equ	48h		; Unreachable IP Address Register
     148:  00:D5B4  (00:0049)           UIPR1		equ	49h
     149:  00:D5B4  (00:004A)           UIPR2		equ	4ah
     150:  00:D5B4  (00:004B)           UIPR3		equ	4bh
     151:  00:D5B4                      
     152:  00:D5B4  (00:004C)           UPORTR0		equ	4ch		; Unreachable Port Number Register
     153:  00:D5B4  (00:004D)           UPORTR1		equ	4dh
     154:  00:D5B4                      
     155:  00:D5B4  (00:004E)           FMTUR0		equ	4eh		; Fragmant MTU Register
     156:  00:D5B4  (00:004F)           FMTUR1		equ	4fh
     157:  00:D5B4                      
     158:  00:D5B4  (00:0061)           P0_BRDYR1	equ	61h		; Pin BRDY0 Configure Register
     159:  00:D5B4  (00:0062)           P0_BDPTHR0 	equ	62h		; Pin BRDY0 Buffer Depth Register
     160:  00:D5B4  (00:0063)           P0_BDPTHR1 	equ	63h
     161:  00:D5B4                      
     162:  00:D5B4  (00:0065)           P1_BRDYR1	equ	65h		; Pin BRDY1 Configure Register
     163:  00:D5B4  (00:0066)           P1_BDPTHR0 	equ	66h		; Pin BRDY1 Buffer Depth Register
     164:  00:D5B4  (00:0067)           P1_BDPTHR1 	equ	67h
     165:  00:D5B4                      
     166:  00:D5B4  (00:0069)           P2_BRDYR1	equ	69h		; Pin BRDY2 Configure Register
     167:  00:D5B4  (00:006A)           P2_BDPTHR0 	equ	6ah		; Pin BRDY2 Buffer Depth Register
     168:  00:D5B4  (00:006B)           P2_BDPTHR1 	equ	6bh
     169:  00:D5B4                      
     170:  00:D5B4  (00:006D)           P3_BRDYR1	equ	6dh		; Pin BRDY3 Configure Register
     171:  00:D5B4  (00:006E)           P3_BDPTHR0 	equ	6eh		; Pin BRDY3 Buffer Depth Register
     172:  00:D5B4  (00:006F)           P3_BDPTHR1 	equ	6fh
     173:  00:D5B4                      ;
     174:  00:D5B4  (00:00FE)           IDR     	equ	0feh		; W5300 ID Register
     175:  00:D5B4  (00:00FE)           IDR0		equ	IDR
     176:  00:D5B4  (00:00FF)           IDR1		equ	IDR+1
     177:  00:D5B4                      ;
     178:  00:D5B4                      ;
     179:  00:D5B4                      ;------------------------------------------------------------------------------
     180:  00:D5B4                      ; SOCKET registers
     181:  00:D5B4                      ;
     182:  00:D5B4  (00:0200)           SOCKETS		equ	0x200		; First socket register
     183:  00:D5B4                      
     184:  00:D5B4  (00:0200)           SOCKET0		equ	SOCKETS+0
     185:  00:D5B4  (00:0240)           SOCKET1		equ	SOCKET0+040h
     186:  00:D5B4  (00:0280)           SOCKET2 	equ	SOCKET1+040h
     187:  00:D5B4  (00:02C0)           SOCKET3 	equ	SOCKET2+040h
     188:  00:D5B4  (00:0300)           SOCKET4 	equ	SOCKET3+040h
     189:  00:D5B4  (00:0340)           SOCKET5 	equ	SOCKET4+040h
     190:  00:D5B4  (00:0380)           SOCKET6 	equ	SOCKET5+040h
     191:  00:D5B4  (00:03C0)           SOCKET7 	equ	SOCKET6+040h
     192:  00:D5B4                      ;
     193:  00:D5B4                      ;
     194:  00:D5B4                      ; Offsets from socket base registers above
     195:  00:D5B4  (00:0000)           Sn_MR		equ	00h		; Socket Mode Register
     196:  00:D5B4  (00:0000)           Sn_MR0		equ	Sn_MR+0
     197:  00:D5B4  (00:0001)           Sn_MR1		equ	Sn_MR+1
     198:  00:D5B4  (00:0000)           Sn_MR_CLOSED	equ	00h
     199:  00:D5B4  (00:0001)           Sn_MR_TCP	equ	01h
     200:  00:D5B4  (00:0002)           Sn_MR_UDP	equ	02h
     201:  00:D5B4  (00:0003)           Sn_MR_IPRAW	equ	03h
     202:  00:D5B4  (00:0004)           Sn_MR_MACRAW	equ	04h
     203:  00:D5B4  (00:0005)           Sn_MR_PPPoE	equ	05h
     204:  00:D5B4  (00:0020)           Sn_MR_ND	equ	20h
     205:  00:D5B4                      ;
     206:  00:D5B4  (00:0002)           Sn_CR		equ	02h		; Socket Command register
     207:  00:D5B4  (00:0002)           Sn_CR0		equ	Sn_CR+0
     208:  00:D5B4  (00:0003)           Sn_CR1		equ	Sn_CR+1
     209:  00:D5B4  (00:0001)           Sn_CR_OPEN	equ	01h
     210:  00:D5B4  (00:0002)           Sn_CR_LISTEN	equ	02h
     211:  00:D5B4  (00:0004)           Sn_CR_CONNECT	equ	04h
     212:  00:D5B4  (00:0008)           Sn_CR_DISCON	equ	08h
     213:  00:D5B4  (00:0010)           Sn_CR_CLOSE	equ	10h
     214:  00:D5B4  (00:0020)           Sn_CR_SEND	equ	20h
     215:  00:D5B4  (00:0021)           Sn_CR_SEND_MAC	equ	21h
     216:  00:D5B4  (00:0022)           Sn_CR_SEND_KEEP	equ	22h
     217:  00:D5B4  (00:0040)           Sn_CR_RECV	equ	40h
     218:  00:D5B4                      ;
     219:  00:D5B4  (00:0004)           Sn_IMR		equ	04h		; Socket Interrupt Mask Register
     220:  00:D5B4  (00:0004)           Sn_IMR0		equ	Sn_IMR+0
     221:  00:D5B4  (00:0005)           Sn_IMR1		equ	Sn_IMR+1
     222:  00:D5B4                      ;
     223:  00:D5B4  (00:0006)           Sn_IR		equ	06h		; Socket Interrupt Register
     224:  00:D5B4  (00:0007)           Sn_IR1		equ	Sn_IR+1		; (IR0 "reserved")
     225:  00:D5B4  (00:0080)           Sn_IR_PRECV	equ	80h
     226:  00:D5B4  (00:0040)           Sn_IR_PFAIL	equ	40h
     227:  00:D5B4  (00:0020)           Sn_IR_PNEXT	equ	20h
     228:  00:D5B4  (00:0010)           Sn_IR_SENDOK	equ	10h
     229:  00:D5B4  (00:0008)           Sn_IR_TIMEOUT	equ	08h
     230:  00:D5B4  (00:0004)           Sn_IR_RECV	equ	04h
     231:  00:D5B4  (00:0002)           Sn_IR_DISCON	equ	02h
     232:  00:D5B4  (00:0001)           Sn_IR_CON	equ	01h
     233:  00:D5B4                      ;
     234:  00:D5B4  (00:0008)           Sn_SSR		equ	08h		; Socket Status Register
     235:  00:D5B4  (00:0009)           Sn_SSR1		equ	Sn_SSR+1	; (SSR0 "reserved")
     236:  00:D5B4  (00:0000)           Sn_SSR_CLOSED	equ	00h
     237:  00:D5B4  (00:0013)           Sn_SSR_INIT	equ	13h
     238:  00:D5B4  (00:0014)           Sn_SSR_LISTEN	equ	14h
     239:  00:D5B4  (00:0017)           Sn_SSR_ESTAB	equ	17h
     240:  00:D5B4  (00:001C)           Sn_SSR_WAIT	equ	1ch
     241:  00:D5B4  (00:0022)           Sn_SSR_UDP	equ	22h
     242:  00:D5B4  (00:0032)           Sn_SSR_IPRAW	equ	32h
     243:  00:D5B4  (00:0042)           Sn_SSR_MACRAW	equ	42h
     244:  00:D5B4  (00:005F)           Sn_SSR_PPPoE	equ	5fh
     245:  00:D5B4  (00:0015)           Sn_SSR_SYNSENT	equ	15h
     246:  00:D5B4  (00:0016)           Sn_SSR_SYNRECV	equ	16h
     247:  00:D5B4  (00:0018)           Sn_SSR_FIN_WAIT	equ	18h
     248:  00:D5B4  (00:001B)           Sn_SSR_TIME_WAIT equ	1bh
     249:  00:D5B4  (00:001D)           Sn_SSR_LAST_ACK	equ	1dh
     250:  00:D5B4  (00:0001)           Sn_SSR_ARP	equ	01h
     251:  00:D5B4                      ;
     252:  00:D5B4  (00:000A)           Sn_PORTR	equ	0ah		; Socket Source Port Register
     253:  00:D5B4                      ;
     254:  00:D5B4  (00:000C)           Sn_DHAR		equ	0ch		; Socket Dest Hardware Address Register
     255:  00:D5B4                      ;
     256:  00:D5B4  (00:0012)           Sn_DPORTR	equ	12h		; Socket Destination Port Register
     257:  00:D5B4                      ;
     258:  00:D5B4  (00:0014)           Sn_DIPR		equ	14h		; Socket Destination IP Address Register
     259:  00:D5B4  (00:0016)           Sn_DIPR2	equ	16h
     260:  00:D5B4                      ;
     261:  00:D5B4  (00:0018)           Sn_MSSR		equ	18h		; Socket Maximum Segment Size Register
     262:  00:D5B4                      ;
     263:  00:D5B4  (00:001A)           Sn_PORTOR	equ	1ah		; Socket Options Register
     264:  00:D5B4                      ;
     265:  00:D5B4  (00:001C)           Sn_TOSR		equ	1ch		; Socket TOS Register
     266:  00:D5B4                      ;
     267:  00:D5B4  (00:001E)           Sn_TTLR		equ	1eh		; Socket TTL Register
     268:  00:D5B4                      ;
     269:  00:D5B4  (00:0020)           Sn_TX_WRSR	equ	20h		; Socket Write Size Register
     270:  00:D5B4  (00:0022)           Sn_TX_WRSR2	equ	22h
     271:  00:D5B4                      ;
     272:  00:D5B4  (00:0024)           Sn_TX_FSR	equ	24h		; Socket Free Size Register
     273:  00:D5B4  (00:0026)           Sn_TX_FSR2	equ	26h
     274:  00:D5B4                      ;
     275:  00:D5B4  (00:0028)           Sn_RX_RSR	equ	28h		; Socket Receive Size Register
     276:  00:D5B4  (00:002A)           Sn_RX_RSR2	equ	2ah
     277:  00:D5B4                      ;
     278:  00:D5B4  (00:002C)           Sn_FRAGR	equ	2ch		; Socket Frag register
     279:  00:D5B4                      ;
     280:  00:D5B4  (00:002E)           Sn_TX_FIFOR	equ	2eh		; Socket 0 Tx FIFO Register
     281:  00:D5B4                      ;
     282:  00:D5B4  (00:0030)           Sn_RX_FIFOR	equ	30h		; Socket 0 Rx FIFO Register
     283:  00:D5B4                      ;
     284:  00:D5B4                      ;
     285:  00:D5B4                      
     286:  00:D5B4                      		endmodule
     102.  00:D5B4                      	include wiz.asm
       1:  00:D5B4                      ; WIZ
       2:  00:D5B4                      ;
       3:  00:D5B4                      ; Basic functions for accessing and initialising the WIZ module
       4:  00:D5B4                      ;
       5:  00:D5B4                      		module wiz
       6:  00:D5B4                      ;
       7:  00:D5B4                      ;==============================================================================
       8:  00:D5B4                      ;
       9:  00:D5B4                      ; This file is part of the EPNET software
      10:  00:D5B4                      ;
      11:  00:D5B4                      ; Copyright (C) 2015  Bruce Tanner
      12:  00:D5B4                      ;
      13:  00:D5B4                      ;    This program is free software: you can redistribute it and/or modify
      14:  00:D5B4                      ;    it under the terms of the GNU General Public License as published by
      15:  00:D5B4                      ;    the Free Software Foundation, either version 3 of the License, or
      16:  00:D5B4                      ;    (at your option) any later version.
      17:  00:D5B4                      ;
      18:  00:D5B4                      ;    This program is distributed in the hope that it will be useful,
      19:  00:D5B4                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      20:  00:D5B4                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      21:  00:D5B4                      ;    GNU General Public License for more details.
      22:  00:D5B4                      ;
      23:  00:D5B4                      ;    You should have received a copy of the GNU General Public License
      24:  00:D5B4                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      25:  00:D5B4                      ;
      26:  00:D5B4                      ; If you do use or modify this file, either for its original purpose or for
      27:  00:D5B4                      ; something new, I'd love to hear about it! I can be contacted by email at:
      28:  00:D5B4                      ;
      29:  00:D5B4                      ; brucetanner@btopenworld.com
      30:  00:D5B4                      ;
      31:  00:D5B4                      ;==============================================================================
      32:  00:D5B4                      ;
      33:  00:D5B4  (00:0008)           SOCKETS		equ	8
      34:  00:D5B4                      ;
      35:  00:D5B4                      ;
      36:  00:D5B4                      ;------------------------------------------------------------------------------
      37:  00:D5B4                      ; read_reg
      38:  00:D5B4                      ;
      39:  00:D5B4                      ; Reads a 16-bit wiz register. socket.asm contains an equivalent routine for
      40:  00:D5B4                      ; reading a per-socket wiz register.
      41:  00:D5B4                      ;
      42:  00:D5B4                      ; In:  DE: W5300 register
      43:  00:D5B4                      ; Out: HL=value read
      44:  00:D5B4                      ;      B,DE preserved
      45:  00:D5B4                      ;
      46:  00:D5B4  FD 4E 01            read_reg:	ld	c,(iy+vars._io)	; Address Register H
      47:  00:D5B7                      ;
      48:  00:D5B7  ED 51               		out	(c),d
      49:  00:D5B9  0C                  		inc	c		; Address Register L
      50:  00:D5BA                      ;
      51:  00:D5BA  ED 59               		out	(c),e
      52:  00:D5BC  0C                  		inc	c		; Data register H
      53:  00:D5BD                      ;
      54:  00:D5BD  ED 60               		in	h,(c)
      55:  00:D5BF  0C                  		inc	c		; Data Register L
      56:  00:D5C0                      ;
      57:  00:D5C0  ED 68               		in	l,(c)
      58:  00:D5C2                      ;
      59:  00:D5C2  C9                  		ret
      60:  00:D5C3                      ;
      61:  00:D5C3                      ;
      62:  00:D5C3                      ;------------------------------------------------------------------------------
      63:  00:D5C3                      ; write_reg
      64:  00:D5C3                      ;
      65:  00:D5C3                      ; Writes a 16-bit value to a wiz register. socket.asm contains an equivalent
      66:  00:D5C3                      ; routine for writing to a per-socket wiz register.
      67:  00:D5C3                      ;
      68:  00:D5C3                      ; In:  DE: W5300 register
      69:  00:D5C3                      ;      HL: value to write
      70:  00:D5C3                      ;      B,DE preserved
      71:  00:D5C3                      ;
      72:  00:D5C3  FD 4E 01            write_reg:	ld	c,(iy+vars._io)	; Address Register H
      73:  00:D5C6                      ;
      74:  00:D5C6  ED 51               		out	(c),d
      75:  00:D5C8  0C                  		inc	c		; Address Register L
      76:  00:D5C9                      ;
      77:  00:D5C9  ED 59               		out	(c),e
      78:  00:D5CB  0C                  		inc	c		; Data register H
      79:  00:D5CC                      ;
      80:  00:D5CC  ED 61               		out	(c),h
      81:  00:D5CE  0C                  		inc	c		; Data register L
      82:  00:D5CF                      ;
      83:  00:D5CF  ED 69               		out	(c),l
      84:  00:D5D1                      ;
      85:  00:D5D1  C9                  		ret
      86:  00:D5D2                      ;
      87:  00:D5D2                      ;
      88:  00:D5D2                      ;------------------------------------------------------------------------------
      89:  00:D5D2                      ; write_IP, write_MAC
      90:  00:D5D2                      ;
      91:  00:D5D2                      ; Reads a MAC/IP address from/to 3/2 successive WIZ registers
      92:  00:D5D2                      ;
      93:  00:D5D2                      ; In:  HL->MAC/IP address
      94:  00:D5D2                      ;      DE=WIZ register
      95:  00:D5D2                      ; Out: BC and all input registers corrupted
      96:  00:D5D2                      ;
      97:  00:D5D2  06 04               write_IP:	ld	b,4
      98:  00:D5D4  18 02               		jr	writeloop
      99:  00:D5D6                      ;
     100:  00:D5D6                      write_MAC:
     101:  00:D5D6  06 06               		ld	b,6
     102:  00:D5D8  FD 4E 01            writeloop:	ld	c,(iy+vars._io)	; Address Register H
     103:  00:D5DB                      ;
     104:  00:D5DB  ED 51               		out	(c),d
     105:  00:D5DD  0C                  		inc	c		; Address Register L
     106:  00:D5DE                      ;
     107:  00:D5DE  ED 59               		out	(c),e
     108:  00:D5E0  0C                  		inc	c		; Returnn pointing to data reg
     109:  00:D5E1                      ;
     110:  00:D5E1  1C                  		inc	e		; Next register next time
     111:  00:D5E2  1C                  		inc	e
     112:  00:D5E3                      ;
     113:  00:D5E3  ED A3               		outi
     114:  00:D5E5  0C                  		inc	c
     115:  00:D5E6                      ;
     116:  00:D5E6  ED A3               		outi
     117:  00:D5E8                      ;
     118:  00:D5E8  20 EE               		jr	nz,writeloop
     119:  00:D5EA                      ;
     120:  00:D5EA  C9                  		ret
     121:  00:D5EB                      ;
     122:  00:D5EB                      ;
     123:  00:D5EB                      ;------------------------------------------------------------------------------
     124:  00:D5EB                      ; read_IP, read_MAC
     125:  00:D5EB                      ;
     126:  00:D5EB                      ; In:  HL->MAC/IP address
     127:  00:D5EB                      ;      DE=WIZ register
     128:  00:D5EB                      ; Out: BC and all input registers corrupted
     129:  00:D5EB                      ;
     130:  00:D5EB  06 04               read_IP:	ld	b,4
     131:  00:D5ED  18 02               		jr	readloop
     132:  00:D5EF                      ;
     133:  00:D5EF  06 06               read_MAC:	ld	b,6
     134:  00:D5F1  FD 4E 01            readloop:	ld	c,(iy+vars._io)	; Address Register H
     135:  00:D5F4                      ;
     136:  00:D5F4  ED 51               		out	(c),d
     137:  00:D5F6  0C                  		inc	c		; Address Register L
     138:  00:D5F7                      ;
     139:  00:D5F7  ED 59               		out	(c),e
     140:  00:D5F9  0C                  		inc	c		; Returnn pointing to data reg
     141:  00:D5FA                      ;
     142:  00:D5FA  1C                  		inc	e		; Next register next time
     143:  00:D5FB  1C                  		inc	e
     144:  00:D5FC                      
     145:  00:D5FC  ED A2               		ini
     146:  00:D5FE  0C                  		inc	c
     147:  00:D5FF                      ;
     148:  00:D5FF  ED A2               		ini
     149:  00:D601                      ;
     150:  00:D601  20 EE               		jr	nz,readloop
     151:  00:D603                      ;
     152:  00:D603  C9                  		ret
     153:  00:D604                      ;
     154:  00:D604                      ;
     155:  00:D604                      ;------------------------------------------------------------------------------
     156:  00:D604                      ; init_mem
     157:  00:D604                      ;
     158:  00:D604                      ; Set up w5300 memory partitioning to 8k for receive and transmit for each
     159:  00:D604                      ; socket. Although the documentation says this is the default, all source
     160:  00:D604                      ; code I have seen does this and a WIZNET reply to a WIZNET forum post
     161:  00:D604                      ; suggests that this is necessary anyway
     162:  00:D604                      ;
     163:  00:D604                      init_mem:
     164:  00:D604  21 08 08            		ld	hl,0808h
     165:  00:D607                      ;
     166:  00:D607  11 20 00            		ld	de,w5300.TMS01R	; Set up tx memory
     167:  00:D60A  CD 10 D6            		call	.write_x4
     168:  00:D60D                      ;
     169:  00:D60D  11 28 00            		ld	de,w5300.RMS01R	; Repeat for rx memory
     170:  00:D610                      .write_x4:	
     171:  00:D610  CD 13 D6            		call	.write_x2
     172:  00:D613  CD 16 D6            .write_x2:	call	.write_x1
     173:  00:D616  CD C3 D5            .write_x1:	call	write_reg
     174:  00:D619  1C                  		inc	e
     175:  00:D61A  1C                  		inc	e		; Next reg
     176:  00:D61B                      ;
     177:  00:D61B  C9                  		ret
     178:  00:D61C                      ;
     179:  00:D61C                      ;
     180:  00:D61C                      ;------------------------------------------------------------------------------
     181:  00:D61C                      ; init
     182:  00:D61C                      ;
     183:  00:D61C                      ; Initialises the W5300.
     184:  00:D61C                      ;
     185:  00:D61C                      ; Once initialised, just returns without doing anything. But :NET DIAG needs
     186:  00:D61C                      ; to re-initialise, so it resets the initialized flags before calling
     187:  00:D61C                      ;
     188:  00:D61C                      ; Out: C set if error
     189:  00:D61C                      ;
     190:  00:D61C                      init:
     191:  00:D61C                      		; Set up WIZ indirect mode and reset
     192:  00:D61C  B7                  		or	a		; NC=>ok
     193:  00:D61D  FD CB 03 46         		bit	vars.init.wiz,(iy+vars._init)
     194:  00:D621  C0                  		ret	nz		; Already initialized, NC
     195:  00:D622                      ;
     196:  00:D622  AF                  		xor	a
     197:  00:D623  32 0A 40            		ld	(vars.init),a	; Nothing initialised yet
     198:  00:D626                      ;
     199:  00:D626  11 9F D2            		ld	de,trace.diag.reset
     200:  00:D629  CD E9 D1            		call	trace.diag.str
     201:  00:D62C                      ;
     202:  00:D62C  3A 0D C0            		ld	a,(io)		; Get fixed ROM i/o address byte
     203:  00:D62F  B7                  		or	a		; Using fixed i/o?
     204:  00:D630  20 03               		jr	nz,.gotio	; <>0 => yes
     205:  00:D632                      ;
     206:  00:D632  DB B3               		in	a,(ep.P3)	; Else get our ROM seg no
     207:  00:D634  0F                  		rrca			; /2 gives i/o base address
     208:  00:D635  3C                  .gotio:		inc	a
     209:  00:D636  3C                  		inc	a
     210:  00:D637  32 08 40            		ld	(vars.io),a	; For efficiency we save the i/o+2
     211:  00:D63A                      ;
     212:  00:D63A  3D                  		dec	a
     213:  00:D63B  3D                  		dec	a
     214:  00:D63C  F5                  		push	af		; Save base i/o port
     215:  00:D63D  CD 0A D2            		 call	trace.diag.byte	; Print it
     216:  00:D640  CD E1 D1            		 call	trace.diag.dots
     217:  00:D643  F1                  		pop	af		; A=base i/o address
     218:  00:D644                      ;
     219:  00:D644  4F                  		ld	c,a		; C->w5300.MR0
     220:  00:D645  3E 38               		ld	a,w5300.MR0_WDF2 or w5300.MR0_WDF1 or w5300.MR0_WDF0
     221:  00:D647  ED 79               		out	(c),a		; Initialise mode register
     222:  00:D649                      ;
     223:  00:D649  0C                  		inc	c		; MR1
     224:  00:D64A  3E 81               		ld	a,w5300.MR1_IND or w5300.MR1_RST
     225:  00:D64C  ED 79               		out	(c),a		; Set up indirect mode & reset
     226:  00:D64E                      ;
     227:  00:D64E                      		; Wait for at least 10mS for w5300's PLL to sync.
     228:  00:D64E  CD 8F D7            		call	delay
     229:  00:D651                      
     230:  00:D651  3E 01               		ld	a,w5300.MR1_IND	; Make sure we're still in indirect mode
     231:  00:D653  ED 79               		out	(c),a
     232:  00:D655                      ;
     233:  00:D655                      		; Clear Interrupt Mask Register (we don't use interrupts)
     234:  00:D655  11 04 00            		ld	de,w5300.IMR
     235:  00:D658  21 00 00            		ld	hl,0
     236:  00:D65B  CD C3 D5            		call	write_reg
     237:  00:D65E                      ;
     238:  00:D65E  CD D7 D1            		call	trace.diag.ok
     239:  00:D661                      ;
     240:  00:D661                      		; Make sure we can read the ID
     241:  00:D661  11 B6 D2            		ld	de,trace.diag.id
     242:  00:D664  CD E9 D1            		call	trace.diag.str
     243:  00:D667  CD E1 D1            		call	trace.diag.dots
     244:  00:D66A                      ;
     245:  00:D66A  11 FE 00            		ld	de,w5300.IDR
     246:  00:D66D  CD B4 D5            		call	read_reg
     247:  00:D670                      ;
     248:  00:D670  7C                  		ld	a,h
     249:  00:D671  D6 53               		sub	53h		; Should get back 0x5300 for W5300
     250:  00:D673  20 03               		jr	nz,.badid
     251:  00:D675                      ;
     252:  00:D675  B5                  		or	l
     253:  00:D676  28 10               		jr	z,idok
     254:  00:D678                      ;
     255:  00:D678  CD 12 D2            .badid:		call	trace.diag.word
     256:  00:D67B  CD DC D1            diagerr:	call	trace.diag.err
     257:  00:D67E  37                  		scf			; :-(
     258:  00:D67F  C9                  		ret
     259:  00:D680                      ;
     260:  00:D680  11 3A D3            diagtimeout:	ld	de,trace.diag.timeout
     261:  00:D683  CD E9 D1            		call	trace.diag.str
     262:  00:D686  37                  		scf
     263:  00:D687  C9                  		ret
     264:  00:D688                      ;
     265:  00:D688  CD D7 D1            idok:		call	trace.diag.ok
     266:  00:D68B                      ;
     267:  00:D68B  CD 04 D6            		call	init_mem	; Set up WIZ memory partitioning
     268:  00:D68E                      ;
     269:  00:D68E                      ;
     270:  00:D68E                      		; Do memory test of WIZ memory
     271:  00:D68E  11 11 D3            		ld	de,trace.diag.memory
     272:  00:D691  CD E9 D1            		call	trace.diag.str
     273:  00:D694                      ;
     274:  00:D694  11 30 00            		ld	de,w5300.MTYPER
     275:  00:D697  21 FF 00            		ld	hl,00ffh	; Top byte Rx, bottom Tx
     276:  00:D69A  CD C3 D5            		call	write_reg
     277:  00:D69D                      ;	
     278:  00:D69D  FD 4E 01            		ld	c,(iy+vars._io)
     279:  00:D6A0  0D                  		dec	c		; C->w5300.MR1
     280:  00:D6A1  3E 21               		ld	a,w5300.MR1_IND or w5300.MR1_MT
     281:  00:D6A3  ED 79               		out	(c),a		; Set up indirect mode & mem test
     282:  00:D6A5                      ;
     283:  00:D6A5  11 00 02            		ld	de,w5300.SOCKET0+w5300.Sn_MR
     284:  00:D6A8  21 01 00            		ld	hl,w5300.Sn_MR_TCP	; Open socket 0 in TCP mode
     285:  00:D6AB  CD C3 D5            		call	write_reg
     286:  00:D6AE                      ;
     287:  00:D6AE  11 02 02            		ld	de,w5300.SOCKET0+w5300.Sn_CR
     288:  00:D6B1  21 01 00            		ld	hl,w5300.Sn_CR_OPEN
     289:  00:D6B4  CD C3 D5            		call	write_reg	; Set OPEN command
     290:  00:D6B7                      ;
     291:  00:D6B7  1E 13               		ld	e,w5300.Sn_SSR_INIT
     292:  00:D6B9  CD A6 D7            		call	wait_SSR	; Wait for command to complete
     293:  00:D6BC  38 C2               		jr	c,diagtimeout
     294:  00:D6BE                      ;
     295:  00:D6BE                      
     296:  00:D6BE                      		; Now we test the WIZ memory but only in diag mode (for speed)
     297:  00:D6BE  FD CB 00 46         		bit	vars.trace.diag,(iy+vars._trace)
     298:  00:D6C2  28 5F               		jr	z,.finish	; NC
     299:  00:D6C4                      ;
     300:  00:D6C4                      		; Now write test values to socket tx memory
     301:  00:D6C4  21 00 00            		ld	hl,0		; Initial test value
     302:  00:D6C7  01 00 10            		ld	bc,8192/2	; Word count
     303:  00:D6CA  11 2E 02            .wloop:		ld	de,w5300.SOCKET0+w5300.Sn_TX_FIFOR
     304:  00:D6CD  C5                  		push	bc
     305:  00:D6CE  E5                  		push	hl
     306:  00:D6CF  CD C3 D5            		call	write_reg
     307:  00:D6D2  E1                  		pop	hl
     308:  00:D6D3  C1                  		pop	bc
     309:  00:D6D4  24                  		inc	h		; Test value next time
     310:  00:D6D5  2C                  		inc	l
     311:  00:D6D6  0B                  		dec	bc
     312:  00:D6D7  78                  		ld	a,b
     313:  00:D6D8  B1                  		or	c
     314:  00:D6D9  20 EF               		jr	nz,.wloop
     315:  00:D6DB                      ;
     316:  00:D6DB                      		; See if we can read them back
     317:  00:D6DB  21 00 00            		ld	hl,0
     318:  00:D6DE  01 00 10            		ld	bc,8192/2
     319:  00:D6E1  11 2E 02            .rloop:		ld	de,w5300.SOCKET0+w5300.Sn_TX_FIFOR
     320:  00:D6E4  C5                  		push	bc
     321:  00:D6E5  E5                  		push	hl
     322:  00:D6E6  CD B4 D5            		call	read_reg
     323:  00:D6E9  D1                  		pop	de
     324:  00:D6EA  C1                  		pop	bc
     325:  00:D6EB  B7                  		or	a
     326:  00:D6EC  ED 52               		sbc	hl,de
     327:  00:D6EE  28 2A               		jr	z,.rok
     328:  00:D6F0                      ;
     329:  00:D6F0  19                  		add	hl,de		; DE=expected value, HL=actual
     330:  00:D6F1                      ;
     331:  00:D6F1  C5                  		push	bc
     332:  00:D6F2  D5                  		push	de
     333:  00:D6F3  E5                  		push	hl
     334:  00:D6F4  11 24 D3            		ld	de,trace.diag.memerr
     335:  00:D6F7  CD E9 D1            		call	trace.diag.str
     336:  00:D6FA  E1                  		pop	hl
     337:  00:D6FB  CD 12 D2            		call	trace.diag.word	; Print actual
     338:  00:D6FE  11 2A D3            		ld	de,trace.diag.expected
     339:  00:D701  CD E9 D1            		call	trace.diag.str
     340:  00:D704  E1                  		pop	hl
     341:  00:D705  CD 12 D2            		call	trace.diag.word	; Print expected
     342:  00:D708  11 35 D3            		ld	de,trace.diag.at
     343:  00:D70B  CD E9 D1            		call	trace.diag.str
     344:  00:D70E  E1                  		pop	hl
     345:  00:D70F  CD 12 D2            		call	trace.diag.word	; Print location
     346:  00:D712  3E 20               		ld	a,' '
     347:  00:D714  CD 02 D2            		call	trace.diag.char
     348:  00:D717  37                  		scf
     349:  00:D718  18 09               		jr	.finish
     350:  00:D71A                      ;
     351:  00:D71A  EB                  .rok:		ex	de,hl		; HL=test value
     352:  00:D71B  24                  		inc	h
     353:  00:D71C  2C                  		inc	l
     354:  00:D71D  0B                  		dec	bc
     355:  00:D71E  78                  		ld	a,b
     356:  00:D71F  B1                  		or	c
     357:  00:D720  20 BF               		jr	nz,.rloop
     358:  00:D722                      ;
     359:  00:D722  B7                  		or	a
     360:  00:D723                      ;
     361:  00:D723  F5                  .finish:	push	af		; C=>error
     362:  00:D724  11 02 02            		ld	de,w5300.SOCKET0+w5300.Sn_CR
     363:  00:D727  21 10 00            		ld	hl,w5300.Sn_CR_CLOSE
     364:  00:D72A  CD C3 D5            		call	write_reg
     365:  00:D72D                      ;
     366:  00:D72D  1E 00               		ld	e,w5300.Sn_SSR_CLOSED
     367:  00:D72F  CD A6 D7            		call	wait_SSR
     368:  00:D732  DA 80 D6            		jp	c,diagtimeout
     369:  00:D735                      ;
     370:  00:D735  FD 4E 01            		ld	c,(iy+vars._io)
     371:  00:D738  0D                  		dec	c		; C->w5300.MR1
     372:  00:D739  3E 01               		ld	a,w5300.MR1_IND
     373:  00:D73B  ED 79               		out	(c),a		; Set up indirect mode & no mem test
     374:  00:D73D  F1                  		pop	af
     375:  00:D73E  DA 7B D6            		jp	c,diagerr
     376:  00:D741                      ;
     377:  00:D741  CD D7 D1            		call	trace.diag.ok
     378:  00:D744                      ;
     379:  00:D744                      ;
     380:  00:D744                      		; Set the MAC address
     381:  00:D744  11 BF D2            		ld	de,trace.diag.writemac
     382:  00:D747  CD E9 D1            		call	trace.diag.str
     383:  00:D74A                      ;
     384:  00:D74A  21 0E C0            		ld	hl,mac
     385:  00:D74D  CD 1A D2            		call	trace.diag.mac
     386:  00:D750  CD E1 D1            		call	trace.diag.dots
     387:  00:D753                      ;
     388:  00:D753  21 0E C0            		ld	hl,mac
     389:  00:D756  11 08 00            		ld	de,w5300.SHAR
     390:  00:D759  CD D6 D5            		call	write_MAC
     391:  00:D75C                      ;
     392:  00:D75C                      		; Read it back & verify
     393:  00:D75C  CD CD D7            		call	get_MAC
     394:  00:D75F  EB                  		ex	de,hl		; DE->MAC address
     395:  00:D760                      ;
     396:  00:D760  21 0E C0            		ld	hl,mac
     397:  00:D763  11 1E 40            		ld	de,vars.diag.buffer
     398:  00:D766  06 06               		ld	b,6
     399:  00:D768  1A                  .macloop:	ld	a,(de)
     400:  00:D769  13                  		inc	de
     401:  00:D76A  BE                  		cp	(hl)
     402:  00:D76B  23                  		inc	hl
     403:  00:D76C  20 07               		jr	nz,.badmac
     404:  00:D76E                      ;
     405:  00:D76E  10 F8               		djnz	.macloop
     406:  00:D770                      ;
     407:  00:D770  CD D7 D1            		call	trace.diag.ok
     408:  00:D773  18 09               		jr	.macok
     409:  00:D775                      ;
     410:  00:D775  21 1E 40            .badmac:	ld	hl,vars.diag.buffer
     411:  00:D778  CD 1A D2            		call	trace.diag.mac
     412:  00:D77B                      ;
     413:  00:D77B  C3 7B D6            		jp	diagerr
     414:  00:D77E                      ;
     415:  00:D77E                      .macok:		
     416:  00:D77E                      ;
     417:  00:D77E  FD CB 03 C6         		set	vars.init.wiz,(iy+vars._init)
     418:  00:D782  C9                  		ret
     419:  00:D783                      ;
     420:  00:D783                      ;
     421:  00:D783                      ;------------------------------------------------------------------------------
     422:  00:D783                      ; check_ip
     423:  00:D783                      ;
     424:  00:D783                      ; Called to see if we have a duplicate IP address on the network
     425:  00:D783                      ;
     426:  00:D783                      ; Out: Cy=>IP address conflict
     427:  00:D783                      ;
     428:  00:D783  11 02 00            check_ip:	ld	de,w5300.IR0
     429:  00:D786  CD B4 D5            		call	read_reg	; HL=IR0
     430:  00:D789  7C                  		ld	a,h		; A=high IR0
     431:  00:D78A  E6 80               		and	80h		; A=NZ if IPCF (IP conflict) bit set
     432:  00:D78C  C6 FF               		add	a,0ffh		; NZ=>Cy, Z=>NC
     433:  00:D78E  C9                  		ret
     434:  00:D78F                      ;
     435:  00:D78F                      ;
     436:  00:D78F                      ;------------------------------------------------------------------------------
     437:  00:D78F                      ; delay
     438:  00:D78F                      ;
     439:  00:D78F                      ; We must wait at least 10mS after resetting the WIZ chip to allow its PLL
     440:  00:D78F                      ; to lock on.
     441:  00:D78F                      ;
     442:  00:D78F                      ; The smallest resolution timer we have access to is the 20mS video interrupt.
     443:  00:D78F                      ; So we wait for one interrupt and then wait for the next to ensure we wait
     444:  00:D78F                      ; at least 20mS (it doesn't matter to the WIZ chip if we wait more than 10mS).
     445:  00:D78F                      ;
     446:  00:D78F  ED 5B 0E 40         delay:		ld	de,(vars.ticks)
     447:  00:D793                      ;
     448:  00:D793                      		; First wait for new tick
     449:  00:D793  13                  		inc	de
     450:  00:D794  2A 0E 40            .loopstart:	ld	hl,(vars.ticks)
     451:  00:D797  B7                  		or	a
     452:  00:D798  ED 52               		sbc	hl,de
     453:  00:D79A  38 F8               		jr	c,.loopstart	; Wait for start of tick
     454:  00:D79C                      ;
     455:  00:D79C                      		; Then wait for end of next tick
     456:  00:D79C  13                  		inc	de
     457:  00:D79D  2A 0E 40            .loopend:	ld	hl,(vars.ticks)
     458:  00:D7A0  B7                  		or	a
     459:  00:D7A1  ED 52               		sbc	hl,de
     460:  00:D7A3  38 F8               		jr	c,.loopend
     461:  00:D7A5                      ;
     462:  00:D7A5  C9                  		ret
     463:  00:D7A6                      ;
     464:  00:D7A6                      ;
     465:  00:D7A6                      ;------------------------------------------------------------------------------
     466:  00:D7A6                      ; Waits for socket open or close to complete
     467:  00:D7A6                      ;
     468:  00:D7A6                      ; IN:  E=SN_SSR_xxx command to wait for
     469:  00:D7A6                      ; Out: C=>timeout
     470:  00:D7A6                      wait_SSR:
     471:  00:D7A6  06 00               		ld	b,0		; Timeout, just in case
     472:  00:D7A8                      		; First wait for CR to become 0
     473:  00:D7A8  D5                  .wait_CR:	push	de
     474:  00:D7A9  11 02 02            		 ld	de,w5300.SOCKET0+w5300.Sn_CR
     475:  00:D7AC  C5                  		 push	bc
     476:  00:D7AD  CD B4 D5            		  call	read_reg
     477:  00:D7B0  C1                  		 pop	bc
     478:  00:D7B1  D1                  		pop	de
     479:  00:D7B2  7C                  		ld	a,h
     480:  00:D7B3  B5                  		or	l
     481:  00:D7B4  28 04               		jr	z,.done_CR
     482:  00:D7B6                      ;
     483:  00:D7B6  10 F0               		djnz	.wait_CR
     484:  00:D7B8                      ;
     485:  00:D7B8  37                  		scf			; Timeout
     486:  00:D7B9  C9                  		ret
     487:  00:D7BA                      .done_CR:
     488:  00:D7BA                      ;
     489:  00:D7BA  06 00               		ld	b,0		; Timeout, just in case
     490:  00:D7BC                      		; Now wait for expected value in SSR
     491:  00:D7BC  D5                  .wait_SSR:	push	de
     492:  00:D7BD  11 08 02            		 ld	de,w5300.SOCKET0+w5300.Sn_SSR
     493:  00:D7C0  C5                  		 push	bc
     494:  00:D7C1  CD B4 D5            		  call	read_reg
     495:  00:D7C4  C1                  		 pop	bc
     496:  00:D7C5  D1                  		pop	de
     497:  00:D7C6  7D                  		ld	a,l
     498:  00:D7C7  BB                  		cp	e
     499:  00:D7C8  C8                  		ret	z		; NC=>ok
     500:  00:D7C9                      ;
     501:  00:D7C9  10 F1               		djnz	.wait_SSR
     502:  00:D7CB                      ;
     503:  00:D7CB  37                  		scf
     504:  00:D7CC  C9                  		ret
     505:  00:D7CD                      ;
     506:  00:D7CD                      ;
     507:  00:D7CD                      ;
     508:  00:D7CD  11 08 00            get_MAC:	ld	de,w5300.SHAR
     509:  00:D7D0  21 1E 40            		ld	hl,vars.diag.buffer
     510:  00:D7D3  E5                  		push	hl
     511:  00:D7D4  CD EF D5            		 call	read_MAC
     512:  00:D7D7  E1                  		pop	hl
     513:  00:D7D8                      ;
     514:  00:D7D8  C9                  		ret
     515:  00:D7D9                      ;
     516:  00:D7D9                      ;
     517:  00:D7D9                      ; In:  HL->IP address
     518:  00:D7D9                      ; Out: Cy=>error
     519:  00:D7D9                      
     520:  00:D7D9  11 D0 D2            set_ip:		ld	de,trace.diag.writeip
     521:  00:D7DC  CD E6 D1            		call	trace.diag.startstr
     522:  00:D7DF                      ;
     523:  00:D7DF  11 18 00            		ld	de,w5300.SIPR
     524:  00:D7E2  18 25               		jr	setip
     525:  00:D7E4                      ;
     526:  00:D7E4                      ;
     527:  00:D7E4  11 18 00            get_ip:		ld	de,w5300.SIPR
     528:  00:D7E7                      ;
     529:  00:D7E7  21 1E 40            getip:		ld	hl,vars.diag.buffer
     530:  00:D7EA  E5                  		push	hl
     531:  00:D7EB  CD EB D5            		 call	read_IP
     532:  00:D7EE  E1                  		pop	hl
     533:  00:D7EF  C9                  		ret
     534:  00:D7F0                      ;
     535:  00:D7F0                      ;
     536:  00:D7F0                      ; In:  HL->IP address
     537:  00:D7F0                      ; Out: Cy=>error
     538:  00:D7F0                      set_subnet:
     539:  00:D7F0  11 E0 D2            		ld	de,trace.diag.subnet
     540:  00:D7F3  CD E6 D1            		call	trace.diag.startstr
     541:  00:D7F6                      ;
     542:  00:D7F6  11 14 00            		ld	de,w5300.SUBR
     543:  00:D7F9  18 0E               		jr	setip
     544:  00:D7FB                      ;
     545:  00:D7FB  11 14 00            get_subnet:	ld	de,w5300.SUBR
     546:  00:D7FE  18 E7               		jr	getip
     547:  00:D800                      ;
     548:  00:D800                      ;
     549:  00:D800                      ; In:  HL->IP address
     550:  00:D800                      ; Out: Cy=>error
     551:  00:D800                      set_gateway:
     552:  00:D800  11 F1 D2            		ld	de,trace.diag.gateway
     553:  00:D803  CD E6 D1            		call	trace.diag.startstr
     554:  00:D806                      ;
     555:  00:D806  11 10 00            		ld	de,w5300.GAR
     556:  00:D809                      ;
     557:  00:D809  D5                  setip:		push	de		; DE=WIZ register
     558:  00:D80A  E5                  		push	hl		; HL->IP
     559:  00:D80B  CD 22 D2            		call	trace.diag.ip
     560:  00:D80E  CD E1 D1            		call	trace.diag.dots
     561:  00:D811  E1                  		pop	hl
     562:  00:D812  D1                  		pop	de
     563:  00:D813                      ;
     564:  00:D813  E5                  		push	hl
     565:  00:D814  D5                  		push	de
     566:  00:D815  CD D2 D5            		call	write_IP
     567:  00:D818  D1                  		pop	de
     568:  00:D819  21 1E 40            		ld	hl,vars.diag.buffer
     569:  00:D81C  CD EB D5            		call	read_IP
     570:  00:D81F  E1                  		pop	hl
     571:  00:D820                      ;
     572:  00:D820  11 1E 40            		ld	de,vars.diag.buffer
     573:  00:D823  06 04               		ld	b,4
     574:  00:D825  1A                  .loop:		ld	a,(de)
     575:  00:D826  13                  		inc	de
     576:  00:D827  BE                  		cp	(hl)
     577:  00:D828  23                  		inc	hl
     578:  00:D829  20 07               		jr	nz,.badip
     579:  00:D82B                      ;
     580:  00:D82B  10 F8               		djnz	.loop
     581:  00:D82D                      ;
     582:  00:D82D  CD D7 D1            		call	trace.diag.ok
     583:  00:D830                      ;
     584:  00:D830  B7                  		or	a		; No error
     585:  00:D831  C9                  		ret
     586:  00:D832                      ;
     587:  00:D832  21 1E 40            .badip:		ld	hl,vars.diag.buffer
     588:  00:D835  CD 22 D2            		call	trace.diag.ip
     589:  00:D838                      ;
     590:  00:D838  C3 7B D6            		jp	diagerr
     591:  00:D83B                      ;
     592:  00:D83B                      ;
     593:  00:D83B  11 10 00            get_gateway:	ld	de,w5300.GAR
     594:  00:D83E  18 A7               		jr	getip
     595:  00:D840                      ;
     596:  00:D840                      ;
     597:  00:D840                      ;
     598:  00:D840                      		endmodule
     103.  00:D840                      	include socket.asm
       1:  00:D840                      ; SOCKET
       2:  00:D840                      ;
       3:  00:D840                      ; This module implements an interface to the WIZ socket registers. It is used
       4:  00:D840                      ; by the protocol modules UDP.ASM, TCP.ASM and IPRAW.ASM.
       5:  00:D840                      ;
       6:  00:D840                      ;==============================================================================
       7:  00:D840                      ;
       8:  00:D840                      ; This file is part of the EPNET software
       9:  00:D840                      ;
      10:  00:D840                      ; Copyright (C) 2015  Bruce Tanner
      11:  00:D840                      ;
      12:  00:D840                      ;    This program is free software: you can redistribute it and/or modify
      13:  00:D840                      ;    it under the terms of the GNU General Public License as published by
      14:  00:D840                      ;    the Free Software Foundation, either version 3 of the License, or
      15:  00:D840                      ;    (at your option) any later version.
      16:  00:D840                      ;
      17:  00:D840                      ;    This program is distributed in the hope that it will be useful,
      18:  00:D840                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      19:  00:D840                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      20:  00:D840                      ;    GNU General Public License for more details.
      21:  00:D840                      ;
      22:  00:D840                      ;    You should have received a copy of the GNU General Public License
      23:  00:D840                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      24:  00:D840                      ;
      25:  00:D840                      ; If you do use or modify this file, either for its original purpose or for
      26:  00:D840                      ; something new, I'd love to hear about it! I can be contacted by email at:
      27:  00:D840                      ;
      28:  00:D840                      ; brucetanner@btopenworld.com
      29:  00:D840                      ;
      30:  00:D840                      ;==============================================================================
      31:  00:D840                      ;
      32:  00:D840                      ; The protocol interfaces take socket numbers as parameters, which need
      33:  00:D840                      ; to be converted to WIZ socket register numbers, which are offsets from
      34:  00:D840                      ; a socket base register. To do this efficiently this module identifies its
      35:  00:D840                      ; sockets as a socket base number in DE. The top two bits of E are the
      36:  00:D840                      ; bottom 2 bits of the socket number, and the bottom bit of D is the the top
      37:  00:D840                      ; bit of the socket number. Bit 1 of D is set. This means when the bottom
      38:  00:D840                      ; 6 bits of E are the socket register offset (the WIZ Sn_xxx constant), DE
      39:  00:D840                      ; is the correct WIZ register number.
      40:  00:D840                      ;
      41:  00:D840                      ; Ie. the socket number->base address mapping is:
      42:  00:D840                      ;
      43:  00:D840                      ; Socket    W5300 Base                D	       E (xxxxxx=WIZ Sn_xxx contant)
      44:  00:D840                      ; 00000000->00000010 00000000 (200h)  00000010 00xxxxxx
      45:  00:D840                      ; 00000001->00000010 01000000 (240h)  00000010 01xxxxxx
      46:  00:D840                      ; 00000010->00000010 10000000 (280h)  00000010 10xxxxxx
      47:  00:D840                      ; 00000011->00000010 11000000 (2c0h)  00000010 11xxxxxx
      48:  00:D840                      ; 00000100->00000011 00000000 (300h)  00000011 00xxxxxx
      49:  00:D840                      ; 00000101->00000011 01000000 (340h)  00000011 01xxxxxx
      50:  00:D840                      ; 00000110->00000011 10000000 (380h)  00000011 10xxxxxx
      51:  00:D840                      ; 00000111->00000011 11000000 (3c0h)  00000011 11xxxxxx
      52:  00:D840                      ;
      53:  00:D840                      ;
      54:  00:D840                      ; We also need to keep some per-socket variables and need to be able to
      55:  00:D840                      ; index into this efficiently. So we keep all the per-socket variables in one
      56:  00:D840                      ; 256-byte page (so 32 bytes/socket available). Thus we need to shift the
      57:  00:D840                      ; offset to the socket variable left and then shift DE right to get the low
      58:  00:D840                      ; byte of the address of the desired variable:
      59:  00:D840                      ;
      60:  00:D840                      ; Socket    LO RAM Address  D	     E       
      61:  00:D840                      ; 00000000->00000000 (00h)  00000010 00xxxxxx
      62:  00:D840                      ; 00000001->00100000 (20h)  00000010 01xxxxxx
      63:  00:D840                      ; 00000010->01000000 (40h)  00000010 10xxxxxx
      64:  00:D840                      ; 00000011->01100000 (60h)  00000010 11xxxxxx
      65:  00:D840                      ; 00000100->10000000 (80h)  00000011 00xxxxxx
      66:  00:D840                      ; 00000101->10100000 (a0h)  00000011 01xxxxxx
      67:  00:D840                      ; 00000110->11000000 (c0h)  00000011 10xxxxxx
      68:  00:D840                      ; 00000111->11100000 (e0h)  00000011 11xxxxxx
      69:  00:D840                      ;
      70:  00:D840                      ;
      71:  00:D840                      ; This macro convers a socket number in A to the base number in DE
      72:  00:D840                      ;
      73:  00:D840                      ;
      74:  00:D840                      		macro	SOCKET_GET_BASE
      75:  00:D840                    < 		 ld	de,0100h
      76:  00:D840                    < 		 rrca
      77:  00:D840                    < 		 rr	e
      78:  00:D840                    < 		 rrca
      79:  00:D840                    < 		 rr	e
      80:  00:D840                    < 		 rrca
      81:  00:D840                    < 		 rl	d
      82:  00:D840                    < 		endm
      83:  00:D840                      ;
      84:  00:D840                      ;
      85:  00:D840                      ; The same but for fixed socket 0 - more efficient
      86:  00:D840                      ;
      87:  00:D840                      		macro	SOCKET_GET_BASE_0
      88:  00:D840                    < 		 ld	de,0200h
      89:  00:D840                    < 		endm
      90:  00:D840                      ;
      91:  00:D840                      ;
      92:  00:D840                      ;------------------------------------------------------------------------------
      93:  00:D840                      ; This macro converts from the base number in DE and offset in A to a RAM
      94:  00:D840                      ; pointer in HL
      95:  00:D840                      		macro	SOCKET_GET_RAM
      96:  00:D840                    < 		 add	a,a
      97:  00:D840                    < 		 or	e
      98:  00:D840                    < 		 ld	l,a
      99:  00:D840                    < 		 ld	a,d
     100:  00:D840                    < 		 rrca
     101:  00:D840                    < 		 rr	l
     102:  00:D840                    < 		 ld	h,high vars.sockets
     103:  00:D840                    < 		endm
     104:  00:D840                      ;
     105:  00:D840                      ; Same but takes a fixed offset as a parameter
     106:  00:D840                      		macro	SOCKET_GET_VAR var
     107:  00:D840                    < 		 if	(var)=0
     108:  00:D840                    < 		  ld	a,e
     109:  00:D840                    < 		 else
     110:  00:D840                    < 		  ld	a,(var)*2
     111:  00:D840                    < 		  or	e
     112:  00:D840                    < 		 endif
     113:  00:D840                    < 		 ld	l,a
     114:  00:D840                    < 		 ld	a,d
     115:  00:D840                    < 		 rrca
     116:  00:D840                    < 		 rr	l
     117:  00:D840                    < 		 ld	h,high vars.sockets
     118:  00:D840                    < 		endm
     119:  00:D840                      ;
     120:  00:D840                      ; 
     121:  00:D840                      		module	socket
     122:  00:D840                      ;
     123:  00:D840                      ;
     124:  00:D840                      ; Structure of variables in per-socket RAM. DPORTR is a copy of the Sn_DPORTR
     125:  00:D840                      ; w5300 register that is necessary because a bug in the w5300 means its
     126:  00:D840                      ; SnDPORTR register cannot be read correctly
     127:  00:D840                      ;
     128:  00:D840                      		struct	vars
     129:  00:D840                    < owner		 word		; ->owner string
     130:  00:D840                    < tcp_connected	 byte		; NZ=>connected to remote party
     131:  00:D840                    < rx_size		 word
     132:  00:D840                    < rx_inhand	 word		; First byte FF => second byte buffered
     133:  00:D840                    < tx_size		 word
     134:  00:D840                    < tx_inhand	 word		; Second byte FF => first byte buffered!
     135:  00:D840                    < DPORTR		 word		; Copy of Sn_DPORTR
     136:  00:D840                    < 		ends
     137:  00:D840                      ;
     138:  00:D840                      ;
     139:  00:D840                      ;------------------------------------------------------------------------------
     140:  00:D840                      ; read_reg
     141:  00:D840                      ;
     142:  00:D840                      ; Reads a 16-bit socket register - as wiz.read_reg but for socket registers.
     143:  00:D840                      ;
     144:  00:D840                      ; In:  DE: W5300 socket base register
     145:  00:D840                      ;       A: Sn_xxx offset
     146:  00:D840                      ; Out: HL=value read
     147:  00:D840                      ;      DE,B preserved
     148:  00:D840                      ;
     149:  00:D840  FD 4E 01            read_reg:	ld	c,(iy+vars._io)	; Address Register H
     150:  00:D843                      ;
     151:  00:D843  ED 51               		out	(c),d
     152:  00:D845  0C                  		inc	c		; Address Register L
     153:  00:D846                      ;
     154:  00:D846  B3                   		or	e
     155:  00:D847  ED 79               		out	(c),a
     156:  00:D849  0C                  		inc	c		; Data register H
     157:  00:D84A                      ;
     158:  00:D84A  ED 60               		in	h,(c)
     159:  00:D84C  0C                  		inc	c		; Data Register L
     160:  00:D84D                      ;
     161:  00:D84D  ED 68               		in	l,(c)
     162:  00:D84F                      ;
     163:  00:D84F  C9                  		ret
     164:  00:D850                      ;
     165:  00:D850                      ;------------------------------------------------------------------------------
     166:  00:D850                      ; write_reg
     167:  00:D850                      ;
     168:  00:D850                      ; Writes a 16-bit socket register - as wiz.write_reg but for socket registers.
     169:  00:D850                      ;
     170:  00:D850                      ; In:  DE: W5300 socket base register
     171:  00:D850                      ;       A: Sn_xxx offset
     172:  00:D850                      ;      HL: value to write
     173:  00:D850                      ; Out: HL=value read
     174:  00:D850                      ;      HL,DE,B preserved
     175:  00:D850                      ;
     176:  00:D850  FD 4E 01            write_reg:	ld	c,(iy+vars._io)	; Address Register H
     177:  00:D853                      ;
     178:  00:D853  ED 51               		out	(c),d
     179:  00:D855  0C                  		inc	c		; Address Register L
     180:  00:D856                      ;
     181:  00:D856  B3                  		or	e
     182:  00:D857  ED 79               		out	(c),a
     183:  00:D859  0C                  		inc	c		; Data register H
     184:  00:D85A                      ;
     185:  00:D85A  ED 61               		out	(c),h
     186:  00:D85C  0C                  		inc	c		; Data register L
     187:  00:D85D                      ;
     188:  00:D85D  ED 69               		out	(c),l
     189:  00:D85F                      ;
     190:  00:D85F  C9                  		ret
     191:  00:D860                      ;
     192:  00:D860                      ;------------------------------------------------------------------------------
     193:  00:D860                      ;
     194:  00:D860                      ; read_FIFO
     195:  00:D860                      ;
     196:  00:D860                      ; Reads a block of words from a wiz rx fifo
     197:  00:D860                      ;
     198:  00:D860                      ; In:  E':HL->block
     199:  00:D860                      ;         DE=w5300 socket base register
     200:  00:D860                      ;         BC=byte count
     201:  00:D860                      ;         C'->P1
     202:  00:D860                      ;         B'=our seg
     203:  00:D860                      ; Out: All main set input registers corrupted
     204:  00:D860                      ;
     205:  00:D860                      _read_FIFO:
     206:  00:D860                      ;
     207:  00:D860                      ; This version sets up B so that we can use INI's decrementing and testing 
     208:  00:D860                      ; of B, which is quicker, for an inner loop and D for an outer loop. We need to
     209:  00:D860                      ; fiddle the byte count registers a little, eg (all counts must be even!):
     210:  00:D860                      ;
     211:  00:D860                      ;   BC	 B (inner)	D (outer)
     212:  00:D860                      ; ----   ---------      ---------
     213:  00:D860                      ; 0001		01		1
     214:  00:D860                      ; 00fe		fe		1
     215:  00:D860                      ; 0100		00		1
     216:  00:D860                      ; 0101		01		2
     217:  00:D860                      ; 01fe		fe		2
     218:  00:D860                      ; 0200		00		2
     219:  00:D860                      ; 0201		01		3
     220:  00:D860                      ;
     221:  00:D860                      ; We also need to arrange the loops so that inc & dec of c, the i/o port, does
     222:  00:D860                      ; not corrupt the B loop count = 0 flag that INI puts in the overflow flag.
     223:  00:D860                      ;
     224:  00:D860  CD E2 D0            		call	status.activity
     225:  00:D863                      
     226:  00:D863  0B                  		dec	bc		; So BC=xx00 has correct outer loop count
     227:  00:D864  79                  		ld	a,c		; A=inner loop count-1
     228:  00:D865                      
     229:  00:D865  FD 4E 01            		ld	c,(iy+vars._io)	; Address Register H
     230:  00:D868                      
     231:  00:D868  ED 51               		out	(c),d		; Output Address Register H
     232:  00:D86A  0C                  		inc	c		; C->Address Register L
     233:  00:D86B                      
     234:  00:D86B  50                  		ld	d,b		; D=outer loop count-1
     235:  00:D86C  14                  		inc	d		; D=outer loop count
     236:  00:D86D  47                  		ld	b,a		; B=inner loop count-1
     237:  00:D86E  04                  		inc	b		; B=inner loop count
     238:  00:D86F                      
     239:  00:D86F  3E 30               		ld	a,w5300.Sn_RX_FIFOR
     240:  00:D871  B3                  		or	e		; A=Sn_xxx register number
     241:  00:D872  ED 79               		out	(c),a		; Output address register L
     242:  00:D874  0C                  		inc	c		; C->Data register H
     243:  00:D875                      ;
     244:  00:D875  D9                  		exx
     245:  00:D876  ED 59               		out	(c),e		; Page in data buffer
     246:  00:D878  D9                  		exx
     247:  00:D879                      ;
     248:  00:D879  0C                  		inc	c		; Compensate for initial dec c
     249:  00:D87A  0D                  .loop:		dec	c		;  4
     250:  00:D87B  ED A2               		ini			; 16
     251:  00:D87D  0C                  		inc	c		;  4
     252:  00:D87E  ED A2               		ini			; 16
     253:  00:D880  C2 7A D8            		jp	nz,.loop	; 10
     254:  00:D883                      					; --
     255:  00:D883                      					; 50
     256:  00:D883                      
     257:  00:D883  15                  		dec	d		;  4
     258:  00:D884  20 F4               		jr	nz,.loop	; 10
     259:  00:D886                      ;
     260:  00:D886  D9                  		exx
     261:  00:D887  ED 41               		out	(c),b		; Restore paging
     262:  00:D889  D9                  		exx
     263:  00:D88A                      ;
     264:  00:D88A  C3 EA D0            		jp	status.inactivity
     265:  00:D88D                      ;
     266:  00:D88D                      ;
     267:  00:D88D                      ;------------------------------------------------------------------------------
     268:  00:D88D                      ; write_FIFO
     269:  00:D88D                      ;
     270:  00:D88D                      ; Writes a block of words to a wiz tx fifo
     271:  00:D88D                      ;
     272:  00:D88D                      ; In:  E':HL ->block
     273:  00:D88D                      ;         DE =wiz FIFO register number
     274:  00:D88D                      ;         BC =byte count (must be even)
     275:  00:D88D                      ;          C'->P1
     276:  00:D88D                      ;          B'=our seg
     277:  00:D88D                      ; Out: HL->next word in black
     278:  00:D88D                      ;      All main input registers corrupted
     279:  00:D88D                      ;
     280:  00:D88D                      _write_FIFO:
     281:  00:D88D  CD E2 D0            		call	status.activity
     282:  00:D890                      
     283:  00:D890  0B                  		dec	bc		; So BC=xx00 has correct outer loop count
     284:  00:D891  79                  		ld	a,c		; A=inner loop count-1
     285:  00:D892                      
     286:  00:D892  FD 4E 01            		ld	c,(iy+vars._io)	; Address Register H
     287:  00:D895                      
     288:  00:D895  ED 51               		out	(c),d		; Output Address Register H
     289:  00:D897  0C                  		inc	c		; C->Address Register L
     290:  00:D898                      
     291:  00:D898  50                  		ld	d,b		; D=outer loop count-1
     292:  00:D899  14                  		inc	d		; D=outer loop count
     293:  00:D89A  47                  		ld	b,a		; B=inner loop count-1
     294:  00:D89B  04                  		inc	b		; B=inner loop count
     295:  00:D89C                      
     296:  00:D89C  3E 2E               		ld	a,w5300.Sn_TX_FIFOR
     297:  00:D89E  B3                  		or	e		; A=Sn_xxx register number
     298:  00:D89F  ED 79               		out	(c),a		; Output address register L
     299:  00:D8A1  0C                  		inc	c		; C->Data register H
     300:  00:D8A2                      ;
     301:  00:D8A2  D9                  		exx
     302:  00:D8A3  ED 59               		out	(c),e		; Page in data buffer
     303:  00:D8A5  D9                  		exx
     304:  00:D8A6                      ;
     305:  00:D8A6  0C                  		inc	c		; Compensate for initial dec c
     306:  00:D8A7  0D                  .loop:		dec	c		;  4 C->Data Register L
     307:  00:D8A8  ED A3               		outi			; 16
     308:  00:D8AA  0C                  		inc	c		;  4
     309:  00:D8AB  ED A3               		outi			; 16
     310:  00:D8AD  C2 A7 D8            		jp	nz,.loop	; 10
     311:  00:D8B0                      					; --
     312:  00:D8B0                      					; 50
     313:  00:D8B0                      ;
     314:  00:D8B0  15                  		dec	d		;  4
     315:  00:D8B1  20 F4               		jr	nz,.loop	; 10
     316:  00:D8B3                      ;
     317:  00:D8B3  D9                  		exx
     318:  00:D8B4  ED 41               		out	(c),b		; Restore paging
     319:  00:D8B6  D9                  		exx
     320:  00:D8B7                      ;
     321:  00:D8B7  C3 EA D0            		jp	status.inactivity
     322:  00:D8BA                      ;
     323:  00:D8BA                      ;
     324:  00:D8BA                      ;------------------------------------------------------------------------------
     325:  00:D8BA                      ; read_FIFO
     326:  00:D8BA                      ;
     327:  00:D8BA                      ; Reads the WIZ FIFO into a memory buffer.
     328:  00:D8BA                      ;
     329:  00:D8BA                      ; This is where raw trace mode is implemented. If raw mode is on the words are
     330:  00:D8BA                      ; output in a hex dump (but as bytes of course!)
     331:  00:D8BA                      ;
     332:  00:D8BA                      ; A lot of pushing and popping is required for trace mode, so for speed the
     333:  00:D8BA                      ; code is arranged to avoid this if trace mode is off.
     334:  00:D8BA                      ;
     335:  00:D8BA                      ; read_header is used to read the WIZ PACKET_INFO that is put in front of the
     336:  00:D8BA                      ; real data. It is the same as read_FIFO but in raw trace mode the output
     337:  00:D8BA                      ; bytes are followed by (header) to indicate they are WIZ-added data and
     338:  00:D8BA                      ; not actually part of the packet. The PACKET_INFO contains the actual
     339:  00:D8BA                      ; number of bytes in the following packet (Sn_RX_RSR also contains the number
     340:  00:D8BA                      ; of bytes but is always even, including a "dummy" byte at the end if the
     341:  00:D8BA                      ; packet is odd). Unfortunately the position of the byte count in PACKET_INFO
     342:  00:D8BA                      ; varies according to the protocol (UDP, TCP, IPRAW etc) (thanks WIZ!) so
     343:  00:D8BA                      ; it is up to the caller to save this in the per-socket variable. We could
     344:  00:D8BA                      ; read the protocol type here and act accordingly but as the caller knows their
     345:  00:D8BA                      ; own protocol it is easier just to do it there.
     346:  00:D8BA                      ;
     347:  00:D8BA                      ; For read_FIFO E' contains the buffer segment, but read_header only ever reads
     348:  00:D8BA                      ; into our own memory so it sets up E' here.
     349:  00:D8BA                      ;
     350:  00:D8BA                      ; In: E':HL->block
     351:  00:D8BA                      ;        BC=byte count
     352:  00:D8BA                      ;        DE=reg base
     353:  00:D8BA                      ;         C'->P1
     354:  00:D8BA                      ;         B'=our seg
     355:  00:D8BA                      ;
     356:  00:D8BA                      read_header_0:	SOCKET_GET_BASE_0
     356:  00:D8BA  11 00 02          >    ld de,0200h
     357:  00:D8BD  D9                  read_header:	exx
     358:  00:D8BE  58                  		ld	e,b	; Data buffer is in our own seg
     359:  00:D8BF  D9                  		exx
     360:  00:D8C0                      ;
     361:  00:D8C0  FD CB 00 7E         		bit	vars.trace.raw,(iy+vars._trace)
     362:  00:D8C4  28 9A               		jr	z,_read_FIFO
     363:  00:D8C6                      ;
     364:  00:D8C6  3E 48               		ld	a,'H'
     365:  00:D8C8  18 0B               		jr	rd_FIFO
     366:  00:D8CA                      ;
     367:  00:D8CA                      ;
     368:  00:D8CA                      read_FIFO_0:	SOCKET_GET_BASE_0
     368:  00:D8CA  11 00 02          >    ld de,0200h
     369:  00:D8CD  FD CB 00 7E         read_FIFO:	bit	vars.trace.raw,(iy+vars._trace)
     370:  00:D8D1  28 8D               		jr	z,_read_FIFO
     371:  00:D8D3                      ;
     372:  00:D8D3                      
     373:  00:D8D3  3E 52               		ld	a,'R'
     374:  00:D8D5  F5                  rd_FIFO:	push	af
     375:  00:D8D6  E5                  		push	hl	; Save regs so we can dump buffer later
     376:  00:D8D7  D5                  		push	de
     377:  00:D8D8  C5                  		push	bc
     378:  00:D8D9                      ;
     379:  00:D8D9  CD 60 D8            		 call	_read_FIFO
     380:  00:D8DC                      ;
     381:  00:D8DC  C1                  		pop	bc
     382:  00:D8DD  D1                  		pop	de			; Restore base reg
     383:  00:D8DE  E1                  		pop	hl
     384:  00:D8DF  F1                  		pop	af
     385:  00:D8E0                      ;
     386:  00:D8E0                      ; Here A contains the dump type (R or T, Receive or Transmit)
     387:  00:D8E0                      ; HL->buffer, BC=byte count
     388:  00:D8E0  FD CB 04 46         dump:		bit	0,(iy+vars._socket.flushing)	; Supress raw output
     389:  00:D8E4  C0                  		ret	nz
     390:  00:D8E5                      ;
     391:  00:D8E5  CD C3 CA            		call	exos.is_stop; Check BEFORE printing anything as this may
     392:  00:D8E8  D8                  		ret	c	;   get called several times after STOP
     393:  00:D8E9                      
     394:  00:D8E9  C5                  		push	bc
     395:  00:D8EA  D5                  		push	de
     396:  00:D8EB  E5                  		push	hl
     397:  00:D8EC                      ;
     398:  00:D8EC  F5                  		 push	af	; Start with new line but save dump type
     399:  00:D8ED  CD 1C D0            		  call	io.start
     400:  00:D8F0  F1                  		 pop	af
     401:  00:D8F1  CD F9 CF            		 call	io.char
     402:  00:D8F4                      ;
     403:  00:D8F4  7A                  		 ld	a,d	; Work out socket number from DE
     404:  00:D8F5  B3                  		 or	e	; Bit 0=socket(7),bits 6,7=socket(0,1)
     405:  00:D8F6  07                  		 rlca
     406:  00:D8F7  07                  		 rlca
     407:  00:D8F8  E6 07               		 and	7
     408:  00:D8FA  C6 30               		 add	a,'0'
     409:  00:D8FC  CD F9 CF            		 call	io.char	; Print socket number
     410:  00:D8FF  3E 3A               		 ld	a,':'
     411:  00:D901  CD F9 CF            		 call	io.char
     412:  00:D904                      ;
     413:  00:D904  D9                  		 exx
     414:  00:D905  7B                  		 ld	a,e		; Get segment
     415:  00:D906  D9                  		 exx
     416:  00:D907  CD E6 CF            		 call	io.byte
     417:  00:D90A  3E 3A               		 ld	a,':'
     418:  00:D90C  CD F9 CF            		 call	io.char
     419:  00:D90F  CD E1 CF            		 call	io.word	; Print address
     420:  00:D912  CD 2A D0            		 call	io.space
     421:  00:D915                      ;
     422:  00:D915                      		 ; If there are loads of bytes we only output a few and then
     423:  00:D915                      		 ; print +n at end of line. The max is chosen so the
     424:  00:D915                      		 ; dump and +n fit nicely on the screen depending on the
     425:  00:D915                      		 ; number of columns
     426:  00:D915  E5                  		 push	hl		; Save ->data
     427:  00:D916  69                  		  ld	l,c		; HL=number of bytes to dump
     428:  00:D917  60                  		  ld	h,b
     429:  00:D918  11 10 00            		  ld	de,16		; 16 bytes max on an 80 col screen
     430:  00:D91B  3A 09 40            		  ld	a,(vars.trace.cols)
     431:  00:D91E  FE 50               		  cp	80
     432:  00:D920  30 02               		  jr	nc,.gotcols
     433:  00:D922                      ;
     434:  00:D922  1E 08               		  ld	e,8		; 8 bytes max on a 40 col screen
     435:  00:D924  B7                  .gotcols:	  or	a
     436:  00:D925  ED 52               		  sbc	hl,de
     437:  00:D927  43                  		  ld	b,e		; B=max in case
     438:  00:D928  30 04               		  jr	nc,.ge		; Go if yes, HL=remaining, B=no.
     439:  00:D92A                      ;
     440:  00:D92A  21 00 00            		  ld	hl,0		; Otherwise no remaining
     441:  00:D92D  41                  		  ld	b,c		; B=no. to dump
     442:  00:D92E                      ;
     443:  00:D92E                      .ge:		  ; So now (SP)->buffer, B=no. bytes to dump, HL=remaining
     444:  00:D92E  E3                  		 ex	(sp),hl		; HL->buffer, (SP)=remaining
     445:  00:D92F  E5                  		  push	hl
     446:  00:D930  C5                  		  push	bc
     447:  00:D931  CD 5D D2            		   call	trace.dumpbytes
     448:  00:D934  C1                  		  pop	bc
     449:  00:D935  E1                  		  pop	hl
     450:  00:D936  38 09               		  jr	c,.stop
     451:  00:D938                      ;
     452:  00:D938                      		  ; Only output ASCII version of bytes if 80 col screen
     453:  00:D938  3A 09 40            		  ld	a,(vars.trace.cols)
     454:  00:D93B  FE 50               		  cp	80
     455:  00:D93D  3F                  		  ccf			; NC (=> not STOP) if <80
     456:  00:D93E  DC 75 D2            		  call	c,trace.dumpchars	; Returns C if STOP
     457:  00:D941  E1                  .stop:		 pop	hl		; HL=remaining words not dumped
     458:  00:D942                      ;
     459:  00:D942  38 0F               		 jr	c,.done		; Stop key pressed
     460:  00:D944                      ;
     461:  00:D944  7C                  		 ld	a,h
     462:  00:D945  B5                  		 or	l
     463:  00:D946  28 0B               		 jr	z,.done		; Don't print +n if n=0
     464:  00:D948                      ;
     465:  00:D948  3E 2B               		 ld	a,'+'
     466:  00:D94A  CD F9 CF            		 call	io.char
     467:  00:D94D  CD AA CF            		 call	io.int
     468:  00:D950  CD 21 D0            		 call	io.crlf
     469:  00:D953                      ;
     470:  00:D953  E1                  .done:		pop	hl
     471:  00:D954  D1                  		pop	de
     472:  00:D955  C1                  		pop	bc
     473:  00:D956                      ;
     474:  00:D956  C9                  		ret
     475:  00:D957                      ;
     476:  00:D957                      ;
     477:  00:D957                      ;------------------------------------------------------------------------------
     478:  00:D957                      ; write_FIFO
     479:  00:D957                      ;
     480:  00:D957                      ; Writes the WIZ FIFO from a memory buffer
     481:  00:D957                      ;
     482:  00:D957                      ; In: E':HL ->block
     483:  00:D957                      ;        BC =byte count
     484:  00:D957                      ;        DE =reg base
     485:  00:D957                      ;         C'->P1
     486:  00:D957                      ;         B'=our seg
     487:  00:D957                      ; Out:   DE preserved.
     488:  00:D957                      ;        All othermain registers corrupted
     489:  00:D957                      ;
     490:  00:D957  D5                  write_FIFO:	push	de
     491:  00:D958                      ;
     492:  00:D958  3E 54               		ld	a,'T'
     493:  00:D95A  FD CB 00 7E         		bit	vars.trace.raw,(iy+vars._trace)
     494:  00:D95E  C4 E0 D8            		call	nz,dump
     495:  00:D961                      ;
     496:  00:D961  CD 8D D8            		call	_write_FIFO
     497:  00:D964                      ;
     498:  00:D964  D1                  		pop	de
     499:  00:D965  C9                  		ret
     500:  00:D966                      ;
     501:  00:D966                      ;
     502:  00:D966                      ;------------------------------------------------------------------------------
     503:  00:D966                      ; tomask
     504:  00:D966                      ;
     505:  00:D966                      ; Converts a socket number in A (not socket base!) to a bit mask 01h, 02h etc
     506:  00:D966  21 70 D9            tomask:		ld	hl,masktab
     507:  00:D969  85                  		add	a,l
     508:  00:D96A  6F                  		ld	l,a
     509:  00:D96B  7E                  		ld	a,(hl)
     510:  00:D96C  C9                  		ret
     511:  00:D96D                      ;
     512:  00:D96D  (0003)              		align	8
     513:  00:D970                      masktab:	db	01h,02h,04h,08h,10h,20h,40h,80h
     513:  00:D970  01 02 04 08 10 20 40 80 
     514:  00:D978                      ;
     515:  00:D978                      ;
     516:  00:D978                      ;
     517:  00:D978                      ;------------------------------------------------------------------------------
     518:  00:D978                      ; open
     519:  00:D978                      ;
     520:  00:D978                      ; opens a WIZ socket.
     521:  00:D978                      ;
     522:  00:D978                      ; For TCP mode, SnDIPR and SnDPORTR must already be set up.
     523:  00:D978                      ;
     524:  00:D978                      ; The WIZ Sn_MR mode register needs different values for different modes.
     525:  00:D978                      ; Similarly once the open command has been issued different responses are
     526:  00:D978                      ; expected in SnSSR, as follows:
     527:  00:D978                      ;
     528:  00:D978                      ; Mode:    UDP        TCP         IPRAW
     529:  00:D978                      ; -------------------------------------------
     530:  00:D978                      ; Sn_MR:   Sn_MR_UDP  Sn_MR_TCP   Sn_MR_IPRAW
     531:  00:D978                      ; Sn_SSR:  Sn_SSR_UDP Sn_SSR_INIT Sn_SSR_IPRAW
     532:  00:D978                      ;
     533:  00:D978                      ; These values are passed in BC
     534:  00:D978                      ;
     535:  00:D978                      ; In:   A= socket number
     536:  00:D978                      ;       B= Sn_MR_UDP  or Sn_MR_TCP   as appropriate (see above)
     537:  00:D978                      ;       C= Sn_SSR_UDP or Sn_SSR_INIT as appropriate (see above)
     538:  00:D978                      ;      HL= our (source) port number
     539:  00:D978                      ;      DE->owner string
     540:  00:D978                      ; Out: Carry set if error
     541:  00:D978                      ;
     542:  00:D978                      open:
     543:  00:D978  FD CB 04 86         		res	0,(iy+vars._socket.flushing)	; Stop supress raw output
     544:  00:D97C                      ;
     545:  00:D97C  FD CB 00 4E         		bit	vars.trace.socket,(iy+vars._trace)
     546:  00:D980  28 45               		jr	z,.tracedone
     547:  00:D982                      ;
     548:  00:D982  F5                  		push	af			; Save socket number
     549:  00:D983  C5                  		push	bc			; Save Sn_ values
     550:  00:D984  E5                  		push	hl			; Save port number
     551:  00:D985                      ;
     552:  00:D985  D5                  		 push	de			; Save owner string
     553:  00:D986  11 AD D3            		  ld	de,trace.socket.open	; "  :Open "
     554:  00:D989  C5                  		  push	bc
     555:  00:D98A  CD 28 DE            		   call	trace_msg		; "Sn"
     556:  00:D98D  C1                  		  pop	bc
     557:  00:D98E                      ;
     558:  00:D98E  78                  		  ld	a,b
     559:  00:D98F  E6 0F               		  and	0fh
     560:  00:D991  11 B3 D3            		  ld	de,trace.socket.udp	;         "UDP"
     561:  00:D994  FE 02               		  cp	w5300.Sn_MR_UDP
     562:  00:D996  28 11               		  jr	z,.protocol
     563:  00:D998                      ;
     564:  00:D998  11 B7 D3            		  ld	de,trace.socket.ipraw	;         "IP"
     565:  00:D99B  FE 03               		  cp	w5300.Sn_MR_IPRAW
     566:  00:D99D  28 0A               		  jr	z,.protocol
     567:  00:D99F                      ;
     568:  00:D99F  11 BA D3            		  ld	de,trace.socket.tcp	;         "TCP"
     569:  00:D9A2  FE 01               		  cp	w5300.Sn_MR_TCP
     570:  00:D9A4  28 03               		  jr	z,.protocol
     571:  00:D9A6                      ;
     572:  00:D9A6  11 BE D3            		  ld	de,trace.socket.unknown	;         "UNKNOWN"
     573:  00:D9A9  CD 36 D0            .protocol:	  call	io.str
     574:  00:D9AC                      ;
     575:  00:D9AC  11 C2 D3            		  ld	de,trace.socket.port	; 	         " port "
     576:  00:D9AF  CD 36 D0            		  call	io.str
     577:  00:D9B2                      ;
     578:  00:D9B2  CD AA CF            		  call	io.int			; Print port
     579:  00:D9B5                      
     580:  00:D9B5  11 C9 D3            		  ld	de,trace.socket.by	;                        " by "
     581:  00:D9B8  CD 36 D0            		  call	io.str
     582:  00:D9BB  D1                  		 pop	de			; DE->owner
     583:  00:D9BC                      ;
     584:  00:D9BC  D5                  		 push	de			; Save owner
     585:  00:D9BD  CD 36 D0            		  call	io.str			; Print ownser
     586:  00:D9C0  CD 36 D2            		  call	trace.dots
     587:  00:D9C3  D1                  		 pop	de
     588:  00:D9C4                      ;
     589:  00:D9C4  E1                  		pop	hl
     590:  00:D9C5  C1                  		pop	bc			; BC=Sn_xxx values
     591:  00:D9C6  F1                  		pop	af			; A=socket number
     592:  00:D9C7                      .tracedone:
     593:  00:D9C7                      ;
     594:  00:D9C7  E5                  		push	hl
     595:  00:D9C8  C5                  		push	bc
     596:  00:D9C9  D5                  		 push	de			; Save owner string
     597:  00:D9CA                      		  SOCKET_GET_BASE
     597:  00:D9CA  11 00 01          >    ld de,0100h
     597:  00:D9CD  0F                >    rrca
     597:  00:D9CE  CB 1B             >    rr e
     597:  00:D9D0  0F                >    rrca
     597:  00:D9D1  CB 1B             >    rr e
     597:  00:D9D3  0F                >    rrca
     597:  00:D9D4  CB 12             >    rl d
     598:  00:D9D6                      ;
     599:  00:D9D6                      		  SOCKET_GET_VAR 0		; HL->socket memory
     599:  00:D9D6                    >    if (var)=0
     599:  00:D9D6  7B                >     ld a,e
     599:  00:D9D7                    >    else
     599:  00:D9D7                    ~     ld a,(var)*2
     599:  00:D9D7                    ~     or e
     599:  00:D9D7                    ~    endif
     599:  00:D9D7  6F                >    ld l,a
     599:  00:D9D8  7A                >    ld a,d
     599:  00:D9D9  0F                >    rrca
     599:  00:D9DA  CB 1D             >    rr l
     599:  00:D9DC  26 42             >    ld h,high vars.sockets
     600:  00:D9DE  01 20 00             		  ld	bc,vars.socket_size	; BC=size of socket memory
     601:  00:D9E1  D5                  		  push	de
     602:  00:D9E2  CD 20 D1            		   call	util.memzero		; Initialise socket memory to 0
     603:  00:D9E5  D1                  		  pop	de
     604:  00:D9E6  E1                  		 pop	hl			; HL->owner string
     605:  00:D9E7  3E 00               		 ld	a,vars.owner
     606:  00:D9E9  CD EA DD            		 call	set_word
     607:  00:D9EC  C1                  		pop	bc
     608:  00:D9ED  E1                  		pop	hl
     609:  00:D9EE                      ;
     610:  00:D9EE  C5                  		push	bc			; Save command & status values
     611:  00:D9EF  3E 0A               		 ld	a,w5300.Sn_PORTR
     612:  00:D9F1  CD 50 D8            		 call	write_reg		; Set port number
     613:  00:D9F4  C1                  		pop	bc			; BC=command & status values
     614:  00:D9F5                      ;
     615:  00:D9F5  C5                  		push	bc
     616:  00:D9F6  3E 00               		 ld	a,w5300.Sn_MR
     617:  00:D9F8  68                  		 ld	l,b
     618:  00:D9F9  26 00               		 ld	h,0			; HL=command register value
     619:  00:D9FB  CD 50 D8            		 call	write_reg		; Set mode
     620:  00:D9FE  C1                  		pop	bc			; C=expected status
     621:  00:D9FF                      ;
     622:  00:D9FF  21 01 00            		ld	hl,w5300.Sn_CR_OPEN	; Issue open command
     623:  00:DA02  CD 7F DA            		call	write_CR
     624:  00:DA05  30 09               		jr	nc,.ok
     625:  00:DA07                      ;
     626:  00:DA07  21 10 00            		ld	hl,w5300.Sn_CR_CLOSE	; Error - make sure it's closed
     627:  00:DA0A  0E 00               		ld	c,w5300.Sn_SSR_CLOSED
     628:  00:DA0C  CD 7F DA            		call	write_CR
     629:  00:DA0F  37                  		scf
     630:  00:DA10                      ;
     631:  00:DA10  FD CB 00 4E         .ok:		bit	vars.trace.socket,(iy+vars._trace)
     632:  00:DA14  C8                  		ret	z
     633:  00:DA15                      ;
     634:  00:DA15  C3 3C D2            		jp	trace.is_timeout
     635:  00:DA18                      ;
     636:  00:DA18                      ;
     637:  00:DA18                      ;------------------------------------------------------------------------------
     638:  00:DA18                      ; connect
     639:  00:DA18                      ;
     640:  00:DA18                      ; This is called after open for a TCP socket, and it puts the socket in client
     641:  00:DA18                      ; TCP mode ie attempts to open a TCP/IP socket with a server
     642:  00:DA18                      ;
     643:  00:DA18                      ; This routine is really only for the TCP module - other users should call
     644:  00:DA18                      ; tcp.connect.
     645:  00:DA18                      ;
     646:  00:DA18                      ; In:   A=socket number
     647:  00:DA18                      ;      HL=dest (server) port no
     648:  00:DA18                      ;      DE->dest (server) IP address
     649:  00:DA18                      ; Out: Cy=>error
     650:  00:DA18                      ;
     651:  00:DA18                      connect:
     652:  00:DA18  FD CB 00 4E         		bit	vars.trace.socket,(iy+vars._trace)
     653:  00:DA1C  28 16               		jr	z,.tracedone
     654:  00:DA1E                      ;
     655:  00:DA1E  F5                  		push	af		; Save socket number
     656:  00:DA1F  E5                  		push	hl		; Save port no
     657:  00:DA20  D5                  		push	de		; Save ->IP address
     658:  00:DA21  11 8A D3            		 ld	de,trace.socket.connect	; "  :Connect to "
     659:  00:DA24  CD 28 DE            		 call	trace_msg			; "Sn"
     660:  00:DA27  4D                  		 ld	c,l
     661:  00:DA28  44                  		 ld	b,h		; BC=port number
     662:  00:DA29  E1                  		pop	hl		; HL->IP address
     663:  00:DA2A  E5                  		push	hl		; Save ->IP address
     664:  00:DA2B  CD 9B CF            		 call	io.ip_port
     665:  00:DA2E  CD 36 D2            		 call	trace.dots
     666:  00:DA31  D1                  		pop	de		; DE->IP address
     667:  00:DA32  E1                  		pop	hl		; HL=port no
     668:  00:DA33  F1                  		pop	af		; A=socket number
     669:  00:DA34                      ;
     670:  00:DA34                      .tracedone:
     671:  00:DA34  E5                  		push	hl		; Save our port no.
     672:  00:DA35  EB                  		 ex	de,hl		; HL->IP adress
     673:  00:DA36  CD F4 DB            		 call	write_DIPR	; Write dest IP address, DE=reg base
     674:  00:DA39  E1                  		pop	hl		; HL=dest port no
     675:  00:DA3A                      ;
     676:  00:DA3A  CD 13 DC            		call	write_DPORTR	; Write dest port no.
     677:  00:DA3D                      ;
     678:  00:DA3D  21 04 00            		ld	hl,w5300.Sn_CR_CONNECT	; Issue connect command
     679:  00:DA40  0E 17               		ld	c,w5300.Sn_SSR_ESTAB
     680:  00:DA42  CD 7F DA            		call	write_CR
     681:  00:DA45  38 00               		jr	c,.error	; Go if error occured
     682:  00:DA47                      ;
     683:  00:DA47  FD CB 00 4E         .error:		bit	vars.trace.socket,(iy+vars._trace)
     684:  00:DA4B  C8                  		ret	z
     685:  00:DA4C                      
     686:  00:DA4C  D5                  		push	de		; Save socket reg base
     687:  00:DA4D  CD 3E D2            		call	 trace.is_error
     688:  00:DA50  D1                  		pop	de
     689:  00:DA51  C9                  		ret
     690:  00:DA52                      ;
     691:  00:DA52                      ;
     692:  00:DA52                      ;------------------------------------------------------------------------------
     693:  00:DA52                      ; disconnect
     694:  00:DA52                      ;
     695:  00:DA52                      ; In TCP mode this disconnects the TCP/IP link with the remote party.
     696:  00:DA52                      ;
     697:  00:DA52                      ; This routine is really only for the TCP module - other users should call
     698:  00:DA52                      ; tcp.disconnect.
     699:  00:DA52                      ;
     700:  00:DA52                      ; Unlike for the other protocols, if the WIZ socket is in TCP mode we must
     701:  00:DA52                      ; disconnect before closing. If we don't, the WIZ socket is closed but the
     702:  00:DA52                      ; TCP connection remains open (but unusable)!
     703:  00:DA52                      ;
     704:  00:DA52                      ; In:  A=socket no.
     705:  00:DA52                      ;
     706:  00:DA52                      disconnect:
     707:  00:DA52                      		SOCKET_GET_BASE
     707:  00:DA52  11 00 01          >    ld de,0100h
     707:  00:DA55  0F                >    rrca
     707:  00:DA56  CB 1B             >    rr e
     707:  00:DA58  0F                >    rrca
     707:  00:DA59  CB 1B             >    rr e
     707:  00:DA5B  0F                >    rrca
     707:  00:DA5C  CB 12             >    rl d
     708:  00:DA5E                      ;
     709:  00:DA5E                      _disconnect:
     710:  00:DA5E  FD CB 00 4E         		bit	vars.trace.socket,(iy+vars._trace)
     711:  00:DA62  28 0B               		jr	z,.donetrace
     712:  00:DA64                      ;
     713:  00:DA64  D5                  		push	de
     714:  00:DA65  CD 3C DE            		 call	_trace
     715:  00:DA68                      ;
     716:  00:DA68  11 96 D3            		 ld	de,trace.socket.disconnect
     717:  00:DA6B  CD 36 D0            		 call	io.str
     718:  00:DA6E  D1                  		pop	de
     719:  00:DA6F                      .donetrace:		
     720:  00:DA6F                      ;
     721:  00:DA6F  21 08 00            		ld	hl,w5300.Sn_CR_DISCON	; HL=Disconnect command
     722:  00:DA72                      ;		ld	c,w5300.Sn_SSR_CLOSED	; C=expected response
     723:  00:DA72  0E 18               		ld	c,w5300.Sn_SSR_FIN_WAIT	; C=expected response
     724:  00:DA74  CD 7F DA            		call	write_CR		; Send Disc
     725:  00:DA77                      ;
     726:  00:DA77  FD CB 00 4E         .donedisc:	bit	vars.trace.socket,(iy+vars._trace)
     727:  00:DA7B  C8                  		ret	z			; Return if not tracing
     728:  00:DA7C                      
     729:  00:DA7C  C3 3E D2            		jp	trace.is_error		; Else print ok/error
     730:  00:DA7F                      ;
     731:  00:DA7F                      ;
     732:  00:DA7F                      ;------------------------------------------------------------------------------
     733:  00:DA7F                      ; write_CR
     734:  00:DA7F                      ;
     735:  00:DA7F                      ; Writes to the socket's CR register and waits for the expected response
     736:  00:DA7F                      ;
     737:  00:DA7F                      ; In:  HL=Sn_CR_xxx command to write
     738:  00:DA7F                      ;      DE=WIZ socket base register
     739:  00:DA7F                      ;      C=Sn_SSR_xxx expected status response
     740:  00:DA7F                      ; Out: C=>timeout waiting for w5300
     741:  00:DA7F                      ;
     742:  00:DA7F                      write_CR:
     743:  00:DA7F  C5                  		push	bc		; Save expected response in C
     744:  00:DA80  3E 02               		 ld	a,w5300.Sn_CR
     745:  00:DA82  CD 50 D8            		 call	write_reg	; Write command
     746:  00:DA85  C1                  		pop	bc		; C=expected response
     747:  00:DA86                      ;
     748:  00:DA86  C5                  .loop:		push	bc		; Save expected response
     749:  00:DA87  3E 08               		 ld	a,w5300.Sn_SSR
     750:  00:DA89  CD 40 D8            		 call	read_reg
     751:  00:DA8C  C1                  		pop	bc		; C=expected response
     752:  00:DA8D  7D                  		ld	a,l
     753:  00:DA8E                      ;
     754:  00:DA8E  B9                  		cp	c
     755:  00:DA8F  C8                  		ret	z		; SSR as expectd, NC
     756:  00:DA90                      ;
     757:  00:DA90  FE 00               		cp	w5300.Sn_SSR_CLOSED	; See if socket has closed
     758:  00:DA92  20 06               		jr	nz,.wait	; Keep waiting if not
     759:  00:DA94                      ;
     760:  00:DA94  79                  		ld	a,c		; A=expected state
     761:  00:DA95  FE 18               		cp	w5300.Sn_SSR_FIN_WAIT	; Closed also ok!
     762:  00:DA97  C8                  		ret	z
     763:  00:DA98                      ;
     764:  00:DA98  37                  		scf			; If it's closed it'll never change!
     765:  00:DA99  C9                  		ret
     766:  00:DA9A                      
     767:  00:DA9A  CD C3 D0            .wait:		call	status.waiting	; Flash status line waiting indicator
     768:  00:DA9D                      ;
     769:  00:DA9D  CD C3 CA            		call	exos.is_stop	; See if stop key pressed
     770:  00:DAA0  D8                  		ret	c		; Ret with C if yes
     771:  00:DAA1                      ;	
     772:  00:DAA1  18 E3               		jr	.loop		; Wait a bit longer
     773:  00:DAA3                      ;
     774:  00:DAA3                      ;
     775:  00:DAA3                      ;------------------------------------------------------------------------------
     776:  00:DAA3                      ; available
     777:  00:DAA3                      ;
     778:  00:DAA3                      ; Returns the number of bytes available to read on an open socket
     779:  00:DAA3                      ;
     780:  00:DAA3                      ; In:  A=socket number
     781:  00:DAA3                      ; Out: HL=number of bytes available to read
     782:  00:DAA3                      ;      DE=socket base reg
     783:  00:DAA3                      ;       Z set according to HL
     784:  00:DAA3                      ;
     785:  00:DAA3  AF                  available_0:	xor	a
     786:  00:DAA4                      available:	SOCKET_GET_BASE
     786:  00:DAA4  11 00 01          >    ld de,0100h
     786:  00:DAA7  0F                >    rrca
     786:  00:DAA8  CB 1B             >    rr e
     786:  00:DAAA  0F                >    rrca
     786:  00:DAAB  CB 1B             >    rr e
     786:  00:DAAD  0F                >    rrca
     786:  00:DAAE  CB 12             >    rl d
     787:  00:DAB0                      ;
     788:  00:DAB0                      		; Just read Sn_RX_RSR. We don't check the high word because we
     789:  00:DAB0                      		; have configured the RX memory to be 8k so larger packets
     790:  00:DAB0                      		; amounts cannot be received
     791:  00:DAB0  3E 2A               _available:	ld	a,w5300.Sn_RX_RSR2
     792:  00:DAB2  CD 40 D8            		call	read_reg
     793:  00:DAB5                      ;
     794:  00:DAB5  7C                  		ld	a,h
     795:  00:DAB6  B5                  		or	l
     796:  00:DAB7  C9                  		ret			; Return with Z set appropriately
     797:  00:DAB8                      ;
     798:  00:DAB8                      ;
     799:  00:DAB8                      ;------------------------------------------------------------------------------
     800:  00:DAB8                      ; is_closed
     801:  00:DAB8                      ;
     802:  00:DAB8                      ; Sees if a socket has been closed. 
     803:  00:DAB8                      ;
     804:  00:DAB8                      ; In:  A=socket number
     805:  00:DAB8                      ; Out: Z if socket has been closed
     806:  00:DAB8                      ;
     807:  00:DAB8                      is_closed:	SOCKET_GET_BASE
     807:  00:DAB8  11 00 01          >    ld de,0100h
     807:  00:DABB  0F                >    rrca
     807:  00:DABC  CB 1B             >    rr e
     807:  00:DABE  0F                >    rrca
     807:  00:DABF  CB 1B             >    rr e
     807:  00:DAC1  0F                >    rrca
     807:  00:DAC2  CB 12             >    rl d
     808:  00:DAC4                      ;
     809:  00:DAC4                      _is_closed:	
     810:  00:DAC4  3E 08               		ld	a,w5300.Sn_SSR
     811:  00:DAC6  CD 40 D8            		call	read_reg
     812:  00:DAC9  7D                  		ld	a,l
     813:  00:DACA                      ;
     814:  00:DACA  FE 00               		cp	w5300.Sn_SSR_CLOSED	; Socket has closed
     815:  00:DACC  C8                  		ret	z
     816:  00:DACD                      ;
     817:  00:DACD  FE 1C               		cp	w5300.Sn_SSR_WAIT	; FIN received from other end
     818:  00:DACF  C8                  		ret	z
     819:  00:DAD0                      ;
     820:  00:DAD0  FE 18               		cp	w5300.Sn_SSR_FIN_WAIT	; In closing state
     821:  00:DAD2  C8                  		ret	z
     822:  00:DAD3                      ;
     823:  00:DAD3  FE 1B               		cp	w5300.Sn_SSR_TIME_WAIT	; In closing state
     824:  00:DAD5  C8                  		ret	z
     825:  00:DAD6                      ;
     826:  00:DAD6  FE 1D               		cp	w5300.Sn_SSR_LAST_ACK	; In closing state
     827:  00:DAD8  C9                  		ret
     828:  00:DAD9                      ;
     829:  00:DAD9                      ;
     830:  00:DAD9                      ;
     831:  00:DAD9                      ;------------------------------------------------------------------------------
     832:  00:DAD9                      ; read
     833:  00:DAD9                      ;
     834:  00:DAD9                      ; Reads from an open socket.
     835:  00:DAD9                      ;
     836:  00:DAD9                      ; read and _read are only called to read into our own buffer, so set up
     837:  00:DAD9                      ; the paging for read_FIFO appropriately. _readx is called from the EXOS
     838:  00:DAD9                      ; devices to read into user's memory, so set up E' before calling.
     839:  00:DAD9                      ;
     840:  00:DAD9                      ; We can only read words from the WIZ chip, not bytes, so to read the last
     841:  00:DAD9                      ; byte of an odd-length packet we read the last byte and a dummy byte. We
     842:  00:DAD9                      ; return Cy here if that is the case.
     843:  00:DAD9                      ;
     844:  00:DAD9                      ; In:   A=socket number
     845:  00:DAD9                      ;      HL->bufer for data
     846:  00:DAD9                      ;      BC=number of bytes to read
     847:  00:DAD9                      ; Out: C=>we've read last byte
     848:  00:DAD9                      ;      HL->rx_size
     849:  00:DAD9                      ;      DE=socket base register
     850:  00:DAD9                      ;
     851:  00:DAD9  AF                  read_0		xor	a
     852:  00:DADA                      read:		SOCKET_GET_BASE
     852:  00:DADA  11 00 01          >    ld de,0100h
     852:  00:DADD  0F                >    rrca
     852:  00:DADE  CB 1B             >    rr e
     852:  00:DAE0  0F                >    rrca
     852:  00:DAE1  CB 1B             >    rr e
     852:  00:DAE3  0F                >    rrca
     852:  00:DAE4  CB 12             >    rl d
     853:  00:DAE6                      ;
     854:  00:DAE6  D9                  _read:		exx
     855:  00:DAE7  58                  		ld	e,b		; Use our seg
     856:  00:DAE8  D9                  		exx
     857:  00:DAE9                      ;
     858:  00:DAE9                      _readx:		; E' must be set to page for buffer
     859:  00:DAE9  C5                  		push	bc
     860:  00:DAEA  03                  		 inc	bc		; Round up to even number
     861:  00:DAEB  CB 81               		 res	0,c
     862:  00:DAED  78                  		 ld	a,b
     863:  00:DAEE  B1                  		 or	c
     864:  00:DAEF  D5                  		 push	de
     865:  00:DAF0  C4 CD D8            		  call	nz,read_FIFO	; Read data
     866:  00:DAF3  D1                  		 pop	de
     867:  00:DAF4  C1                  		pop	bc		; BC=bye count
     868:  00:DAF5                      
     869:  00:DAF5                      		; Update size remaining
     870:  00:DAF5                      		SOCKET_GET_VAR	vars.rx_size	; HL->rx_size
     870:  00:DAF5                    >    if (var)=0
     870:  00:DAF5                    ~     ld a,e
     870:  00:DAF5                    ~    else
     870:  00:DAF5  3E 06             >     ld a,(var)*2
     870:  00:DAF7  B3                >     or e
     870:  00:DAF8                    >    endif
     870:  00:DAF8  6F                >    ld l,a
     870:  00:DAF9  7A                >    ld a,d
     870:  00:DAFA  0F                >    rrca
     870:  00:DAFB  CB 1D             >    rr l
     870:  00:DAFD  26 42             >    ld h,high vars.sockets
     871:  00:DAFF                      ;
     872:  00:DAFF  7E                  		ld	a,(hl)		; rx_size -= BC
     873:  00:DB00  91                  		sub	c
     874:  00:DB01  77                  		ld	(hl),a
     875:  00:DB02  23                  		inc	hl
     876:  00:DB03                      ;
     877:  00:DB03  7E                  		ld	a,(hl)
     878:  00:DB04  98                  		sbc	a,b
     879:  00:DB05  77                  		ld	(hl),a
     880:  00:DB06  30 06               		jr	nc,.donesize	; Go with NC if not gone -ve
     881:  00:DB08                      ;
     882:  00:DB08                      		; This can happen if it's an odd-sized packet eg. we read the
     883:  00:DB08                      		; last word (because we can only read words) but it is in fact
     884:  00:DB08                      		; just a single byte because there's only one byte remaining
     885:  00:DB08                      		; unread in the packet
     886:  00:DB08  AF                  		xor	a		; zero rx_size
     887:  00:DB09  77                  		ld	(hl),a
     888:  00:DB0A  2B                  		dec	hl
     889:  00:DB0B  77                  		ld	(hl),a
     890:  00:DB0C  23                  		inc	hl
     891:  00:DB0D  37                  		scf			; Cy=>read end
     892:  00:DB0E  2B                  .donesize:	dec	hl		; HL->first byte of rx_size
     893:  00:DB0F                      ;
     894:  00:DB0F  C9                  		ret
     895:  00:DB10                      ;
     896:  00:DB10                      ;
     897:  00:DB10                      ;------------------------------------------------------------------------------
     898:  00:DB10                      ; read_byte
     899:  00:DB10                      ;
     900:  00:DB10                      ; This is a byte-by-byte read interface to a WIZ socket - a bit tricky
     901:  00:DB10                      ; because of the word-by-word nature of the WIZ interface
     902:  00:DB10                      ;
     903:  00:DB10                      ; In:  A=socket number
     904:  00:DB10                      ; Out: A=byte read
     905:  00:DB10                      ;      HL,DE,BC preserved
     906:  00:DB10                      ;      C=>no bytes were read
     907:  00:DB10                      ;
     908:  00:DB10  AF                  read_byte_0:	xor	a
     909:  00:DB11  D5                  read_byte:	push	de
     910:  00:DB12  E5                  		push	hl
     911:  00:DB13                      ;
     912:  00:DB13                      		 SOCKET_GET_BASE
     912:  00:DB13  11 00 01          >    ld de,0100h
     912:  00:DB16  0F                >    rrca
     912:  00:DB17  CB 1B             >    rr e
     912:  00:DB19  0F                >    rrca
     912:  00:DB1A  CB 1B             >    rr e
     912:  00:DB1C  0F                >    rrca
     912:  00:DB1D  CB 12             >    rl d
     913:  00:DB1F                      ;
     914:  00:DB1F                      		 SOCKET_GET_VAR vars.rx_inhand	; HL->rx_inhand
     914:  00:DB1F                    >    if (var)=0
     914:  00:DB1F                    ~     ld a,e
     914:  00:DB1F                    ~    else
     914:  00:DB1F  3E 0A             >     ld a,(var)*2
     914:  00:DB21  B3                >     or e
     914:  00:DB22                    >    endif
     914:  00:DB22  6F                >    ld l,a
     914:  00:DB23  7A                >    ld a,d
     914:  00:DB24  0F                >    rrca
     914:  00:DB25  CB 1D             >    rr l
     914:  00:DB27  26 42             >    ld h,high vars.sockets
     915:  00:DB29                      ;
     916:  00:DB29  7E                  		 ld	a,(hl)		; FF=>buffered byte, 0=>none
     917:  00:DB2A  3C                  		 inc	a
     918:  00:DB2B  20 05               		 jr	nz,.notgot
     919:  00:DB2D                      ;
     920:  00:DB2D  77                  		 ld	(hl),a		; 0=>no buffered byte anymore
     921:  00:DB2E  23                  		 inc	hl
     922:  00:DB2F  7E                  		 ld	a,(hl)		; Get byte
     923:  00:DB30  18 23               		 jr	.okret
     924:  00:DB32                      ;
     925:  00:DB32  3E 03               .notgot:	 ld	a,vars.rx_size
     926:  00:DB34  CD 0A DE            		 call	get_word
     927:  00:DB37  7C                  		 ld	a,h
     928:  00:DB38  B5                  		 or	l
     929:  00:DB39  37                  		 scf			; C=>nothing left to read
     930:  00:DB3A  28 1A               		 jr	z,.ret		; Byte count=0=>nothing left to read
     931:  00:DB3C                      ;
     932:  00:DB3C  C5                  		 push	bc
     933:  00:DB3D                      ;
     934:  00:DB3D                      		  SOCKET_GET_VAR vars.rx_inhand	; HL->rx_inhand
     934:  00:DB3D                    >    if (var)=0
     934:  00:DB3D                    ~     ld a,e
     934:  00:DB3D                    ~    else
     934:  00:DB3D  3E 0A             >     ld a,(var)*2
     934:  00:DB3F  B3                >     or e
     934:  00:DB40                    >    endif
     934:  00:DB40  6F                >    ld l,a
     934:  00:DB41  7A                >    ld a,d
     934:  00:DB42  0F                >    rrca
     934:  00:DB43  CB 1D             >    rr l
     934:  00:DB45  26 42             >    ld h,high vars.sockets
     935:  00:DB47                      ;
     936:  00:DB47  E5                  		  push	hl
     937:  00:DB48  01 02 00            		   ld	bc,2
     938:  00:DB4B  CD E6 DA            		   call	_read		; Read 2 bytes to rx_inhand
     939:  00:DB4E  E1                  		  pop	hl
     940:  00:DB4F  7E                  		  ld	a,(hl)		; Get first byte read
     941:  00:DB50  38 02               		  jr	c,.got1		; Go if only 1 byte was left to read
     942:  00:DB52                      ;
     943:  00:DB52  36 FF               		  ld	(hl),0ffh	; Else ff=>byte buffered in following
     944:  00:DB54  C1                  .got1:		 pop	bc
     945:  00:DB55  B7                  .okret:		 or	a		; NC=>not end of packet
     946:  00:DB56  E1                  .ret:		pop	hl
     947:  00:DB57  D1                  		pop	de
     948:  00:DB58  C9                  		ret
     949:  00:DB59                      ;
     950:  00:DB59                      ;
     951:  00:DB59                      ;------------------------------------------------------------------------------
     952:  00:DB59                      ; read_flush
     953:  00:DB59                      ;
     954:  00:DB59                      ; The WIZ chip needs you to read every byte in the current packet, even if you
     955:  00:DB59                      ; don't actually want it. Or you can close the socket, but then you don't get
     956:  00:DB59                      ; any following packets.
     957:  00:DB59                      ;
     958:  00:DB59                      ; In:   A=socket number
     959:  00:DB59                      ; Out: DE=socket base register
     960:  00:DB59                      ;
     961:  00:DB59  AF                  read_flush_0:	xor	a
     962:  00:DB5A                      read_flush:	SOCKET_GET_BASE
     962:  00:DB5A  11 00 01          >    ld de,0100h
     962:  00:DB5D  0F                >    rrca
     962:  00:DB5E  CB 1B             >    rr e
     962:  00:DB60  0F                >    rrca
     962:  00:DB61  CB 1B             >    rr e
     962:  00:DB63  0F                >    rrca
     962:  00:DB64  CB 12             >    rl d
     963:  00:DB66                      
     964:  00:DB66  FD CB 04 C6         _read_flush:	set	0,(iy+vars._socket.flushing)	; Supress raw output
     965:  00:DB6A                      ;
     966:  00:DB6A  3E 03               		ld	a,vars.rx_size
     967:  00:DB6C  CD 0A DE            		call	get_word	; HL=no.bytes remaining
     968:  00:DB6F                      ;
     969:  00:DB6F  23                  		inc	hl		; Convert to even making sure we catch
     970:  00:DB70  CB 85               		res	0,l		;   odd byte at end of odd length packets
     971:  00:DB72                      ;
     972:  00:DB72                      .loop:		; In this loop HL=total # bytes to read (even!)
     973:  00:DB72                      		; We read in chunks into the DHCP packet buffer
     974:  00:DB72  7C                  		ld	a,h
     975:  00:DB73  B5                  		or	l
     976:  00:DB74  28 1D               		jr	z,.done		; No more to read
     977:  00:DB76                      ;		
     978:  00:DB76  01 2C 00            		ld	bc,vars.dhcp.packet_size	; BC=buffer size (even!)
     979:  00:DB79  B7                  		or	a
     980:  00:DB7A  ED 42               		sbc	hl,bc		; HL=remainder after read
     981:  00:DB7C  30 06               		jr	nc,.sizeok	; Go if still more after this read
     982:  00:DB7E                      ;
     983:  00:DB7E  09                  		add	hl,bc		; Else get back original size
     984:  00:DB7F  4D                  		ld	c,l
     985:  00:DB80  44                  		ld	b,h		; BC=amount to read this time
     986:  00:DB81  B7                  		or	a
     987:  00:DB82  ED 62               		sbc	hl,hl		; HL=amount to read next time (0)
     988:  00:DB84  E5                  .sizeok:	push	hl		; Save amount to read next time
     989:  00:DB85  21 00 43            		 ld	hl,vars.dhcp.packet	; Buffer to read to
     990:  00:DB88  D9                  		 exx
     991:  00:DB89  58                  		 ld	e,b		; Use our segment
     992:  00:DB8A  D9                  		 exx
     993:  00:DB8B  D5                  		 push	de
     994:  00:DB8C  CD CD D8            		  call	read_FIFO
     995:  00:DB8F  D1                  		 pop	de
     996:  00:DB90  E1                  		pop	hl		; HL=amount for next read
     997:  00:DB91  18 DF               		jr	.loop
     998:  00:DB93                      ;
     999:  00:DB93  FD CB 04 86         .done:		res	0,(iy+vars._socket.flushing)	; Stop supress raw output
    1000:  00:DB97                      ;
    1001:  00:DB97  3E 05               		ld	a,vars.rx_inhand
    1002:  00:DB99  B7                  		or	a
    1003:  00:DB9A  ED 62               		sbc	hl,hl			; HL=0
    1004:  00:DB9C  CD EA DD            		call	set_word		; No buffered byte
    1005:  00:DB9F                      ;
    1006:  00:DB9F  3E 03               		ld	a,vars.rx_size
    1007:  00:DBA1  B7                  		or	a
    1008:  00:DBA2  ED 62               		sbc	hl,hl
    1009:  00:DBA4  C3 EA DD            		jp	set_word
    1010:  00:DBA7                      ;
    1011:  00:DBA7                      ;
    1012:  00:DBA7                      ;------------------------------------------------------------------------------
    1013:  00:DBA7                      ; read_end
    1014:  00:DBA7                      ;
    1015:  00:DBA7                      ; Called when reading has finished. It can be called when we no longer want
    1016:  00:DBA7                      ; the packet, so it needs to call read_flush because the WIZ w5300 insists
    1017:  00:DBA7                      ; we read everything.
    1018:  00:DBA7                      ;
    1019:  00:DBA7                      ; _recv can be called to send the RECV command to the w5300 if we are
    1020:  00:DBA7                      ; certain everything has been read. (tcp.read_block does this because it
    1021:  00:DBA7                      ; doesn't want to loose any bytes buffered in rx_inhand).
    1022:  00:DBA7                      ;
    1023:  00:DBA7                      ; In:  A=socket number
    1024:  00:DBA7                      ; Out: DE=socket base register
    1025:  00:DBA7                      ;
    1026:  00:DBA7  AF                  read_end_0:	xor	a
    1027:  00:DBA8                      read_end:	SOCKET_GET_BASE
    1027:  00:DBA8  11 00 01          >    ld de,0100h
    1027:  00:DBAB  0F                >    rrca
    1027:  00:DBAC  CB 1B             >    rr e
    1027:  00:DBAE  0F                >    rrca
    1027:  00:DBAF  CB 1B             >    rr e
    1027:  00:DBB1  0F                >    rrca
    1027:  00:DBB2  CB 12             >    rl d
    1028:  00:DBB4                      ;
    1029:  00:DBB4  CD 66 DB            _read_end:	call	_read_flush		; Read any unread words
    1030:  00:DBB7                      ;
    1031:  00:DBB7  21 40 00            _recv:		ld	hl,w5300.Sn_CR_RECV	; Received!
    1032:  00:DBBA  3E 02               		ld	a,w5300.Sn_CR
    1033:  00:DBBC  C3 50 D8            		jp	write_reg
    1034:  00:DBBF                      ;
    1035:  00:DBBF                      ;
    1036:  00:DBBF                      ;------------------------------------------------------------------------------
    1037:  00:DBBF                      ; write
    1038:  00:DBBF                      ;
    1039:  00:DBBF                      ; Writes to a previously open socket
    1040:  00:DBBF                      ;
    1041:  00:DBBF                      ; In:   A=socket number
    1042:  00:DBBF                      ;      HL->data to write
    1043:  00:DBBF                      ;      BC=byte count
    1044:  00:DBBF                      ; Out: Cy=>error
    1045:  00:DBBF                      ;
    1046:  00:DBBF  AF                  write_0:	xor	a
    1047:  00:DBC0                      write:		SOCKET_GET_BASE
    1047:  00:DBC0  11 00 01          >    ld de,0100h
    1047:  00:DBC3  0F                >    rrca
    1047:  00:DBC4  CB 1B             >    rr e
    1047:  00:DBC6  0F                >    rrca
    1047:  00:DBC7  CB 1B             >    rr e
    1047:  00:DBC9  0F                >    rrca
    1047:  00:DBCA  CB 12             >    rl d
    1048:  00:DBCC                      ;
    1049:  00:DBCC  D9                  _write:		exx
    1050:  00:DBCD  58                  		ld	e,b	; Use our seg for buffer
    1051:  00:DBCE  D9                  		exx
    1052:  00:DBCF                      ;
    1053:  00:DBCF  E5                  		push	hl	; Save user's buffer ptr
    1054:  00:DBD0  CD 43 DC            		 call	read_FSR; Check FSR to make sure there's enough room 
    1055:  00:DBD3  B7                  		 or	a
    1056:  00:DBD4  ED 42               		 sbc	hl,bc
    1057:  00:DBD6  E1                  		pop	hl
    1058:  00:DBD7  D8                  		ret	c	; Shouldn't happen!
    1059:  00:DBD8                      ;
    1060:  00:DBD8  C5                  .bigenough:	push	bc	; Save byte count
    1061:  00:DBD9  03                  		 inc	bc	; Round up to even # bytes
    1062:  00:DBDA  CB 81               		 res	0,c
    1063:  00:DBDC  CD 57 D9            		 call	write_FIFO
    1064:  00:DBDF  C1                  		pop	bc	; BC=byte count just written
    1065:  00:DBE0                      ;
    1066:  00:DBE0                      add_tx_size:	SOCKET_GET_VAR vars.tx_size	; HL->tx_size
    1066:  00:DBE0                    >    if (var)=0
    1066:  00:DBE0                    ~     ld a,e
    1066:  00:DBE0                    ~    else
    1066:  00:DBE0  3E 0E             >     ld a,(var)*2
    1066:  00:DBE2  B3                >     or e
    1066:  00:DBE3                    >    endif
    1066:  00:DBE3  6F                >    ld l,a
    1066:  00:DBE4  7A                >    ld a,d
    1066:  00:DBE5  0F                >    rrca
    1066:  00:DBE6  CB 1D             >    rr l
    1066:  00:DBE8  26 42             >    ld h,high vars.sockets
    1067:  00:DBEA  7E                  		ld	a,(hl)		; Add on amount just written
    1068:  00:DBEB  81                  		add	a,c
    1069:  00:DBEC  77                  		ld	(hl),a
    1070:  00:DBED  23                  		inc	hl
    1071:  00:DBEE  7E                  		ld	a,(hl)
    1072:  00:DBEF  88                  		adc	a,b
    1073:  00:DBF0  77                  		ld	(hl),a
    1074:  00:DBF1                      ;
    1075:  00:DBF1  B7                  		or	a	; NC=>no error
    1076:  00:DBF2  C9                  		ret
    1077:  00:DBF3                      ;
    1078:  00:DBF3                      ;
    1079:  00:DBF3                      ;------------------------------------------------------------------------------
    1080:  00:DBF3                      ; write_DIPR and wrte_DPORTR
    1081:  00:DBF3                      ;
    1082:  00:DBF3                      ; These are called prior to write() to set up the destination IP address
    1083:  00:DBF3                      ; (when in UDP and IPRAW modes) and DPORTR (when in UDP mode).
    1084:  00:DBF3                      ;
    1085:  00:DBF3                      ; In:   A=socket number
    1086:  00:DBF3                      ;      HL->IP address
    1087:  00:DBF3                      ; Out: DE=reg base
    1088:  00:DBF3                      ;
    1089:  00:DBF3  AF                  write_DIPR_0:	xor	a
    1090:  00:DBF4                      write_DIPR:	SOCKET_GET_BASE
    1090:  00:DBF4  11 00 01          >    ld de,0100h
    1090:  00:DBF7  0F                >    rrca
    1090:  00:DBF8  CB 1B             >    rr e
    1090:  00:DBFA  0F                >    rrca
    1090:  00:DBFB  CB 1B             >    rr e
    1090:  00:DBFD  0F                >    rrca
    1090:  00:DBFE  CB 12             >    rl d
    1091:  00:DC00                      ;
    1092:  00:DC00  E5                  		push	hl		; Save ->IP address
    1093:  00:DC01  06 14               		 ld	b,w5300.Sn_DIPR; Do first register
    1094:  00:DC03  CD 0B DC            		 call	.doone
    1095:  00:DC06  E1                  		pop	hl		; HL->IP address
    1096:  00:DC07                      ;
    1097:  00:DC07  06 16               		ld	b,w5300.Sn_DIPR2; Then second register
    1098:  00:DC09  23                  		inc	hl
    1099:  00:DC0A  23                  		inc	hl
    1100:  00:DC0B                      ;
    1101:  00:DC0B  7E                  .doone:		ld	a,(hl)		; Repeat for 2nd word
    1102:  00:DC0C  23                  		inc	hl
    1103:  00:DC0D  6E                  		ld	l,(hl)
    1104:  00:DC0E  67                  		ld	h,a
    1105:  00:DC0F  78                  		ld	a,b
    1106:  00:DC10  C3 50 D8            		jp	write_reg
    1107:  00:DC13                      ;
    1108:  00:DC13                      ;
    1109:  00:DC13                      ; Due to a bug in the w5300, DPORTR cannot be read. So here we save the value
    1110:  00:DC13                      ; in per-socket RAM as well as actually write it to the w5300.
    1111:  00:DC13                      ;
    1112:  00:DC13                      ; In: DE=reg base, probably left over from call to write_DIPR
    1113:  00:DC13                      ;     HL=port number
    1114:  00:DC13  E5                  write_DPORTR:	push	hl		; Save value
    1115:  00:DC14  3E 0B               		 ld	a,vars.DPORTR
    1116:  00:DC16  CD EA DD            		 call	set_word	; Save copy of DPORTR
    1117:  00:DC19  E1                  		pop	hl
    1118:  00:DC1A  3E 12               		ld	a,w5300.Sn_DPORTR
    1119:  00:DC1C  C3 50 D8            		jp	write_reg	; Write port #
    1120:  00:DC1F                      ;
    1121:  00:DC1F                      ;
    1122:  00:DC1F                      ;------------------------------------------------------------------------------
    1123:  00:DC1F                      ; read_DIPR and read_DPORTR
    1124:  00:DC1F                      ;
    1125:  00:DC1F                      ; These are called to get the IP address and socket number of an established
    1126:  00:DC1F                      ; copnnection.
    1127:  00:DC1F                      ;
    1128:  00:DC1F                      ; In:   A=socket number
    1129:  00:DC1F                      ;      HL->buffer for IP address
    1130:  00:DC1F                      ; Out: DE=socket reg base
    1131:  00:DC1F                      read_DIPR:
    1132:  00:DC1F                      		SOCKET_GET_BASE
    1132:  00:DC1F  11 00 01          >    ld de,0100h
    1132:  00:DC22  0F                >    rrca
    1132:  00:DC23  CB 1B             >    rr e
    1132:  00:DC25  0F                >    rrca
    1132:  00:DC26  CB 1B             >    rr e
    1132:  00:DC28  0F                >    rrca
    1132:  00:DC29  CB 12             >    rl d
    1133:  00:DC2B                      ;
    1134:  00:DC2B  3E 14               		ld	a,w5300.Sn_DIPR
    1135:  00:DC2D  CD 32 DC            		call	.doone
    1136:  00:DC30                      ;
    1137:  00:DC30  3E 16               		ld	a,w5300.Sn_DIPR2
    1138:  00:DC32  E5                  .doone:		push	hl		; Save ->IP buffer
    1139:  00:DC33  CD 40 D8            		 call	read_reg	; HL=2 bytes of IP
    1140:  00:DC36  4D                  		 ld	c,l
    1141:  00:DC37  44                  		 ld	b,h		; BC=2 bytes of IP
    1142:  00:DC38  E1                  		pop	hl		; HL->IP
    1143:  00:DC39  70                  		ld	(hl),b
    1144:  00:DC3A  23                  		inc	hl
    1145:  00:DC3B  71                  		ld	(hl),c
    1146:  00:DC3C  23                  		inc	hl
    1147:  00:DC3D  C9                  		ret
    1148:  00:DC3E                      ;
    1149:  00:DC3E                      ;
    1150:  00:DC3E                      ; Due to a bug in the w5300, DPORTR cannot be read. So here we read the value
    1151:  00:DC3E                      ; that was saved in per-socket RAM instead of reading from the w5300.
    1152:  00:DC3E                      
    1153:  00:DC3E                      ; In:  DE=reg base, probably left over from call to read_DIPR
    1154:  00:DC3E                      ; Out: HL=port number
    1155:  00:DC3E                      ;
    1156:  00:DC3E  3E 0B               read_DPORTR:	ld	a,vars.DPORTR
    1157:  00:DC40  C3 0A DE            		jp	get_word	; HL=port number
    1158:  00:DC43                      ;
    1159:  00:DC43                      ;
    1160:  00:DC43                      ;------------------------------------------------------------------------------
    1161:  00:DC43                      ; read_FSR
    1162:  00:DC43                      ;
    1163:  00:DC43                      ; Returns in HL the number of bytes of free tx memory o0n the WIZ chip
    1164:  00:DC43                      ;
    1165:  00:DC43                      read_FSR:
    1166:  00:DC43                      		; Strictly speaking FSR is a 32-bit value but as we've
    1167:  00:DC43                      		; configured the w5300 tx memory to be 8k max on each socket,
    1168:  00:DC43                      		; here we're only checking the LSW.
    1169:  00:DC43  3E 26               		 ld	a,w5300.Sn_TX_FSR2; FSR is the high word, FSR2 the low
    1170:  00:DC45  C5                  		 push	bc		; Save byte count
    1171:  00:DC46  CD 40 D8            		  call	read_reg
    1172:  00:DC49  C1                  		 pop	bc
    1173:  00:DC4A  C9                  		 ret
    1174:  00:DC4B                      ;
    1175:  00:DC4B                      ;
    1176:  00:DC4B                      ;------------------------------------------------------------------------------
    1177:  00:DC4B                      ; send
    1178:  00:DC4B                      ;
    1179:  00:DC4B                      ; Called after a series of writes to actually send the data.
    1180:  00:DC4B                      ;
    1181:  00:DC4B                      ; For UDP mode DIPR and DPORTR must be set up to indicate the destination
    1182:  00:DC4B                      ; IP and port.
    1183:  00:DC4B                      ;
    1184:  00:DC4B                      ;  In: DE=socket base register
    1185:  00:DC4B                      ; Out: Cy=>error
    1186:  00:DC4B                      ;      DE preserved
    1187:  00:DC4B                      ;
    1188:  00:DC4B                      _send:
    1189:  00:DC4B  B7                  		or	a
    1190:  00:DC4C  ED 62               		sbc	hl,hl
    1191:  00:DC4E  3E 20               		ld	a,w5300.Sn_TX_WRSR	; Write #bytes
    1192:  00:DC50  CD 50 D8            		call	write_reg
    1193:  00:DC53                      ;
    1194:  00:DC53  3E 07               		ld	a,vars.tx_size
    1195:  00:DC55  CD 0A DE            		call	get_word		; HL=no. bytes written
    1196:  00:DC58                      ;
    1197:  00:DC58                      ; Commented out for tcp.read_block sending 0 length packet to fix w5300 bug!
    1198:  00:DC58                      ;		ld	a,h
    1199:  00:DC58                      ;		or	l
    1200:  00:DC58                      ;		jr	z,.end			; Nothing to send!
    1201:  00:DC58                      ;
    1202:  00:DC58  3E 22               		ld	a,w5300.Sn_TX_WRSR2	; Tell WIZ
    1203:  00:DC5A  CD 50 D8            		call	write_reg
    1204:  00:DC5D                      ;
    1205:  00:DC5D  3E 02               		ld	a,w5300.Sn_CR
    1206:  00:DC5F  21 20 00            		ld	hl,w5300.Sn_CR_SEND
    1207:  00:DC62  CD 50 D8            		call	write_reg		; Send it!
    1208:  00:DC65                      ;
    1209:  00:DC65                      ; Here we wait till the send has finished. It would be more efficient to
    1210:  00:DC65                      ; return and let the z80 get on with other things while it is being sent,
    1211:  00:DC65                      ; and to check for sending complete on entry (and socket close?) but for now
    1212:  00:DC65                      ; it is simpler and less error prone to wait here. 100MBps Ethernet doesn't
    1213:  00:DC65                      ; take very long to send in 4MHz Z80 time ie. the Z80 would not be able to
    1214:  00:DC65                      ; do much before the send had compketed!
    1215:  00:DC65                      ;
    1216:  00:DC65  3E 06               .loop:		ld	a,w5300.Sn_IR
    1217:  00:DC67  CD 40 D8            		call	read_reg
    1218:  00:DC6A  7D                  		ld	a,l
    1219:  00:DC6B  E6 10               		and	w5300.Sn_IR_SENDOK
    1220:  00:DC6D  20 1B               		jr	nz,.sendok
    1221:  00:DC6F                      ;
    1222:  00:DC6F  7D                  		ld	a,l
    1223:  00:DC70  E6 08               		and	w5300.Sn_IR_TIMEOUT
    1224:  00:DC72  20 10               		jr	nz,.timeout
    1225:  00:DC74                      ;
    1226:  00:DC74  CD C4 DA            		call	_is_closed
    1227:  00:DC77  37                  		scf
    1228:  00:DC78  28 23               		jr	z,.end
    1229:  00:DC7A                      
    1230:  00:DC7A  CD C3 D0            		call	status.waiting
    1231:  00:DC7D                      ;
    1232:  00:DC7D  CD C3 CA            		call	exos.is_stop	; Just in case we're looping forever
    1233:  00:DC80  38 1B               		jr	c,.end		;   (shouldn't happen!)
    1234:  00:DC82                      ;
    1235:  00:DC82  18 E1               		jr	.loop
    1236:  00:DC84                      
    1237:  00:DC84  37                  .timeout:	scf			; Return error
    1238:  00:DC85  21 08 00            		ld	hl,w5300.Sn_IR_TIMEOUT
    1239:  00:DC88  18 04               		jr	.ret
    1240:  00:DC8A                      ;
    1241:  00:DC8A  B7                  .sendok:	or	a		; NC=>No error
    1242:  00:DC8B  21 10 00            		ld	hl,w5300.Sn_IR_SENDOK
    1243:  00:DC8E  F5                  .ret:		push	af		; Save error flag
    1244:  00:DC8F  3E 06               		 ld	a,w5300.Sn_IR
    1245:  00:DC91  CD 50 D8            		 call	write_reg	; Clear interrupt
    1246:  00:DC94                      ;
    1247:  00:DC94  B7                  		 or	a
    1248:  00:DC95  ED 62               		 sbc	hl,hl		; HL=0
    1249:  00:DC97  3E 07               		 ld	a,vars.tx_size
    1250:  00:DC99  CD EA DD            		 call	set_word	; Reset tx count
    1251:  00:DC9C  F1                  		pop	af
    1252:  00:DC9D                      ;
    1253:  00:DC9D  FD CB 00 4E         .end:		bit	vars.trace.socket,(iy+vars._trace)
    1254:  00:DCA1  C8                  		ret	z
    1255:  00:DCA2                      ;
    1256:  00:DCA2  D5                  		push	de
    1257:  00:DCA3  CD 3C D2            		 call	trace.is_timeout
    1258:  00:DCA6  D1                  		pop	de
    1259:  00:DCA7  C9                  		ret
    1260:  00:DCA8                      ;
    1261:  00:DCA8                      ;
    1262:  00:DCA8                      ;------------------------------------------------------------------------------
    1263:  00:DCA8                      ; keepalive
    1264:  00:DCA8                      ;
    1265:  00:DCA8                      ; Sends a TCP/IP "keep alive" packet
    1266:  00:DCA8                      ;
    1267:  00:DCA8                      ; In:  A=socket number (or DE=socket base reg at _keepalive:)
    1268:  00:DCA8                      ;
    1269:  00:DCA8                      ;keepalive:	SOCKET_GET_BASE
    1270:  00:DCA8                      ;_keepalive:
    1271:  00:DCA8                      ;		; To manually send a Keep Alive, auto-Keep Alives have to be
    1272:  00:DCA8                      ;		; OFF so we save the current Keep Alive timer, set it to 0,
    1273:  00:DCA8                      ;		; send the Keep Alive, and then restore it
    1274:  00:DCA8                      ;		ld	a,w5300.Sn_PORTOR
    1275:  00:DCA8                      ;		call	read_reg
    1276:  00:DCA8                      ;		push	hl		; Save keep alive timer value
    1277:  00:DCA8                      ;
    1278:  00:DCA8                      ;		 ld	a,w5300.Sn_PORTOR
    1279:  00:DCA8                      ;		 or	a
    1280:  00:DCA8                      ;		 sbc	hl,hl		; H=Sn_KPALVTR=0, L=Sn_PROTOR=0
    1281:  00:DCA8                      ;		 call	write_reg	; Make sure auto-keep-alives are OFF
    1282:  00:DCA8                      ;
    1283:  00:DCA8                      ;		 ld	hl,w5300.Sn_CR_SEND_KEEP; HL=Send Keepalive command value
    1284:  00:DCA8                      ;		 ld	c,w5300.Sn_SSR_ESTAB	; C=expected status reg value
    1285:  00:DCA8                      ;		 call	write_CR	; Send command
    1286:  00:DCA8                      ;
    1287:  00:DCA8                      ;		pop	hl		; HL=old keep alive timer value
    1288:  00:DCA8                      ;		ld	a,w5300.Sn_PORTOR
    1289:  00:DCA8                      ;		jp	write_reg	; Restore keep alive timer register
    1290:  00:DCA8                      ;
    1291:  00:DCA8                      ;
    1292:  00:DCA8                      ;------------------------------------------------------------------------------
    1293:  00:DCA8                      ; close
    1294:  00:DCA8                      ;
    1295:  00:DCA8                      ; Closes a previously opened socket
    1296:  00:DCA8                      ;
    1297:  00:DCA8                      ; In:  A=socket number
    1298:  00:DCA8                      ;
    1299:  00:DCA8  AF                  close_0:	xor	a
    1300:  00:DCA9  F5                  close:		push	af		; Save socket no
    1301:  00:DCAA                      		 SOCKET_GET_BASE	; DE=socket base reg
    1301:  00:DCAA  11 00 01          >    ld de,0100h
    1301:  00:DCAD  0F                >    rrca
    1301:  00:DCAE  CB 1B             >    rr e
    1301:  00:DCB0  0F                >    rrca
    1301:  00:DCB1  CB 1B             >    rr e
    1301:  00:DCB3  0F                >    rrca
    1301:  00:DCB4  CB 12             >    rl d
    1302:  00:DCB6                      ;
    1303:  00:DCB6  3E 06               		 ld	a,w5300.Sn_IR
    1304:  00:DCB8  21 FF 00            		 ld	hl,0ffh
    1305:  00:DCBB  CD 50 D8            		 call	write_reg	; Clear socket interrupt flags
    1306:  00:DCBE  F1                  		pop	af		; A=socket number
    1307:  00:DCBF                      ;
    1308:  00:DCBF  F5                  		push	af		; Save socket number
    1309:  00:DCC0  D5                  		 push	de		; Save reg base
    1310:  00:DCC1  CD 66 D9            		  call	tomask		; Get bitmask for socket
    1311:  00:DCC4  6F                  		  ld	l,a
    1312:  00:DCC5  26 00               		  ld	h,0
    1313:  00:DCC7  11 02 00            		  ld	de,w5300.IR
    1314:  00:DCCA  CD C3 D5            		  call	wiz.write_reg	; Clear this socket's interrupt flag
    1315:  00:DCCD  D1                  		 pop	de		; DE=reg base
    1316:  00:DCCE  F1                  		pop	af		; A=socket number
    1317:  00:DCCF                      ;
    1318:  00:DCCF  F5                  		push	af
    1319:  00:DCD0  D5                  		push	de
    1320:  00:DCD1  FD CB 00 4E         		 bit	vars.trace.socket,(iy+vars._trace)
    1321:  00:DCD5  11 A4 D3            		 ld	de,trace.socket.close
    1322:  00:DCD8  C4 28 DE            		 call	nz,trace_msg
    1323:  00:DCDB  D1                  		pop	de
    1324:  00:DCDC  F1                  		pop	af		; A=socket no
    1325:  00:DCDD                      ;
    1326:  00:DCDD  21 10 00            		ld	hl,w5300.Sn_CR_CLOSE
    1327:  00:DCE0  0E 00               		ld	c,w5300.Sn_SSR_CLOSED	; C=expected response
    1328:  00:DCE2  CD 7F DA            		call	write_CR
    1329:  00:DCE5                      ;
    1330:  00:DCE5  FD CB 00 4E         		bit	vars.trace.socket,(iy+vars._trace)
    1331:  00:DCE9  C8                  		ret	z
    1332:  00:DCEA                      ;
    1333:  00:DCEA  C3 3E D2            		jp	trace.is_error
    1334:  00:DCED                      ;
    1335:  00:DCED                      ;
    1336:  00:DCED                      ;------------------------------------------------------------------------------
    1337:  00:DCED                      ; find
    1338:  00:DCED                      ;
    1339:  00:DCED                      ; Finds an unused socket
    1340:  00:DCED                      ;
    1341:  00:DCED                      ; Socket 0 is reserved for fixed sychronous protocols such as DHCP (it makes
    1342:  00:DCED                      ; the code slightly easier to use fixed socket 0).
    1343:  00:DCED                      ;
    1344:  00:DCED                      ; Out: A=socket number of a free socket
    1345:  00:DCED                      ;      Cy=>no free socket
    1346:  00:DCED                      ;
    1347:  00:DCED  21 0C 40            find:		ld	hl,vars.socket.last	; Last socket opened
    1348:  00:DCF0  7E                  		ld	a,(hl)
    1349:  00:DCF1  3C                  .inc:		inc	a
    1350:  00:DCF2  E6 07               		and	wiz.SOCKETS-1
    1351:  00:DCF4  28 FB               		jr	z,.inc		; Ignore socket 0
    1352:  00:DCF6                      ;
    1353:  00:DCF6  BE                  		cp	(hl)		; Uh-oh, no free sockets
    1354:  00:DCF7  37                  		scf
    1355:  00:DCF8  C8                  		ret	z
    1356:  00:DCF9                      ;
    1357:  00:DCF9  CD 01 DD            		call	status		; Get socket status
    1358:  00:DCFC  FE 00               		cp	w5300.Sn_SSR_CLOSED	; Closed?
    1359:  00:DCFE  20 F1               		jr	nz,.inc		; Check next if not
    1360:  00:DD00                      ;
    1361:  00:DD00  C9                  		ret			; Use this one (NC)
    1362:  00:DD01                      ;
    1363:  00:DD01                      ;
    1364:  00:DD01                      ;------------------------------------------------------------------------------
    1365:  00:DD01                      ; status
    1366:  00:DD01                      ;
    1367:  00:DD01                      ; Returns the open/closed status of a socket
    1368:  00:DD01                      ;
    1369:  00:DD01                      ; In:   A=socket number
    1370:  00:DD01                      ; Out: HL=Sn_SSR value
    1371:  00:DD01                      ;
    1372:  00:DD01                      status:		SOCKET_GET_BASE
    1372:  00:DD01  11 00 01          >    ld de,0100h
    1372:  00:DD04  0F                >    rrca
    1372:  00:DD05  CB 1B             >    rr e
    1372:  00:DD07  0F                >    rrca
    1372:  00:DD08  CB 1B             >    rr e
    1372:  00:DD0A  0F                >    rrca
    1372:  00:DD0B  CB 12             >    rl d
    1373:  00:DD0D                      ;
    1374:  00:DD0D  3E 08               		ld	a,w5300.Sn_SSR
    1375:  00:DD0F  C3 40 D8            		jp	read_reg	; HL=Sn_SSR value
    1376:  00:DD12                      ;
    1377:  00:DD12                      ;
    1378:  00:DD12                      ;------------------------------------------------------------------------------
    1379:  00:DD12                      ; status_str
    1380:  00:DD12                      ;
    1381:  00:DD12                      ; In:   A=Sn_SSR value
    1382:  00:DD12                      ; Out:  A preserved
    1383:  00:DD12                      ;      HL->string if NC
    1384:  00:DD12                      ;      NC=>Sn_SSR value was found
    1385:  00:DD12                      ;
    1386:  00:DD12                      status_str:
    1387:  00:DD12  21 2D DD            		ld	hl,.val_tab	; HL->table of values
    1388:  00:DD15  01 0F 00            		ld	bc,.val_tab_num	; BC=number of entries in table
    1389:  00:DD18  E5                  		push	hl		; Save start of table
    1390:  00:DD19  ED B1               		 cpir			; Look for Sn_SSR value in table
    1391:  00:DD1B  C1                  		pop	bc		; BC=start of table
    1392:  00:DD1C  37                  		scf
    1393:  00:DD1D  C0                  		ret	nz		; Return with Cy if not found
    1394:  00:DD1E                      ;
    1395:  00:DD1E  2B                  		dec	hl		; Point back to matching entry
    1396:  00:DD1F  B7                  		or	a
    1397:  00:DD20  ED 42               		sbc	hl,bc		; HL=offset into table
    1398:  00:DD22  01 3C DD            		ld	bc,.str_tab	; BC->table of string pointers
    1399:  00:DD25  29                  		add	hl,hl		; *2 cos addresses
    1400:  00:DD26  09                  		add	hl,bc		; HL->string pointer
    1401:  00:DD27  4E                  		ld	c,(hl)
    1402:  00:DD28  23                  		inc	hl
    1403:  00:DD29  66                  		ld	h,(hl)
    1404:  00:DD2A  69                  		ld	l,c		; HL->string
    1405:  00:DD2B  B7                  		or	a		; NC=>ok
    1406:  00:DD2C  C9                  		ret
    1407:  00:DD2D                      ;
    1408:  00:DD2D  00                  .val_tab:	db	w5300.Sn_SSR_CLOSED
    1409:  00:DD2E  13                  		db	w5300.Sn_SSR_INIT
    1410:  00:DD2F  14                  		db	w5300.Sn_SSR_LISTEN
    1411:  00:DD30  17                  		db	w5300.Sn_SSR_ESTAB
    1412:  00:DD31  1C                  		db	w5300.Sn_SSR_WAIT
    1413:  00:DD32  22                  		db	w5300.Sn_SSR_UDP
    1414:  00:DD33  32                  		db	w5300.Sn_SSR_IPRAW
    1415:  00:DD34  42                  		db	w5300.Sn_SSR_MACRAW
    1416:  00:DD35  5F                  		db	w5300.Sn_SSR_PPPoE
    1417:  00:DD36  15                  		db	w5300.Sn_SSR_SYNSENT
    1418:  00:DD37  16                  		db	w5300.Sn_SSR_SYNRECV
    1419:  00:DD38  18                  		db	w5300.Sn_SSR_FIN_WAIT
    1420:  00:DD39  1B                  		db	w5300.Sn_SSR_TIME_WAIT
    1421:  00:DD3A  1D                  		db	w5300.Sn_SSR_LAST_ACK
    1422:  00:DD3B  01                  		db	w5300.Sn_SSR_ARP
    1423:  00:DD3C                      ;
    1424:  00:DD3C  (00:000F)           .val_tab_num	equ	$-.val_tab
    1425:  00:DD3C                      ;
    1426:  00:DD3C                      .str_tab:				; Same order as above!
    1427:  00:DD3C  5A DD               		dw	.str_CLOSED
    1428:  00:DD3E  61 DD                               dw	.str_INIT
    1429:  00:DD40  6E DD                               dw	.str_LISTEN
    1430:  00:DD42  78 DD                               dw	.str_ESTAB
    1431:  00:DD44  82 DD                               dw	.str_WAIT
    1432:  00:DD46  8A DD                               dw	.str_UDP
    1433:  00:DD48  8E DD                               dw	.str_IPRAW
    1434:  00:DD4A  95 DD                               dw	.str_MACRAW
    1435:  00:DD4C  9D DD                               dw	.str_PPPoE
    1436:  00:DD4E  A3 DD                               dw	.str_SYNSENT
    1437:  00:DD50  AC DD                               dw	.str_SYNRECV
    1438:  00:DD52  B9 DD                               dw	.str_FIN_WAIT
    1439:  00:DD54  C2 DD                               dw	.str_TIME_WAIT
    1440:  00:DD56  CC DD                               dw	.str_LAST_ACK
    1441:  00:DD58  D5 DD                               dw	.str_ARP
    1442:  00:DD5A                      ;
    1443:  00:DD5A                      .str_CLOSED:	db	"Closed",0
    1443:  00:DD5A  43 6C 6F 73 65 64 00 
    1444:  00:DD61                      .str_INIT:	db	"Initialising",0
    1444:  00:DD61  49 6E 69 74 69 61 6C 69 73 69 6E 67 00 
    1445:  00:DD6E                      .str_LISTEN:	db	"Listening",0
    1445:  00:DD6E  4C 69 73 74 65 6E 69 6E 67 00 
    1446:  00:DD78                      .str_ESTAB:	db	"Connected",0
    1446:  00:DD78  43 6F 6E 6E 65 63 74 65 64 00 
    1447:  00:DD82                      .str_WAIT:	db	"Closing",0
    1447:  00:DD82  43 6C 6F 73 69 6E 67 00 
    1448:  00:DD8A  55 44 50 00         .str_UDP:	db	"UDP",0
    1449:  00:DD8E                      .str_IPRAW:	db	"IP raw",0
    1449:  00:DD8E  49 50 20 72 61 77 00 
    1450:  00:DD95                      .str_MACRAW:	db	"MAC raw",0
    1450:  00:DD95  4D 41 43 20 72 61 77 00 
    1451:  00:DD9D  50 50 50 6F 45 00   .str_PPPoE:	db	"PPPoE",0
    1452:  00:DDA3                      .str_SYNSENT:	db	"SYN Sent",0
    1452:  00:DDA3  53 59 4E 20 53 65 6E 74 00 
    1453:  00:DDAC                      .str_SYNRECV:	db	"SYN Received",0
    1453:  00:DDAC  53 59 4E 20 52 65 63 65 69 76 65 64 00 
    1454:  00:DDB9                      .str_FIN_WAIT:	db	"FIN Wait",0
    1454:  00:DDB9  46 49 4E 20 57 61 69 74 00 
    1455:  00:DDC2                      .str_TIME_WAIT:	db	"Time Wait",0
    1455:  00:DDC2  54 69 6D 65 20 57 61 69 74 00 
    1456:  00:DDCC                      .str_LAST_ACK:	db	"Last ACK",0
    1456:  00:DDCC  4C 61 73 74 20 41 43 4B 00 
    1457:  00:DDD5                      .str_ARP:	db	"ARP request",0
    1457:  00:DDD5  41 52 50 20 72 65 71 75 65 73 74 00 
    1458:  00:DDE1                      ;
    1459:  00:DDE1                      ;
    1460:  00:DDE1                      ;------------------------------------------------------------------------------
    1461:  00:DDE1                      ; byteswapword
    1462:  00:DDE1                      ;
    1463:  00:DDE1                      ; Any WORDs that we read from the WIZ are in HILO order so need to be byte
    1464:  00:DDE1                      ; swapped before we can use them naturally on the Z80.
    1465:  00:DDE1                      ; In:  HL->word
    1466:  00:DDE1                      ; Out: word byte swapped and returned in HL
    1467:  00:DDE1                      ;
    1468:  00:DDE1  46                  byteswapword:	ld	b,(hl)
    1469:  00:DDE2  23                  		inc	hl
    1470:  00:DDE3  4E                  		ld	c,(hl)
    1471:  00:DDE4  70                  		ld	(hl),b
    1472:  00:DDE5  2B                  		dec	hl
    1473:  00:DDE6  71                  		ld	(hl),c
    1474:  00:DDE7  69                  		ld	l,c
    1475:  00:DDE8  60                  		ld	h,b
    1476:  00:DDE9  C9                  		ret
    1477:  00:DDEA                      ;
    1478:  00:DDEA                      ;
    1479:  00:DDEA                      ;------------------------------------------------------------------------------
    1480:  00:DDEA                      ; set_word
    1481:  00:DDEA                      ;
    1482:  00:DDEA                      ; Writes a 16-bit value to per-socket variable
    1483:  00:DDEA                      ;
    1484:  00:DDEA                      ; In:  A=var
    1485:  00:DDEA                      ;     DE=reg base
    1486:  00:DDEA                      ;     HL=value
    1487:  00:DDEA                      ;
    1488:  00:DDEA  E5                  set_word:	push	hl		; Save new value
    1489:  00:DDEB                      		 SOCKET_GET_RAM		; HL->variable
    1489:  00:DDEB  87                >    add a,a
    1489:  00:DDEC  B3                >    or e
    1489:  00:DDED  6F                >    ld l,a
    1489:  00:DDEE  7A                >    ld a,d
    1489:  00:DDEF  0F                >    rrca
    1489:  00:DDF0  CB 1D             >    rr l
    1489:  00:DDF2  26 42             >    ld h,high vars.sockets
    1490:  00:DDF4  EB                  		 ex	de,hl		; DE->variable, HL=reg base
    1491:  00:DDF5  E3                  		ex	(sp),hl		; HL=new value, (SP)=reg base
    1492:  00:DDF6  EB                  		 ex	de,hl		; HL->variable, DE=new value
    1493:  00:DDF7  73                  		 ld	(hl),e		; Save new value
    1494:  00:DDF8  23                  		 inc	hl
    1495:  00:DDF9  72                  		 ld	(hl),d
    1496:  00:DDFA  D1                  		 pop	de		; DE=reg base
    1497:  00:DDFB  C9                  		ret
    1498:  00:DDFC                      ;
    1499:  00:DDFC                      ;
    1500:  00:DDFC                      ;------------------------------------------------------------------------------
    1501:  00:DDFC                      ; get_word
    1502:  00:DDFC                      ;
    1503:  00:DDFC                      ; Reads a 16-bit value to per-socket variable
    1504:  00:DDFC                      ; In:   A=var
    1505:  00:DDFC                      ;      DE=reg base
    1506:  00:DDFC                      ; Out: HL=value
    1507:  00:DDFC                      ;
    1508:  00:DDFC                      get_rx_size:	SOCKET_GET_BASE
    1508:  00:DDFC  11 00 01          >    ld de,0100h
    1508:  00:DDFF  0F                >    rrca
    1508:  00:DE00  CB 1B             >    rr e
    1508:  00:DE02  0F                >    rrca
    1508:  00:DE03  CB 1B             >    rr e
    1508:  00:DE05  0F                >    rrca
    1508:  00:DE06  CB 12             >    rl d
    1509:  00:DE08  3E 03               		ld	a,vars.rx_size
    1510:  00:DE0A                      ;
    1511:  00:DE0A                      get_word:	SOCKET_GET_RAM
    1511:  00:DE0A  87                >    add a,a
    1511:  00:DE0B  B3                >    or e
    1511:  00:DE0C  6F                >    ld l,a
    1511:  00:DE0D  7A                >    ld a,d
    1511:  00:DE0E  0F                >    rrca
    1511:  00:DE0F  CB 1D             >    rr l
    1511:  00:DE11  26 42             >    ld h,high vars.sockets
    1512:  00:DE13  7E                  		ld	a,(hl)
    1513:  00:DE14  23                  		inc	hl
    1514:  00:DE15  66                  		ld	h,(hl)
    1515:  00:DE16  6F                  		ld	l,a
    1516:  00:DE17  C9                  		ret
    1517:  00:DE18                      ;
    1518:  00:DE18                      ;
    1519:  00:DE18                      ;------------------------------------------------------------------------------
    1520:  00:DE18                      ; get_owner
    1521:  00:DE18                      ;
    1522:  00:DE18                      ; Returns the name of the socket opener
    1523:  00:DE18                      ;
    1524:  00:DE18                      ; In:    A=socket number
    1525:  00:DE18                      ; Out:  HL->owner string
    1526:  00:DE18                      ;
    1527:  00:DE18                      get_owner:	SOCKET_GET_BASE
    1527:  00:DE18  11 00 01          >    ld de,0100h
    1527:  00:DE1B  0F                >    rrca
    1527:  00:DE1C  CB 1B             >    rr e
    1527:  00:DE1E  0F                >    rrca
    1527:  00:DE1F  CB 1B             >    rr e
    1527:  00:DE21  0F                >    rrca
    1527:  00:DE22  CB 12             >    rl d
    1528:  00:DE24  3E 00               		ld	a,vars.owner
    1529:  00:DE26  18 E2               		jr	get_word
    1530:  00:DE28                      ;
    1531:  00:DE28                      ;
    1532:  00:DE28                      ;------------------------------------------------------------------------------
    1533:  00:DE28                      ; trace, trace_msg
    1534:  00:DE28                      ;
    1535:  00:DE28                      ; At the start of each trace line output, "Sn" is displayed (n is the port
    1536:  00:DE28                      ; number).
    1537:  00:DE28                      ;
    1538:  00:DE28                      ; trace_msg is the same but prints the message at DE afterwards.
    1539:  00:DE28                      ;
    1540:  00:DE28                      ; In:  A=socket number
    1541:  00:DE28                      ;     DE=->message to print
    1542:  00:DE28                      ;
    1543:  00:DE28  D5                  trace_msg:	push	de
    1544:  00:DE29  CD 30 DE            		 call	trace
    1545:  00:DE2C  D1                  		pop	de
    1546:  00:DE2D  C3 36 D0            		jp	io.str
    1547:  00:DE30                      ;		
    1548:  00:DE30                      trace:		SOCKET_GET_BASE
    1548:  00:DE30  11 00 01          >    ld de,0100h
    1548:  00:DE33  0F                >    rrca
    1548:  00:DE34  CB 1B             >    rr e
    1548:  00:DE36  0F                >    rrca
    1548:  00:DE37  CB 1B             >    rr e
    1548:  00:DE39  0F                >    rrca
    1548:  00:DE3A  CB 12             >    rl d
    1549:  00:DE3C  CD 1C D0            _trace:		call	io.start
    1550:  00:DE3F  3E 53               		ld	a,'S'
    1551:  00:DE41  CD F9 CF            		call	io.char
    1552:  00:DE44  7A                  		ld	a,d		; Bit 0 = port bit 2
    1553:  00:DE45  E6 01               		and	1
    1554:  00:DE47  B3                  		or	e		; Bits 6,7 = port bits 0,1
    1555:  00:DE48  07                  		rlca
    1556:  00:DE49  07                  		rlca			; Bits 0,1,2 = port bits 0,1,2
    1557:  00:DE4A  C6 30               		add	a,'0'
    1558:  00:DE4C  CD F9 CF            		call	io.char
    1559:  00:DE4F  3E 3A               		ld	a,':'
    1560:  00:DE51  C3 F9 CF            		jp	io.char
    1561:  00:DE54                      ;
    1562:  00:DE54                      ;
    1563:  00:DE54                      ;
    1564:  00:DE54                      		endmodule
    1565:  00:DE54                      		
     104.  00:DE54                      	include ipraw.asm
       1:  00:DE54                      ; IPRAW
       2:  00:DE54                      ;
       3:  00:DE54                      ; Implements an interface to the sockets of the WIZ chip in IPRAW mode
       4:  00:DE54                      ;
       5:  00:DE54                      		module	ipraw
       6:  00:DE54                      ;
       7:  00:DE54                      ;==============================================================================
       8:  00:DE54                      ;
       9:  00:DE54                      ; This file is part of the EPNET software
      10:  00:DE54                      ;
      11:  00:DE54                      ; Copyright (C) 2015  Bruce Tanner
      12:  00:DE54                      ;
      13:  00:DE54                      ;    This program is free software: you can redistribute it and/or modify
      14:  00:DE54                      ;    it under the terms of the GNU General Public License as published by
      15:  00:DE54                      ;    the Free Software Foundation, either version 3 of the License, or
      16:  00:DE54                      ;    (at your option) any later version.
      17:  00:DE54                      ;
      18:  00:DE54                      ;    This program is distributed in the hope that it will be useful,
      19:  00:DE54                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      20:  00:DE54                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      21:  00:DE54                      ;    GNU General Public License for more details.
      22:  00:DE54                      ;
      23:  00:DE54                      ;    You should have received a copy of the GNU General Public License
      24:  00:DE54                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      25:  00:DE54                      ;
      26:  00:DE54                      ; If you do use or modify this file, either for its original purpose or for
      27:  00:DE54                      ; something new, I'd love to hear about it! I can be contacted by email at:
      28:  00:DE54                      ;
      29:  00:DE54                      ; brucetanner@btopenworld.com
      30:  00:DE54                      ;
      31:  00:DE54                      ;==============================================================================
      32:  00:DE54                      ; open
      33:  00:DE54                      ;
      34:  00:DE54                      ; Opens a WIZ socket in IPRAW mode
      35:  00:DE54                      ;
      36:  00:DE54                      ; In: A=socket number
      37:  00:DE54                      ;     HL=port number
      38:  00:DE54                      ;     DE->owner string
      39:  00:DE54                      ; Out: Carry set if error
      40:  00:DE54                      ;
      41:  00:DE54  AF                  open_0:		xor	a
      42:  00:DE55                      open:
      43:  00:DE55  01 32 03            		ld	bc,w5300.Sn_MR_IPRAW*256+w5300.Sn_SSR_IPRAW
      44:  00:DE58  C3 78 D9            		jp	socket.open		; Open socket in UDP mode
      45:  00:DE5B                      ;
      46:  00:DE5B                      ;
      47:  00:DE5B                      ;------------------------------------------------------------------------------
      48:  00:DE5B                      ; header
      49:  00:DE5B                      ;
      50:  00:DE5B                      ; Reads the WIZ's PACKET_INFO header for IPRAW mode
      51:  00:DE5B                      ;
      52:  00:DE5B                      ; In:  A=socket number
      53:  00:DE5B                      ;
      54:  00:DE5B  AF                  header_0:	xor	a
      55:  00:DE5C                      header:
      56:  00:DE5C                      		SOCKET_GET_BASE
      56:  00:DE5C  11 00 01          >    ld de,0100h
      56:  00:DE5F  0F                >    rrca
      56:  00:DE60  CB 1B             >    rr e
      56:  00:DE62  0F                >    rrca
      56:  00:DE63  CB 1B             >    rr e
      56:  00:DE65  0F                >    rrca
      56:  00:DE66  CB 12             >    rl d
      57:  00:DE68                      ;
      58:  00:DE68  21 1E 40            		ld	hl,vars.icmp.header		; Read W5300 header
      59:  00:DE6B  01 06 00            		ld	bc,vars.icmp.header_size	; No. bytes in header
      60:  00:DE6E  CD BD D8            		call	socket.read_header
      61:  00:DE71                      ;
      62:  00:DE71  21 22 40            		ld	hl,vars.icmp.size
      63:  00:DE74  CD E1 DD            		call	socket.byteswapword	; Byte swap
      64:  00:DE77                      ;
      65:  00:DE77  3E 03               		ld	a,socket.vars.rx_size
      66:  00:DE79  CD EA DD            		call	socket.set_word		; Save in per-socket variable
      67:  00:DE7C                      ;
      68:  00:DE7C  FD CB 00 4E          		bit	vars.trace.socket,(iy+vars._trace)
      69:  00:DE80  28 18               		jr	z,.ret
      70:  00:DE82                      ;
      71:  00:DE82  CD 3C DE            		call	socket._trace
      72:  00:DE85                      ;		
      73:  00:DE85  11 00 D4            		ld	de,trace.ipraw.rx
      74:  00:DE88  CD 36 D0            		call	io.str
      75:  00:DE8B                      ;
      76:  00:DE8B  21 1E 40            		ld	hl,vars.icmp.ip
      77:  00:DE8E  CD 85 CF            		call	io.ip
      78:  00:DE91                      ;
      79:  00:DE91  2A 22 40            		ld	hl,(vars.icmp.size)
      80:  00:DE94  CD 2A D2            		call	trace.bytes
      81:  00:DE97  CD 2A D0            		call	io.space
      82:  00:DE9A                      ;
      83:  00:DE9A  2A 22 40            .ret:		ld	hl,(vars.icmp.size)
      84:  00:DE9D  7C                  		ld	a,h
      85:  00:DE9E  B5                  		or	l
      86:  00:DE9F  C9                  		ret
      87:  00:DEA0                      ;
      88:  00:DEA0                      ;
      89:  00:DEA0                      ;------------------------------------------------------------------------------
      90:  00:DEA0                      ; send
      91:  00:DEA0                      ;
      92:  00:DEA0                      ; Send whatever data has been writen to the Tx FIFO.
      93:  00:DEA0                      ;
      94:  00:DEA0                      ; In:  A=socket number
      95:  00:DEA0                      ;     HL->ip address to send to
      96:  00:DEA0                      ;      vars.icmp.ip = dest IP address to send to
      97:  00:DEA0                      ; Out: NC=>ok
      98:  00:DEA0                      ;
      99:  00:DEA0  AF                  send_0:		xor	a
     100:  00:DEA1  FD CB 00 4E         send:		bit	vars.trace.socket,(iy+vars._trace)
     101:  00:DEA5  28 2D               		jr	z,.notrace
     102:  00:DEA7                      ;
     103:  00:DEA7  F5                  		push	af		; Save socket no
     104:  00:DEA8  E5                  		 push	hl		; Save ->ip address
     105:  00:DEA9  CD 30 DE            		  call	socket.trace
     106:  00:DEAC                      ;
     107:  00:DEAC  11 0F D4            		  ld	de,trace.ipraw.tx
     108:  00:DEAF  CD 36 D0            		  call	io.str
     109:  00:DEB2  E1                  		 pop	hl		; HL->ip address
     110:  00:DEB3  F1                  		pop	af		; A=socket number
     111:  00:DEB4                      ;
     112:  00:DEB4  F5                  		push	af		; Save socket number
     113:  00:DEB5  E5                  		 push	hl		; Save ->ip address
     114:  00:DEB6  F5                  		  push	af		; Save socket number
     115:  00:DEB7  CD 85 CF            		   call	io.ip		; Print dest ip address
     116:  00:DEBA  F1                  		  pop	af		; A=socket number
     117:  00:DEBB                      ;
     118:  00:DEBB                      		  SOCKET_GET_BASE
     118:  00:DEBB  11 00 01          >    ld de,0100h
     118:  00:DEBE  0F                >    rrca
     118:  00:DEBF  CB 1B             >    rr e
     118:  00:DEC1  0F                >    rrca
     118:  00:DEC2  CB 1B             >    rr e
     118:  00:DEC4  0F                >    rrca
     118:  00:DEC5  CB 12             >    rl d
     119:  00:DEC7  3E 07               		  ld	a,socket.vars.tx_size
     120:  00:DEC9  CD 0A DE            		  call	socket.get_word	; HL=tx_size
     121:  00:DECC  CD 2A D2            		  call	trace.bytes	; Print it
     122:  00:DECF  CD 36 D2            		  call	trace.dots
     123:  00:DED2  E1                  		 pop	hl		; HL->IP address
     124:  00:DED3  F1                  		pop	af		; A=socket no
     125:  00:DED4                      ;
     126:  00:DED4  CD F4 DB            .notrace:	call	socket.write_DIPR	; Also sets DE=base reg
     127:  00:DED7                      ;
     128:  00:DED7  C3 4B DC            		jp	socket._send	; Do the send
     129:  00:DEDA                      ;
     130:  00:DEDA                      ;
     131:  00:DEDA                      		endmodule
     132:  00:DEDA                      		
     105.  00:DEDA                      	include udp.asm
       1:  00:DEDA                      ; UDP
       2:  00:DEDA                      ;
       3:  00:DEDA                      ; Impements an interface to the sockets of the WIZ chip in UDP mode
       4:  00:DEDA                      ;
       5:  00:DEDA                      		module	udp
       6:  00:DEDA                      ;
       7:  00:DEDA                      ;==============================================================================
       8:  00:DEDA                      ;
       9:  00:DEDA                      ; This file is part of the EPNET software
      10:  00:DEDA                      ;
      11:  00:DEDA                      ; Copyright (C) 2015  Bruce Tanner
      12:  00:DEDA                      ;
      13:  00:DEDA                      ;    This program is free software: you can redistribute it and/or modify
      14:  00:DEDA                      ;    it under the terms of the GNU General Public License as published by
      15:  00:DEDA                      ;    the Free Software Foundation, either version 3 of the License, or
      16:  00:DEDA                      ;    (at your option) any later version.
      17:  00:DEDA                      ;
      18:  00:DEDA                      ;    This program is distributed in the hope that it will be useful,
      19:  00:DEDA                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      20:  00:DEDA                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      21:  00:DEDA                      ;    GNU General Public License for more details.
      22:  00:DEDA                      ;
      23:  00:DEDA                      ;    You should have received a copy of the GNU General Public License
      24:  00:DEDA                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      25:  00:DEDA                      ;
      26:  00:DEDA                      ; If you do use or modify this file, either for its original purpose or for
      27:  00:DEDA                      ; something new, I'd love to hear about it! I can be contacted by email at:
      28:  00:DEDA                      ;
      29:  00:DEDA                      ; brucetanner@btopenworld.com
      30:  00:DEDA                      ;
      31:  00:DEDA                      ;==============================================================================
      32:  00:DEDA                      ; open
      33:  00:DEDA                      ;
      34:  00:DEDA                      ; Opens a WIZ socket in UDP mode
      35:  00:DEDA                      ;
      36:  00:DEDA                      ; In: A=socket number
      37:  00:DEDA                      ;     HL=port number
      38:  00:DEDA                      ;     DE->owner string
      39:  00:DEDA                      ; Out: Carry set if error
      40:  00:DEDA  AF                  open_0:		xor	a
      41:  00:DEDB                      open:
      42:  00:DEDB  01 22 02            		ld	bc,w5300.Sn_MR_UDP*256+w5300.Sn_SSR_UDP
      43:  00:DEDE  C3 78 D9            		jp	socket.open		; Open socket in UDP mode
      44:  00:DEE1                      ;
      45:  00:DEE1                      ;
      46:  00:DEE1                      ;------------------------------------------------------------------------------
      47:  00:DEE1                      ; header:
      48:  00:DEE1                      ;
      49:  00:DEE1                      ; Starts reading a packet from an open socket - we have to read the WIZ
      50:  00:DEE1                      ; PACKET_INFO first and this is what this does.
      51:  00:DEE1                      ;
      52:  00:DEE1                      ; In:  A=socket number
      53:  00:DEE1                      ; Out: NC=>no error
      54:  00:DEE1                      ;       Z=>nothing to read
      55:  00:DEE1                      ;      HL=no bytes in packet (0 if nothing read)
      56:  00:DEE1                      ;      vars.upd.header filled if HL<>0
      57:  00:DEE1                      ;
      58:  00:DEE1  AF                  header_0:	xor	a
      59:  00:DEE2  CD A4 DA            header:		call	socket.available; See if any bytes available to read
      60:  00:DEE5  C8                  		ret	z		; Nope
      61:  00:DEE6                      ;
      62:  00:DEE6                      ; A packet has been received. First 8 bytes are PACKET_INFO: ip address, port
      63:  00:DEE6                      ; and packet size
      64:  00:DEE6                      .gotdata:	; We rely on the w5300 behaving here - if there's some data
      65:  00:DEE6                      		; there must be at least a UDP header there
      66:  00:DEE6  01 08 00            		ld	bc,vars.udp.header_size	; Header = 4 words
      67:  00:DEE9  21 1E 40            		ld	hl,vars.udp.header
      68:  00:DEEC  D5                  		push	de
      69:  00:DEED  CD BD D8            		 call	socket.read_header	; Read header
      70:  00:DEF0  D1                  		pop	de			; DE=base reg
      71:  00:DEF1                      ;
      72:  00:DEF1  21 22 40            		ld	hl,vars.udp.port	; Update header byte orders
      73:  00:DEF4  CD E1 DD            		call	socket.byteswapword
      74:  00:DEF7                      ;
      75:  00:DEF7  21 24 40            		ld	hl,vars.udp.size
      76:  00:DEFA  CD E1 DD            		call	socket.byteswapword
      77:  00:DEFD                      ;
      78:  00:DEFD  3E 03               		ld	a,socket.vars.rx_size
      79:  00:DEFF  CD EA DD            		call	socket.set_word		; Set up per-socket vars
      80:  00:DF02                      ;
      81:  00:DF02  FD CB 00 4E          		bit	vars.trace.socket,(iy+vars._trace)
      82:  00:DF06  28 1C               		jr	z,.ret
      83:  00:DF08                      ;
      84:  00:DF08  CD 3C DE            		call	socket._trace
      85:  00:DF0B                      ;
      86:  00:DF0B  11 CE D3            		ld	de,trace.udp.rx
      87:  00:DF0E  CD 36 D0            		call	io.str
      88:  00:DF11                      ;
      89:  00:DF11  21 1E 40            		ld	hl,vars.udp.ip
      90:  00:DF14  ED 4B 22 40         		ld	bc,(vars.udp.port)
      91:  00:DF18  CD 9B CF            		call	io.ip_port
      92:  00:DF1B                      ;
      93:  00:DF1B  2A 24 40            		ld	hl,(vars.udp.size)
      94:  00:DF1E  CD 2A D2            		call	trace.bytes
      95:  00:DF21  CD 2A D0            		call	io.space
      96:  00:DF24                      ;
      97:  00:DF24  2A 24 40            .ret:		ld	hl,(vars.udp.size)
      98:  00:DF27  7C                  		ld	a,h
      99:  00:DF28  B5                  		or	l
     100:  00:DF29  C9                  		ret
     101:  00:DF2A                      ;
     102:  00:DF2A                      ;
     103:  00:DF2A                      ;------------------------------------------------------------------------------
     104:  00:DF2A                      ; send
     105:  00:DF2A                      ;
     106:  00:DF2A                      ; Having written the data with one or more calls to write(), this actually
     107:  00:DF2A                      ; sends the packet. The destination ip address and port are in vars.udp.ip and
     108:  00:DF2A                      ; vars.udp.port.
     109:  00:DF2A                      ;
     110:  00:DF2A                      ; In:  A=socket number
     111:  00:DF2A                      ;      vars.udp.ip = dest IP address to send to
     112:  00:DF2A                      ;      vars.udp.port = dest port no.
     113:  00:DF2A                      ; Out: NC=>ok
     114:  00:DF2A  AF                  send_0:		xor	a
     115:  00:DF2B  FD CB 00 4E         send:		bit	vars.trace.socket,(iy+vars._trace)
     116:  00:DF2F  28 2E               		jr	z,.notrace
     117:  00:DF31                      ;
     118:  00:DF31  F5                  		push	af		; Save socket no
     119:  00:DF32  CD 30 DE            		 call	socket.trace
     120:  00:DF35                      
     121:  00:DF35  11 DB D3            		 ld	de,trace.udp.tx
     122:  00:DF38  CD 36 D0            		 call	io.str
     123:  00:DF3B                      ;
     124:  00:DF3B  21 1E 40            		 ld	hl,vars.udp.ip
     125:  00:DF3E  ED 4B 22 40         		 ld	bc,(vars.udp.port)
     126:  00:DF42  CD 9B CF            		 call	io.ip_port	; Print dest ip address & port
     127:  00:DF45  F1                  		pop	af		; A=socket number
     128:  00:DF46                      ;
     129:  00:DF46  F5                  		push	af		; Save socket number
     130:  00:DF47                      		 SOCKET_GET_BASE
     130:  00:DF47  11 00 01          >    ld de,0100h
     130:  00:DF4A  0F                >    rrca
     130:  00:DF4B  CB 1B             >    rr e
     130:  00:DF4D  0F                >    rrca
     130:  00:DF4E  CB 1B             >    rr e
     130:  00:DF50  0F                >    rrca
     130:  00:DF51  CB 12             >    rl d
     131:  00:DF53  3E 07               		 ld	a,socket.vars.tx_size
     132:  00:DF55  CD 0A DE            		 call	socket.get_word
     133:  00:DF58  CD 2A D2            		 call	trace.bytes
     134:  00:DF5B  CD 36 D2            		 call	trace.dots
     135:  00:DF5E  F1                  		pop	af		; A=socket no
     136:  00:DF5F                      ;
     137:  00:DF5F                      .notrace:
     138:  00:DF5F  21 1E 40            		ld	hl,vars.udp.ip		; Set up dest IP address
     139:  00:DF62  CD F4 DB            		call	socket.write_DIPR	; Sets DE=base reg
     140:  00:DF65                      ;
     141:  00:DF65  2A 22 40            		ld	hl,(vars.udp.port)	
     142:  00:DF68  CD 13 DC            		call	socket.write_DPORTR	; Set up dest port #
     143:  00:DF6B                      ;
     144:  00:DF6B  C3 4B DC            		jp	socket._send		; Do the send
     145:  00:DF6E                      ;
     146:  00:DF6E                      ;
     147:  00:DF6E                      		endmodule
     106.  00:DF6E                      	include	tcp.asm
       1:  00:DF6E                      ; TCP
       2:  00:DF6E                      ;
       3:  00:DF6E                      ; Implements an interface to the sockets of the WIZ chip in TCP mode
       4:  00:DF6E                      ;
       5:  00:DF6E                      		module tcp
       6:  00:DF6E                      ;
       7:  00:DF6E                      ;==============================================================================
       8:  00:DF6E                      ;
       9:  00:DF6E                      ; This file is part of the EPNET software
      10:  00:DF6E                      ;
      11:  00:DF6E                      ; Copyright (C) 2015  Bruce Tanner
      12:  00:DF6E                      ;
      13:  00:DF6E                      ;    This program is free software: you can redistribute it and/or modify
      14:  00:DF6E                      ;    it under the terms of the GNU General Public License as published by
      15:  00:DF6E                      ;    the Free Software Foundation, either version 3 of the License, or
      16:  00:DF6E                      ;    (at your option) any later version.
      17:  00:DF6E                      ;
      18:  00:DF6E                      ;    This program is distributed in the hope that it will be useful,
      19:  00:DF6E                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      20:  00:DF6E                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      21:  00:DF6E                      ;    GNU General Public License for more details.
      22:  00:DF6E                      ;
      23:  00:DF6E                      ;    You should have received a copy of the GNU General Public License
      24:  00:DF6E                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      25:  00:DF6E                      ;
      26:  00:DF6E                      ; If you do use or modify this file, either for its original purpose or for
      27:  00:DF6E                      ; something new, I'd love to hear about it! I can be contacted by email at:
      28:  00:DF6E                      ;
      29:  00:DF6E                      ; brucetanner@btopenworld.com
      30:  00:DF6E                      ;
      31:  00:DF6E                      ;==============================================================================
      32:  00:DF6E                      ; open
      33:  00:DF6E                      ;
      34:  00:DF6E                      ; Opens a WIZ socket in TCP client mode
      35:  00:DF6E                      ;
      36:  00:DF6E                      ; In:  A=socket number
      37:  00:DF6E                      ;     HL=our port number
      38:  00:DF6E                      ;     DE->owner string
      39:  00:DF6E                      ; Out: Carry set if error
      40:  00:DF6E                      ;
      41:  00:DF6E                      open:
      42:  00:DF6E  01 13 21            		ld	bc,(w5300.Sn_MR_TCP or w5300.Sn_MR_ND)*256+                                                              w5300.Sn_SSR_INIT
      43:  00:DF71  C3 78 D9            		jp	socket.open		; Open socket in TCP client mode
      44:  00:DF74                      ;
      45:  00:DF74                      ;
      46:  00:DF74                      ;------------------------------------------------------------------------------
      47:  00:DF74                      ; header
      48:  00:DF74                      ;
      49:  00:DF74                      ; Starts reading a packet from an open socket
      50:  00:DF74                      ;
      51:  00:DF74                      ; In:  A=socket number
      52:  00:DF74                      ; Out: NC=>no error
      53:  00:DF74                      ;       Z=>nothing to read
      54:  00:DF74                      ;      HL=no bytes in packet (0 if nothing read)
      55:  00:DF74                      ;      DE=socket base register
      56:  00:DF74                      header:		SOCKET_GET_BASE
      56:  00:DF74  11 00 01          >    ld de,0100h
      56:  00:DF77  0F                >    rrca
      56:  00:DF78  CB 1B             >    rr e
      56:  00:DF7A  0F                >    rrca
      56:  00:DF7B  CB 1B             >    rr e
      56:  00:DF7D  0F                >    rrca
      56:  00:DF7E  CB 12             >    rl d
      57:  00:DF80  CD B0 DA            _header:	call	socket._available; See if any bytes available to read
      58:  00:DF83  C8                  		ret	z		; Z=>nope
      59:  00:DF84                      ;
      60:  00:DF84                      ; A packet has been received. First 2 bytes are PACKET_INFO: just 
      61:  00:DF84                      ; packet size for TCP mode
      62:  00:DF84                      ;
      63:  00:DF84                      		; We rely on the w5300 behaving here - if there's some data
      64:  00:DF84                      		; there must be at least a PACKET_INFO header here
      65:  00:DF84  01 02 00            		ld	bc,vars.tcp.header_size	; Header 1 word for TCP mode
      66:  00:DF87  21 24 40            		ld	hl,vars.tcp.header
      67:  00:DF8A  D5                  		push	de
      68:  00:DF8B  CD BD D8            		 call	socket.read_header	; Read header
      69:  00:DF8E  D1                  		pop	de			; DE=base reg
      70:  00:DF8F                      ;
      71:  00:DF8F  21 24 40            		ld	hl,vars.tcp.size
      72:  00:DF92  CD E1 DD            		call	socket.byteswapword
      73:  00:DF95                      ;
      74:  00:DF95  3E 03               		ld	a,socket.vars.rx_size
      75:  00:DF97  CD EA DD            		call	socket.set_word		; Set up per-socket vars
      76:  00:DF9A                      ;
      77:  00:DF9A  FD CB 00 4E          		bit	vars.trace.socket,(iy+vars._trace)
      78:  00:DF9E  28 14               		jr	z,.ret
      79:  00:DFA0                      ;
      80:  00:DFA0  D5                  		push	de			; Save socket base reg
      81:  00:DFA1  CD 3C DE            		 call	socket._trace
      82:  00:DFA4                      ;
      83:  00:DFA4  11 F2 D3            		 ld	de,trace.tcp.rx
      84:  00:DFA7  CD 36 D0            		 call	io.str
      85:  00:DFAA                      ;
      86:  00:DFAA  2A 24 40            		 ld	hl,(vars.tcp.size)
      87:  00:DFAD  CD 2A D2            		 call	trace.bytes
      88:  00:DFB0  CD 2A D0            		 call	io.space
      89:  00:DFB3  D1                  		pop	de			; DE=socket base reg
      90:  00:DFB4                      ;
      91:  00:DFB4  2A 24 40            .ret:		ld	hl,(vars.tcp.size)
      92:  00:DFB7  7C                  		ld	a,h
      93:  00:DFB8  B5                  		or	l			; NC=>no error, NZ=>bytes ready
      94:  00:DFB9  C9                  		ret
      95:  00:DFBA                      ;
      96:  00:DFBA                      ;
      97:  00:DFBA                      ;------------------------------------------------------------------------------
      98:  00:DFBA                      ; read_block
      99:  00:DFBA                      ;
     100:  00:DFBA                      ; This is called from the EXOS device to read a block of data into the user's
     101:  00:DFBA                      ; buffer. It must cope with odd-length reads and multiple TCP packets.
     102:  00:DFBA                      ;
     103:  00:DFBA                      ; In:     A =socket number
     104:  00:DFBA                      ;     D':DE ->buffer
     105:  00:DFBA                      ;        BC =total number of bytes to read, >0
     106:  00:DFBA                      ;         B'=our segment
     107:  00:DFBA                      ;         C'->P1
     108:  00:DFBA                      ; Out: NC & A=0 if no error
     109:  00:DFBA                      ;      Cy=>error, A=1 => socket closed, A=2 => STOP pressed, A=3 => timeout
     110:  00:DFBA                      ;
     111:  00:DFBA                      read_block:
     112:  00:DFBA                      ; POKE '{'
     113:  00:DFBA  EB                  		ex	de,hl		; HL->user's buffer
     114:  00:DFBB                      		SOCKET_GET_BASE		; DE=socket base register
     114:  00:DFBB  11 00 01          >    ld de,0100h
     114:  00:DFBE  0F                >    rrca
     114:  00:DFBF  CB 1B             >    rr e
     114:  00:DFC1  0F                >    rrca
     114:  00:DFC2  CB 1B             >    rr e
     114:  00:DFC4  0F                >    rrca
     114:  00:DFC5  CB 12             >    rl d
     115:  00:DFC7                      ;
     116:  00:DFC7                      .loop:
     117:  00:DFC7                      ; POKE 'l'
     118:  00:DFC7                      ; POKEBYTE d
     119:  00:DFC7                      ; POKEBYTE e
     120:  00:DFC7  78                  		ld	a,b		; See if byte count == 0
     121:  00:DFC8  B1                  		or	c
     122:  00:DFC9  C8                  		ret	z		; All done
     123:  00:DFCA                      ;		
     124:  00:DFCA                      		; First we look to see if we have an odd byte buffered and,
     125:  00:DFCA                      		; if we have, put this in the user's buffer
     126:  00:DFCA  E5                  		push	hl		; Save ->buffer
     127:  00:DFCB                      		 SOCKET_GET_VAR socket.vars.rx_inhand
     127:  00:DFCB                    >    if (var)=0
     127:  00:DFCB                    ~     ld a,e
     127:  00:DFCB                    ~    else
     127:  00:DFCB  3E 0A             >     ld a,(var)*2
     127:  00:DFCD  B3                >     or e
     127:  00:DFCE                    >    endif
     127:  00:DFCE  6F                >    ld l,a
     127:  00:DFCF  7A                >    ld a,d
     127:  00:DFD0  0F                >    rrca
     127:  00:DFD1  CB 1D             >    rr l
     127:  00:DFD3  26 42             >    ld h,high vars.sockets
     128:  00:DFD5  7E                  		 ld	a,(hl)		; FF=>buffered byte, 0=>none
     129:  00:DFD6  3C                  		 inc	a
     130:  00:DFD7  20 11               		 jr	nz,.no_inhand	; Go if no byte inhand
     131:  00:DFD9                      ;
     132:  00:DFD9  77                  		 ld	(hl),a		; No byte buffered now
     133:  00:DFDA  23                  		 inc	hl
     134:  00:DFDB  7E                  		 ld	a,(hl)		; Get buffered byte
     135:  00:DFDC  E1                  		pop	hl		; HL->user's buffer
     136:  00:DFDD                      ;
     137:  00:DFDD  D9                  .putbyte:	exx
     138:  00:DFDE  ED 51               		out	(c),d		; Switch to user's paging
     139:  00:DFE0  D9                  		exx
     140:  00:DFE1                      ; POKE '='
     141:  00:DFE1                      ; POKEBYTE a
     142:  00:DFE1                      ;
     143:  00:DFE1  77                  		ld	(hl),a		; Put byte into user's buffer
     144:  00:DFE2                      ;
     145:  00:DFE2  D9                  		exx
     146:  00:DFE3  ED 41               		out	(c),b		; Switch back to our paging
     147:  00:DFE5  D9                  		exx
     148:  00:DFE6                      ;
     149:  00:DFE6  23                  		inc	hl		; Adjust ->user's buffer
     150:  00:DFE7  0B                  		dec	bc		; Adjust total byte count
     151:  00:DFE8  18 DD               		jr	.loop		; Repeat but now we know no byte buffered
     152:  00:DFEA                      ;
     153:  00:DFEA  E1                  .no_inhand:	pop	hl		; HL->user's buffer
     154:  00:DFEB                      ;
     155:  00:DFEB                      		; Now we definitely need one or more bytes from a packet, so
     156:  00:DFEB                      		; see if we have started reading from one
     157:  00:DFEB  E5                  		push	hl
     158:  00:DFEC  C5                  		push	bc
     159:  00:DFED                      		 SOCKET_GET_VAR socket.vars.rx_size
     159:  00:DFED                    >    if (var)=0
     159:  00:DFED                    ~     ld a,e
     159:  00:DFED                    ~    else
     159:  00:DFED  3E 06             >     ld a,(var)*2
     159:  00:DFEF  B3                >     or e
     159:  00:DFF0                    >    endif
     159:  00:DFF0  6F                >    ld l,a
     159:  00:DFF1  7A                >    ld a,d
     159:  00:DFF2  0F                >    rrca
     159:  00:DFF3  CB 1D             >    rr l
     159:  00:DFF5  26 42             >    ld h,high vars.sockets
     160:  00:DFF7  4E                  		 ld	c,(hl)
     161:  00:DFF8  23                  		 inc	hl
     162:  00:DFF9  46                  		 ld	b,(hl)		; BC=amount available
     163:  00:DFFA  78                  		 ld	a,b
     164:  00:DFFB  B1                  		 or	c
     165:  00:DFFC  20 36               		 jr	nz,.got_packet	; Go if packet waiting
     166:  00:DFFE                      ;
     167:  00:DFFE                      		 ; Here we need to read more but we have exhausted the current
     168:  00:DFFE                      		 ; packet, so we need to wait until RSR indicates that there
     169:  00:DFFE                      		 ; is something available and then read the PACKET_INFO of
     170:  00:DFFE                      		 ; the next packet (if there is one)
     171:  00:DFFE                      		 ;
     172:  00:DFFE                      		 ; We need to check for a packet ready *before* checking to
     173:  00:DFFE                      		 ; see if the socket is closed, as the other end may well
     174:  00:DFFE                      		 ; send lots of packets then close the link before we have
     175:  00:DFFE                      		 ; read them all
     176:  00:DFFE                      ;
     177:  00:DFFE  2A 0E 40            		 ld	hl,(vars.ticks)	; Setup timout timer
     178:  00:E001  22 1C 40            		 ld	(vars.tcp.start),hl
     179:  00:E004                      ;
     180:  00:E004                      .wait:
     181:  00:E004                      ; POKE 'w'
     182:  00:E004                      ; POKEBYTE d
     183:  00:E004                      ; POKEBYTE e
     184:  00:E004  CD 80 DF            		 call	_header		; See if packet arrived
     185:  00:E007  20 2B               		 jr	nz,.got_packet	; Go and read it if yes
     186:  00:E009                      ;
     187:  00:E009  CD C4 DA            		 call	socket._is_closed; Other end closed connection
     188:  00:E00C                      ; POKEcc z,'e'
     189:  00:E00C  3E 01               		 ld	a,1
     190:  00:E00E  28 20               		 jr	z,.ret		; Return with A=1 if yes
     191:  00:E010                      ;
     192:  00:E010  CD C3 D0            		 call	status.waiting	; Flash waiting indicator
     193:  00:E013                      ;
     194:  00:E013  CD 6C E1            		 call	_send		; Send 0 bytes to update TCP/IP window
     195:  00:E016                      ;
     196:  00:E016  CD C3 CA            		 call	exos.is_stop	; Stop key pressed?
     197:  00:E019  3E 02               		 ld	a,2
     198:  00:E01B  38 13               		 jr	c,.ret		; Return with A=2 if yes
     199:  00:E01D                      ;
     200:  00:E01D  ED 4B 1C 40         		 ld	bc,(vars.tcp.start)
     201:  00:E021  2A 0E 40            		 ld	hl,(vars.ticks)
     202:  00:E024  B7                  		 or	a
     203:  00:E025  ED 42               		 sbc	hl,bc		; HL=duraction in ticks
     204:  00:E027  01 B8 0B            		 ld	bc,TICKS_1m
     205:  00:E02A  ED 42               		 sbc	hl,bc		; See if timed out (1 S)
     206:  00:E02C  38 D6               		 jr	c,.wait		; Keep waiting if not
     207:  00:E02E                      ;
     208:  00:E02E  3E 03               		 ld	a,3		; Return with A=3 if timed out
     209:  00:E030                      ;
     210:  00:E030  C1                  .ret:		pop	bc
     211:  00:E031  E1                  		pop	hl
     212:  00:E032  37                  		scf			; Cy=>error
     213:  00:E033  C9                  		ret
     214:  00:E034                      ;
     215:  00:E034  C1                  .got_packet:	pop	bc
     216:  00:E035  E1                  		pop	hl
     217:  00:E036                      ; POKE 'g'
     218:  00:E036                      ;
     219:  00:E036                      		; Here there is a packet buffered and we need one or more
     220:  00:E036                      		; bytes from it
     221:  00:E036                      		; HL->user's buffer
     222:  00:E036                      		; BC=total bytes needed
     223:  00:E036                      		; DE=socket base
     224:  00:E036                      ;
     225:  00:E036                      		; First we read as many even bytes as we can from the packet
     226:  00:E036  C5                  		push	bc	; Save total byte count
     227:  00:E037  E5                  		 push	hl	; Save->user's buffer
     228:  00:E038  CB 81               		  res	0,c	; Only doing even bytes (could == 0!)
     229:  00:E03A  C5                  		  push	bc	; Save # even bytes required
     230:  00:E03B                      		   SOCKET_GET_VAR socket.vars.rx_size
     230:  00:E03B                    >    if (var)=0
     230:  00:E03B                    ~     ld a,e
     230:  00:E03B                    ~    else
     230:  00:E03B  3E 06             >     ld a,(var)*2
     230:  00:E03D  B3                >     or e
     230:  00:E03E                    >    endif
     230:  00:E03E  6F                >    ld l,a
     230:  00:E03F  7A                >    ld a,d
     230:  00:E040  0F                >    rrca
     230:  00:E041  CB 1D             >    rr l
     230:  00:E043  26 42             >    ld h,high vars.sockets
     231:  00:E045  4E                  		   ld	c,(hl)
     232:  00:E046  23                  		   inc	hl
     233:  00:E047  46                  		   ld	b,(hl)	; BC=amount available
     234:  00:E048  CB 81               		   res	0,c	; Only doing even bytes (could now = 0!)
     235:  00:E04A  E1                  		  pop	hl	; HL=#even bytes required
     236:  00:E04B  B7                  		  or	a
     237:  00:E04C  ED 42               		  sbc	hl,bc	; HL=remainder after read
     238:  00:E04E  30 03               		  jr	nc,.all	; Go if amount in packet < required
     239:  00:E050                      ;
     240:  00:E050  09                  		  add	hl,bc	; HL=amount to read from packet
     241:  00:E051  4D                  		  ld	c,l
     242:  00:E052  44                  		  ld	b,h	; BC=amount for this read
     243:  00:E053                      ;
     244:  00:E053  E1                  .all:		 pop	hl	; HL->user's buffer
     245:  00:E054                      
     246:  00:E054                      		 ; Now BC   = number of even bytes to read from packet
     247:  00:E054                      		 ;     HL   ->user's buffer
     248:  00:E054                      		 ;     (SP) = total bytes required
     249:  00:E054                      ;
     250:  00:E054  78                  		 ld	a,b
     251:  00:E055  B1                  		 or	c	; A=0 => no even bytes to read
     252:  00:E056  28 1C               		 jr	z,.odd
     253:  00:E058                      ;
     254:  00:E058  E5                  		 push	hl	; Save ->user's buffer
     255:  00:E059  09                  		  add	hl,bc	; HL->user's buffer updated
     256:  00:E05A  E3                  		 ex	(sp),hl	; HL->user's buffer, (SP)->buffer updated
     257:  00:E05B  C5                  		  push	bc	; Save amount to read
     258:  00:E05C  D9                  		   exx
     259:  00:E05D  5A                  		   ld	e,d	; Setup for user's paging
     260:  00:E05E  D9                  		   exx
     261:  00:E05F  CD E9 DA            		   call	socket._readx	; Read the bytes; HL->rx_size
     262:  00:E062  7E                  		   ld	a,(hl)
     263:  00:E063  23                  		   inc	hl
     264:  00:E064  B6                  		   or	(hl)	; See if we've read everything
     265:  00:E065  CC B7 DB            		   call	z,socket._recv	; Indicate end of read if we have
     266:  00:E068  C1                  		  pop	bc	; BC=amount just read
     267:  00:E069  E1                  		 pop	hl	; HL->user's buffer updated
     268:  00:E06A  E3                  		ex	(sp),hl	; HL=total byte count, (SP)=buffer updated
     269:  00:E06B  B7                  		 or	a
     270:  00:E06C  ED 42               		 sbc	hl,bc	; Total bytes required -= amount just read
     271:  00:E06E  4D                  		 ld	c,l
     272:  00:E06F  44                  		 ld	b,h	; BC=new total byte count
     273:  00:E070  E1                  		pop	hl	; HL->new user's buffer
     274:  00:E071                      ;
     275:  00:E071  C3 C7 DF            		jp	.loop
     276:  00:E074                      ;
     277:  00:E074  C1                  .odd:		pop	bc	; BC=total byte count
     278:  00:E075                      ;
     279:  00:E075                      ; POKE 'o'
     280:  00:E075                      		; We now have a packet and have read as many even bytes as we
     281:  00:E075                      		; can from it. If we end up here either a) it's an odd-length
     282:  00:E075                      		; read and we need the last odd byte, or b) we have an
     283:  00:E075                      		; odd-length packet and we need to read the last byte from it
     284:  00:E075                      ;
     285:  00:E075                      		; HL->user's buffer
     286:  00:E075                      		; BC=bytes still required
     287:  00:E075                      ;
     288:  00:E075                      		; When doing a byte read we normally read a word and buffer
     289:  00:E075                      		; the second byte in rx_inhand. But if it's the last byte of
     290:  00:E075                      		; an odd-length packet we have to discard the second byte as
     291:  00:E075                      		; it's a dummy!
     292:  00:E075                      ;
     293:  00:E075  E5                  		push	hl
     294:  00:E076  C5                  		push	bc
     295:  00:E077                      		 SOCKET_GET_VAR socket.vars.rx_inhand	; Read 2 bytes to here
     295:  00:E077                    >    if (var)=0
     295:  00:E077                    ~     ld a,e
     295:  00:E077                    ~    else
     295:  00:E077  3E 0A             >     ld a,(var)*2
     295:  00:E079  B3                >     or e
     295:  00:E07A                    >    endif
     295:  00:E07A  6F                >    ld l,a
     295:  00:E07B  7A                >    ld a,d
     295:  00:E07C  0F                >    rrca
     295:  00:E07D  CB 1D             >    rr l
     295:  00:E07F  26 42             >    ld h,high vars.sockets
     296:  00:E081  01 02 00            		 ld	bc,2	; Read 2 bytes
     297:  00:E084  E5                  		 push	hl	; Save->rx_inhand
     298:  00:E085  CD E6 DA            		  call	socket._read	; Read 1 word; Cy=>past last byte
     299:  00:E088  F5                  		  push	af	; Save last byte flag
     300:  00:E089  7E                  		   ld	a,(hl)	; Check rx_size to see if we've read everything
     301:  00:E08A  23                  		   inc	hl
     302:  00:E08B  B6                  		   or	(hl)	; See if we've read everything
     303:  00:E08C  CC B7 DB            		   call	z,socket._recv	; Indicate end of read if we have
     304:  00:E08F  F1                  		  pop	af	; Cy=>read past last byte
     305:  00:E090  E1                  		 pop	hl	; HL->rx_inhand
     306:  00:E091  3F                  		 ccf		; NC=>last byte, Cy=>not last byte
     307:  00:E092  9F                  		 sbc	a,a	; A= 0=>last byte, ff=>not last byte
     308:  00:E093  46                  		 ld	b,(hl)	; B=first of the two bytes
     309:  00:E094  77                  		 ld	(hl),a	; FF=>buffered byte, 0=>no buffered byte
     310:  00:E095  78                  		 ld	a,b	; A=byte to put in user's buffer
     311:  00:E096  C1                  		pop	bc	; BC=total byte count
     312:  00:E097  E1                  		pop	hl	; HL->user's buffer
     313:  00:E098  C3 DD DF            		jp	.putbyte; Put byte in user's buffer & update HL & BC
     314:  00:E09B                      ;
     315:  00:E09B                      ;
     316:  00:E09B                      ;------------------------------------------------------------------------------
     317:  00:E09B                      ; write_block
     318:  00:E09B                      ;
     319:  00:E09B                      ; This is called from the EXOS device to write a block of data from the user's
     320:  00:E09B                      ; buffer. It must cope with odd-length writes and splitting large blocks into
     321:  00:E09B                      ; multiple TCP packets.
     322:  00:E09B                      ;
     323:  00:E09B                      ; In:      A=socket number
     324:  00:E09B                      ;     D':DE ->buffer
     325:  00:E09B                      ;        BC =total number of bytes to read, >0
     326:  00:E09B                      ;         C'->P1
     327:  00:E09B                      ;         B'=our seg
     328:  00:E09B                      ; Out: Cy=>error
     329:  00:E09B                      ;
     330:  00:E09B                      write_block:
     331:  00:E09B  EB                  		ex	de,hl		; HL->user's buffer
     332:  00:E09C                      		SOCKET_GET_BASE		; DE=socket base register
     332:  00:E09C  11 00 01          >    ld de,0100h
     332:  00:E09F  0F                >    rrca
     332:  00:E0A0  CB 1B             >    rr e
     332:  00:E0A2  0F                >    rrca
     332:  00:E0A3  CB 1B             >    rr e
     332:  00:E0A5  0F                >    rrca
     332:  00:E0A6  CB 12             >    rl d
     333:  00:E0A8                      ;
     334:  00:E0A8                      		; First we look to see if we have an odd byte buffered from
     335:  00:E0A8                      		; the previous write and, if we have, take first byte from
     336:  00:E0A8                      		; the current write to form a word with it, and write it
     337:  00:E0A8  E5                  		push	hl		; Save ->buffer
     338:  00:E0A9                      		 SOCKET_GET_VAR socket.vars.tx_inhand+1
     338:  00:E0A9                    >    if (var)=0
     338:  00:E0A9                    ~     ld a,e
     338:  00:E0A9                    ~    else
     338:  00:E0A9  3E 14             >     ld a,(var)*2
     338:  00:E0AB  B3                >     or e
     338:  00:E0AC                    >    endif
     338:  00:E0AC  6F                >    ld l,a
     338:  00:E0AD  7A                >    ld a,d
     338:  00:E0AE  0F                >    rrca
     338:  00:E0AF  CB 1D             >    rr l
     338:  00:E0B1  26 42             >    ld h,high vars.sockets
     339:  00:E0B3  7E                  		 ld	a,(hl)		; FF=>buffered byte, 0=>none
     340:  00:E0B4  B7                  		 or	a		; NC
     341:  00:E0B5  3C                  		 inc	a
     342:  00:E0B6  20 14               		 jr	nz,.nobuf	; Go with NC if no byte inhand
     343:  00:E0B8                      ;
     344:  00:E0B8  E3                  		 ex	(sp),hl		; (SP)->tx_inhand+1, HL->user's buffer
     345:  00:E0B9  7E                  		 ld	a,(hl)		; Get user's first data byte
     346:  00:E0BA  23                  		 inc	hl
     347:  00:E0BB  E3                  		 ex	(sp),hl		; (SP)->user's data, HL->tx_inhand+1
     348:  00:E0BC  77                  		 ld	(hl),a		; tx_inhand now = next word to write
     349:  00:E0BD  2B                  		 dec	hl		; HL->tx_inhand
     350:  00:E0BE  0B                  		 dec	bc		; User's byte count now 1 less
     351:  00:E0BF  C5                  		 push	bc
     352:  00:E0C0  E5                  		  push	hl		; Save ->tx_inhand
     353:  00:E0C1  01 02 00            		   ld	bc,2		; Write 1 word
     354:  00:E0C4  CD F5 E0            		   call	_write_block
     355:  00:E0C7  E1                  		  pop	hl		; HL->tx_inhand
     356:  00:E0C8  23                  		  inc	hl
     357:  00:E0C9  36 00               		  ld	(hl),0		; 0 => no buffered byte
     358:  00:E0CB  C1                  		 pop	bc		; BC=remaining bytes to write
     359:  00:E0CC  E1                  .nobuf:		pop	hl		; HL->user's data
     360:  00:E0CD  D8                  		ret	c		; Error
     361:  00:E0CE                      ;
     362:  00:E0CE                      		; Now we write the even words
     363:  00:E0CE                      		; HL->user's buffer
     364:  00:E0CE                      		; BC=byte count (could now be 0, could still be odd)
     365:  00:E0CE                      		; DE=socket base
     366:  00:E0CE  E5                  		push	hl		; Save ->user's buffer
     367:  00:E0CF  C5                  		 push	bc		; Save byte count
     368:  00:E0D0  CB 81               		  res	0,c		; We'll do odd bytes l8r
     369:  00:E0D2  78                  		  ld	a,b
     370:  00:E0D3  B1                  		  or	c		; NC as well as testing BC
     371:  00:E0D4  D9                  		  exx
     372:  00:E0D5  5A                  		  ld	e,d		; Set up for user's paging
     373:  00:E0D6  D9                  		  exx
     374:  00:E0D7  C4 F8 E0            		  call	nz,_write_blockx
     375:  00:E0DA  C1                  		 pop	bc		; BC=byte count jusrt written
     376:  00:E0DB  E1                  		pop	hl		; HL->user's buffer
     377:  00:E0DC                      ;
     378:  00:E0DC  D8                  		ret	c		; Error from _write_block
     379:  00:E0DD                      ;
     380:  00:E0DD  CB 41               		bit	0,c		; An odd #bytes?
     381:  00:E0DF  C8                  		ret	z		; We're done if not
     382:  00:E0E0                      ;
     383:  00:E0E0                      		; If there's an odd byte at the end, save it in tx_inhand for
     384:  00:E0E0                      		; the next write
     385:  00:E0E0  09                  		add	hl,bc		; Adjust ->buffer for write
     386:  00:E0E1  2B                  		dec	hl		; ->last odd byte
     387:  00:E0E2  7E                  		ld	a,(hl)
     388:  00:E0E3  F5                  		push	af		; Save odd byte
     389:  00:E0E4                      		 SOCKET_GET_VAR socket.vars.tx_inhand
     389:  00:E0E4                    >    if (var)=0
     389:  00:E0E4                    ~     ld a,e
     389:  00:E0E4                    ~    else
     389:  00:E0E4  3E 12             >     ld a,(var)*2
     389:  00:E0E6  B3                >     or e
     389:  00:E0E7                    >    endif
     389:  00:E0E7  6F                >    ld l,a
     389:  00:E0E8  7A                >    ld a,d
     389:  00:E0E9  0F                >    rrca
     389:  00:E0EA  CB 1D             >    rr l
     389:  00:E0EC  26 42             >    ld h,high vars.sockets
     390:  00:E0EE  F1                  		pop	af		; A=last odd byte
     391:  00:E0EF  77                  		ld	(hl),a		; Save last byte in tx_inhand
     392:  00:E0F0  23                  		inc	hl
     393:  00:E0F1  36 FF               		ld	(hl),0ffh	; FF->got a buffered byte in hand
     394:  00:E0F3  B7                  		or	a		; NC=>no error
     395:  00:E0F4  C9                  		ret
     396:  00:E0F5                      ;
     397:  00:E0F5                      ;
     398:  00:E0F5                      ; _write_block
     399:  00:E0F5                      ;
     400:  00:E0F5                      ; write_block (above) deals with odd bytes, so here we just write a block given
     401:  00:E0F5                      ; an even byte count. However it could be a large block so we might have to
     402:  00:E0F5                      ; split it up into separate WIZ sends ( ie. separate TCP packets)
     403:  00:E0F5                      ;
     404:  00:E0F5                      ; _write_block is called when the buffer is in our memory
     405:  00:E0F5                      ; _write_blockx uses the segment in E' is the segment for the buffer
     406:  00:E0F5                      ;
     407:  00:E0F5                      ; In:  HL->bufer
     408:  00:E0F5                      ;      BC=word byte, >0
     409:  00:E0F5                      ;      DE=socket register base
     410:  00:E0F5                      ; Out: DE preserved
     411:  00:E0F5                      ;      Cy=>error
     412:  00:E0F5                      ;
     413:  00:E0F5                      _write_block:
     414:  00:E0F5                      ;
     415:  00:E0F5  D9                  		exx
     416:  00:E0F6  58                  		ld	e,b		; Use our seg
     417:  00:E0F7  D9                  		exx
     418:  00:E0F8                      ;
     419:  00:E0F8                      _write_blockx:				; E' must be set up with seg
     420:  00:E0F8                      
     421:  00:E0F8                      		; First see if it's time to send a packet
     422:  00:E0F8  E5                  		push	hl		; Save ->data
     423:  00:E0F9  C5                  		 push	bc		; Save byte count
     424:  00:E0FA  CD 43 DC            .loop:		  call	socket.read_FSR	; HL=space available (in bytes)
     425:  00:E0FD  7C                  		  ld	a,h
     426:  00:E0FE  B5                  		  or	l
     427:  00:E0FF  20 08               		  jr	nz,.donesend
     428:  00:E101                      ;
     429:  00:E101  CD 6C E1            		  call	tcp._send	; Send if WIZ buffer full
     430:  00:E104  30 F4               		  jr	nc,.loop
     431:  00:E106                      ;
     432:  00:E106  C1                  		 pop	bc
     433:  00:E107  E1                  		pop	hl
     434:  00:E108  C9                  		ret
     435:  00:E109                      
     436:  00:E109                      ;
     437:  00:E109  4D                  .donesend:	  ld	c,l
     438:  00:E10A  44                  		  ld	b,h		; BC=no bytes to write this time
     439:  00:E10B  E1                  		 pop	hl		; HL=total byte count to write
     440:  00:E10C  B7                  		 or	a
     441:  00:E10D  ED 42               		 sbc	hl,bc		; HL=remainder after this write
     442:  00:E10F  30 06               		 jr	nc,.notlast
     443:  00:E111                      ;
     444:  00:E111  09                  		 add	hl,bc		; HL=amount to write this time
     445:  00:E112  4D                  		 ld	c,l
     446:  00:E113  44                  		 ld	b,h		; BC=#bytes to write this time
     447:  00:E114                      
     448:  00:E114  B7                  		 or	a
     449:  00:E115  ED 62               		 sbc	hl,hl		; HL=0, #bytes to write next time
     450:  00:E117                      ;
     451:  00:E117                      .notlast:
     452:  00:E117                      		 ; HL=remaining byte count
     453:  00:E117                      		 ; BC=byte count this time
     454:  00:E117                      		 ; (SP)->data
     455:  00:E117  E3                  		ex	(sp),hl		; (SP)=remaining bytes, HL->data
     456:  00:E118  C5                  		 push	bc		; Save # byte about to be written
     457:  00:E119  D5                  		  push	de		; Save socket base register
     458:  00:E11A  CD 57 D9            		   call	socket.write_FIFO; Write data; HL=updated ->data
     459:  00:E11D  D1                  		  pop	de		; DE=socket register base
     460:  00:E11E  E3                  		 ex	(sp),hl		; (SP)->data, HL=#bytes just written
     461:  00:E11F  4D                  		  ld	c,l
     462:  00:E120  44                  		  ld	b,h
     463:  00:E121  CD E0 DB            		  call	socket.add_tx_size	; Add on to tx_size
     464:  00:E124  E1                  		 pop	hl		; HL->data
     465:  00:E125  C1                  		pop	bc		; BC=#bytes remaining
     466:  00:E126  78                  		ld	a,b
     467:  00:E127  B1                  		or	c
     468:  00:E128  20 CE               		jr	nz,_write_blockx; Do it again if more to write
     469:  00:E12A                      ;
     470:  00:E12A  C9                  		ret			; NC =>no error
     471:  00:E12B                      ;
     472:  00:E12B                      ;
     473:  00:E12B                      ;------------------------------------------------------------------------------
     474:  00:E12B                      ; status
     475:  00:E12B                      ;
     476:  00:E12B                      ; This is called from EXOS devices to determine whether there is a byte
     477:  00:E12B                      ; ready to be read or not.
     478:  00:E12B                      ;
     479:  00:E12B                      ; In:  A=socket number
     480:  00:E12B                      ; Out: A=0=>byte ready, FF=>end of file, 1 otherwise
     481:  00:E12B                      ;      Note: flags may not be set according to A!
     482:  00:E12B                      ;
     483:  00:E12B                      status:	
     484:  00:E12B                      		SOCKET_GET_BASE		; DE=socket base register
     484:  00:E12B  11 00 01          >    ld de,0100h
     484:  00:E12E  0F                >    rrca
     484:  00:E12F  CB 1B             >    rr e
     484:  00:E131  0F                >    rrca
     484:  00:E132  CB 1B             >    rr e
     484:  00:E134  0F                >    rrca
     484:  00:E135  CB 12             >    rl d
     485:  00:E137                      ;
     486:  00:E137                      		; First see if we have a byte buffered
     487:  00:E137                      		SOCKET_GET_VAR socket.vars.rx_inhand
     487:  00:E137                    >    if (var)=0
     487:  00:E137                    ~     ld a,e
     487:  00:E137                    ~    else
     487:  00:E137  3E 0A             >     ld a,(var)*2
     487:  00:E139  B3                >     or e
     487:  00:E13A                    >    endif
     487:  00:E13A  6F                >    ld l,a
     487:  00:E13B  7A                >    ld a,d
     487:  00:E13C  0F                >    rrca
     487:  00:E13D  CB 1D             >    rr l
     487:  00:E13F  26 42             >    ld h,high vars.sockets
     488:  00:E141  7E                  		ld	a,(hl)		; FF=>buffered byte, 0=>none
     489:  00:E142  3C                  		inc	a
     490:  00:E143  C8                  		ret	z		; Return with A=0 if byte buffered
     491:  00:E144                      ;
     492:  00:E144                      		SOCKET_GET_VAR socket.vars.rx_size
     492:  00:E144                    >    if (var)=0
     492:  00:E144                    ~     ld a,e
     492:  00:E144                    ~    else
     492:  00:E144  3E 06             >     ld a,(var)*2
     492:  00:E146  B3                >     or e
     492:  00:E147                    >    endif
     492:  00:E147  6F                >    ld l,a
     492:  00:E148  7A                >    ld a,d
     492:  00:E149  0F                >    rrca
     492:  00:E14A  CB 1D             >    rr l
     492:  00:E14C  26 42             >    ld h,high vars.sockets
     493:  00:E14E  7E                  		ld	a,(hl)		; See if any packet read started
     494:  00:E14F  23                  		inc	hl
     495:  00:E150  B6                  		or	(hl)
     496:  00:E151  CC B0 DA            		call	z,socket._available; Or any packet waiting
     497:  00:E154  3E 00               		ld	a,0
     498:  00:E156  C0                  		ret	nz		; Return with A=0 if yes
     499:  00:E157                      ;
     500:  00:E157  CD C4 DA            		call	socket._is_closed
     501:  00:E15A  3E FF               		ld	a,0ffh
     502:  00:E15C  C8                  		ret	z		; FF=>EOF if socket closed (or closing)
     503:  00:E15D                      ;
     504:  00:E15D  3E 01               		ld	a,1
     505:  00:E15F  C9                  		ret
     506:  00:E160                      ;
     507:  00:E160                      ;
     508:  00:E160                      ;------------------------------------------------------------------------------
     509:  00:E160                      ; keepalive
     510:  00:E160                      ;
     511:  00:E160                      ; Sets the Keep Alive timer so the session does not time out
     512:  00:E160                      ;
     513:  00:E160                      ;keepalive:	SOCKET_GET_BASE		; DE=socket base register
     514:  00:E160                      ;
     515:  00:E160                      ;		ld	a,w5300.Sn_PORTOR	; Timer is in Port Options Reg
     516:  00:E160                      ;		ld	hl,(60/5)*256+0	; H=1 min, L=0 not used in TCP mode
     517:  00:E160                      ;		jp	socket.write_reg
     518:  00:E160                      ;
     519:  00:E160                      ;
     520:  00:E160                      ;------------------------------------------------------------------------------
     521:  00:E160                      ; send
     522:  00:E160                      ;
     523:  00:E160                      ; Sends data that has already been written to the tx FIFO.
     524:  00:E160                      ;
     525:  00:E160                      ; In:  A=socket number
     526:  00:E160                      ;
     527:  00:E160                      send:		SOCKET_GET_BASE
     527:  00:E160  11 00 01          >    ld de,0100h
     527:  00:E163  0F                >    rrca
     527:  00:E164  CB 1B             >    rr e
     527:  00:E166  0F                >    rrca
     527:  00:E167  CB 1B             >    rr e
     527:  00:E169  0F                >    rrca
     527:  00:E16A  CB 12             >    rl d
     528:  00:E16C                      _send:
     529:  00:E16C  FD CB 00 4E         		bit	vars.trace.socket,(iy+vars._trace)
     530:  00:E170  CA 4B DC            		jp	z,socket._send
     531:  00:E173                      ;
     532:  00:E173  CD 3C DE            		call	socket._trace
     533:  00:E176                      ;
     534:  00:E176  D5                  		push	de
     535:  00:E177  11 F9 D3            		 ld	de,trace.tcp.tx
     536:  00:E17A  CD 36 D0            		 call	io.str
     537:  00:E17D  D1                  		pop	de
     538:  00:E17E                      ;
     539:  00:E17E  D5                  		push	de
     540:  00:E17F  3E 07               		 ld	a,socket.vars.tx_size
     541:  00:E181  CD 0A DE            		 call	socket.get_word
     542:  00:E184  CD 2A D2            		 call	trace.bytes
     543:  00:E187  CD 36 D2            		 call	trace.dots
     544:  00:E18A  D1                  		pop	de
     545:  00:E18B                      ;
     546:  00:E18B  C3 4B DC            		jp	socket._send	; Do the send
     547:  00:E18E                      ;
     548:  00:E18E                      ;
     549:  00:E18E                      ;------------------------------------------------------------------------------
     550:  00:E18E                      ; connect
     551:  00:E18E                      ;
     552:  00:E18E                      ; Attempts to open a socket in client TCP mode ie attempts to open a TCP/IP
     553:  00:E18E                      ; link with a remote server
     554:  00:E18E                      ;
     555:  00:E18E                      ; In:   A=socket number
     556:  00:E18E                      ; Out: NC=>no error
     557:  00:E18E  CD 18 DA            connect:	call	socket.connect	; Attempt t connect
     558:  00:E191  D8                  		ret	c		; Error occured
     559:  00:E192                      ;
     560:  00:E192                      		SOCKET_GET_VAR socket.vars.tcp_connected; HL->tcp.connected
     560:  00:E192                    >    if (var)=0
     560:  00:E192                    ~     ld a,e
     560:  00:E192                    ~    else
     560:  00:E192  3E 04             >     ld a,(var)*2
     560:  00:E194  B3                >     or e
     560:  00:E195                    >    endif
     560:  00:E195  6F                >    ld l,a
     560:  00:E196  7A                >    ld a,d
     560:  00:E197  0F                >    rrca
     560:  00:E198  CB 1D             >    rr l
     560:  00:E19A  26 42             >    ld h,high vars.sockets
     561:  00:E19C  36 FF               		ld	(hl),0ffh	; NZ=>we are connected
     562:  00:E19E  B7                  		or	a		; NC=>no error
     563:  00:E19F  C9                  		ret
     564:  00:E1A0                      ;
     565:  00:E1A0                      ;
     566:  00:E1A0                      ;------------------------------------------------------------------------------
     567:  00:E1A0                      ; disconnect
     568:  00:E1A0                      ;
     569:  00:E1A0                      ; Attempts to disconnect a TCP/IP link.
     570:  00:E1A0                      ;
     571:  00:E1A0                      ; In:  A=socket number
     572:  00:E1A0                      ; Out: NC=>no error
     573:  00:E1A0                      ;
     574:  00:E1A0                      disconnect:	SOCKET_GET_BASE
     574:  00:E1A0  11 00 01          >    ld de,0100h
     574:  00:E1A3  0F                >    rrca
     574:  00:E1A4  CB 1B             >    rr e
     574:  00:E1A6  0F                >    rrca
     574:  00:E1A7  CB 1B             >    rr e
     574:  00:E1A9  0F                >    rrca
     574:  00:E1AA  CB 12             >    rl d
     575:  00:E1AC                      _disconnect:
     576:  00:E1AC  CD C0 E1            		call	.readall	; Make sure we have a rx window<>0
     577:  00:E1AF                      ;
     578:  00:E1AF                      		SOCKET_GET_VAR socket.vars.tcp_connected
     578:  00:E1AF                    >    if (var)=0
     578:  00:E1AF                    ~     ld a,e
     578:  00:E1AF                    ~    else
     578:  00:E1AF  3E 04             >     ld a,(var)*2
     578:  00:E1B1  B3                >     or e
     578:  00:E1B2                    >    endif
     578:  00:E1B2  6F                >    ld l,a
     578:  00:E1B3  7A                >    ld a,d
     578:  00:E1B4  0F                >    rrca
     578:  00:E1B5  CB 1D             >    rr l
     578:  00:E1B7  26 42             >    ld h,high vars.sockets
     579:  00:E1B9  36 00               		ld	(hl),0		; 0=>not connected any more
     580:  00:E1BB                      ;
     581:  00:E1BB  D5                  		push	de
     582:  00:E1BC  CD 5E DA            		 call	socket._disconnect	; Send disconnect
     583:  00:E1BF  D1                  		pop	de
     584:  00:E1C0                      ;
     585:  00:E1C0  3E 03               .readall:	ld	a,socket.vars.rx_size
     586:  00:E1C2  CD 0A DE            		call	socket.get_word	; HL=no. bytes left to read
     587:  00:E1C5  7C                  		ld	a,h
     588:  00:E1C6  B5                  		or	l		; See if we've started a read
     589:  00:E1C7  C4 B4 DB            		call	nz,socket._read_end	; Flush & finish if yes
     590:  00:E1CA                      ;
     591:  00:E1CA  CD 80 DF            		call	_header		; See if more packets waiting
     592:  00:E1CD  20 F1               		jr	nz,.readall	; Read them if yes
     593:  00:E1CF                      ;
     594:  00:E1CF  B7                  		or	a		; No error
     595:  00:E1D0  C9                  		ret
     596:  00:E1D1                      ;
     597:  00:E1D1                      ;
     598:  00:E1D1                      ;------------------------------------------------------------------------------
     599:  00:E1D1                      ; close
     600:  00:E1D1                      ;
     601:  00:E1D1                      ; Closes the socket
     602:  00:E1D1                      ;
     603:  00:E1D1                      ; In:  A=socket number
     604:  00:E1D1                      close:
     605:  00:E1D1  F5                  		push	af
     606:  00:E1D2                      		 SOCKET_GET_BASE
     606:  00:E1D2  11 00 01          >    ld de,0100h
     606:  00:E1D5  0F                >    rrca
     606:  00:E1D6  CB 1B             >    rr e
     606:  00:E1D8  0F                >    rrca
     606:  00:E1D9  CB 1B             >    rr e
     606:  00:E1DB  0F                >    rrca
     606:  00:E1DC  CB 12             >    rl d
     607:  00:E1DE                      ;
     608:  00:E1DE                      		 ; If there's an odd byte waiting to be written it needs to
     609:  00:E1DE                      		 ; be flushed, so we write a final dummy byte but decrement
     610:  00:E1DE                      		 ; the byte count after so it doesn't actually get sent
     611:  00:E1DE                      		 SOCKET_GET_VAR socket.vars.tx_inhand+1
     611:  00:E1DE                    >    if (var)=0
     611:  00:E1DE                    ~     ld a,e
     611:  00:E1DE                    ~    else
     611:  00:E1DE  3E 14             >     ld a,(var)*2
     611:  00:E1E0  B3                >     or e
     611:  00:E1E1                    >    endif
     611:  00:E1E1  6F                >    ld l,a
     611:  00:E1E2  7A                >    ld a,d
     611:  00:E1E3  0F                >    rrca
     611:  00:E1E4  CB 1D             >    rr l
     611:  00:E1E6  26 42             >    ld h,high vars.sockets
     612:  00:E1E8  7E                  		 ld	a,(hl)		; FF=>bufered byte
     613:  00:E1E9  3C                  		 inc	a
     614:  00:E1EA  20 19               		 jr	nz,.doneinhand
     615:  00:E1EC                      ;
     616:  00:E1EC  77                  		 ld	(hl),a		; Final dummy byte, 0 =>nothing inhand
     617:  00:E1ED  2B                  		 dec	hl		; Point to last user byte
     618:  00:E1EE  01 02 00            		 ld	bc,2
     619:  00:E1F1  CD F5 E0            		 call	_write_block	; Write final byte+dummy
     620:  00:E1F4                      ;		
     621:  00:E1F4                      		 SOCKET_GET_VAR socket.vars.tx_size
     621:  00:E1F4                    >    if (var)=0
     621:  00:E1F4                    ~     ld a,e
     621:  00:E1F4                    ~    else
     621:  00:E1F4  3E 0E             >     ld a,(var)*2
     621:  00:E1F6  B3                >     or e
     621:  00:E1F7                    >    endif
     621:  00:E1F7  6F                >    ld l,a
     621:  00:E1F8  7A                >    ld a,d
     621:  00:E1F9  0F                >    rrca
     621:  00:E1FA  CB 1D             >    rr l
     621:  00:E1FC  26 42             >    ld h,high vars.sockets
     622:  00:E1FE  7E                  		 ld	a,(hl)
     623:  00:E1FF  35                  		 dec	(hl)		; Dec tx_size so dummy isn't written
     624:  00:E200  B7                  		 or	a
     625:  00:E201  20 02               		 jr	nz,.doneinhand	; If LSB was 0 then must dec MSB
     626:  00:E203                      ;
     627:  00:E203  23                  		 inc	hl
     628:  00:E204  35                  		 dec	(hl)
     629:  00:E205                      .doneinhand:
     630:  00:E205                      		 ; Any odd byte at the end that was buffered in tx_inhand has
     631:  00:E205                      		 ; now been dealt with. Now need to actually send any bytes
     632:  00:E205                      		 ; that have been written to the WIZ chip but not yet sent
     633:  00:E205                      		 SOCKET_GET_VAR socket.vars.tx_size
     633:  00:E205                    >    if (var)=0
     633:  00:E205                    ~     ld a,e
     633:  00:E205                    ~    else
     633:  00:E205  3E 0E             >     ld a,(var)*2
     633:  00:E207  B3                >     or e
     633:  00:E208                    >    endif
     633:  00:E208  6F                >    ld l,a
     633:  00:E209  7A                >    ld a,d
     633:  00:E20A  0F                >    rrca
     633:  00:E20B  CB 1D             >    rr l
     633:  00:E20D  26 42             >    ld h,high vars.sockets
     634:  00:E20F  7E                  		 ld	a,(hl)
     635:  00:E210  23                  		 inc	hl
     636:  00:E211  B6                  		 or	(hl)
     637:  00:E212  C4 6C E1            		 call	nz,_send	; Ignore errors 'cos we're closing
     638:  00:E215                      ;
     639:  00:E215                      		 SOCKET_GET_VAR socket.vars.tcp_connected; Currently connected?
     639:  00:E215                    >    if (var)=0
     639:  00:E215                    ~     ld a,e
     639:  00:E215                    ~    else
     639:  00:E215  3E 04             >     ld a,(var)*2
     639:  00:E217  B3                >     or e
     639:  00:E218                    >    endif
     639:  00:E218  6F                >    ld l,a
     639:  00:E219  7A                >    ld a,d
     639:  00:E21A  0F                >    rrca
     639:  00:E21B  CB 1D             >    rr l
     639:  00:E21D  26 42             >    ld h,high vars.sockets
     640:  00:E21F  7E                  		 ld	a,(hl)		; NZ=>connected
     641:  00:E220  B7                  		 or	a
     642:  00:E221  D5                  		 push	de
     643:  00:E222  C4 AC E1            		  call	nz,_disconnect	; Disconnect before closing if yes
     644:  00:E225  D1                  		 pop	de
     645:  00:E226  F1                  		pop	af
     646:  00:E227                      ;
     647:  00:E227  CD A9 DC            		call	socket.close
     648:  00:E22A                      ;
     649:  00:E22A  FD CB 00 4E         		bit	vars.trace.socket,(iy+vars._trace)
     650:  00:E22E  C8                  		ret	z
     651:  00:E22F                      ;
     652:  00:E22F  C3 40 D2            		jp	trace.ok
     653:  00:E232                      ;
     654:  00:E232                      ;
     655:  00:E232                      		endmodule
     107.  00:E232                      	include dhcp.asm
       1:  00:E232                      ; DHCP
       2:  00:E232                      ;
       3:  00:E232                      ; Attempts to get IP address, subnet mask etc using the DHCP protocol.
       4:  00:E232                      ;
       5:  00:E232                      ;
       6:  00:E232                      		module	dhcp
       7:  00:E232                      ;
       8:  00:E232                      ;==============================================================================
       9:  00:E232                      ;
      10:  00:E232                      ; This file is part of the EPNET software
      11:  00:E232                      ;
      12:  00:E232                      ; Copyright (C) 2015  Bruce Tanner
      13:  00:E232                      ;
      14:  00:E232                      ;    This program is free software: you can redistribute it and/or modify
      15:  00:E232                      ;    it under the terms of the GNU General Public License as published by
      16:  00:E232                      ;    the Free Software Foundation, either version 3 of the License, or
      17:  00:E232                      ;    (at your option) any later version.
      18:  00:E232                      ;
      19:  00:E232                      ;    This program is distributed in the hope that it will be useful,
      20:  00:E232                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      21:  00:E232                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      22:  00:E232                      ;    GNU General Public License for more details.
      23:  00:E232                      ;
      24:  00:E232                      ;    You should have received a copy of the GNU General Public License
      25:  00:E232                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      26:  00:E232                      ;
      27:  00:E232                      ; If you do use or modify this file, either for its original purpose or for
      28:  00:E232                      ; something new, I'd love to hear about it! I can be contacted by email at:
      29:  00:E232                      ;
      30:  00:E232                      ; brucetanner@btopenworld.com
      31:  00:E232                      ;
      32:  00:E232                      ;==============================================================================
      33:  00:E232                      ;
      34:  00:E232                      ; For reference, this is the format of a DHCP packet (from RFC 2131):
      35:  00:E232                      ;
      36:  00:E232                      ;   0                   1                   2                   3
      37:  00:E232                      ;   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      38:  00:E232                      ;   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      39:  00:E232                      ;   |     op (1)    |   htype (1)   |   hlen (1)    |   hops (1)    |
      40:  00:E232                      ;   +---------------+---------------+---------------+---------------+
      41:  00:E232                      ;   |                            xid (4)                            |
      42:  00:E232                      ;   +-------------------------------+-------------------------------+
      43:  00:E232                      ;   |           secs (2)            |           flags (2)           |
      44:  00:E232                      ;   +-------------------------------+-------------------------------+
      45:  00:E232                      ;   |                          ciaddr  (4)                          |
      46:  00:E232                      ;   +---------------------------------------------------------------+
      47:  00:E232                      ;   |                          yiaddr  (4)                          |
      48:  00:E232                      ;   +---------------------------------------------------------------+
      49:  00:E232                      ;   |                          siaddr  (4)                          |
      50:  00:E232                      ;   +---------------------------------------------------------------+
      51:  00:E232                      ;   |                          giaddr  (4)                          |
      52:  00:E232                      ;   +---------------------------------------------------------------+
      53:  00:E232                      ;   |                          chaddr  (16)                         |
      54:  00:E232                      ;   +---------------------------------------------------------------+
      55:  00:E232                      ;   |                          sname   (64)                         |
      56:  00:E232                      ;   +---------------------------------------------------------------+
      57:  00:E232                      ;   |                          file    (128)                        |
      58:  00:E232                      ;   +---------------------------------------------------------------+
      59:  00:E232                      ;   |                          options (variable)                   |
      60:  00:E232                      ;   +---------------------------------------------------------------+
      61:  00:E232                      ;
      62:  00:E232                      ;   FIELD      OCTETS       DESCRIPTION
      63:  00:E232                      ;   -----      ------       -----------
      64:  00:E232                      ;
      65:  00:E232                      ;   op            1  Message op code / message type.
      66:  00:E232                      ;                    1 = BOOTREQUEST, 2 = BOOTREPLY
      67:  00:E232                      ;   htype         1  Hardware address type, see ARP section in "Assigned
      68:  00:E232                      ;                    Numbers" RFC; e.g., '1' = 10mb ethernet.
      69:  00:E232                      ;   hlen          1  Hardware address length (e.g.  '6' for 10mb
      70:  00:E232                      ;                    ethernet).
      71:  00:E232                      ;   hops          1  Client sets to zero, optionally used by relay agents
      72:  00:E232                      ;                    when booting via a relay agent.
      73:  00:E232                      ;   xid           4  Transaction ID, a random number chosen by the
      74:  00:E232                      ;                    client, used by the client and server to associate
      75:  00:E232                      ;                    messages and responses between a client and a
      76:  00:E232                      ;                    server.
      77:  00:E232                      ;   secs          2  Filled in by client, seconds elapsed since client
      78:  00:E232                      ;                    began address acquisition or renewal process.
      79:  00:E232                      ;   flags         2  Flags (see figure 2).
      80:  00:E232                      ;   ciaddr        4  Client IP address; only filled in if client is in
      81:  00:E232                      ;                    BOUND, RENEW or REBINDING state and can respond
      82:  00:E232                      ;                    to ARP requests.
      83:  00:E232                      ;   yiaddr        4  'your' (client) IP address.
      84:  00:E232                      ;   siaddr        4  IP address of next server to use in bootstrap;
      85:  00:E232                      ;                    returned in DHCPOFFER, DHCPACK by server.
      86:  00:E232                      ;   giaddr        4  Relay agent IP address, used in booting via a
      87:  00:E232                      ;                    relay agent.
      88:  00:E232                      ;   chaddr       16  Client hardware address.
      89:  00:E232                      ;   sname        64  Optional server host name, null terminated string.
      90:  00:E232                      ;   file        128  Boot file name, null terminated string; "generic"
      91:  00:E232                      ;                    name or null in DHCPDISCOVER, fully qualified
      92:  00:E232                      ;                    directory-path name in DHCPOFFER.
      93:  00:E232                      ;   options     var  Optional parameters field.  See the options
      94:  00:E232                      ;                    documents for a list of defined options.
      95:  00:E232                      ;
      96:  00:E232  (00:0001)           DHCP_OP.BOOTREQUEST	equ	1
      97:  00:E232  (00:0002)           DHCP_OP.BOOTREPLY	equ	2
      98:  00:E232                      ;
      99:  00:E232  (00:0001)           DHCP_HTYPE.10MB		equ	1
     100:  00:E232  (00:0002)           DHCP_HTYPE.100MB	equ	2
     101:  00:E232                      ;
     102:  00:E232  (00:0006)           DHCP_HLEN.ETHERNET	equ	6
     103:  00:E232  (00:0000)           DHCP.HOPS		equ	0
     104:  00:E232  (00:8000)           DHCP_FLAGS.BROADCAST	equ	8000h
     105:  00:E232                      ;
     106:  00:E232                      ;
     107:  00:E232                      ; The "options" field is variable length and consists of zero or more options
     108:  00:E232                      ; (from RFC 2132, options we don't use omitted):
     109:  00:E232                      ;
     110:  00:E232                      ; 3.1. Pad Option
     111:  00:E232                      ;
     112:  00:E232                      ; The pad option can be used to cause subsequent fields to align on
     113:  00:E232                      ; word boundaries.
     114:  00:E232                      ;
     115:  00:E232                      ;   The code for the pad option is 0, and its length is 1 octet.
     116:  00:E232                      ;
     117:  00:E232                      ;    Code
     118:  00:E232                      ;   +-----+
     119:  00:E232                      ;   |  0  |
     120:  00:E232                      ;   +-----+
     121:  00:E232                      ;
     122:  00:E232  (00:0000)           DHCP_OPT.PAD		equ	0
     123:  00:E232                      ;
     124:  00:E232                      ;
     125:  00:E232                      ; 3.2. End Option
     126:  00:E232                      ;
     127:  00:E232                      ;   The end option marks the end of valid information in the vendor
     128:  00:E232                      ;   field.  Subsequent octets should be filled with pad options.
     129:  00:E232                      ;
     130:  00:E232                      ;   The code for the end option is 255, and its length is 1 octet.
     131:  00:E232                      ;
     132:  00:E232                      ;    Code
     133:  00:E232                      ;   +-----+
     134:  00:E232                      ;   | 255 |
     135:  00:E232                      ;   +-----+
     136:  00:E232                      ;
     137:  00:E232  (00:00FF)           DHCP_OPT.END		equ	255
     138:  00:E232                      ;
     139:  00:E232                      ;
     140:  00:E232                      ; 3.3. Subnet Mask
     141:  00:E232                      ;
     142:  00:E232                      ;   The subnet mask option specifies the client's subnet mask as per RFC
     143:  00:E232                      ;   950 [5].
     144:  00:E232                      ;
     145:  00:E232                      ;   If both the subnet mask and the router option are specified in a DHCP
     146:  00:E232                      ;   reply, the subnet mask option MUST be first.
     147:  00:E232                      ;
     148:  00:E232                      ;   The code for the subnet mask option is 1, and its length is 4 octets.
     149:  00:E232                      ;
     150:  00:E232                      ;    Code   Len        Subnet Mask
     151:  00:E232                      ;   +-----+-----+-----+-----+-----+-----+
     152:  00:E232                      ;   |  1  |  4  |  m1 |  m2 |  m3 |  m4 |
     153:  00:E232                      ;   +-----+-----+-----+-----+-----+-----+
     154:  00:E232                      ;
     155:  00:E232  (00:0001)           DHCP_OPT.SUBNET		equ	1
     156:  00:E232                      ;
     157:  00:E232                      ;
     158:  00:E232                      ; 3.4. Time Offset
     159:  00:E232                      ;
     160:  00:E232                      ;   The time offset field specifies the offset of the client's subnet in
     161:  00:E232                      ;   seconds from Coordinated Universal Time (UTC).  The offset is
     162:  00:E232                      ;   expressed as a two's complement 32-bit integer.  A positive offset
     163:  00:E232                      ;   indicates a location east of the zero meridian and a negative offset
     164:  00:E232                      ;   indicates a location west of the zero meridian.
     165:  00:E232                      ;
     166:  00:E232                      ;   The code for the time offset option is 2, and its length is 4 octets.
     167:  00:E232                      ;
     168:  00:E232                      ;    Code   Len        Time Offset
     169:  00:E232                      ;   +-----+-----+-----+-----+-----+-----+
     170:  00:E232                      ;   |  2  |  4  |  n1 |  n2 |  n3 |  n4 |
     171:  00:E232                      ;   +-----+-----+-----+-----+-----+-----+
     172:  00:E232                      ;
     173:  00:E232                      ; 3.5. Router Option
     174:  00:E232                      ;
     175:  00:E232                      ;   The router option specifies a list of IP addresses for routers on the
     176:  00:E232                      ;   client's subnet.  Routers SHOULD be listed in order of preference.
     177:  00:E232                      ;
     178:  00:E232                      ;   The code for the router option is 3.  The minimum length for the
     179:  00:E232                      ;   router option is 4 octets, and the length MUST always be a multiple
     180:  00:E232                      ;   of 4.
     181:  00:E232                      ;
     182:  00:E232                      ;    Code   Len         Address 1               Address 2
     183:  00:E232                      ;   +-----+-----+-----+-----+-----+-----+-----+-----+--
     184:  00:E232                      ;   |  3  |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
     185:  00:E232                      ;   +-----+-----+-----+-----+-----+-----+-----+-----+--
     186:  00:E232                      ;
     187:  00:E232  (00:0003)           DHCP_OPT.ROUTER		equ	3
     188:  00:E232                      ;
     189:  00:E232                      ;
     190:  00:E232                      ; 3.6. Time Server Option
     191:  00:E232                      ;
     192:  00:E232                      ;   The time server option specifies a list of RFC 868 [6] time servers
     193:  00:E232                      ;   available to the client.  Servers SHOULD be listed in order of
     194:  00:E232                      ;   preference.
     195:  00:E232                      ;
     196:  00:E232                      ;   The code for the time server option is 4.  The minimum length for
     197:  00:E232                      ;   this option is 4 octets, and the length MUST always be a multiple of
     198:  00:E232                      ;   4.
     199:  00:E232                      ;
     200:  00:E232                      ;    Code   Len         Address 1               Address 2
     201:  00:E232                      ;   +-----+-----+-----+-----+-----+-----+-----+-----+--
     202:  00:E232                      ;   |  4  |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
     203:  00:E232                      ;   +-----+-----+-----+-----+-----+-----+-----+-----+--
     204:  00:E232                      ;
     205:  00:E232                      ;
     206:  00:E232                      ; 3.7. Name Server Option
     207:  00:E232                      ;
     208:  00:E232                      ;   The name server option specifies a list of IEN 116 [7] name servers
     209:  00:E232                      ;   available to the client.  Servers SHOULD be listed in order of
     210:  00:E232                      ;   preference.
     211:  00:E232                      ;
     212:  00:E232                      ;   The code for the name server option is 5.  The minimum length for
     213:  00:E232                      ;   this option is 4 octets, and the length MUST always be a multiple of
     214:  00:E232                      ;   4.
     215:  00:E232                      ;
     216:  00:E232                      ;    Code   Len         Address 1               Address 2
     217:  00:E232                      ;   +-----+-----+-----+-----+-----+-----+-----+-----+--
     218:  00:E232                      ;   |  5  |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
     219:  00:E232                      ;   +-----+-----+-----+-----+-----+-----+-----+-----+--
     220:  00:E232                      ;
     221:  00:E232                      ;
     222:  00:E232                      ; 3.8. Domain Name Server Option
     223:  00:E232                      ;
     224:  00:E232                      ;   The domain name server option specifies a list of Domain Name System
     225:  00:E232                      ;   (STD 13, RFC 1035 [8]) name servers available to the client.  Servers
     226:  00:E232                      ;   SHOULD be listed in order of preference.
     227:  00:E232                      ;
     228:  00:E232                      ;   The code for the domain name server option is 6.  The minimum length
     229:  00:E232                      ;   for this option is 4 octets, and the length MUST always be a multiple
     230:  00:E232                      ;   of 4.
     231:  00:E232                      ;
     232:  00:E232                      ;    Code   Len         Address 1               Address 2
     233:  00:E232                      ;   +-----+-----+-----+-----+-----+-----+-----+-----+--
     234:  00:E232                      ;   |  6  |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
     235:  00:E232                      ;   +-----+-----+-----+-----+-----+-----+-----+-----+--
     236:  00:E232                      ;
     237:  00:E232  (00:0006)           DHCP_OPT.DNS		equ	6
     238:  00:E232                      ;
     239:  00:E232                      ;
     240:  00:E232                      ; 3.14. Host Name Option
     241:  00:E232                      ;
     242:  00:E232                      ;   This option specifies the name of the client.  The name may or may
     243:  00:E232                      ;   not be qualified with the local domain name (see section 3.17 for the
     244:  00:E232                      ;   preferred way to retrieve the domain name).  See RFC 1035 for
     245:  00:E232                      ;   character set restrictions.
     246:  00:E232                      ;
     247:  00:E232                      ;   The code for this option is 12, and its minimum length is 1.
     248:  00:E232                      ;
     249:  00:E232                      ;    Code   Len                 Host Name
     250:  00:E232                      ;   +-----+-----+-----+-----+-----+-----+-----+-----+--
     251:  00:E232                      ;   |  12 |  n  |  h1 |  h2 |  h3 |  h4 |  h5 |  h6 |  ...
     252:  00:E232                      ;   +-----+-----+-----+-----+-----+-----+-----+-----+--
     253:  00:E232                      ;
     254:  00:E232  (00:000C)           DHCP_OPT.HOST		equ	12
     255:  00:E232                      ;
     256:  00:E232                      ;
     257:  00:E232                      ; 3.17. Domain Name
     258:  00:E232                      ;
     259:  00:E232                      ;   This option specifies the domain name that client should use when
     260:  00:E232                      ;   resolving hostnames via the Domain Name System.
     261:  00:E232                      ;
     262:  00:E232                      ;   The code for this option is 15.  Its minimum length is 1.
     263:  00:E232                      ;
     264:  00:E232                      ;    Code   Len        Domain Name
     265:  00:E232                      ;   +-----+-----+-----+-----+-----+-----+--
     266:  00:E232                      ;   |  15 |  n  |  d1 |  d2 |  d3 |  d4 |  ...
     267:  00:E232                      ;   +-----+-----+-----+-----+-----+-----+--
     268:  00:E232                      ;
     269:  00:E232  (00:000F)           DHCP_OPT.DOMAIN		equ	15
     270:  00:E232                      ;
     271:  00:E232                      ;
     272:  00:E232                      ; 8.3. Network Time Protocol Servers Option
     273:  00:E232                      ;
     274:  00:E232                      ;   This option specifies a list of IP addresses indicating NTP [18]
     275:  00:E232                      ;   servers available to the client.  Servers SHOULD be listed in order
     276:  00:E232                      ;   of preference.
     277:  00:E232                      ;
     278:  00:E232                      ;   The code for this option is 42.  Its minimum length is 4, and the
     279:  00:E232                      ;   length MUST be a multiple of 4.
     280:  00:E232                      ;
     281:  00:E232                      ;    Code   Len         Address 1               Address 2
     282:  00:E232                      ;   +-----+-----+-----+-----+-----+-----+-----+-----+--
     283:  00:E232                      ;   |  42 |  n  |  a1 |  a2 |  a3 |  a4 |  a1 |  a2 |  ...
     284:  00:E232                      ;   +-----+-----+-----+-----+-----+-----+-----+-----+--
     285:  00:E232                      ;
     286:  00:E232  (00:002A)           DHCP_OPT.NTP		equ	42
     287:  00:E232                      ;
     288:  00:E232                      ;
     289:  00:E232                      ; 9.1. Requested IP Address
     290:  00:E232                      ;
     291:  00:E232                      ;   This option is used in a client request (DHCPDISCOVER) to allow the
     292:  00:E232                      ;   client to request that a particular IP address be assigned.
     293:  00:E232                      ;
     294:  00:E232                      ;   The code for this option is 50, and its length is 4.
     295:  00:E232                      ;
     296:  00:E232                      ;    Code   Len          Address
     297:  00:E232                      ;   +-----+-----+-----+-----+-----+-----+
     298:  00:E232                      ;   |  50 |  4  |  a1 |  a2 |  a3 |  a4 |
     299:  00:E232                      ;   +-----+-----+-----+-----+-----+-----+
     300:  00:E232                      ;
     301:  00:E232  (00:0032)           DHCP_OPT.IP		equ	50
     302:  00:E232                      ;
     303:  00:E232                      ;
     304:  00:E232                      ; 9.2. IP Address Lease Time
     305:  00:E232                      ;
     306:  00:E232                      ;   This option is used in a client request (DHCPDISCOVER or DHCPREQUEST)
     307:  00:E232                      ;   to allow the client to request a lease time for the IP address.  In a
     308:  00:E232                      ;   server reply (DHCPOFFER), a DHCP server uses this option to specify
     309:  00:E232                      ;   the lease time it is willing to offer.
     310:  00:E232                      ;
     311:  00:E232                      ;   The time is in units of seconds, and is specified as a 32-bit
     312:  00:E232                      ;   unsigned integer.
     313:  00:E232                      ;
     314:  00:E232                      ;   The code for this option is 51, and its length is 4.
     315:  00:E232                      ;
     316:  00:E232                      ;    Code   Len         Lease Time
     317:  00:E232                      ;   +-----+-----+-----+-----+-----+-----+
     318:  00:E232                      ;   |  51 |  4  |  t1 |  t2 |  t3 |  t4 |
     319:  00:E232                      ;   +-----+-----+-----+-----+-----+-----+
     320:  00:E232                      ;
     321:  00:E232  (00:0033)           DHCP_OPT.LEASE		equ	51
     322:  00:E232                      ;
     323:  00:E232                      ;
     324:  00:E232                      ; 9.6. DHCP Message Type
     325:  00:E232                      ;
     326:  00:E232                      ;   This option is used to convey the type of the DHCP message.  The code
     327:  00:E232                      ;   for this option is 53, and its length is 1.  Legal values for this
     328:  00:E232                      ;   option are:
     329:  00:E232                      ;
     330:  00:E232                      ;           Value   Message Type
     331:  00:E232                      ;           -----   ------------
     332:  00:E232                      ;             1     DHCPDISCOVER
     333:  00:E232                      ;             2     DHCPOFFER
     334:  00:E232                      ;             3     DHCPREQUEST
     335:  00:E232                      ;             4     DHCPDECLINE
     336:  00:E232                      ;             5     DHCPACK
     337:  00:E232                      ;             6     DHCPNAK
     338:  00:E232                      ;             7     DHCPRELEASE
     339:  00:E232                      ;             8     DHCPINFORM
     340:  00:E232                      ;
     341:  00:E232                      ;    Code   Len  Type
     342:  00:E232                      ;   +-----+-----+-----+
     343:  00:E232                      ;   |  53 |  1  | 1-9 |
     344:  00:E232                      ;   +-----+-----+-----+
     345:  00:E232                      ;
     346:  00:E232  (00:0035)           DHCP_OPT.TYPE		equ	53
     347:  00:E232                      ;
     348:  00:E232  (00:0001)           DHCP_TYPE.DISCOVER	equ	1
     349:  00:E232  (00:0002)           DHCP_TYPE.OFFER		equ	2
     350:  00:E232  (00:0003)           DHCP_TYPE.REQUEST	equ	3
     351:  00:E232  (00:0004)           DHCP_TYPE.DECLINE	equ	4
     352:  00:E232  (00:0005)           DHCP_TYPE.ACK		equ	5
     353:  00:E232  (00:0006)           DHCP_TYPE.NAK		equ	6
     354:  00:E232  (00:0007)           DHCP_TYPE.RELEASE	equ	7
     355:  00:E232  (00:0008)           DHCP_TYPE.INFORM	equ	8
     356:  00:E232                      ;
     357:  00:E232                      ;
     358:  00:E232                      ; 9.7. Server Identifier
     359:  00:E232                      ;
     360:  00:E232                      ;   This option is used in DHCPOFFER and DHCPREQUEST messages, and may
     361:  00:E232                      ;   optionally be included in the DHCPACK and DHCPNAK messages.  DHCP
     362:  00:E232                      ;   servers include this option in the DHCPOFFER in order to allow the
     363:  00:E232                      ;   client to distinguish between lease offers.  DHCP clients use the
     364:  00:E232                      ;   contents of the 'server identifier' field as the destination address
     365:  00:E232                      ;   for any DHCP messages unicast to the DHCP server.  DHCP clients also
     366:  00:E232                      ;   indicate which of several lease offers is being accepted by including
     367:  00:E232                      ;   this option in a DHCPREQUEST message.
     368:  00:E232                      ;
     369:  00:E232                      ;   The identifier is the IP address of the selected server.
     370:  00:E232                      ;
     371:  00:E232                      ;   The code for this option is 54, and its length is 4.
     372:  00:E232                      ;
     373:  00:E232                      ;    Code   Len            Address
     374:  00:E232                      ;   +-----+-----+-----+-----+-----+-----+
     375:  00:E232                      ;   |  54 |  4  |  a1 |  a2 |  a3 |  a4 |
     376:  00:E232                      ;   +-----+-----+-----+-----+-----+-----+
     377:  00:E232                      ;
     378:  00:E232  (00:0036)           DHCP_OPT.SERVER		equ	54
     379:  00:E232                      ;
     380:  00:E232                      ;
     381:  00:E232                      ; 9.8. Parameter Request List
     382:  00:E232                      ;
     383:  00:E232                      ;   This option is used by a DHCP client to request values for specified
     384:  00:E232                      ;   configuration parameters.  The list of requested parameters is
     385:  00:E232                      ;   specified as n octets, where each octet is a valid DHCP option code
     386:  00:E232                      ;   as defined in this document.
     387:  00:E232                      ;
     388:  00:E232                      ;   The client MAY list the options in order of preference.  The DHCP
     389:  00:E232                      ;   server is not required to return the options in the requested order,
     390:  00:E232                      ;   but MUST try to insert the requested options in the order requested
     391:  00:E232                      ;   by the client.
     392:  00:E232                      ;
     393:  00:E232                      ;   The code for this option is 55.  Its minimum length is 1.
     394:  00:E232                      ;
     395:  00:E232                      ;    Code   Len   Option Codes
     396:  00:E232                      ;   +-----+-----+-----+-----+---
     397:  00:E232                      ;   |  55 |  n  |  c1 |  c2 | ...
     398:  00:E232                      ;   +-----+-----+-----+-----+---
     399:  00:E232                      ;
     400:  00:E232  (00:0037)           DHCP_OPT.PARAM		equ	55
     401:  00:E232                      ;
     402:  00:E232                      ;
     403:  00:E232                      ; 9.9. Message
     404:  00:E232                      ;
     405:  00:E232                      ;   This option is used by a DHCP server to provide an error message to a
     406:  00:E232                      ;   DHCP client in a DHCPNAK message in the event of a failure. A client
     407:  00:E232                      ;   may use this option in a DHCPDECLINE message to indicate the why the
     408:  00:E232                      ;   client declined the offered parameters.  The message consists of n
     409:  00:E232                      ;   octets of NVT ASCII text, which the client may display on an
     410:  00:E232                      ;   available output device.
     411:  00:E232                      ;
     412:  00:E232                      ;   The code for this option is 56 and its minimum length is 1.
     413:  00:E232                      ;
     414:  00:E232                      ;    Code   Len     Text
     415:  00:E232                      ;   +-----+-----+-----+-----+---
     416:  00:E232                      ;   |  56 |  n  |  c1 |  c2 | ...
     417:  00:E232                      ;   +-----+-----+-----+-----+---
     418:  00:E232                      ;
     419:  00:E232                      ;
     420:  00:E232                      ; 9.11. Renewal (T1) Time Value
     421:  00:E232                      ;
     422:  00:E232                      ;   This option specifies the time interval from address assignment until
     423:  00:E232                      ;   the client transitions to the RENEWING state.
     424:  00:E232                      ;
     425:  00:E232                      ;   The value is in units of seconds, and is specified as a 32-bit
     426:  00:E232                      ;   unsigned integer.
     427:  00:E232                      ;
     428:  00:E232                      ;   The code for this option is 58, and its length is 4.
     429:  00:E232                      ;
     430:  00:E232                      ;    Code   Len         T1 Interval
     431:  00:E232                      ;   +-----+-----+-----+-----+-----+-----+
     432:  00:E232                      ;   |  58 |  4  |  t1 |  t2 |  t3 |  t4 |
     433:  00:E232                      ;   +-----+-----+-----+-----+-----+-----+
     434:  00:E232                      ;
     435:  00:E232  (00:003A)           DHCP_OPT.T1		equ	58
     436:  00:E232                      ;
     437:  00:E232                      ;
     438:  00:E232                      ; 9.12. Rebinding (T2) Time Value
     439:  00:E232                      ;
     440:  00:E232                      ;   This option specifies the time interval from address assignment until
     441:  00:E232                      ;   the client transitions to the REBINDING state.
     442:  00:E232                      ;
     443:  00:E232                      ;   The value is in units of seconds, and is specified as a 32-bit
     444:  00:E232                      ;   unsigned integer.
     445:  00:E232                      ;
     446:  00:E232                      ;   The code for this option is 59, and its length is 4.
     447:  00:E232                      ;
     448:  00:E232                      ;    Code   Len         T2 Interval
     449:  00:E232                      ;   +-----+-----+-----+-----+-----+-----+
     450:  00:E232                      ;   |  59 |  4  |  t1 |  t2 |  t3 |  t4 |
     451:  00:E232                      ;   +-----+-----+-----+-----+-----+-----+
     452:  00:E232                      ;
     453:  00:E232  (00:003B)           DHCP_OPT.T2		equ	59
     454:  00:E232                      ;
     455:  00:E232                      ;
     456:  00:E232                      ; 9.14. Client-identifier
     457:  00:E232                      ;
     458:  00:E232                      ;   This option is used by DHCP clients to specify their unique
     459:  00:E232                      ;   identifier.  DHCP servers use this value to index their database of
     460:  00:E232                      ;   address bindings.  This value is expected to be unique for all
     461:  00:E232                      ;   clients in an administrative domain.
     462:  00:E232                      ;
     463:  00:E232                      ;   Identifiers SHOULD be treated as opaque objects by DHCP servers.
     464:  00:E232                      ;
     465:  00:E232                      ;   The client identifier MAY consist of type-value pairs similar to the
     466:  00:E232                      ;   'htype'/'chaddr' fields defined in [3]. For instance, it MAY consist
     467:  00:E232                      ;   of a hardware type and hardware address. In this case the type field
     468:  00:E232                      ;   SHOULD be one of the ARP hardware types defined in STD2 [22].  A
     469:  00:E232                      ;   hardware type of 0 (zero) should be used when the value field
     470:  00:E232                      ;   contains an identifier other than a hardware address (e.g. a fully
     471:  00:E232                      ;   qualified domain name).
     472:  00:E232                      ;
     473:  00:E232                      ;   For correct identification of clients, each client's client-
     474:  00:E232                      ;   identifier MUST be unique among the client-identifiers used on the
     475:  00:E232                      ;   subnet to which the client is attached.  Vendors and system
     476:  00:E232                      ;   administrators are responsible for choosing client-identifiers that
     477:  00:E232                      ;   meet this requirement for uniqueness.
     478:  00:E232                      ;
     479:  00:E232                      ;   The code for this option is 61, and its minimum length is 2.
     480:  00:E232                      ;
     481:  00:E232                      ;   Code   Len   Type  Client-Identifier
     482:  00:E232                      ;   +-----+-----+-----+-----+-----+---
     483:  00:E232                      ;   |  61 |  n  |  t1 |  i1 |  i2 | ...
     484:  00:E232                      ;   +-----+-----+-----+-----+-----+---
     485:  00:E232                      ;
     486:  00:E232  (00:003D)           DHCP_OPT.CLIENT		equ	61
     487:  00:E232                      ;
     488:  00:E232                      ;==============================================================================
     489:  00:E232                      ;
     490:  00:E232  (00:0043)           DHCP_SERVER_PORT	equ	67	; Standard fixed port numbers used
     491:  00:E232  (00:0044)           DHCP_CLIENT_PORT	equ	68	;   for DHCP
     492:  00:E232                      ;
     493:  00:E232                      ;
     494:  00:E232                      ;
     495:  00:E232                      ; init
     496:  00:E232                      ;
     497:  00:E232                      ; Starts the whole DHCP process. If we have not yet been initialized, we do
     498:  00:E232                      ; the DHCP process. If we have been initialized, we check whether the lease
     499:  00:E232                      ; time has expired.
     500:  00:E232                      ;
     501:  00:E232                      ; Out: NC=>ok
     502:  00:E232                      init:
     503:  00:E232  FD CB 03 4E         		bit	vars.init.dhcp,(iy+vars._init)	; Initialized?
     504:  00:E236  28 11               		jr	z,.do_dhcp			; Go if not
     505:  00:E238                      ;
     506:  00:E238  B7                  		or	a
     507:  00:E239  FD CB 03 56         		bit	vars.init.lease,(iy+vars._init)	; Got a lease?
     508:  00:E23D  C8                  		ret	z				; Just return NC if not
     509:  00:E23E                      ;
     510:  00:E23E  21 41 40            		ld	hl,vars.dhcp.lease	; See if lease has expired
     511:  00:E241  06 04               		ld	b,4
     512:  00:E243  AF                  		xor	a
     513:  00:E244  B6                  .loop:		or	(hl)
     514:  00:E245  C0                  		ret	nz
     515:  00:E246                      ;
     516:  00:E246  23                  		inc	hl
     517:  00:E247  10 FB               		djnz	.loop
     518:  00:E249                      ;
     519:  00:E249                      		; Lease count has gone to 0 so renew DHCP params
     520:  00:E249                      ;
     521:  00:E249  FD CB 03 8E         .do_dhcp:	res	vars.init.dhcp,(iy+vars._init)	; Not initialized
     522:  00:E24D  FD CB 03 96         		res	vars.init.lease,(iy+vars._init)	; No lease time
     523:  00:E251                      
     524:  00:E251  11 48 D3            		ld	de,trace.diag.dhcp
     525:  00:E254  CD E9 D1            		call	trace.diag.str
     526:  00:E257                      ;
     527:  00:E257  FD CB 00 56         		bit	vars.trace.dhcp,(iy+vars._trace)
     528:  00:E25B  28 09               		jr	z,.donetrace
     529:  00:E25D                      ;		
     530:  00:E25D  CD 1C D0            		call	io.start
     531:  00:E260  11 1C D4            		ld	de,trace.dhcp.start
     532:  00:E263  CD 36 D0            		call	io.str
     533:  00:E266                      .donetrace:
     534:  00:E266                      ;
     535:  00:E266  CD AE D0            		call	status.start		; Start status line blob
     536:  00:E269                      ;		
     537:  00:E269  AF                  		xor	a			; We always start with xid=0
     538:  00:E26A  ED 62               		sbc	hl,hl
     539:  00:E26C  22 49 40            		ld	(vars.dhcp.xid),hl
     540:  00:E26F  22 4B 40            		ld	(vars.dhcp.xid+2),hl
     541:  00:E272                      ;
     542:  00:E272  22 4D 40            		ld	(vars.dhcp.secs),hl
     543:  00:E275                      ;
     544:  00:E275  32 28 40            		ld	(vars.dhcp.retries),a
     545:  00:E278  18 05               		jr	donetrace
     546:  00:E27A                      
     547:  00:E27A  CD A8 DC            restart:	call	socket.close_0
     548:  00:E27D  38 14               		jr	c,init.error
     549:  00:E27F                      
     550:  00:E27F  21 29 40            donetrace:	ld	hl,vars.dhcp.values	; Clear DHCP values
     551:  00:E282  01 20 00            		ld	bc,vars.dhcp.values_size
     552:  00:E285  CD 20 D1            		call	util.memzero
     553:  00:E288                      ;
     554:  00:E288  11 EA E6            		ld	de,owner_str		; Our name
     555:  00:E28B  21 44 00            		ld	hl,DHCP_CLIENT_PORT	; Always use this port
     556:  00:E28E  CD DA DE            		call	udp.open_0		; Open socket
     557:  00:E291  30 0F               		jr	nc,init.startok
     558:  00:E293                      ;
     559:  00:E293  FD CB 00 56         init.error:	bit	vars.trace.dhcp,(iy+vars._trace)
     560:  00:E297  C4 4D D2            		call	nz,trace.error
     561:  00:E29A                      ;
     562:  00:E29A  CD A8 DC            init.abort:	call	socket.close_0
     563:  00:E29D  CD A2 D0            		call	status.stop		; Restore status line
     564:  00:E2A0  37                  		scf
     565:  00:E2A1  C9                  		ret
     566:  00:E2A2                      ;
     567:  00:E2A2  FD CB 00 56         init.startok:	bit	vars.trace.dhcp,(iy+vars._trace)
     568:  00:E2A6  C4 40 D2            		call	nz,trace.ok
     569:  00:E2A9                      ;
     570:  00:E2A9                      start:		; Inc the current transaction id. But for simplicity we just
     571:  00:E2A9                      		; always use top word = 0
     572:  00:E2A9  2A 49 40            		ld	hl,(vars.dhcp.xid)	; We don't bother with the top
     573:  00:E2AC  23                  		inc	hl			;   word of 32-bit xid, always
     574:  00:E2AD  22 49 40            		ld	(vars.dhcp.xid),hl	;   0
     575:  00:E2B0  B7                  		or	a
     576:  00:E2B1  ED 62               		sbc	hl,hl
     577:  00:E2B3  22 4B 40            		ld	(vars.dhcp.xid+2),hl
     578:  00:E2B6                      ;
     579:  00:E2B6  FD CB 00 56         		bit	vars.trace.dhcp,(iy+vars._trace)
     580:  00:E2BA  28 12               		jr	z,.donetrace
     581:  00:E2BC                      ;
     582:  00:E2BC  CD 1C D0            		call	io.start
     583:  00:E2BF  11 2A D4            		ld	de,trace.dhcp.discover
     584:  00:E2C2  CD 36 D0            		call	io.str
     585:  00:E2C5  2A 49 40            		ld	hl,(vars.dhcp.xid)
     586:  00:E2C8  CD AA CF            		call	io.int
     587:  00:E2CB  CD 36 D2            		call	trace.dots
     588:  00:E2CE                      .donetrace:
     589:  00:E2CE                      ;
     590:  00:E2CE  3A 28 40            		ld	a,(vars.dhcp.retries)
     591:  00:E2D1  3C                  		inc	a
     592:  00:E2D2  32 28 40            		ld	(vars.dhcp.retries),a
     593:  00:E2D5  FE 0A               		cp	10
     594:  00:E2D7  30 BA               		jr	nc,init.error		; Try 10 times, then give up
     595:  00:E2D9                      ;
     596:  00:E2D9  3E 01               		ld	a,DHCP_TYPE.DISCOVER
     597:  00:E2DB  CD 48 E3            		call	send
     598:  00:E2DE  38 B3               		jr	c,init.error
     599:  00:E2E0                      ;
     600:  00:E2E0  CD 41 E4            		call	read
     601:  00:E2E3  38 B5               		jr	c,init.abort
     602:  00:E2E5                      ;
     603:  00:E2E5  FE 02               		cp	DHCP_TYPE.OFFER
     604:  00:E2E7  20 91               		jr	nz,restart
     605:  00:E2E9                      ;
     606:  00:E2E9  2A 4F 40            		ld	hl,(vars.dhcp.packet_xid)
     607:  00:E2EC  22 49 40            		ld	(vars.dhcp.xid),hl
     608:  00:E2EF  2A 51 40            		ld	hl,(vars.dhcp.packet_xid+2); Use offer's xid
     609:  00:E2F2  22 4B 40            		ld	(vars.dhcp.xid+2),hl
     610:  00:E2F5                      ;
     611:  00:E2F5  FD CB 00 56         		bit	vars.trace.dhcp,(iy+vars._trace)
     612:  00:E2F9  28 12               		jr	z,.dontr2
     613:  00:E2FB                      
     614:  00:E2FB  CD 1C D0            		call	io.start
     615:  00:E2FE  11 3C D4            		ld	de,trace.dhcp.request
     616:  00:E301  CD 36 D0            		call	io.str
     617:  00:E304  2A 49 40            		ld	hl,(vars.dhcp.xid)
     618:  00:E307  CD AA CF            		call	io.int
     619:  00:E30A  CD 36 D2            		call	trace.dots
     620:  00:E30D                      .dontr2:
     621:  00:E30D                      ;
     622:  00:E30D  3E 03               		ld	a,DHCP_TYPE.REQUEST
     623:  00:E30F  CD 48 E3            		call	send
     624:  00:E312  DA 93 E2            		jp	c,init.error
     625:  00:E315                      ;
     626:  00:E315  CD 41 E4            		call	read
     627:  00:E318  DA 9A E2            		jp	c,init.abort
     628:  00:E31B                      ;
     629:  00:E31B  FE 05               		cp	DHCP_TYPE.ACK
     630:  00:E31D  C2 7A E2            		jp	nz,restart
     631:  00:E320                      ;
     632:  00:E320  11 B0 D4            		ld	de,trace.dhcp.end
     633:  00:E323  FD CB 00 56         		bit	vars.trace.dhcp,(iy+vars._trace)
     634:  00:E327  C4 36 D0            		call	nz,io.str
     635:  00:E32A                      ;
     636:  00:E32A  21 29 40            		ld	hl,vars.dhcp.ip
     637:  00:E32D  CD D9 D7            		call	wiz.set_ip
     638:  00:E330                      ;
     639:  00:E330  21 2D 40            		ld	hl,vars.dhcp.subnet
     640:  00:E333  D4 F0 D7            		call	nc,wiz.set_subnet
     641:  00:E336                      ;
     642:  00:E336  21 31 40            		ld	hl,vars.dhcp.gateway
     643:  00:E339  D4 00 D8            		call	nc,wiz.set_gateway
     644:  00:E33C                      ;
     645:  00:E33C  CD A8 DC            		call	socket.close_0
     646:  00:E33F                      ;
     647:  00:E33F  CD A2 D0            		call	status.stop		; Restore status line
     648:  00:E342                      ;		
     649:  00:E342  FD CB 03 CE         		set	vars.init.dhcp,(iy+vars._init)	; Initialised!
     650:  00:E346                      ;
     651:  00:E346  B7                  		or	a
     652:  00:E347  C9                  		ret
     653:  00:E348                      ;
     654:  00:E348                      ;
     655:  00:E348                      ;------------------------------------------------------------------------------
     656:  00:E348                      ; send
     657:  00:E348                      ;
     658:  00:E348                      ; Sends a DHCP packet
     659:  00:E348                      ;
     660:  00:E348                      ; In:  A=DHCP_TYPE.xxx
     661:  00:E348                      ; Out: NC=>ok
     662:  00:E348  08                  send:		ex	af,af			; Save DHCP type in A'
     663:  00:E349                      ;
     664:  00:E349                      		; Set up udp header with dest ip address & port
     665:  00:E349  21 1E 40            		ld	hl,vars.udp.ip
     666:  00:E34C  06 04               		ld	b,4
     667:  00:E34E  36 FF               .loop:		ld	(hl),0xff		; Broadcast
     668:  00:E350  23                  		inc	hl
     669:  00:E351  10 FB               		djnz	.loop
     670:  00:E353                      ;
     671:  00:E353  21 43 00            		ld	hl,DHCP_SERVER_PORT	; Standard DHCP port
     672:  00:E356  22 22 40            		ld	(vars.udp.port),hl
     673:  00:E359                      ;
     674:  00:E359                      		; Construct a DHCP packet
     675:  00:E359  CD 82 E6            		call	packet_init		; Zero packet buffer
     676:  00:E35C                      ;
     677:  00:E35C  36 01               		ld	(hl),DHCP_OP.BOOTREQUEST;
     678:  00:E35E  23                  		inc	hl			; HL->packet.htype
     679:  00:E35F  36 01               		ld	(hl),DHCP_HTYPE.10MB;
     680:  00:E361  23                  		inc	hl			; HL->packet.hlen
     681:  00:E362  36 06               		ld	(hl),DHCP_HLEN.ETHERNET
     682:  00:E364  23                  		inc	hl			; HL->packet.hops
     683:  00:E365  36 00               		ld	(hl),DHCP.HOPS
     684:  00:E367  23                  		inc	hl			; HL->packet.xid
     685:  00:E368                      ;
     686:  00:E368                      		; Copy in transaction id, byte swapping
     687:  00:E368  ED 5B 4B 40         		ld	de,(vars.dhcp.xid+2)
     688:  00:E36C  72                  		ld	(hl),d
     689:  00:E36D  23                  		inc	hl
     690:  00:E36E  73                  		ld	(hl),e
     691:  00:E36F  23                  		inc	hl
     692:  00:E370  ED 5B 49 40         		ld	de,(vars.dhcp.xid)
     693:  00:E374  72                  		ld	(hl),d
     694:  00:E375  23                  		inc	hl
     695:  00:E376  73                  		ld	(hl),e
     696:  00:E377  23                  		inc	hl
     697:  00:E378                      ;
     698:  00:E378                      		; secs has to be byte swapped too
     699:  00:E378  ED 5B 4D 40         		ld	de,(vars.dhcp.secs)
     700:  00:E37C  72                  		ld	(hl),d
     701:  00:E37D  23                  		inc	hl
     702:  00:E37E  73                  		ld	(hl),e
     703:  00:E37F  23                  		inc	hl
     704:  00:E380                      ;
     705:  00:E380  36 80               		ld	(hl),HIGH DHCP_FLAGS.BROADCAST
     706:  00:E382  23                  		inc	hl
     707:  00:E383  36 00               		ld	(hl),LOW DHCP_FLAGS.BROADCAST
     708:  00:E385                      ;
     709:  00:E385                      		; ciaddr, yiaddr, siaddr & giaddr already zeroed
     710:  00:E385                      ;
     711:  00:E385  21 1C 43            		ld	hl,vars.dhcp.packet.chaddr	; Copy MAC adrdess to chaddr
     712:  00:E388  CD 8B E6            		call	packet_mac	; Rest of packet.chaddr already 0
     713:  00:E38B                      ;
     714:  00:E38B                      		ASSERT	(vars.dhcp.packet_size & 1) = 0
     715:  00:E38B                      ;
     716:  00:E38B  01 2C 00            		ld	bc,vars.dhcp.packet_size
     717:  00:E38E  CD 79 E6            		call	packet_write	; Write packet upto & including chaddr
     718:  00:E391  38 55               		jr	c,.error
     719:  00:E393                      ;
     720:  00:E393  CD 82 E6            		call	packet_init	; Zero packet buffer again
     721:  00:E396                      ;
     722:  00:E396                      		; Write 32 bytes from zerod buffer for sname & file
     723:  00:E396  06 06               		ld	b,6		; 6x32 bytes = 192
     724:  00:E398  C5                  .writezeros:	push	bc
     725:  00:E399  01 20 00            		ld	bc,32
     726:  00:E39C  CD 79 E6            		call	packet_write
     727:  00:E39F  C1                  		pop	bc
     728:  00:E3A0  38 46               		jr	c,.error
     729:  00:E3A2                      ;
     730:  00:E3A2  10 F4               		djnz	.writezeros
     731:  00:E3A4                      ;
     732:  00:E3A4                      		; OPT - Magic cookie
     733:  00:E3A4  36 63               		ld	(hl),99
     734:  00:E3A6  23                  		inc	hl
     735:  00:E3A7  36 82               		ld	(hl),130
     736:  00:E3A9  23                  		inc	hl
     737:  00:E3AA  36 53               		ld	(hl),83
     738:  00:E3AC  23                  		inc	hl
     739:  00:E3AD  36 63               		ld	(hl),99
     740:  00:E3AF  23                  		inc	hl
     741:  00:E3B0  (00:0004)           .LEN_COOKIE	equ	4
     742:  00:E3B0                      ;
     743:  00:E3B0                      		; OPT - Message type
     744:  00:E3B0  36 35               		ld	(hl),DHCP_OPT.TYPE; Message type
     745:  00:E3B2  23                  		inc	hl
     746:  00:E3B3  36 01               		ld	(hl),1		; One byte
     747:  00:E3B5  23                  		inc	hl
     748:  00:E3B6  08                  		ex	af,af		; Get back our message type
     749:  00:E3B7  77                  		ld	(hl),a
     750:  00:E3B8  23                  		inc	hl
     751:  00:E3B9  08                  		ex	af,af		; Save type again
     752:  00:E3BA  (00:0003)           .LEN_TYPE	equ	3
     753:  00:E3BA                      ;
     754:  00:E3BA                      		; OPT - Client identifier
     755:  00:E3BA  36 3D               		ld	(hl),DHCP_OPT.CLIENT	; Client identifier
     756:  00:E3BC  23                  		inc	hl
     757:  00:E3BD  36 07               		ld	(hl),7		; Length
     758:  00:E3BF  23                  		inc	hl
     759:  00:E3C0  36 01               		ld	(hl),1		; Type 1 (hardware)
     760:  00:E3C2  23                  		inc	hl
     761:  00:E3C3  CD 8B E6            		call	packet_mac
     762:  00:E3C6  (00:0009)           .LEN_CLIENT	equ	9
     763:  00:E3C6                      ;
     764:  00:E3C6  E5                  		push	hl		; Save ptr to end of mac
     765:  00:E3C7                      		 ; OPT - host name
     766:  00:E3C7  36 0C               		 ld	(hl),DHCP_OPT.HOST	; Host name
     767:  00:E3C9  23                  		 inc	hl
     768:  00:E3CA  36 08               		 ld	(hl),2+(2*3)	; "EP" + 3 bytes from mac
     769:  00:E3CC  23                  		 inc	hl
     770:  00:E3CD  36 45               		 ld	(hl),'E'
     771:  00:E3CF  23                  		 inc	hl
     772:  00:E3D0  36 50               		 ld	(hl),'P'
     773:  00:E3D2  23                  		 inc	hl
     774:  00:E3D3                      ;		 ld	(hl),'-'
     775:  00:E3D3                      ;		 inc	hl
     776:  00:E3D3  D1                  		pop	de		; DE->end of mac address
     777:  00:E3D4  1B                  		dec	de		; Point to ;last 3 bytes of MAC address
     778:  00:E3D5  1B                  		dec	de
     779:  00:E3D6  1B                  		dec	de
     780:  00:E3D7  CD A1 E6            		call	packet_byte
     781:  00:E3DA  CD A1 E6            		call	packet_byte
     782:  00:E3DD  CD A1 E6            		call	packet_byte
     783:  00:E3E0  (00:000A)           .LEN_HOST	equ	10
     784:  00:E3E0                      ;
     785:  00:E3E0                      		; Write above OPTs
     786:  00:E3E0  (00:001A)           .packet_size	equ	.LEN_COOKIE+.LEN_TYPE+.LEN_CLIENT+.LEN_HOST
     787:  00:E3E0                      		ASSERT	(.packet_size & 1) = 0
     788:  00:E3E0                      ;
     789:  00:E3E0  01 1A 00            		ld	bc,.packet_size
     790:  00:E3E3  CD 79 E6            		call	packet_write
     791:  00:E3E6  30 08               		jr	nc,.noerror
     792:  00:E3E8                      ;
     793:  00:E3E8                      .error:
     794:  00:E3E8  FD CB 00 56         		bit	vars.trace.dhcp,(iy+vars._trace)
     795:  00:E3EC  C8                  		ret	z
     796:  00:E3ED                      ;
     797:  00:E3ED  C3 4D D2            		jp	trace.error
     798:  00:E3F0                      ;
     799:  00:E3F0  08                  .noerror:	ex	af,af		; Get back message type
     800:  00:E3F1  FE 03               		cp	DHCP_TYPE.REQUEST
     801:  00:E3F3  20 1A               		jr	nz,.notreq
     802:  00:E3F5                      ;
     803:  00:E3F5  36 32               		ld	(hl),DHCP_OPT.IP; Requested ip address
     804:  00:E3F7  23                  		inc	hl
     805:  00:E3F8  11 29 40            		ld	de,vars.dhcp.ip
     806:  00:E3FB  CD 96 E6            		call	packet_ip
     807:  00:E3FE                      ;
     808:  00:E3FE  36 36               		ld	(hl),DHCP_OPT.SERVER	; Server identifier
     809:  00:E400  23                  		inc	hl
     810:  00:E401  11 35 40            		ld	de,vars.dhcp.server
     811:  00:E404  CD 96 E6            		call	packet_ip
     812:  00:E407                      ;
     813:  00:E407  01 0C 00            		ld	bc,2*(2+4)	; 2 lots of (type+length+ip)
     814:  00:E40A  CD 79 E6            		call	packet_write
     815:  00:E40D  38 D9               		jr	c,.error
     816:  00:E40F                      ;
     817:  00:E40F                      .notreq:
     818:  00:E40F  36 37               		ld	(hl),DHCP_OPT.PARAM	; Param Request
     819:  00:E411  23                  		inc	hl
     820:  00:E412  36 07               		ld	(hl),7		; Number of params
     821:  00:E414  23                  		inc	hl
     822:  00:E415  36 01               		ld	(hl),DHCP_OPT.SUBNET	; subnet mask
     823:  00:E417  23                  		inc	hl
     824:  00:E418  36 03               		ld	(hl),DHCP_OPT.ROUTER	; routers on subnet
     825:  00:E41A  23                  		inc	hl
     826:  00:E41B  36 06               		ld	(hl),DHCP_OPT.DNS	; DNS server
     827:  00:E41D  23                  		inc	hl
     828:  00:E41E  36 0F               		ld	(hl),DHCP_OPT.DOMAIN	; domain name
     829:  00:E420  23                  		inc	hl
     830:  00:E421  36 2A               		ld	(hl),DHCP_OPT.NTP	; Time server
     831:  00:E423  23                  		inc	hl
     832:  00:E424  36 3A               		ld	(hl),DHCP_OPT.T1
     833:  00:E426  23                  		inc	hl
     834:  00:E427  36 3B               		ld	(hl),DHCP_OPT.T2
     835:  00:E429  23                  		inc	hl
     836:  00:E42A  36 FF               		ld	(hl),DHCP_OPT.END	; End option
     837:  00:E42C  01 0A 00            		ld	bc,10		; #bytes written above
     838:  00:E42F  CD 79 E6            		call	packet_write
     839:  00:E432  38 B4               		jr	c,.error
     840:  00:E434                      ;
     841:  00:E434  CD 2A DF            		call	udp.send_0
     842:  00:E437  38 AF               		jr	c,.error
     843:  00:E439                      ;
     844:  00:E439  FD CB 00 56         		bit	vars.trace.dhcp,(iy+vars._trace)
     845:  00:E43D  C8                  		ret	z
     846:  00:E43E                      ;
     847:  00:E43E  C3 40 D2            		jp	trace.ok
     848:  00:E441                      ;
     849:  00:E441                      ;
     850:  00:E441                      ;------------------------------------------------------------------------------
     851:  00:E441                      ; read
     852:  00:E441                      ;
     853:  00:E441                      ; Receives and parses a DHCP response
     854:  00:E441                      ;
     855:  00:E441                      ; Out: A=DHCP_TYPE.xx if valid response, else 0 or ff
     856:  00:E441                      ;      Cy=>error
     857:  00:E441                      read:
     858:  00:E441  2A 0E 40            		ld	hl,(vars.ticks)
     859:  00:E444  22 26 40            		ld	(vars.dhcp.timeout),hl
     860:  00:E447  18 0D               		jr	.loop
     861:  00:E449                      ;
     862:  00:E449  11 01 D5            .eop:		ld	de,trace.dhcp.eop
     863:  00:E44C  FD CB 00 56         .badpacket:	bit	vars.trace.dhcp,(iy+vars._trace)
     864:  00:E450  C4 36 D0            		call	nz,io.str
     865:  00:E453  CD A7 DB            .retry:		call	socket.read_end_0
     866:  00:E456                      ;
     867:  00:E456  CD E1 DE            .loop:		call	udp.header_0
     868:  00:E459  20 20               		jr	nz,.gotpacket
     869:  00:E45B                      ;
     870:  00:E45B  CD C3 D0            		call	status.waiting	; Flash status line blob
     871:  00:E45E                      ;
     872:  00:E45E  CD C3 CA            		call	exos.is_stop
     873:  00:E461  38 11               		jr	c,.errret
     874:  00:E463                      ;
     875:  00:E463  ED 5B 26 40         		ld	de,(vars.dhcp.timeout)	; Start tick count
     876:  00:E467  2A 0E 40            		ld	hl,(vars.ticks)		; Current tick count
     877:  00:E46A  B7                  		or	a
     878:  00:E46B  ED 52               		sbc	hl,de		; HL=duration in ticks
     879:  00:E46D  11 32 00            		ld	de,TICKS_1s	; 1S timeout in ticks
     880:  00:E470  ED 52               		sbc	hl,de
     881:  00:E472  38 E2               		jr	c,.loop		; Not timed out yet
     882:  00:E474                      ;
     883:  00:E474                      .errret:				; Cy=>error, or NC=>timeout
     884:  00:E474  F5                  		push	af
     885:  00:E475  CD A7 DB            		 call	socket.read_end_0
     886:  00:E478  F1                  		pop	af
     887:  00:E479  9F                  		sbc	a,a		; FF and carry or 0 and NC
     888:  00:E47A  C9                  		ret
     889:  00:E47B                      ;
     890:  00:E47B                      ;
     891:  00:E47B                      .gotpacket:		; Got something - must be at least DHCP header long
     892:  00:E47B  FD CB 00 56         		bit	vars.trace.dhcp,(iy+vars._trace)
     893:  00:E47F  28 09               		jr	z,.donetrace
     894:  00:E481                      ;
     895:  00:E481  CD 1C D0            		call	io.start
     896:  00:E484  11 4D D4            		ld	de,trace.dhcp.rx
     897:  00:E487  CD 36 D0            		call	io.str
     898:  00:E48A                      .donetrace:
     899:  00:E48A                      ;
     900:  00:E48A  B7                  		or	a
     901:  00:E48B  01 2C 00            		ld	bc,vars.dhcp.packet_size
     902:  00:E48E  ED 42               		sbc	hl,bc
     903:  00:E490  11 CB D4            		ld	de,trace.dhcp.small
     904:  00:E493  38 B7               		jr	c,.badpacket	; Too small - ignore
     905:  00:E495                      ;
     906:  00:E495  21 00 43            		ld	hl,vars.dhcp.packet
     907:  00:E498  01 2C 00            		ld	bc,vars.dhcp.packet_size
     908:  00:E49B  CD D9 DA            		call	socket.read_0		; Read start of DHCP packet
     909:  00:E49E                      ;
     910:  00:E49E                      		; Check packet has come from the right port
     911:  00:E49E  2A 22 40            		ld	hl,(vars.udp.port)
     912:  00:E4A1  01 43 00            		ld	bc,DHCP_SERVER_PORT	; Standard server port
     913:  00:E4A4  B7                  		or	a
     914:  00:E4A5  ED 42               		sbc	hl,bc
     915:  00:E4A7  11 D5 D4            		ld	de,trace.dhcp.port
     916:  00:E4AA  20 A0               		jr	nz,.badpacket
     917:  00:E4AC                      ;
     918:  00:E4AC                      		; Check it's the right sort of DHCP reply
     919:  00:E4AC  3A 00 43            		ld	a,(vars.dhcp.packet.op)
     920:  00:E4AF  FE 02               		cp	2		; BOOTREPLY
     921:  00:E4B1  11 DE D4            		ld	de,trace.dhcp.op
     922:  00:E4B4  C2 4C E4            		jp	nz,.badpacket
     923:  00:E4B7                      ;
     924:  00:E4B7                      		; Check chaddr has our mac address
     925:  00:E4B7  21 1C 43            		ld	hl,vars.dhcp.packet.chaddr
     926:  00:E4BA  11 0E C0            		ld	de,mac
     927:  00:E4BD  06 06               		ld	b,6
     928:  00:E4BF  CD 2D D1            		call	util.memcmp
     929:  00:E4C2  11 E5 D4            		ld	de,trace.dhcp.addr
     930:  00:E4C5  C2 4C E4            		jp	nz,.badpacket
     931:  00:E4C8                      ;
     932:  00:E4C8                      		; Check xid. Top word MBZ as we always send it 0
     933:  00:E4C8  2A 04 43            		ld	hl,(vars.dhcp.packet.xid)
     934:  00:E4CB  7C                  		ld	a,h
     935:  00:E4CC  B5                  		or	l
     936:  00:E4CD  11 EE D4            .xiderrnz:	ld	de,trace.dhcp.xid
     937:  00:E4D0  C2 4C E4            		jp	nz,.badpacket
     938:  00:E4D3                      ;
     939:  00:E4D3                      		; Save packet's xid in vars.dhcp.packet_xid because we
     940:  00:E4D3                      		; reuse the packet buffer later
     941:  00:E4D3  7C                  		ld	a,h		; Get it in Z80 order
     942:  00:E4D4  65                  		ld	h,l
     943:  00:E4D5  6F                  		ld	l,a
     944:  00:E4D6  22 51 40            		ld	(vars.dhcp.packet_xid+2),hl
     945:  00:E4D9                      ;
     946:  00:E4D9  2A 06 43            		ld	hl,(vars.dhcp.packet.xid+2)
     947:  00:E4DC  7C                  		ld	a,h		; Get it in Z80 order
     948:  00:E4DD  65                  		ld	h,l
     949:  00:E4DE  6F                  		ld	l,a
     950:  00:E4DF  22 4F 40            		ld	(vars.dhcp.packet_xid),hl
     951:  00:E4E2  ED 5B 49 40         		ld	de,(vars.dhcp.xid)
     952:  00:E4E6  EB                  		ex	de,hl		; HL=our xid, DE=packet xid
     953:  00:E4E7  B7                  		or	a
     954:  00:E4E8  ED 52               		sbc	hl,de		; Make sure it's <= current xid
     955:  00:E4EA  38 E1               		jr	c,.xiderrnz	; Also NZ if Cy
     956:  00:E4EC                      .xidok:	
     957:  00:E4EC                      ;
     958:  00:E4EC  11 29 40            		ld	de,vars.dhcp.ip	; Get the IP address
     959:  00:E4EF  21 10 43            		ld	hl,vars.dhcp.packet.yiaddr
     960:  00:E4F2  01 04 00            		ld	bc,4
     961:  00:E4F5  ED B0               		ldir
     962:  00:E4F7                      ;
     963:  00:E4F7                      		; Now we need to skip to the options part
     964:  00:E4F7                      		; so read 6x32 bytes
     965:  00:E4F7                      		; This will trash the DHCP header!!
     966:  00:E4F7  06 06               		ld	b,6
     967:  00:E4F9  21 00 43            .readlots:	ld	hl,vars.dhcp.packet
     968:  00:E4FC  C5                  		push	bc
     969:  00:E4FD  01 20 00            		 ld	bc,32
     970:  00:E500  CD D9 DA            		 call	socket.read_0
     971:  00:E503  C1                  		pop	bc
     972:  00:E504  10 F3               		djnz	.readlots
     973:  00:E506                      ;
     974:  00:E506                      		; Read the magic cookie
     975:  00:E506  21 00 43            		ld	hl,vars.dhcp.packet
     976:  00:E509  01 04 00            		ld	bc,4		; Read the magic cookie
     977:  00:E50C  CD D9 DA            		call	socket.read_0
     978:  00:E50F                      ;
     979:  00:E50F  2A 00 43            		ld	hl,(vars.dhcp.packet+0)
     980:  00:E512  11 63 82            		ld	de,130*256+99
     981:  00:E515  B7                  		or	a
     982:  00:E516  ED 52               		sbc	hl,de
     983:  00:E518  20 0B               		jr	nz,.cookiebad
     984:  00:E51A                      ;
     985:  00:E51A  2A 02 43            		ld	hl,(vars.dhcp.packet+2)
     986:  00:E51D  11 53 63            		ld	de,99*256+83
     987:  00:E520  B7                  		or	a
     988:  00:E521  ED 52               		sbc	hl,de
     989:  00:E523  28 06               		jr	z,.cookieok
     990:  00:E525                      ;
     991:  00:E525  11 F6 D4            .cookiebad:	ld	de,trace.dhcp.cookie
     992:  00:E528  C3 4C E4            		jp	.badpacket
     993:  00:E52B                      
     994:  00:E52B                      .cookieok:
     995:  00:E52B                      		; Now read the variable-sized options
     996:  00:E52B  AF                  		xor	a		; Initialise DHCP type
     997:  00:E52C  08                  		ex	af,af		; Save in AF'
     998:  00:E52D                      ;
     999:  00:E52D  18 0D               		jr	.nextopt
    1000:  00:E52F                      ;
    1001:  00:E52F  CD A7 DB            .ret:		call	socket.read_end_0
    1002:  00:E532  FD CB 00 56         		bit	vars.trace.dhcp,(iy+vars._trace)
    1003:  00:E536  C4 40 D2            		call	nz,trace.ok
    1004:  00:E539  08                  		ex	af,af		; Get back saved DHCP type
    1005:  00:E53A  B7                  		or	a		; NC=>no error
    1006:  00:E53B  C9                  		ret
    1007:  00:E53C                      ;
    1008:  00:E53C                      .nextopt:
    1009:  00:E53C  CD 10 DB            		call	socket.read_byte_0
    1010:  00:E53F  DA 49 E4            		jp	c,.eop		; Nothing left to read but no end opt
    1011:  00:E542                      ;
    1012:  00:E542                      		; FF is the end of options
    1013:  00:E542                      		; 00 is just padding
    1014:  00:E542                      		; All others are (should be!) followed by a length byte
    1015:  00:E542                      
    1016:  00:E542  FE FF               		cp	0ffh		; End option?
    1017:  00:E544  28 E9               		jr	z,.ret
    1018:  00:E546                      ;
    1019:  00:E546  B7                  		or	a		; Padding?
    1020:  00:E547  28 F3               		jr	z,.nextopt
    1021:  00:E549                      
    1022:  00:E549  4F                  		ld	c,a		; Save opt code
    1023:  00:E54A                      ;
    1024:  00:E54A  CD 10 DB            		call	socket.read_byte_0; Get length byte
    1025:  00:E54D  DA 49 E4            		jp	c,.eop
    1026:  00:E550                      ;
    1027:  00:E550  47                  		ld	b,a		; Save length
    1028:  00:E551  79                  		ld	a,c		; Get back opt code
    1029:  00:E552                      ;
    1030:  00:E552  FE 35               		cp	DHCP_OPT.TYPE	; Message type?
    1031:  00:E554  20 48               		jr	nz,.not53
    1032:  00:E556                      ;
    1033:  00:E556  CD 10 DB            		call	socket.read_byte_0; Get DHCP message type
    1034:  00:E559  DA 49 E4            		jp	c,.eop
    1035:  00:E55C                      ;
    1036:  00:E55C  47                  		ld	b,a
    1037:  00:E55D  08                  		ex	af,af		; Save in AF for returning type
    1038:  00:E55E                      ;
    1039:  00:E55E  FD CB 00 56         		bit	vars.trace.dhcp,(iy+vars._trace)
    1040:  00:E562  28 D8               		jr	z,.nextopt
    1041:  00:E564                      ;
    1042:  00:E564  78                  		ld	a,b		; Retrieve message type
    1043:  00:E565  11 8B D4            		ld	de,trace.dhcp.offer
    1044:  00:E568  FE 02               		cp	DHCP_TYPE.OFFER
    1045:  00:E56A  28 1B               		jr	z,.tracetype
    1046:  00:E56C                      ;
    1047:  00:E56C  11 92 D4            		ld	de,trace.dhcp.decline
    1048:  00:E56F  FE 04               		cp	DHCP_TYPE.DECLINE
    1049:  00:E571  28 14               		jr	z,.tracetype
    1050:  00:E573                      ;
    1051:  00:E573  11 9B D4            		ld	de,trace.dhcp.ack
    1052:  00:E576  FE 05               		cp	DHCP_TYPE.ACK
    1053:  00:E578  28 0D               		jr	z,.tracetype
    1054:  00:E57A                      ;
    1055:  00:E57A  11 A0 D4            		ld	de,trace.dhcp.nak
    1056:  00:E57D  FE 06               		cp	DHCP_TYPE.NAK
    1057:  00:E57F  28 06               		jr	z,.tracetype
    1058:  00:E581                      ;
    1059:  00:E581  CD A7 CF            		call	io.short
    1060:  00:E584  11 A5 D4            		ld	de,trace.dhcp.type
    1061:  00:E587  CD 36 D0            .tracetype:	call	io.str		; Print message type
    1062:  00:E58A                      ;
    1063:  00:E58A  2A 4F 40            		ld	hl,(vars.dhcp.packet_xid)
    1064:  00:E58D  CD AA CF            		call	io.int		; Followed by xid...
    1065:  00:E590  CD 36 D2            		call	trace.dots
    1066:  00:E593                      ;
    1067:  00:E593  01 29 40            		ld	bc,vars.dhcp.ip
    1068:  00:E596  11 56 D4            		ld	de,trace.dhcp.gotip
    1069:  00:E599  CD 64 E6            		call	traceip		; And the IP we received
    1070:  00:E59C                      ;
    1071:  00:E59C  18 9E               		jr	.nextopt
    1072:  00:E59E                      .not53:
    1073:  00:E59E                      ;
    1074:  00:E59E  FE 01               		cp	DHCP_OPT.SUBNET		; Subnet mask?
    1075:  00:E5A0  20 14               		jr	nz,.not1
    1076:  00:E5A2                      ;
    1077:  00:E5A2  21 2D 40            		ld	hl,vars.dhcp.subnet
    1078:  00:E5A5  CD 55 E6            		call	read_ip
    1079:  00:E5A8  DA 49 E4            		jp	c,.eop
    1080:  00:E5AB                      ;
    1081:  00:E5AB  11 5B D4            		ld	de,trace.dhcp.gotsubnet
    1082:  00:E5AE  01 2D 40            		ld	bc,vars.dhcp.subnet
    1083:  00:E5B1  CD 64 E6            		call	traceip
    1084:  00:E5B4                      ;
    1085:  00:E5B4  18 86               		jr	.nextopt
    1086:  00:E5B6                      .not1:		
    1087:  00:E5B6                      ;
    1088:  00:E5B6  FE 03               		cp	DHCP_OPT.ROUTER		; Routers on subnet?
    1089:  00:E5B8  20 18               		jr	nz,.not3
    1090:  00:E5BA                      ;
    1091:  00:E5BA  C5                  		push	bc		; Save length
    1092:  00:E5BB  21 31 40            		 ld	hl,vars.dhcp.gateway
    1093:  00:E5BE  CD 55 E6            		 call	read_ip
    1094:  00:E5C1  C1                  		pop	bc
    1095:  00:E5C2  DA 49 E4            		jp	c,.eop
    1096:  00:E5C5                      ;
    1097:  00:E5C5  C5                  		push	bc
    1098:  00:E5C6  11 64 D4            		 ld	de,trace.dhcp.gotgateway
    1099:  00:E5C9  01 31 40            		 ld	bc,vars.dhcp.gateway
    1100:  00:E5CC  CD 64 E6            		 call	traceip
    1101:  00:E5CF  C1                  		pop	bc
    1102:  00:E5D0                      ;
    1103:  00:E5D0  18 1A               		jr	.skip4
    1104:  00:E5D2                      .not3:
    1105:  00:E5D2                      ;
    1106:  00:E5D2  FE 06               		cp	DHCP_OPT.DNS	; DNS server?
    1107:  00:E5D4  20 1C               		jr	nz,.not6
    1108:  00:E5D6                      ;
    1109:  00:E5D6  C5                  		push	bc		; Save length
    1110:  00:E5D7  21 39 40            		 ld	hl,vars.dhcp.dns
    1111:  00:E5DA  CD 55 E6            		 call	read_ip
    1112:  00:E5DD  C1                  		pop	bc
    1113:  00:E5DE  DA 49 E4            		jp	c,.eop
    1114:  00:E5E1                      ;
    1115:  00:E5E1  C5                  		push	bc
    1116:  00:E5E2  11 7F D4            		 ld	de,trace.dhcp.gotdns
    1117:  00:E5E5  01 39 40            		 ld	bc,vars.dhcp.dns
    1118:  00:E5E8  CD 64 E6            .traceip:	 call	traceip
    1119:  00:E5EB  C1                  		pop	bc
    1120:  00:E5EC                      ;
    1121:  00:E5EC  78                  .skip4:		ld	a,b
    1122:  00:E5ED  D6 04               		sub	4		; Allow for bytes just read
    1123:  00:E5EF  47                  		ld	b,a
    1124:  00:E5F0  18 54               		jr	.skipopt	; Skip rest of option
    1125:  00:E5F2                      .not6:
    1126:  00:E5F2                      ;
    1127:  00:E5F2  FE 2A               		cp	DHCP_OPT.NTP	; NTP server?
    1128:  00:E5F4  20 14               		jr	nz,.not42
    1129:  00:E5F6                      ;
    1130:  00:E5F6  C5                  		push	bc		; Save length
    1131:  00:E5F7  21 3D 40            		 ld	hl,vars.dhcp.ntp
    1132:  00:E5FA  CD 55 E6            		 call	read_ip
    1133:  00:E5FD  C1                  		pop	bc
    1134:  00:E5FE  DA 49 E4            		jp	c,.eop
    1135:  00:E601                      ;
    1136:  00:E601  C5                  		push	bc
    1137:  00:E602  11 85 D4            		 ld	de,trace.dhcp.gotntp
    1138:  00:E605  01 3D 40            		 ld	bc,vars.dhcp.ntp
    1139:  00:E608  18 DE               		jr	.traceip
    1140:  00:E60A                      .not42:
    1141:  00:E60A                      ;
    1142:  00:E60A  FE 36               		cp	DHCP_OPT.SERVER	; Server identifier?
    1143:  00:E60C  20 15               		jr	nz,.not54
    1144:  00:E60E                      ;
    1145:  00:E60E  21 35 40            		ld	hl,vars.dhcp.server
    1146:  00:E611  CD 55 E6            		call	read_ip
    1147:  00:E614  DA 49 E4            		jp	c,.eop
    1148:  00:E617                      ;
    1149:  00:E617  11 6E D4            		ld	de,trace.dhcp.gotserver
    1150:  00:E61A  01 35 40            		ld	bc,vars.dhcp.server
    1151:  00:E61D  CD 64 E6            		call	traceip
    1152:  00:E620                      ;
    1153:  00:E620  C3 3C E5            		jp	.nextopt
    1154:  00:E623                      .not54:
    1155:  00:E623                      ;
    1156:  00:E623  FE 33               		cp	DHCP_OPT.LEASE	; IP lease time?
    1157:  00:E625  20 1F               		jr	nz,.not51
    1158:  00:E627                      ;
    1159:  00:E627  21 41 40            		ld	hl,vars.dhcp.lease
    1160:  00:E62A  CD 55 E6            		call	read_ip		; It's not an IP addr, but it is 4 bytes!
    1161:  00:E62D  DA 49 E4            		jp	c,.eop
    1162:  00:E630                      ;
    1163:  00:E630  B7                  		or	a
    1164:  00:E631  ED 62               		sbc	hl,hl
    1165:  00:E633  22 10 40            		ld	(vars.dhcp.ticks),hl		; Reset tick count
    1166:  00:E636  FD CB 03 D6         		set	vars.init.lease,(iy+vars._init)	; Got a lease time!
    1167:  00:E63A                      ;
    1168:  00:E63A  11 77 D4            		ld	de,trace.dhcp.gotlease
    1169:  00:E63D  01 41 40            		ld	bc,vars.dhcp.lease
    1170:  00:E640  CD 64 E6            		call	traceip
    1171:  00:E643                      ;
    1172:  00:E643  C3 3C E5            		jp	.nextopt
    1173:  00:E646                      		
    1174:  00:E646                      .not51:
    1175:  00:E646                      ;
    1176:  00:E646                      					; Unrecognised option - just skip
    1177:  00:E646  78                  .skipopt:	ld	a,b		; Get length byte
    1178:  00:E647  B7                  		or	a
    1179:  00:E648  28 08               		jr	z,.skipped
    1180:  00:E64A                      ;
    1181:  00:E64A  CD 10 DB            .skiploop:	call	socket.read_byte_0
    1182:  00:E64D  DA 49 E4            		jp	c,.eop
    1183:  00:E650                      ;
    1184:  00:E650  10 F8               		djnz	.skiploop
    1185:  00:E652                      ;
    1186:  00:E652  C3 3C E5            .skipped:	jp	.nextopt
    1187:  00:E655                      ;
    1188:  00:E655                      ;
    1189:  00:E655                      ;
    1190:  00:E655                      ; read_ip
    1191:  00:E655                      ;
    1192:  00:E655                      ; Calls udp.read_byte() 4 times to read an IP address
    1193:  00:E655                      ;
    1194:  00:E655                      ; In:  HL->buffer
    1195:  00:E655                      ;       B=length of parameter in packet
    1196:  00:E655                      ; Out: Cy=>error
    1197:  00:E655  78                  read_ip:	ld	a,b		; Get #bytes to follow
    1198:  00:E656  FE 04               		cp	4
    1199:  00:E658  D8                  		ret	c		; Not enough for an IP address!
    1200:  00:E659                      ;
    1201:  00:E659  06 04               		ld	b,4
    1202:  00:E65B  CD 10 DB            .loop:		call	socket.read_byte_0
    1203:  00:E65E  D8                  		ret	c
    1204:  00:E65F                      ;
    1205:  00:E65F  77                  		ld	(hl),a
    1206:  00:E660  23                  		inc	hl
    1207:  00:E661  10 F8               		djnz	.loop
    1208:  00:E663                      ;
    1209:  00:E663  C9                  		ret
    1210:  00:E664                      ;
    1211:  00:E664                      ;
    1212:  00:E664                      ; DE->string
    1213:  00:E664                      ; BC->IP
    1214:  00:E664                      ; HL preserved
    1215:  00:E664                      traceip:
    1216:  00:E664  FD CB 00 56         		bit	vars.trace.dhcp,(iy+vars._trace)
    1217:  00:E668  C8                  		ret	z
    1218:  00:E669                      ;
    1219:  00:E669  E5                  		push	hl
    1220:  00:E66A  C5                  		 push	bc
    1221:  00:E66B  CD 36 D0            		  call	io.str
    1222:  00:E66E  E1                  		 pop	hl		; HL->IP
    1223:  00:E66F                      ;
    1224:  00:E66F  CD 85 CF            		 call	io.ip
    1225:  00:E672  3E 2C               		 ld	a,','
    1226:  00:E674  CD F9 CF            		 call	io.char
    1227:  00:E677  E1                  		pop	hl
    1228:  00:E678  C9                  		ret
    1229:  00:E679                      ;
    1230:  00:E679                      ;
    1231:  00:E679                      ; packet_write
    1232:  00:E679                      ;
    1233:  00:E679                      ; Writes the data built up in dhcp.packet
    1234:  00:E679                      ;
    1235:  00:E679                      ; In:  BC=no.bytes in packet buffer
    1236:  00:E679                      ; Out: NC=>no error
    1237:  00:E679                      ;      HL->start of packet
    1238:  00:E679  21 00 43            packet_write:	ld	hl,vars.dhcp.packet
    1239:  00:E67C  E5                  		push	hl
    1240:  00:E67D  CD BF DB            		 call	socket.write_0
    1241:  00:E680  E1                  		pop	hl
    1242:  00:E681  C9                  		ret
    1243:  00:E682                      ;
    1244:  00:E682                      ;
    1245:  00:E682                      ;
    1246:  00:E682  21 00 43            packet_init:	ld	hl,vars.dhcp.packet
    1247:  00:E685  01 2C 00            		ld	bc,vars.dhcp.packet_size
    1248:  00:E688  C3 20 D1            		jp	util.memzero
    1249:  00:E68B                      ;
    1250:  00:E68B                      ;
    1251:  00:E68B                      ; packet_mac
    1252:  00:E68B                      ;
    1253:  00:E68B                      ; Copies our MAC address into packet buffer
    1254:  00:E68B                      ;
    1255:  00:E68B                      ; In:  HL->packet buffer
    1256:  00:E68B                      ; Out: HL updated
    1257:  00:E68B  EB                  packet_mac:	ex	de,hl		; DE->buffer
    1258:  00:E68C  21 0E C0            		ld	hl,mac
    1259:  00:E68F  01 06 00            		ld	bc,6
    1260:  00:E692  ED B0               		ldir
    1261:  00:E694  EB                  		ex	de,hl
    1262:  00:E695                      ;
    1263:  00:E695  C9                  		ret
    1264:  00:E696                      ;
    1265:  00:E696                      ; packet_ip
    1266:  00:E696                      ;
    1267:  00:E696                      ; Puts a length byte and copies an IP address into packet buffer
    1268:  00:E696                      ;
    1269:  00:E696                      ; In:  HL->packet buffer
    1270:  00:E696                      ;      DE->IP address (4 bytes)
    1271:  00:E696                      ; Out: HL updated
    1272:  00:E696  36 04               packet_ip:	ld	(hl),4		; Length byte
    1273:  00:E698  23                  		inc	hl
    1274:  00:E699  EB                  		ex	de,hl		; DE->buffer
    1275:  00:E69A  01 04 00            		ld	bc,4
    1276:  00:E69D  ED B0               		ldir
    1277:  00:E69F  EB                  		ex	de,hl
    1278:  00:E6A0                      ;
    1279:  00:E6A0  C9                  		ret
    1280:  00:E6A1                      ;
    1281:  00:E6A1                      ; packet_byte
    1282:  00:E6A1                      ;
    1283:  00:E6A1                      ; Puts a byte in ASCII into packet buffer
    1284:  00:E6A1                      ;
    1285:  00:E6A1                      ; In:  HL->packet buffer
    1286:  00:E6A1                      ;      DE->byte
    1287:  00:E6A1                      ; Out: HL and DE updated
    1288:  00:E6A1                      ;
    1289:  00:E6A1  1A                  packet_byte:	ld	a,(de)
    1290:  00:E6A2  0F                  		rrca
    1291:  00:E6A3  0F                  		rrca
    1292:  00:E6A4  0F                  		rrca
    1293:  00:E6A5  0F                  		rrca
    1294:  00:E6A6  CD AB E6            		call	packet_nibble
    1295:  00:E6A9  1A                  		ld	a,(de)
    1296:  00:E6AA  13                  		inc	de
    1297:  00:E6AB                      ;
    1298:  00:E6AB  E6 0F               packet_nibble:	and	0fh
    1299:  00:E6AD  C6 30               		add	a,'0'
    1300:  00:E6AF  FE 3A               		cp	a,'9'+1
    1301:  00:E6B1  38 02               		jr	c,.done
    1302:  00:E6B3                      ;
    1303:  00:E6B3  C6 07               		add	a,'A'-'9'-1
    1304:  00:E6B5  77                  .done:		ld	(hl),a
    1305:  00:E6B6  23                  		inc	hl
    1306:  00:E6B7  C9                  		ret
    1307:  00:E6B8                      ;
    1308:  00:E6B8                      ;
    1309:  00:E6B8                      ;------------------------------------------------------------------------------
    1310:  00:E6B8                      ; interrupt
    1311:  00:E6B8                      ;
    1312:  00:E6B8                      ; This is an interrupt routine that is called every tick (20mS). It divides
    1313:  00:E6B8                      ; ticks down into seconds, and then every second decrements the 32-bit lease
    1314:  00:E6B8                      ; time until it reaches 0.
    1315:  00:E6B8                      ;
    1316:  00:E6B8                      interrupt:	; Increment lease tick count
    1317:  00:E6B8  2A 10 40            		ld	hl,(vars.dhcp.ticks)
    1318:  00:E6BB  23                  		inc	hl
    1319:  00:E6BC  22 10 40            		ld	(vars.dhcp.ticks),hl
    1320:  00:E6BF                      ;
    1321:  00:E6BF                      		; See if it's reached 1S
    1322:  00:E6BF  11 32 00            		ld	de,TICKS_1s
    1323:  00:E6C2  B7                  		or	a
    1324:  00:E6C3  ED 52               		sbc	hl,de
    1325:  00:E6C5  D8                  		ret	c
    1326:  00:E6C6                      ;
    1327:  00:E6C6                      		; Reset the tick count back to 0
    1328:  00:E6C6                      		; If it's just gone NC, HL should be 0!
    1329:  00:E6C6  22 10 40            		ld	(vars.dhcp.ticks),hl
    1330:  00:E6C9                      ;
    1331:  00:E6C9  2A 4D 40            		ld	hl,(vars.dhcp.secs)		; Inc seconds count
    1332:  00:E6CC  23                  		inc	hl
    1333:  00:E6CD  22 4D 40            		ld	(vars.dhcp.secs),hl
    1334:  00:E6D0                      
    1335:  00:E6D0  FD CB 03 56         		bit	vars.init.lease,(iy+vars._init)	; Got a lease time?
    1336:  00:E6D4  C8                  		ret	z				; Return if not
    1337:  00:E6D5                      ;
    1338:  00:E6D5                      		; Now decrement the 32-bit lease time a byte at a time,
    1339:  00:E6D5                      		; starting with the LSB. If the byte is 0 before we decrement
    1340:  00:E6D5                      		; it, it will decrement below 0 so we go on to do the next
    1341:  00:E6D5                      		; byte. If this happens to the last byte, it's gone below 0
    1342:  00:E6D5                      		; so the lease has expired
    1343:  00:E6D5  21 44 40            		ld	hl,vars.dhcp.lease+3
    1344:  00:E6D8  06 04               		ld	b,4
    1345:  00:E6DA  7E                  .loop:		ld	a,(hl)
    1346:  00:E6DB  35                  		dec	(hl)
    1347:  00:E6DC  B7                  		or	a
    1348:  00:E6DD  C0                  		ret	nz
    1349:  00:E6DE                      ;
    1350:  00:E6DE  2B                  		dec	hl
    1351:  00:E6DF  10 F9               		djnz	.loop
    1352:  00:E6E1                      ;
    1353:  00:E6E1                      		; If we get here, it's gone -ve so set back to 0
    1354:  00:E6E1  ED 62               		sbc	hl,hl
    1355:  00:E6E3  22 41 40            		ld	(vars.dhcp.lease),hl
    1356:  00:E6E6  22 43 40            		ld	(vars.dhcp.lease+2),hl
    1357:  00:E6E9                      ;
    1358:  00:E6E9  C9                  		ret
    1359:  00:E6EA                      ;
    1360:  00:E6EA                      ;
    1361:  00:E6EA  44 48 43 50 00      owner_str:	db	"DHCP",0
    1362:  00:E6EF                      ;
    1363:  00:E6EF                      ;
    1364:  00:E6EF                      ;
    1365:  00:E6EF                      		endmodule
     108.  00:E6EF                      	include ping.asm
       1:  00:E6EF                      ; PING
       2:  00:E6EF                      ;
       3:  00:E6EF                      ; This module implements an interface to the WIZ W5300 that provides a
       4:  00:E6EF                      ; 'ping' command.
       5:  00:E6EF                      ;
       6:  00:E6EF                      		module	ping
       7:  00:E6EF                      ;
       8:  00:E6EF                      ;==============================================================================
       9:  00:E6EF                      ;
      10:  00:E6EF                      ; This file is part of the EPNET software
      11:  00:E6EF                      ;
      12:  00:E6EF                      ; Copyright (C) 2015  Bruce Tanner
      13:  00:E6EF                      ;
      14:  00:E6EF                      ;    This program is free software: you can redistribute it and/or modify
      15:  00:E6EF                      ;    it under the terms of the GNU General Public License as published by
      16:  00:E6EF                      ;    the Free Software Foundation, either version 3 of the License, or
      17:  00:E6EF                      ;    (at your option) any later version.
      18:  00:E6EF                      ;
      19:  00:E6EF                      ;    This program is distributed in the hope that it will be useful,
      20:  00:E6EF                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      21:  00:E6EF                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      22:  00:E6EF                      ;    GNU General Public License for more details.
      23:  00:E6EF                      ;
      24:  00:E6EF                      ;    You should have received a copy of the GNU General Public License
      25:  00:E6EF                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      26:  00:E6EF                      ;
      27:  00:E6EF                      ; If you do use or modify this file, either for its original purpose or for
      28:  00:E6EF                      ; something new, I'd love to hear about it! I can be contacted by email at:
      29:  00:E6EF                      ;
      30:  00:E6EF                      ; brucetanner@btopenworld.com
      31:  00:E6EF                      ;
      32:  00:E6EF                      ;==============================================================================
      33:  00:E6EF                      ;
      34:  00:E6EF                      ; You would think they would make it easy to implement this most basic of
      35:  00:E6EF                      ; commands but unfortunately it is necessary to open a WIZ socket in "IP raw"
      36:  00:E6EF                      ; mode and construct ICMP packets to do this.
      37:  00:E6EF                      ;
      38:  00:E6EF                      ; The ping ICMP packet format (from RFC 792) is:
      39:  00:E6EF                      ;
      40:  00:E6EF                      ; Echo or Echo Reply Message
      41:  00:E6EF                      ;
      42:  00:E6EF                      ;    0                   1                   2                   3
      43:  00:E6EF                      ;    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      44:  00:E6EF                      ;   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      45:  00:E6EF                      ;   |     Type      |     Code      |          Checksum             |
      46:  00:E6EF                      ;   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      47:  00:E6EF                      ;   |           Identifier          |        Sequence Number        |
      48:  00:E6EF                      ;   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      49:  00:E6EF                      ;   |     Data ...
      50:  00:E6EF                      ;   +-+-+-+-+-
      51:  00:E6EF                      ;
      52:  00:E6EF                      ;   IP Fields:
      53:  00:E6EF                      ;
      54:  00:E6EF                      ;   Addresses
      55:  00:E6EF                      ;
      56:  00:E6EF                      ;      The address of the source in an echo message will be the
      57:  00:E6EF                      ;      destination of the echo reply message.  To form an echo reply
      58:  00:E6EF                      ;      message, the source and destination addresses are simply reversed,
      59:  00:E6EF                      ;      the type code changed to 0, and the checksum recomputed.
      60:  00:E6EF                      ;
      61:  00:E6EF                      ;   IP Fields:
      62:  00:E6EF                      ;
      63:  00:E6EF                      ;   Type
      64:  00:E6EF                      ;
      65:  00:E6EF                      ;      8 for echo message;
      66:  00:E6EF                      ;
      67:  00:E6EF                      ;      0 for echo reply message.
      68:  00:E6EF                      ;
      69:  00:E6EF                      ;   Code
      70:  00:E6EF                      ;
      71:  00:E6EF                      ;      0
      72:  00:E6EF                      ;
      73:  00:E6EF                      ;   Checksum
      74:  00:E6EF                      ;
      75:  00:E6EF                      ;      The checksum is the 16-bit ones's complement of the one's
      76:  00:E6EF                      ;      complement sum of the ICMP message starting with the ICMP Type.
      77:  00:E6EF                      ;      For computing the checksum , the checksum field should be zero.
      78:  00:E6EF                      ;      If the total length is odd, the received data is padded with one
      79:  00:E6EF                      ;      octet of zeros for computing the checksum.  This checksum may be
      80:  00:E6EF                      ;      replaced in the future.
      81:  00:E6EF                      ;
      82:  00:E6EF                      ;   Identifier
      83:  00:E6EF                      ;
      84:  00:E6EF                      ;      If code = 0, an identifier to aid in matching echos and replies,
      85:  00:E6EF                      ;      may be zero.
      86:  00:E6EF                      ;
      87:  00:E6EF  (00:4242)           OUR_ID		equ	4242h
      88:  00:E6EF                      ;
      89:  00:E6EF                      ;   Sequence Number
      90:  00:E6EF                      ;
      91:  00:E6EF                      ;      If code = 0, a sequence number to aid in matching echos and
      92:  00:E6EF                      ;      replies, may be zero.
      93:  00:E6EF                      ;
      94:  00:E6EF                      ;   Description
      95:  00:E6EF                      ;
      96:  00:E6EF                      ;      The data received in the echo message must be returned in the echo
      97:  00:E6EF                      ;      reply message.
      98:  00:E6EF                      ;
      99:  00:E6EF                      ;      The identifier and sequence number may be used by the echo sender
     100:  00:E6EF                      ;      to aid in matching the replies with the echo requests.  For
     101:  00:E6EF                      ;      example, the identifier might be used like a port in TCP or UDP to
     102:  00:E6EF                      ;      identify a session, and the sequence number might be incremented
     103:  00:E6EF                      ;      on each echo request sent.  The echoer returns these same values
     104:  00:E6EF                      ;      in the echo reply.
     105:  00:E6EF                      ;
     106:  00:E6EF                      ;      Code 0 may be received from a gateway or a host.
     107:  00:E6EF                      ;
     108:  00:E6EF                      ;==============================================================================
     109:  00:E6EF                      ; init
     110:  00:E6EF                      ;
     111:  00:E6EF                      ; In:  vars.ping.ip contains IP address
     112:  00:E6EF                      ; Out: Cy=>error occured
     113:  00:E6EF                      init:
     114:  00:E6EF  AF                  		xor	a		; Always use socket 0
     115:  00:E6F0                      		SOCKET_GET_BASE
     115:  00:E6F0  11 00 01          >    ld de,0100h
     115:  00:E6F3  0F                >    rrca
     115:  00:E6F4  CB 1B             >    rr e
     115:  00:E6F6  0F                >    rrca
     115:  00:E6F7  CB 1B             >    rr e
     115:  00:E6F9  0F                >    rrca
     115:  00:E6FA  CB 12             >    rl d
     116:  00:E6FC                      ;
     117:  00:E6FC                      		; We have to set SnPROTOR to the IP protocol number
     118:  00:E6FC                      		; 01 (ICMP). SnPROTOR is a byte register that is half of
     119:  00:E6FC                      		; 16-bit SnPORTOR (look carefully, one is PROT and one is PORT!) 
     120:  00:E6FC                      		; The other half of SnPORTOR is SnKPALVTR and it is not clear
     121:  00:E6FC                      		; if we have to preserve this for when this socket is re-used in
     122:  00:E6FC                      		; TCP mode. So just in case we read SnKPALVTR first and write
     123:  00:E6FC                      		; it back along with our new value for SnPROTOR.
     124:  00:E6FC  3E 1A               		ld	a,w5300.Sn_PORTOR
     125:  00:E6FE  CD 40 D8            		call	socket.read_reg	; H=SnKPALVTR, L=SnPROT
     126:  00:E701  2E 01               		ld	l,1		; 1=>ICMP
     127:  00:E703  3E 1A               		ld	a,w5300.Sn_PORTOR
     128:  00:E705  CD 50 D8            		call	socket.write_reg
     129:  00:E708                      ;
     130:  00:E708  11 5D E8            		ld	de,owner_str	; Our name
     131:  00:E70B  32 4D 40            		ld	(vars.ping.seq),a
     132:  00:E70E  CD 54 DE            		call	ipraw.open_0	; Open socket in IP RAW mode
     133:  00:E711  38 0B               		jr	c,.end
     134:  00:E713                      ;
     135:  00:E713  06 05               		ld	b,5		; Do 5 pings/attempts
     136:  00:E715  C5                  .loop		push	bc
     137:  00:E716  CD 24 E7            		 call	do_ping
     138:  00:E719  C1                  		pop	bc
     139:  00:E71A  38 02               		jr	c,.end
     140:  00:E71C                      ;
     141:  00:E71C  10 F7               		djnz	.loop
     142:  00:E71E                      ;
     143:  00:E71E  F5                  .end:		push	af		; Save error indication in Cy
     144:  00:E71F  CD A8 DC            		 call	socket.close_0
     145:  00:E722  F1                  		pop	af
     146:  00:E723                      ;
     147:  00:E723  C9                  		ret
     148:  00:E724                      ;
     149:  00:E724                      ;
     150:  00:E724                      ;
     151:  00:E724                      ; Out: Cy=>error or STOP key
     152:  00:E724                      do_ping:
     153:  00:E724  11 0C D5            		ld	de,trace.ping.pinging
     154:  00:E727  CD 36 D0            		call	io.str		; "Pinging a.b.c.d..."
     155:  00:E72A  21 49 40            		ld	hl,vars.ping.ip
     156:  00:E72D  CD 85 CF            		call	io.ip
     157:  00:E730  CD 36 D2            		call	trace.dots
     158:  00:E733                      ;
     159:  00:E733                      		; Normally send would return an error (Cy) if the IP address
     160:  00:E733                      		; does not exist (the WIZ chip does ARP stuff) but here we
     161:  00:E733                      		; just ignore an error return and let the timeout/retry
     162:  00:E733                      		; mechanism retry it
     163:  00:E733  CD 0F E8            		call	build		; Build ping packet
     164:  00:E736                      ;
     165:  00:E736  CD AE D0            		call	status.start	; Start waiting indicator
     166:  00:E739                      ;
     167:  00:E739  ED 4B 0E 40         		ld	bc,(vars.ticks)	; Wait for start of tick
     168:  00:E73D  2A 0E 40            .wait:		ld	hl,(vars.ticks)
     169:  00:E740  B7                  		or	a
     170:  00:E741  ED 42               		sbc	hl,bc
     171:  00:E743  28 F8               		jr	z,.wait
     172:  00:E745                      ;
     173:  00:E745  09                  		add	hl,bc
     174:  00:E746  22 26 40            		ld	(vars.ping.start_ticks),hl	; Save ticks at start
     175:  00:E749                      ;
     176:  00:E749  21 49 40            		ld	hl,vars.ping.ip	; HL->ip address
     177:  00:E74C  CD A0 DE            		call	ipraw.send_0	; Send packet on socket 0
     178:  00:E74F  30 07               		jr	nc,.loop	; Go if no error
     179:  00:E751                      ;
     180:  00:E751  CD C3 CA            		call	exos.is_stop	; See if it was due to stop key
     181:  00:E754  38 28               		jr	c,.ret		; Return with Cy if yes
     182:  00:E756                      ;
     183:  00:E756  18 1F               		jr	.timeout	; Else print timeout & continue
     184:  00:E758                      ;
     185:  00:E758                      		; Now wait for a reply for up to a second
     186:  00:E758  CD A3 DA            .loop:		call	socket.available_0; Packet received?
     187:  00:E75B  20 27               		jr	nz,.gotreply
     188:  00:E75D                      ;
     189:  00:E75D  CD C3 D0            		call	status.waiting	; Show waiting indicator
     190:  00:E760                      ;
     191:  00:E760  CD C3 CA            		call	exos.is_stop	; STOP key?
     192:  00:E763  38 19               		jr	c,.ret		; Go with C if yes
     193:  00:E765                      ;
     194:  00:E765  2A 0E 40            		ld	hl,(vars.ticks)		; HL=current ticks
     195:  00:E768  ED 5B 26 40         		ld	de,(vars.ping.start_ticks); DE=start ticks
     196:  00:E76C  B7                  		or	a
     197:  00:E76D  ED 52               		sbc	hl,de		; HL=elapsed time in ticks
     198:  00:E76F  11 32 00            		ld	de,TICKS_1s	; See if >= 1s timeout
     199:  00:E772  B7                  		or	a
     200:  00:E773  ED 52               		sbc	hl,de
     201:  00:E775  38 E1               		jr	c,.loop		; Keep waiting if no timeout
     202:  00:E777                      ;
     203:  00:E777  11 90 D5            .timeout:	ld	de,trace.timeout_str
     204:  00:E77A  CD 36 D0            .okret:		call	io.str		; Print ok or timeout
     205:  00:E77D  B7                  		or	a		; NC cos not a fatal error
     206:  00:E77E  F5                  .ret:		push	af		; Save Cy
     207:  00:E77F  CD A2 D0            		call	status.stop	; Turn off waiting indicator
     208:  00:E782  F1                  		pop	af		; Restore Cy error indicator
     209:  00:E783  C9                  		ret
     210:  00:E784                      ;
     211:  00:E784  2A 0E 40            .gotreply:	ld	hl,(vars.ticks)
     212:  00:E787  22 28 40            		ld	(vars.ping.end_ticks),hl
     213:  00:E78A                      ;
     214:  00:E78A  CD 5B DE            		call	ipraw.header_0	; Read header
     215:  00:E78D                      ;
     216:  00:E78D  21 1E 40            		ld	hl,vars.icmp.ip
     217:  00:E790  11 49 40            		ld	de,vars.ping.ip
     218:  00:E793  CD 2B D1            		call	util.ipcmp
     219:  00:E796  37                  		scf
     220:  00:E797  20 1D               		jr	nz,.rejectheader
     221:  00:E799                      
     222:  00:E799  2A 22 40            		ld	hl,(vars.icmp.size); Make sure enough bytes received
     223:  00:E79C  01 08 00            		ld	bc,vars.ping.packet_size
     224:  00:E79F  B7                  		or	a
     225:  00:E7A0  ED 42               		sbc	hl,bc
     226:  00:E7A2  38 12               		jr	c,.rejectheader		; Go with Cy if not enough
     227:  00:E7A4                      ;
     228:  00:E7A4  21 00 43            		ld	hl,vars.ping.packet	; Read packet start
     229:  00:E7A7  01 08 00            		ld	bc,vars.ping.packet_size
     230:  00:E7AA                      ;
     231:  00:E7AA  CD D9 DA            		call	socket.read_0		; Read packet
     232:  00:E7AD                      ;
     233:  00:E7AD  2A 22 40            		ld	hl,(vars.icmp.size)
     234:  00:E7B0  01 08 00            		ld	bc,vars.ping.packet_size
     235:  00:E7B3  B7                  		or	a
     236:  00:E7B4  ED 42               		sbc	hl,bc			; HL=amount left to read
     237:  00:E7B6                      ;
     238:  00:E7B6                      .rejectheader:
     239:  00:E7B6  F5                  .readrest:	push	af
     240:  00:E7B7  CD 59 DB            		 call	socket.read_flush_0	; Read remainder of packet
     241:  00:E7BA  F1                  		pop	af
     242:  00:E7BB  DA 58 E7            		jp	c,.loop			; Reject header
     243:  00:E7BE                      ;
     244:  00:E7BE  21 00 43            		ld	hl,vars.ping.packet
     245:  00:E7C1  01 08 00            		ld	bc,vars.ping.packet_size
     246:  00:E7C4  CD 42 E8            		call	checksum
     247:  00:E7C7  7C                  		ld	a,h
     248:  00:E7C8  B5                  		or	l
     249:  00:E7C9  C2 58 E7            		jp	nz,.loop		; Ignore packet
     250:  00:E7CC                       
     251:  00:E7CC  3A 00 43            		ld	a,(vars.ping.packet.type)
     252:  00:E7CF  B7                  		or	a			; Type should be 0 for reply
     253:  00:E7D0  C2 58 E7            		jp	nz,.loop		; Ignore packet
     254:  00:E7D3                      ;
     255:  00:E7D3  3A 01 43            		ld	a,(vars.ping.packet.code)
     256:  00:E7D6  B7                  		or	a			; Code should be 0 for reply
     257:  00:E7D7  C2 58 E7            		jp	nz,.loop		; Ignore packet
     258:  00:E7DA                      ;
     259:  00:E7DA  2A 04 43            		ld	hl,(vars.ping.packet.id); Check it's our id
     260:  00:E7DD  11 42 42            		ld	de,OUR_ID
     261:  00:E7E0  ED 52               		sbc	hl,de
     262:  00:E7E2  7C                  		ld	a,h
     263:  00:E7E3  B5                  		or	l
     264:  00:E7E4  C2 58 E7            		jp	nz,.loop
     265:  00:E7E7                      ;
     266:  00:E7E7  ED 4B 26 40         		ld	bc,(vars.ping.start_ticks)
     267:  00:E7EB  2A 28 40            		ld	hl,(vars.ping.end_ticks)
     268:  00:E7EE  B7                  		or	a
     269:  00:E7EF  ED 42               		sbc	hl,bc			; HL=# ticks elapsed
     270:  00:E7F1  11 07 E8            		ld	de,lt20mS_str
     271:  00:E7F4  28 0E               		jr	z,.printmS		; Print "<20mS" if ticks=0
     272:  00:E7F6                      ;
     273:  00:E7F6  23                  		inc	hl			; x20 to get mS, 1=>40, 2=>80 etc
     274:  00:E7F7  29                  		add	hl,hl			; ticks*2
     275:  00:E7F8  4D                  		ld	c,l
     276:  00:E7F9  44                  		ld	b,h			; BC=ticks*2
     277:  00:E7FA  29                  		add	hl,hl			; ticks*4
     278:  00:E7FB  29                  		add	hl,hl			; ticks*8
     279:  00:E7FC  09                  		add	hl,bc			; ticks*10
     280:  00:E7FD  29                  		add	hl,hl			; ticks*20
     281:  00:E7FE  CD AA CF            		call	io.int			; Print it
     282:  00:E801  11 0A E8            		ld	de,mS_str
     283:  00:E804  C3 7A E7            .printmS:	jp	.okret
     284:  00:E807                      ;
     285:  00:E807  3C 32 30            lt20mS_str:	db	"<20"		; No null as includes next string
     286:  00:E80A  6D 53 0D 0A 00      mS_str:		db	"mS",CR,LF,0
     287:  00:E80F                      
     288:  00:E80F                      ;
     289:  00:E80F                      ;------------------------------------------------------------------------------
     290:  00:E80F  11 00 43            build:		ld	de,vars.ping.packet
     291:  00:E812  D5                  		push	de
     292:  00:E813  21 3A E8            		 ld	hl,packet
     293:  00:E816  01 08 00            		 ld	bc,packet_size
     294:  00:E819  ED B0               		 ldir				; Copy fixed packet to buffer
     295:  00:E81B                      ;
     296:  00:E81B  21 4D 40            		 ld	hl,vars.ping.seq	; Put sequence # in packet
     297:  00:E81E  34                  		 inc	(hl)
     298:  00:E81F  7E                  		 ld	a,(hl)
     299:  00:E820  32 07 43            		 ld	(vars.ping.packet.seq+1),a; Use network byte order!
     300:  00:E823                      ;
     301:  00:E823  E1                  		pop	hl			; HL->packet
     302:  00:E824  E5                  		push	hl
     303:  00:E825                      ;
     304:  00:E825  01 08 00            		 ld	bc,vars.ping.packet_size
     305:  00:E828  C5                  		 push	bc
     306:  00:E829  CD 42 E8            		  call	checksum
     307:  00:E82C  7C                  		  ld	a,h
     308:  00:E82D  65                  		  ld	h,l
     309:  00:E82E  6F                  		  ld	l,a
     310:  00:E82F  22 02 43            		  ld	(vars.ping.packet.csum),hl
     311:  00:E832  C1                  		 pop	bc			; BC=byte count
     312:  00:E833                      ;
     313:  00:E833  E1                  		pop	hl			; HL->data
     314:  00:E834                      ;
     315:  00:E834  C5                  		push	bc
     316:  00:E835  CD BF DB            		 call	socket.write_0
     317:  00:E838  E1                  		pop	hl			; HL=bytes sent
     318:  00:E839                      ;
     319:  00:E839  C9                  		ret
     320:  00:E83A                      ;
     321:  00:E83A  08                  packet:		db	8			; Type 8 = echo
     322:  00:E83B  00                  		db	0			; Code always 0
     323:  00:E83C  00 00               		dw	0			; Checksum 0 for now
     324:  00:E83E  42 42               		dw	OUR_ID			; Identifier
     325:  00:E840  00 00               		db	0, 0			; Sequence 0
     326:  00:E842  (00:0008)           packet_size	equ	$-packet
     327:  00:E842                      ;
     328:  00:E842                      ;------------------------------------------------------------------------------
     329:  00:E842                      ; checksum
     330:  00:E842                      ;
     331:  00:E842                      ; Calculates a checksum for a ICMP packet.
     332:  00:E842                      ;
     333:  00:E842                      ; "The checksum is the 16-bit one's complement of the one's complement sum of
     334:  00:E842                      ; the ICMP message starting with the ICMP type".
     335:  00:E842                      ;
     336:  00:E842                      ; In:  HL->data
     337:  00:E842                      ;      BC=byte count but must be even
     338:  00:E842  EB                  checksum:	ex	de,hl		; DE->data
     339:  00:E843  B7                  		or	a
     340:  00:E844  ED 62               		sbc	hl,hl		; Initial checksum
     341:  00:E846  13                  .loop:		inc	de		; Do low byte first
     342:  00:E847  1A                  		ld	a,(de)
     343:  00:E848  85                  		add	a,l
     344:  00:E849  6F                  		ld	l,a
     345:  00:E84A                      ;
     346:  00:E84A  1B                  		dec	de		; Then high byte
     347:  00:E84B  1A                  		ld	a,(de)
     348:  00:E84C  8C                  		adc	a,h
     349:  00:E84D  67                  		ld	h,a
     350:  00:E84E                      ;
     351:  00:E84E  13                  		inc	de		; Move on to next word
     352:  00:E84F  13                  		inc	de
     353:  00:E850                      ;
     354:  00:E850  0B                  		dec	bc
     355:  00:E851  0B                  		dec	bc
     356:  00:E852  78                  		ld	a,b
     357:  00:E853  B1                  		or	c
     358:  00:E854  20 F0               		jr	nz,.loop
     359:  00:E856                      ;
     360:  00:E856  EB                  		ex	de,hl		; DE=checksum
     361:  00:E857  ED 62               		sbc	hl,hl		; HL=0
     362:  00:E859  ED 52               		sbc	hl,de		; HL=2s complement
     363:  00:E85B  2B                  		dec	hl		; HL=1s complement
     364:  00:E85C  C9                  		ret
     365:  00:E85D                      ;
     366:  00:E85D                      ;
     367:  00:E85D  50 49 4E 47 00      owner_str:	db	"PING",0
     368:  00:E862                      ;
     369:  00:E862                      ;
     370:  00:E862                      ;
     371:  00:E862                      		endmodule
     109.  00:E862                      	include	ntp.asm
       1:  00:E862                      ; NTP
       2:  00:E862                      ;
       3:  00:E862                      ; Attempts to obtain the current date and time using the Simple Network Time
       4:  00:E862                      ; Protocol
       5:  00:E862                      ;
       6:  00:E862                      		module	ntp
       7:  00:E862                      ;
       8:  00:E862                      ;==============================================================================
       9:  00:E862                      ;
      10:  00:E862                      ; This file is part of the EPNET software
      11:  00:E862                      ;
      12:  00:E862                      ; Copyright (C) 2015  Bruce Tanner
      13:  00:E862                      ;
      14:  00:E862                      ;    This program is free software: you can redistribute it and/or modify
      15:  00:E862                      ;    it under the terms of the GNU General Public License as published by
      16:  00:E862                      ;    the Free Software Foundation, either version 3 of the License, or
      17:  00:E862                      ;    (at your option) any later version.
      18:  00:E862                      ;
      19:  00:E862                      ;    This program is distributed in the hope that it will be useful,
      20:  00:E862                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      21:  00:E862                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      22:  00:E862                      ;    GNU General Public License for more details.
      23:  00:E862                      ;
      24:  00:E862                      ;    You should have received a copy of the GNU General Public License
      25:  00:E862                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      26:  00:E862                      ;
      27:  00:E862                      ; If you do use or modify this file, either for its original purpose or for
      28:  00:E862                      ; something new, I'd love to hear about it! I can be contacted by email at:
      29:  00:E862                      ;
      30:  00:E862                      ; brucetanner@btopenworld.com
      31:  00:E862                      ;
      32:  00:E862                      ;==============================================================================
      33:  00:E862                      ;
      34:  00:E862                      ; For reference, this is the interesting bit of RFC 4330:
      35:  00:E862                      ;
      36:  00:E862                      ;3.  NTP Timestamp Format
      37:  00:E862                      ;
      38:  00:E862                      ;   SNTP uses the standard NTP timestamp format described in RFC 1305 and
      39:  00:E862                      ;   previous versions of that document.  In conformance with standard
      40:  00:E862                      ;   Internet practice, NTP data are specified as integer or fixed-point
      41:  00:E862                      ;   quantities, with bits numbered in big-endian fashion from 0 starting
      42:  00:E862                      ;   at the left or most significant end.  Unless specified otherwise, all
      43:  00:E862                      ;   quantities are unsigned and may occupy the full field width with an
      44:  00:E862                      ;   implied 0 preceding bit 0.
      45:  00:E862                      ;
      46:  00:E862                      ;   Because NTP timestamps are cherished data and, in fact, represent the
      47:  00:E862                      ;   main product of the protocol, a special timestamp format has been
      48:  00:E862                      ;   established.  NTP timestamps are represented as a 64-bit unsigned
      49:  00:E862                      ;   fixed-point number, in seconds relative to 0h on 1 January 1900.  The
      50:  00:E862                      ;   integer part is in the first 32 bits, and the fraction part in the
      51:  00:E862                      ;   last 32 bits.  In the fraction part, the non-significant low-order
      52:  00:E862                      ;   bits are not specified and are ordinarily set to 0.
      53:  00:E862                      ;
      54:  00:E862                      ;      It is advisable to fill the non-significant low-order bits of the
      55:  00:E862                      ;      timestamp with a random, unbiased bitstring, both to avoid
      56:  00:E862                      ;      systematic roundoff errors and to provide loop detection and
      57:  00:E862                      ;      replay detection (see below).  It is important that the bitstring
      58:  00:E862                      ;      be unpredictable by an intruder.  One way of doing this is to
      59:  00:E862                      ;      generate a random 128-bit bitstring at startup.  After that, each
      60:  00:E862                      ;      time the system clock is read, the string consisting of the
      61:  00:E862                      ;      timestamp and bitstring is hashed with the MD5 algorithm, then the
      62:  00:E862                      ;      non-significant bits of the timestamp are copied from the result.
      63:  00:E862                      ;
      64:  00:E862                      ;   The NTP format allows convenient multiple-precision arithmetic and
      65:  00:E862                      ;   conversion to UDP/TIME message (seconds), but does complicate the
      66:  00:E862                      ;   conversion to ICMP Timestamp message (milliseconds) and Unix time
      67:  00:E862                      ;   values (seconds and microseconds or seconds and nanoseconds).  The
      68:  00:E862                      ;   maximum number that can be represented is 4,294,967,295 seconds with
      69:  00:E862                      ;   a precision of about 232 picoseconds, which should be adequate for
      70:  00:E862                      ;   even the most exotic requirements.
      71:  00:E862                      ;
      72:  00:E862                      ;                           1                   2                   3
      73:  00:E862                      ;       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      74:  00:E862                      ;      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      75:  00:E862                      ;      |                           Seconds                             |
      76:  00:E862                      ;      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      77:  00:E862                      ;      |                  Seconds Fraction (0-padded)                  |
      78:  00:E862                      ;      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      79:  00:E862                      ;
      80:  00:E862                      ;   Note that since some time in 1968 (second 2,147,483,648), the most
      81:  00:E862                      ;   significant bit (bit 0 of the integer part) has been set and that the
      82:  00:E862                      ;   64-bit field will overflow some time in 2036 (second 4,294,967,296).
      83:  00:E862                      ;   There will exist a 232-picosecond interval, henceforth ignored, every
      84:  00:E862                      ;   136 years when the 64-bit field will be 0, which by convention is
      85:  00:E862                      ;   interpreted as an invalid or unavailable timestamp.
      86:  00:E862                      ;
      87:  00:E862                      ;      As the NTP timestamp format has been in use for over 20 years, it
      88:  00:E862                      ;      is possible that it will be in use 32 years from now, when the
      89:  00:E862                      ;      seconds field overflows.  As it is probably inappropriate to
      90:  00:E862                      ;      archive NTP timestamps before bit 0 was set in 1968, a convenient
      91:  00:E862                      ;      way to extend the useful life of NTP timestamps is the following
      92:  00:E862                      ;      convention: If bit 0 is set, the UTC time is in the range 1968-
      93:  00:E862                      ;      2036, and UTC time is reckoned from 0h 0m 0s UTC on 1 January
      94:  00:E862                      ;      1900.  If bit 0 is not set, the time is in the range 2036-2104 and
      95:  00:E862                      ;      UTC time is reckoned from 6h 28m 16s UTC on 7 February 2036.  Note
      96:  00:E862                      ;      that when calculating the correspondence, 2000 is a leap year, and
      97:  00:E862                      ;      leap seconds are not included in the reckoning.
      98:  00:E862                      ;
      99:  00:E862                      ;      The arithmetic calculations used by NTP to determine the clock
     100:  00:E862                      ;      offset and roundtrip delay require the client time to be within 34
     101:  00:E862                      ;      years of the server time before the client is launched.  As the
     102:  00:E862                      ;      time since the Unix base 1970 is now more than 34 years, means
     103:  00:E862                      ;      must be available to initialize the clock at a date closer to the
     104:  00:E862                      ;      present, either with a time-of-year (TOY) chip or from firmware.
     105:  00:E862                      ;
     106:  00:E862                      ; 4.  Message Format
     107:  00:E862                      ;
     108:  00:E862                      ;   Both NTP and SNTP are clients of the User Datagram Protocol (UDP)
     109:  00:E862                      ;   specified in RFC 768 [POS80].  The structures of the IP and UDP
     110:  00:E862                      ;   headers are described in the cited specification documents and will
     111:  00:E862                      ;   not be detailed further here.  The UDP port number assigned by the
     112:  00:E862                      ;   IANA to NTP is 123.  The SNTP client should use this value in the UDP
     113:  00:E862                      ;   Destination Port field for client request messages.  The Source Port
     114:  00:E862                      ;   field of these messages can be any nonzero value chosen for
     115:  00:E862                      ;   identification or multiplexing purposes.  The server interchanges
     116:  00:E862                      ;   these fields for the corresponding reply messages.
     117:  00:E862                      ;
     118:  00:E862                      ;      This differs from the RFC 2030 specifications, which required both
     119:  00:E862                      ;      the source and destination ports to be 123.  The intent of this
     120:  00:E862                      ;      change is to allow the identification of particular client
     121:  00:E862                      ;      implementations (which are now allowed to use unreserved port
     122:  00:E862                      ;      numbers, including ones of their choosing) and to attain
     123:  00:E862                      ;      compatibility with Network Address Port Translation (NAPT)
     124:  00:E862                      ;      described in RFC 2663 [SRI99] and RFC 3022 [SRI01].
     125:  00:E862                      ;
     126:  00:E862  (00:007B)           NTP_CLIENT_PORT		equ	123
     127:  00:E862  (00:007B)           NTP_SERVER_PORT		equ	123
     128:  00:E862                      ;
     129:  00:E862                      ;   Figure 1 is a description of the NTP and SNTP message format, which
     130:  00:E862                      ;   follows the IP and UDP headers in the message.  This format is
     131:  00:E862                      ;   identical to the NTP message format described in RFC 1305, with the
     132:  00:E862                      ;   exception of the Reference Identifier field described below.  For
     133:  00:E862                      ;   SNTP client messages, most of these fields are zero or initialized
     134:  00:E862                      ;   with pre-specified data.  For completeness, the function of each
     135:  00:E862                      ;   field is briefly summarized below.
     136:  00:E862                      ;
     137:  00:E862                      ;                           1                   2                   3
     138:  00:E862                      ;       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
     139:  00:E862                      ;   0: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     140:  00:E862                      ;      |LI | VN  |Mode |    Stratum    |     Poll      |   Precision   |
     141:  00:E862                      ;   4: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     142:  00:E862                      ;      |                          Root  Delay                          |
     143:  00:E862                      ;   8: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     144:  00:E862                      ;      |                       Root  Dispersion                        |
     145:  00:E862                      ;  12: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     146:  00:E862                      ;      |                     Reference Identifier                      |
     147:  00:E862                      ;  16: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     148:  00:E862                      ;      |                                                               |
     149:  00:E862                      ;      |                    Reference Timestamp (64)                   |
     150:  00:E862                      ;      |                                                               |
     151:  00:E862                      ;  24: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     152:  00:E862                      ;      |                                                               |
     153:  00:E862                      ;      |                    Originate Timestamp (64)                   |
     154:  00:E862                      ;      |                                                               |
     155:  00:E862                      ;  32: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     156:  00:E862                      ;      |                                                               |
     157:  00:E862                      ;      |                     Receive Timestamp (64)                    |
     158:  00:E862                      ;      |                                                               |
     159:  00:E862                      ;  40: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     160:  00:E862                      ;      |                                                               |
     161:  00:E862                      ;      |                     Transmit Timestamp (64)                   |
     162:  00:E862                      ;      |                                                               |
     163:  00:E862                      ;  48: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     164:  00:E862                      ;      |                 Key Identifier (optional) (32)                |
     165:  00:E862                      ;      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     166:  00:E862                      ;      |                                                               |
     167:  00:E862                      ;      |                                                               |
     168:  00:E862                      ;      |                 Message Digest (optional) (128)               |
     169:  00:E862                      ;      |                                                               |
     170:  00:E862                      ;      |                                                               |
     171:  00:E862                      ;      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     172:  00:E862                      ;
     173:  00:E862                      ;                        Figure 1.  NTP Packet Header
     174:  00:E862                      ;
     175:  00:E862                      ;   Leap Indicator (LI): This is a two-bit code warning of an impending
     176:  00:E862                      ;   leap second to be inserted/deleted in the last minute of the current
     177:  00:E862                      ;   day.  This field is significant only in server messages, where the
     178:  00:E862                      ;   values are defined as follows:
     179:  00:E862                      ;
     180:  00:E862                      ;      LI       Meaning
     181:  00:E862                      ;      ---------------------------------------------
     182:  00:E862                      ;      0        no warning
     183:  00:E862                      ;      1        last minute has 61 seconds
     184:  00:E862                      ;      2        last minute has 59 seconds
     185:  00:E862                      ;      3        alarm condition (clock not synchronized)
     186:  00:E862                      ;
     187:  00:E862                      ;   On startup, servers set this field to 3 (clock not synchronized), and
     188:  00:E862                      ;   set this field to some other value when synchronized to the primary
     189:  00:E862                      ;   reference clock.  Once set to a value other than 3, the field is
     190:  00:E862                      ;   never set to that value again, even if all synchronization sources
     191:  00:E862                      ;   become unreachable or defective.
     192:  00:E862                      ;
     193:  00:E862                      ;   Version Number (VN): This is a three-bit integer indicating the
     194:  00:E862                      ;   NTP/SNTP version number, currently 4.  If necessary to distinguish
     195:  00:E862                      ;   between IPv4, IPv6, and OSI, the encapsulating context must be
     196:  00:E862                      ;   inspected.
     197:  00:E862                      ;
     198:  00:E862                      ;   Mode: This is a three-bit number indicating the protocol mode.  The
     199:  00:E862                      ;   values are defined as follows:
     200:  00:E862                      ;
     201:  00:E862                      ;      Mode     Meaning
     202:  00:E862                      ;      ------------------------------------
     203:  00:E862                      ;      0        reserved
     204:  00:E862                      ;      1        symmetric active
     205:  00:E862                      ;      2        symmetric passive
     206:  00:E862                      ;      3        client
     207:  00:E862                      ;      4        server
     208:  00:E862                      ;      5        broadcast
     209:  00:E862                      ;      6        reserved for NTP control message
     210:  00:E862                      ;      7        reserved for private use
     211:  00:E862                      ;
     212:  00:E862                      ;   In unicast and manycast modes, the client sets this field to 3
     213:  00:E862                      ;   (client) in the request, and the server sets it to 4 (server) in the
     214:  00:E862                      ;   reply.  In broadcast mode, the server sets this field to 5
     215:  00:E862                      ;   (broadcast).  The other modes are not used by SNTP servers and
     216:  00:E862                      ;   clients.
     217:  00:E862                      ;
     218:  00:E862                      ;   Stratum: This is an eight-bit unsigned integer indicating the
     219:  00:E862                      ;   stratum.  This field is significant only in SNTP server messages,
     220:  00:E862                      ;   where the values are defined as follows:
     221:  00:E862                      ;
     222:  00:E862                      ;      Stratum  Meaning
     223:  00:E862                      ;      ----------------------------------------------
     224:  00:E862                      ;      0        kiss-o'-death message (see below)
     225:  00:E862                      ;      1        primary reference (e.g., synchronized by radio clock)
     226:  00:E862                      ;      2-15     secondary reference (synchronized by NTP or SNTP)
     227:  00:E862                      ;      16-255   reserved
     228:  00:E862                      ;
     229:  00:E862                      ;   Poll Interval: This is an eight-bit unsigned integer used as an
     230:  00:E862                      ;   exponent of two, where the resulting value is the maximum interval
     231:  00:E862                      ;   between successive messages in seconds.  This field is significant
     232:  00:E862                      ;   only in SNTP server messages, where the values range from 4 (16 s) to
     233:  00:E862                      ;   17 (131,072 s -- about 36 h).
     234:  00:E862                      ;
     235:  00:E862                      ;   Precision: This is an eight-bit signed integer used as an exponent of
     236:  00:E862                      ;   two, where the resulting value is the precision of the system clock
     237:  00:E862                      ;   in seconds.  This field is significant only in server messages, where
     238:  00:E862                      ;   the values range from -6 for mains-frequency clocks to -20 for
     239:  00:E862                      ;   microsecond clocks found in some workstations.
     240:  00:E862                      ;
     241:  00:E862                      ;   Root Delay: This is a 32-bit signed fixed-point number indicating the
     242:  00:E862                      ;   total roundtrip delay to the primary reference source, in seconds
     243:  00:E862                      ;   with the fraction point between bits 15 and 16.  Note that this
     244:  00:E862                      ;   variable can take on both positive and negative values, depending on
     245:  00:E862                      ;   the relative time and frequency offsets.  This field is significant
     246:  00:E862                      ;   only in server messages, where the values range from negative values
     247:  00:E862                      ;   of a few milliseconds to positive values of several hundred
     248:  00:E862                      ;   milliseconds.
     249:  00:E862                      ;
     250:  00:E862                      ;      Code       External Reference Source
     251:  00:E862                      ;      ------------------------------------------------------------------
     252:  00:E862                      ;      LOCL       uncalibrated local clock
     253:  00:E862                      ;      CESM       calibrated Cesium clock
     254:  00:E862                      ;      RBDM       calibrated Rubidium clock
     255:  00:E862                      ;      PPS        calibrated quartz clock or other pulse-per-second
     256:  00:E862                      ;                 source
     257:  00:E862                      ;      IRIG       Inter-Range Instrumentation Group
     258:  00:E862                      ;      ACTS       NIST telephone modem service
     259:  00:E862                      ;      USNO       USNO telephone modem service
     260:  00:E862                      ;      PTB        PTB (Germany) telephone modem service
     261:  00:E862                      ;      TDF        Allouis (France) Radio 164 kHz
     262:  00:E862                      ;      DCF        Mainflingen (Germany) Radio 77.5 kHz
     263:  00:E862                      ;      MSF        Rugby (UK) Radio 60 kHz
     264:  00:E862                      ;      WWV        Ft. Collins (US) Radio 2.5, 5, 10, 15, 20 MHz
     265:  00:E862                      ;      WWVB       Boulder (US) Radio 60 kHz
     266:  00:E862                      ;      WWVH       Kauai Hawaii (US) Radio 2.5, 5, 10, 15 MHz
     267:  00:E862                      ;      CHU        Ottawa (Canada) Radio 3330, 7335, 14670 kHz
     268:  00:E862                      ;      LORC       LORAN-C radionavigation system
     269:  00:E862                      ;      OMEG       OMEGA radionavigation system
     270:  00:E862                      ;      GPS        Global Positioning Service
     271:  00:E862                      ;
     272:  00:E862                      ;                     Figure 2.  Reference Identifier Codes
     273:  00:E862                      ;
     274:  00:E862                      ;   Root Dispersion: This is a 32-bit unsigned fixed-point number
     275:  00:E862                      ;   indicating the maximum error due to the clock frequency tolerance, in
     276:  00:E862                      ;   seconds with the fraction point between bits 15 and 16.  This field
     277:  00:E862                      ;   is significant only in server messages, where the values range from
     278:  00:E862                      ;   zero to several hundred milliseconds.
     279:  00:E862                      ;
     280:  00:E862                      ;   Reference Identifier: This is a 32-bit bitstring identifying the
     281:  00:E862                      ;   particular reference source.  This field is significant only in
     282:  00:E862                      ;   server messages, where for stratum 0 (kiss-o'-death message) and 1
     283:  00:E862                      ;   (primary server), the value is a four-character ASCII string, left
     284:  00:E862                      ;   justified and zero padded to 32 bits.  For IPv4 secondary servers,
     285:  00:E862                      ;   the value is the 32-bit IPv4 address of the synchronization source.
     286:  00:E862                      ;   For IPv6 and OSI secondary servers, the value is the first 32 bits of
     287:  00:E862                      ;   the MD5 hash of the IPv6 or NSAP address of the synchronization
     288:  00:E862                      ;   source.
     289:  00:E862                      ;
     290:  00:E862                      ;   Primary (stratum 1) servers set this field to a code identifying the
     291:  00:E862                      ;   external reference source according to Figure 2.  If the external
     292:  00:E862                      ;   reference is one of those listed, the associated code should be used.
     293:  00:E862                      ;   Codes for sources not listed can be contrived, as appropriate.
     294:  00:E862                      ;
     295:  00:E862                      ;      In previous NTP and SNTP secondary servers and clients, this field
     296:  00:E862                      ;      was often used to walk-back the synchronization subnet to the root
     297:  00:E862                      ;      (primary server) for management purposes.  In SNTPv4 with IPv6 or
     298:  00:E862                      ;      OSI, this feature is not available, because the addresses are
     299:  00:E862                      ;      longer than 32 bits, and only a hash is available.  However, a
     300:  00:E862                      ;      walk-back can be accomplished using the NTP control message and
     301:  00:E862                      ;      the reference identifier field described in RFC 1305.
     302:  00:E862                      ;
     303:  00:E862                      ;   Reference Timestamp: This field is the time the system clock was last
     304:  00:E862                      ;   set or corrected, in 64-bit timestamp format.
     305:  00:E862                      ;
     306:  00:E862                      ;   Originate Timestamp: This is the time at which the request departed
     307:  00:E862                      ;   the client for the server, in 64-bit timestamp format.
     308:  00:E862                      ;
     309:  00:E862                      ;   Receive Timestamp: This is the time at which the request arrived at
     310:  00:E862                      ;   the server or the reply arrived at the client, in 64-bit timestamp
     311:  00:E862                      ;   format.
     312:  00:E862                      ;
     313:  00:E862                      ;   Transmit Timestamp: This is the time at which the request departed
     314:  00:E862                      ;   the client or the reply departed the server, in 64-bit timestamp
     315:  00:E862                      ;   format.
     316:  00:E862                      ;
     317:  00:E862                      ;   Authenticator (optional): When the NTP authentication scheme is
     318:  00:E862                      ;   implemented, the Key Identifier and Message Digest fields contain the
     319:  00:E862                      ;   message authentication code (MAC) information defined in Appendix C
     320:  00:E862                      ;   of RFC 1305.
     321:  00:E862                      ;
     322:  00:E862                      ;------------------------------------------------------------------------------
     323:  00:E862                      ; init
     324:  00:E862                      ;
     325:  00:E862                      ; Called to get the current time.
     326:  00:E862                      ;
     327:  00:E862                      ; dhcp.dns must contain the time server ip address.
     328:  00:E862                      ;
     329:  00:E862                      ; Out:  NC=>ok
     330:  00:E862                      ;
     331:  00:E862                      init:
     332:  00:E862  11 6A D3            		ld	de,trace.diag.ntp	; Diag mode trace
     333:  00:E865  CD E9 D1            		call	trace.diag.str
     334:  00:E868                      ;
     335:  00:E868  AF                  		xor	a
     336:  00:E869  32 28 40            		ld	(vars.ntp.retries),a
     337:  00:E86C                      ;
     338:  00:E86C  CD AE D0            		call	status.start	; Start waiting indicator
     339:  00:E86F                      ;
     340:  00:E86F  11 8D E9            		ld	de,owner_str	; Our name
     341:  00:E872  21 7B 00            		ld	hl,NTP_CLIENT_PORT	; Always use this port
     342:  00:E875  CD DA DE            		call	udp.open_0	; Open socket
     343:  00:E878  38 02               		jr	c,.error
     344:  00:E87A                      ;
     345:  00:E87A  18 0F               		jr	.start
     346:  00:E87C                      ;
     347:  00:E87C  FD CB 00 66         .error:		bit	vars.trace.ntp,(iy+vars._trace)
     348:  00:E880  C4 4D D2            		call	nz,trace.error
     349:  00:E883                      ;
     350:  00:E883  CD A8 DC            .abort:		call	socket.close_0
     351:  00:E886  CD A2 D0            		call	status.stop	; Stop waiting indicator
     352:  00:E889  37                  		scf
     353:  00:E88A  C9                  		ret
     354:  00:E88B                      ;
     355:  00:E88B                      .start:
     356:  00:E88B  21 28 40            		ld	hl,vars.ntp.retries
     357:  00:E88E  34                  		inc	(hl)
     358:  00:E88F  3E 0A               		ld	a,10
     359:  00:E891  BE                  		cp	(hl)
     360:  00:E892  38 E8               		jr	c,.error	; Try 10 times, then give up
     361:  00:E894                      ;
     362:  00:E894  CD 24 E9            		call	send		; Send a time request
     363:  00:E897  38 E3               		jr	c,.error
     364:  00:E899                      ;
     365:  00:E899                      		; Wait for a replay with timeout
     366:  00:E899  2A 0E 40            		ld	hl,(vars.ticks)
     367:  00:E89C  22 26 40            		ld	(vars.ntp.timeout),hl
     368:  00:E89F  CD E1 DE            .loop:		call	udp.header_0
     369:  00:E8A2  20 2B               		jr	nz,.gotpacket
     370:  00:E8A4                      ;
     371:  00:E8A4  CD C3 D0            		call	status.waiting	; Flash status indicator
     372:  00:E8A7                      ;
     373:  00:E8A7  CD C3 CA            		call	exos.is_stop
     374:  00:E8AA  38 D7               		jr	c,.abort
     375:  00:E8AC                      ;
     376:  00:E8AC  ED 5B 26 40         		ld	de,(vars.ntp.timeout)
     377:  00:E8B0  2A 0E 40            		ld	hl,(vars.ticks)
     378:  00:E8B3  B7                  		or	a
     379:  00:E8B4  ED 52               		sbc	hl,de		; HL=duration so far
     380:  00:E8B6  11 32 00            		ld	de,TICKS_1s	; 1S timout in ticks
     381:  00:E8B9  ED 52               		sbc	hl,de
     382:  00:E8BB  38 E2               		jr	c,.loop		; Keep waiting if not timed out
     383:  00:E8BD                      ;
     384:  00:E8BD  FD CB 00 66         		bit	vars.trace.ntp,(iy+vars._trace)
     385:  00:E8C1  C4 48 D2            		call	nz,trace.timeout
     386:  00:E8C4                      ;
     387:  00:E8C4  18 C5               		jr	.start		; Timed out...send req again
     388:  00:E8C6                      ;
     389:  00:E8C6  FD CB 00 66         .badpacket:	bit	vars.trace.ntp,(iy+vars._trace)
     390:  00:E8CA  C4 4D D2            		call	nz,trace.error
     391:  00:E8CD  18 BC               		jr	.start
     392:  00:E8CF                      ;
     393:  00:E8CF                      .gotpacket:
     394:  00:E8CF  FD CB 00 66         		bit	vars.trace.ntp,(iy+vars._trace)
     395:  00:E8D3  28 09               		jr	z,.donetrace
     396:  00:E8D5                      ;
     397:  00:E8D5  CD 1C D0            		call	io.start
     398:  00:E8D8  11 28 D5            		ld	de,trace.ntp.rx
     399:  00:E8DB  CD 36 D0            		call	io.str
     400:  00:E8DE                      .donetrace:
     401:  00:E8DE                      ;
     402:  00:E8DE  B7                  		or	a
     403:  00:E8DF  01 30 00            		ld	bc,vars.ntp.packet_size
     404:  00:E8E2  ED 42               		sbc	hl,bc
     405:  00:E8E4  38 E0               		jr	c,.badpacket	; Too small - ignore
     406:  00:E8E6                      ;
     407:  00:E8E6  21 00 43            		ld	hl,vars.ntp.packet
     408:  00:E8E9  01 30 00            		ld	bc,vars.ntp.packet_size
     409:  00:E8EC  CD D9 DA            		call	socket.read_0	; Read start of NTP packet
     410:  00:E8EF  CD A7 DB            		call	socket.read_end_0
     411:  00:E8F2                      ;
     412:  00:E8F2                      		; Check packet has come from the right port
     413:  00:E8F2  2A 22 40            		ld	hl,(vars.udp.port)
     414:  00:E8F5  01 7B 00            		ld	bc,NTP_SERVER_PORT; Standard server port
     415:  00:E8F8  B7                  		or	a
     416:  00:E8F9  ED 42               		sbc	hl,bc
     417:  00:E8FB  20 C9               		jr	nz,.badpacket
     418:  00:E8FD                      ;
     419:  00:E8FD  FD CB 00 66         		bit	vars.trace.ntp,(iy+vars._trace)
     420:  00:E901  28 19               		jr	z,.donetrace2
     421:  00:E903                      ;
     422:  00:E903  21 2B 43            		ld	hl,vars.ntp.packet.transmit+3	; Time packet left server
     423:  00:E906  5E                  		ld	e,(hl)
     424:  00:E907  2B                  		dec	hl
     425:  00:E908  56                  		ld	d,(hl)
     426:  00:E909  2B                  		dec	hl
     427:  00:E90A  E5                  		push	hl
     428:  00:E90B  EB                  		 ex	de,hl
     429:  00:E90C  CD AA CF            		 call	io.int
     430:  00:E90F  E1                  		pop	hl
     431:  00:E910  3E 2C               		ld	a,','
     432:  00:E912  CD F9 CF            		call	io.char
     433:  00:E915  5E                  		ld	e,(hl)
     434:  00:E916  2B                  		dec	hl
     435:  00:E917  56                  		ld	d,(hl)
     436:  00:E918  EB                  		ex	de,hl
     437:  00:E919  CD AA CF            		call	io.int
     438:  00:E91C                      
     439:  00:E91C                      .donetrace2:
     440:  00:E91C  CD A8 DC            		call	socket.close_0
     441:  00:E91F  CD A2 D0            		call	status.stop	; Stop waiting indicator
     442:  00:E922  B7                  		or	a		; NC=>no error
     443:  00:E923  C9                  		ret
     444:  00:E924                      ;
     445:  00:E924                      ;
     446:  00:E924                      ;------------------------------------------------------------------------------
     447:  00:E924                      ; send
     448:  00:E924                      ;
     449:  00:E924                      ; Sends a request to the time server
     450:  00:E924                      ;
     451:  00:E924                      ; Out: NC=>ok
     452:  00:E924                      send:
     453:  00:E924                      		; If we got an NTP address via DHCP, we use that. Otherwise
     454:  00:E924                      		; we use the standard broadcast address
     455:  00:E924  21 3D 40            		ld	hl,vars.dhcp.ntp; HL->DHCP NTP IP adrdess
     456:  00:E927  7E                  		ld	a,(hl)		; 0=>not set
     457:  00:E928  B7                  		or	a
     458:  00:E929  20 03               		jr	nz,.gotntp	; Go if got an IP address via DHCP
     459:  00:E92B                      ;
     460:  00:E92B  21 89 E9            		ld	hl,broadcast_ip	; Else use standard broadcast
     461:  00:E92E  11 1E 40            .gotntp:	ld	de,vars.udp.ip	; Copy IP to use to udp.ip
     462:  00:E931  01 04 00            		ld	bc,4
     463:  00:E934  ED B0               		ldir
     464:  00:E936                      ;
     465:  00:E936  21 7B 00            		ld	hl,NTP_SERVER_PORT	; Standard NTP port
     466:  00:E939  22 22 40            		ld	(vars.udp.port),hl
     467:  00:E93C                      ;
     468:  00:E93C  FD CB 00 66         		bit	vars.trace.ntp,(iy+vars._trace)
     469:  00:E940  28 1D               		jr	z,.donetrace
     470:  00:E942                      ;
     471:  00:E942  CD 1C D0            		call	io.start
     472:  00:E945  11 15 D5            		ld	de,trace.ntp.tx
     473:  00:E948  CD 36 D0            		call	io.str
     474:  00:E94B  21 1E 40            		ld	hl,vars.udp.ip
     475:  00:E94E  CD 85 CF            		call	io.ip
     476:  00:E951  3E 3A               		ld	a,':'
     477:  00:E953  CD F9 CF            		call	io.char
     478:  00:E956  2A 22 40            		ld	hl,(vars.udp.port)
     479:  00:E959  CD AA CF            		call	io.int
     480:  00:E95C  CD 36 D2            		call	trace.dots
     481:  00:E95F                      .donetrace:
     482:  00:E95F                      		; Construct a SNTP packet
     483:  00:E95F  21 00 43            		ld	hl,vars.ntp.packet
     484:  00:E962  01 30 00            		ld	bc,vars.ntp.packet_size
     485:  00:E965  E5                  		push	hl			; Save ->packet
     486:  00:E966  C5                  		push	bc			; Save packet size
     487:  00:E967  CD 20 D1            		 call	util.memzero		; Zero packet buffer
     488:  00:E96A                      ;
     489:  00:E96A  36 E3               		 ld	(hl),11100011b		; LI, Version, mode
     490:  00:E96C  23                  		 inc	hl			; HL->stratum
     491:  00:E96D  23                  		 inc	hl			; HL->poll
     492:  00:E96E  36 06               		 ld	(hl),6			; Poll interval=6
     493:  00:E970  23                  		 inc	hl			; HL->Precision
     494:  00:E971  36 EC               		 ld	(hl),0ech
     495:  00:E973                      ;
     496:  00:E973  21 0C 43            		 ld	hl,vars.ntp.packet.identifier
     497:  00:E976  36 31               		 ld	(hl),49
     498:  00:E978  23                  		 inc	hl
     499:  00:E979  36 4E               		 ld	(hl),4eh
     500:  00:E97B  23                  		 inc	hl
     501:  00:E97C  36 31               		 ld	(hl),49
     502:  00:E97E  23                  		 inc	hl
     503:  00:E97F  36 34               		 ld	(hl),52
     504:  00:E981  C1                  		pop	bc			; BC=packet size
     505:  00:E982  E1                  		pop	hl			; HL->packet
     506:  00:E983  CD BF DB            		call	socket.write_0
     507:  00:E986                      ;
     508:  00:E986  C3 2A DF            		jp	udp.send_0
     509:  00:E989                      ;
     510:  00:E989                      ;broadcast_ip:	db	224,0,1,1	; Standard NTP default broadcast ip
     511:  00:E989  FF FF FF FF         broadcast_ip:	db	255,255,255,255	; Standard NTP default broadcast ip
     512:  00:E98D                      ;
     513:  00:E98D                      ;
     514:  00:E98D  4E 54 50 00         owner_str:	db	"NTP",0
     515:  00:E991                      ;
     516:  00:E991                      ;
     517:  00:E991                      ;
     518:  00:E991                      		endmodule
     110.  00:E991                      	include	ftp.asm
       1:  00:E991                      ; FTP
       2:  00:E991                      ;
       3:  00:E991                      ; This module implements the FTP protocol
       4:  00:E991                      ;
       5:  00:E991                      		module	ftp
       6:  00:E991                      ;
       7:  00:E991                      ;==============================================================================
       8:  00:E991                      ;
       9:  00:E991                      ; This file is part of the EPNET software
      10:  00:E991                      ;
      11:  00:E991                      ; Copyright (C) 2015  Bruce Tanner
      12:  00:E991                      ;
      13:  00:E991                      ;    This program is free software: you can redistribute it and/or modify
      14:  00:E991                      ;    it under the terms of the GNU General Public License as published by
      15:  00:E991                      ;    the Free Software Foundation, either version 3 of the License, or
      16:  00:E991                      ;    (at your option) any later version.
      17:  00:E991                      ;
      18:  00:E991                      ;    This program is distributed in the hope that it will be useful,
      19:  00:E991                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      20:  00:E991                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      21:  00:E991                      ;    GNU General Public License for more details.
      22:  00:E991                      ;
      23:  00:E991                      ;    You should have received a copy of the GNU General Public License
      24:  00:E991                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      25:  00:E991                      ;
      26:  00:E991                      ; If you do use or modify this file, either for its original purpose or for
      27:  00:E991                      ; something new, I'd love to hear about it! I can be contacted by email at:
      28:  00:E991                      ;
      29:  00:E991                      ; brucetanner@btopenworld.com
      30:  00:E991                      ;
      31:  00:E991                      ;==============================================================================
      32:  00:E991                      ;
      33:  00:E991                      ; For reference, here are the interesting bits of RFC 959:
      34:  00:E991                      ;
      35:  00:E991                      ; 4.  FILE TRANSFER FUNCTIONS
      36:  00:E991                      ;
      37:  00:E991                      ;   The communication channel from the user-PI to the server-PI is
      38:  00:E991                      ;   established as a TCP connection from the user to the standard server
      39:  00:E991                      ;   port.  The user protocol interpreter is responsible for sending FTP
      40:  00:E991                      ;   commands and interpreting the replies received; the server-PI
      41:  00:E991                      ;   interprets commands, sends replies and directs its DTP to set up the
      42:  00:E991                      ;   data connection and transfer the data.  If the second party to the
      43:  00:E991                      ;   data transfer (the passive transfer process) is the user-DTP, then it
      44:  00:E991                      ;   is governed through the internal protocol of the user-FTP host; if it
      45:  00:E991                      ;   is a second server-DTP, then it is governed by its PI on command from
      46:  00:E991                      ;   the user-PI.  The FTP replies are discussed in the next section.  In
      47:  00:E991                      ;   the description of a few of the commands in this section, it is
      48:  00:E991                      ;   helpful to be explicit about the possible replies.
      49:  00:E991                      ;
      50:  00:E991                      ;   4.1.  FTP COMMANDS
      51:  00:E991                      ;
      52:  00:E991                      ;      4.1.1.  ACCESS CONTROL COMMANDS
      53:  00:E991                      ;
      54:  00:E991                      ;         The following commands specify access control identifiers
      55:  00:E991                      ;         (command codes are shown in parentheses).
      56:  00:E991                      ;
      57:  00:E991                      ;         USER NAME (USER)
      58:  00:E991                      ;
      59:  00:E991                      ;            The argument field is a Telnet string identifying the user.
      60:  00:E991                      ;            The user identification is that which is required by the
      61:  00:E991                      ;            server for access to its file system.  This command will
      62:  00:E991                      ;            normally be the first command transmitted by the user after
      63:  00:E991                      ;            the control connections are made (some servers may require
      64:  00:E991                      ;            this).  Additional identification information in the form of
      65:  00:E991                      ;            a password and/or an account command may also be required by
      66:  00:E991                      ;            some servers.  Servers may allow a new USER command to be
      67:  00:E991                      ;            entered at any point in order to change the access control
      68:  00:E991                      ;            and/or accounting information.  This has the effect of
      69:  00:E991                      ;            flushing any user, password, and account information already
      70:  00:E991                      ;            supplied and beginning the login sequence again.  All
      71:  00:E991                      ;            transfer parameters are unchanged and any file transfer in
      72:  00:E991                      ;            progress is completed under the old access control
      73:  00:E991                      ;            parameters.
      74:  00:E991                      ;
      75:  00:E991                      ;         PASSWORD (PASS)
      76:  00:E991                      ;
      77:  00:E991                      ;            The argument field is a Telnet string specifying the user's
      78:  00:E991                      ;            password.  This command must be immediately preceded by the
      79:  00:E991                      ;            user name command, and, for some sites, completes the user's
      80:  00:E991                      ;            identification for access control.  Since password
      81:  00:E991                      ;            information is quite sensitive, it is desirable in general
      82:  00:E991                      ;            to "mask" it or suppress typeout.  It appears that the
      83:  00:E991                      ;            server has no foolproof way to achieve this.  It is
      84:  00:E991                      ;            therefore the responsibility of the user-FTP process to hide
      85:  00:E991                      ;            the sensitive password information.
      86:  00:E991                      ;
      87:  00:E991                      ;         ACCOUNT (ACCT)
      88:  00:E991                      ;
      89:  00:E991                      ;            The argument field is a Telnet string identifying the user's
      90:  00:E991                      ;            account.  The command is not necessarily related to the USER
      91:  00:E991                      ;            command, as some sites may require an account for login and
      92:  00:E991                      ;            others only for specific access, such as storing files.  In
      93:  00:E991                      ;            the latter case the command may arrive at any time.
      94:  00:E991                      ;
      95:  00:E991                      ;            There are reply codes to differentiate these cases for the
      96:  00:E991                      ;            automation: when account information is required for login,
      97:  00:E991                      ;            the response to a successful PASSword command is reply code
      98:  00:E991                      ;            332.  On the other hand, if account information is NOT
      99:  00:E991                      ;            required for login, the reply to a successful PASSword
     100:  00:E991                      ;            command is 230; and if the account information is needed for
     101:  00:E991                      ;            a command issued later in the dialogue, the server should
     102:  00:E991                      ;            return a 332 or 532 reply depending on whether it stores
     103:  00:E991                      ;            (pending receipt of the ACCounT command) or discards the
     104:  00:E991                      ;            command, respectively.
     105:  00:E991                      ;
     106:  00:E991                      ;         CHANGE WORKING DIRECTORY (CWD)
     107:  00:E991                      ;
     108:  00:E991                      ;            This command allows the user to work with a different
     109:  00:E991                      ;            directory or dataset for file storage or retrieval without
     110:  00:E991                      ;            altering his login or accounting information.  Transfer
     111:  00:E991                      ;            parameters are similarly unchanged.  The argument is a
     112:  00:E991                      ;            pathname specifying a directory or other system dependent
     113:  00:E991                      ;            file group designator.
     114:  00:E991                      ;
     115:  00:E991                      ;         CHANGE TO PARENT DIRECTORY (CDUP)
     116:  00:E991                      ;
     117:  00:E991                      ;            This command is a special case of CWD, and is included to
     118:  00:E991                      ;            simplify the implementation of programs for transferring
     119:  00:E991                      ;            directory trees between operating systems having different
     120:  00:E991                      ;            syntaxes for naming the parent directory.  The reply codes
     121:  00:E991                      ;            shall be identical to the reply codes of CWD.  See
     122:  00:E991                      ;            Appendix II for further details.
     123:  00:E991                      ;
     124:  00:E991                      ;         STRUCTURE MOUNT (SMNT)
     125:  00:E991                      ;
     126:  00:E991                      ;            This command allows the user to mount a different file
     127:  00:E991                      ;            system data structure without altering his login or
     128:  00:E991                      ;            accounting information.  Transfer parameters are similarly
     129:  00:E991                      ;            unchanged.  The argument is a pathname specifying a
     130:  00:E991                      ;            directory or other system dependent file group designator.
     131:  00:E991                      ;
     132:  00:E991                      ;         REINITIALIZE (REIN)
     133:  00:E991                      ;
     134:  00:E991                      ;            This command terminates a USER, flushing all I/O and account
     135:  00:E991                      ;            information, except to allow any transfer in progress to be
     136:  00:E991                      ;            completed.  All parameters are reset to the default settings
     137:  00:E991                      ;            and the control connection is left open.  This is identical
     138:  00:E991                      ;            to the state in which a user finds himself immediately after
     139:  00:E991                      ;            the control connection is opened.  A USER command may be
     140:  00:E991                      ;            expected to follow.
     141:  00:E991                      ;
     142:  00:E991                      ;         LOGOUT (QUIT)
     143:  00:E991                      ;
     144:  00:E991                      ;            This command terminates a USER and if file transfer is not
     145:  00:E991                      ;            in progress, the server closes the control connection.  If
     146:  00:E991                      ;            file transfer is in progress, the connection will remain
     147:  00:E991                      ;            open for result response and the server will then close it.
     148:  00:E991                      ;            If the user-process is transferring files for several USERs
     149:  00:E991                      ;            but does not wish to close and then reopen connections for
     150:  00:E991                      ;            each, then the REIN command should be used instead of QUIT.
     151:  00:E991                      ;
     152:  00:E991                      ;            An unexpected close on the control connection will cause the
     153:  00:E991                      ;            server to take the effective action of an abort (ABOR) and a
     154:  00:E991                      ;            logout (QUIT).
     155:  00:E991                      ;
     156:  00:E991                      ;      4.1.2.  TRANSFER PARAMETER COMMANDS
     157:  00:E991                      ;
     158:  00:E991                      ;         All data transfer parameters have default values, and the
     159:  00:E991                      ;         commands specifying data transfer parameters are required only
     160:  00:E991                      ;         if the default parameter values are to be changed.  The default
     161:  00:E991                      ;         value is the last specified value, or if no value has been
     162:  00:E991                      ;         specified, the standard default value is as stated here.  This
     163:  00:E991                      ;         implies that the server must "remember" the applicable default
     164:  00:E991                      ;         values.  The commands may be in any order except that they must
     165:  00:E991                      ;         precede the FTP service request.  The following commands
     166:  00:E991                      ;         specify data transfer parameters:
     167:  00:E991                      ;
     168:  00:E991                      ;         DATA PORT (PORT)
     169:  00:E991                      ;
     170:  00:E991                      ;            The argument is a HOST-PORT specification for the data port
     171:  00:E991                      ;            to be used in data connection.  There are defaults for both
     172:  00:E991                      ;            the user and server data ports, and under normal
     173:  00:E991                      ;            circumstances this command and its reply are not needed.  If
     174:  00:E991                      ;            this command is used, the argument is the concatenation of a
     175:  00:E991                      ;            32-bit internet host address and a 16-bit TCP port address.
     176:  00:E991                      ;            This address information is broken into 8-bit fields and the
     177:  00:E991                      ;            value of each field is transmitted as a decimal number (in
     178:  00:E991                      ;            character string representation).  The fields are separated
     179:  00:E991                      ;            by commas.  A port command would be:
     180:  00:E991                      ;
     181:  00:E991                      ;               PORT h1,h2,h3,h4,p1,p2
     182:  00:E991                      ;
     183:  00:E991                      ;            where h1 is the high order 8 bits of the internet host
     184:  00:E991                      ;            address.
     185:  00:E991                      ;
     186:  00:E991                      ;         PASSIVE (PASV)
     187:  00:E991                      ;
     188:  00:E991                      ;            This command requests the server-DTP to "listen" on a data
     189:  00:E991                      ;            port (which is not its default data port) and to wait for a
     190:  00:E991                      ;            connection rather than initiate one upon receipt of a
     191:  00:E991                      ;            transfer command.  The response to this command includes the
     192:  00:E991                      ;            host and port address this server is listening on.
     193:  00:E991                      ;
     194:  00:E991                      ;         REPRESENTATION TYPE (TYPE)
     195:  00:E991                      ;
     196:  00:E991                      ;            The argument specifies the representation type as described
     197:  00:E991                      ;            in the Section on Data Representation and Storage.  Several
     198:  00:E991                      ;            types take a second parameter.  The first parameter is
     199:  00:E991                      ;            denoted by a single Telnet character, as is the second
     200:  00:E991                      ;            Format parameter for ASCII and EBCDIC; the second parameter
     201:  00:E991                      ;            for local byte is a decimal integer to indicate Bytesize.
     202:  00:E991                      ;            The parameters are separated by a <SP> (Space, ASCII code
     203:  00:E991                      ;            32).
     204:  00:E991                      ;
     205:  00:E991                      ;            The following codes are assigned for type:
     206:  00:E991                      ;
     207:  00:E991                      ;                         \    /
     208:  00:E991                      ;               A - ASCII |    | N - Non-print
     209:  00:E991                      ;                         |-><-| T - Telnet format effectors
     210:  00:E991                      ;               E - EBCDIC|    | C - Carriage Control (ASA)
     211:  00:E991                      ;                         /    \
     212:  00:E991                      ;               I - Image
     213:  00:E991                      ;               
     214:  00:E991                      ;               L <byte size> - Local byte Byte size
     215:  00:E991                      ;
     216:  00:E991                      ;            The default representation type is ASCII Non-print.  If the
     217:  00:E991                      ;            Format parameter is changed, and later just the first
     218:  00:E991                      ;            argument is changed, Format then returns to the Non-print
     219:  00:E991                      ;            default.
     220:  00:E991                      ;
     221:  00:E991                      ;         FILE STRUCTURE (STRU)
     222:  00:E991                      ;
     223:  00:E991                      ;            The argument is a single Telnet character code specifying
     224:  00:E991                      ;            file structure described in the Section on Data
     225:  00:E991                      ;            Representation and Storage.
     226:  00:E991                      ;
     227:  00:E991                      ;            The following codes are assigned for structure:
     228:  00:E991                      ;
     229:  00:E991                      ;               F - File (no record structure)
     230:  00:E991                      ;               R - Record structure
     231:  00:E991                      ;               P - Page structure
     232:  00:E991                      ;
     233:  00:E991                      ;            The default structure is File.
     234:  00:E991                      ;
     235:  00:E991                      ;         TRANSFER MODE (MODE)
     236:  00:E991                      ;
     237:  00:E991                      ;            The argument is a single Telnet character code specifying
     238:  00:E991                      ;            the data transfer modes described in the Section on
     239:  00:E991                      ;            Transmission Modes.
     240:  00:E991                      ;
     241:  00:E991                      ;            The following codes are assigned for transfer modes:
     242:  00:E991                      ;
     243:  00:E991                      ;               S - Stream
     244:  00:E991                      ;               B - Block
     245:  00:E991                      ;               C - Compressed
     246:  00:E991                      ;
     247:  00:E991                      ;            The default transfer mode is Stream.
     248:  00:E991                      ;
     249:  00:E991                      ;      4.1.3.  FTP SERVICE COMMANDS
     250:  00:E991                      ;
     251:  00:E991                      ;         The FTP service commands define the file transfer or the file
     252:  00:E991                      ;         system function requested by the user.  The argument of an FTP
     253:  00:E991                      ;         service command will normally be a pathname.  The syntax of
     254:  00:E991                      ;         pathnames must conform to server site conventions (with
     255:  00:E991                      ;         standard defaults applicable), and the language conventions of
     256:  00:E991                      ;         the control connection.  The suggested default handling is to
     257:  00:E991                      ;         use the last specified device, directory or file name, or the
     258:  00:E991                      ;         standard default defined for local users.  The commands may be
     259:  00:E991                      ;         in any order except that a "rename from" command must be
     260:  00:E991                      ;         followed by a "rename to" command and the restart command must
     261:  00:E991                      ;         be followed by the interrupted service command (e.g., STOR or
     262:  00:E991                      ;         RETR).  The data, when transferred in response to FTP service
     263:  00:E991                      ;         commands, shall always be sent over the data connection, except
     264:  00:E991                      ;         for certain informative replies.  The following commands
     265:  00:E991                      ;         specify FTP service requests:
     266:  00:E991                      ;
     267:  00:E991                      ;         RETRIEVE (RETR)
     268:  00:E991                      ;
     269:  00:E991                      ;            This command causes the server-DTP to transfer a copy of the
     270:  00:E991                      ;            file, specified in the pathname, to the server- or user-DTP
     271:  00:E991                      ;            at the other end of the data connection.  The status and
     272:  00:E991                      ;            contents of the file at the server site shall be unaffected.
     273:  00:E991                      ;
     274:  00:E991                      ;         STORE (STOR)
     275:  00:E991                      ;
     276:  00:E991                      ;            This command causes the server-DTP to accept the data
     277:  00:E991                      ;            transferred via the data connection and to store the data as
     278:  00:E991                      ;            a file at the server site.  If the file specified in the
     279:  00:E991                      ;            pathname exists at the server site, then its contents shall
     280:  00:E991                      ;            be replaced by the data being transferred.  A new file is
     281:  00:E991                      ;            created at the server site if the file specified in the
     282:  00:E991                      ;            pathname does not already exist.
     283:  00:E991                      ;
     284:  00:E991                      ;         STORE UNIQUE (STOU)
     285:  00:E991                      ;
     286:  00:E991                      ;            This command behaves like STOR except that the resultant
     287:  00:E991                      ;            file is to be created in the current directory under a name
     288:  00:E991                      ;            unique to that directory.  The 250 Transfer Started response
     289:  00:E991                      ;            must include the name generated.
     290:  00:E991                      ;
     291:  00:E991                      ;         APPEND (with create) (APPE)
     292:  00:E991                      ;
     293:  00:E991                      ;            This command causes the server-DTP to accept the data
     294:  00:E991                      ;            transferred via the data connection and to store the data in
     295:  00:E991                      ;            a file at the server site.  If the file specified in the
     296:  00:E991                      ;            pathname exists at the server site, then the data shall be
     297:  00:E991                      ;            appended to that file; otherwise the file specified in the
     298:  00:E991                      ;            pathname shall be created at the server site.
     299:  00:E991                      ;
     300:  00:E991                      ;         ALLOCATE (ALLO)
     301:  00:E991                      ;
     302:  00:E991                      ;            This command may be required by some servers to reserve
     303:  00:E991                      ;            sufficient storage to accommodate the new file to be
     304:  00:E991                      ;            transferred.  The argument shall be a decimal integer
     305:  00:E991                      ;            representing the number of bytes (using the logical byte
     306:  00:E991                      ;            size) of storage to be reserved for the file.  For files
     307:  00:E991                      ;            sent with record or page structure a maximum record or page
     308:  00:E991                      ;            size (in logical bytes) might also be necessary; this is
     309:  00:E991                      ;            indicated by a decimal integer in a second argument field of
     310:  00:E991                      ;            the command.  This second argument is optional, but when
     311:  00:E991                      ;            present should be separated from the first by the three
     312:  00:E991                      ;            Telnet characters <SP> R <SP>.  This command shall be
     313:  00:E991                      ;            followed by a STORe or APPEnd command.  The ALLO command
     314:  00:E991                      ;            should be treated as a NOOP (no operation) by those servers
     315:  00:E991                      ;            which do not require that the maximum size of the file be
     316:  00:E991                      ;            declared beforehand, and those servers interested in only
     317:  00:E991                      ;            the maximum record or page size should accept a dummy value
     318:  00:E991                      ;            in the first argument and ignore it.
     319:  00:E991                      ;
     320:  00:E991                      ;         RESTART (REST)
     321:  00:E991                      ;
     322:  00:E991                      ;            The argument field represents the server marker at which
     323:  00:E991                      ;            file transfer is to be restarted.  This command does not
     324:  00:E991                      ;            cause file transfer but skips over the file to the specified
     325:  00:E991                      ;            data checkpoint.  This command shall be immediately followed
     326:  00:E991                      ;            by the appropriate FTP service command which shall cause
     327:  00:E991                      ;            file transfer to resume.
     328:  00:E991                      ;
     329:  00:E991                      ;         RENAME FROM (RNFR)
     330:  00:E991                      ;
     331:  00:E991                      ;            This command specifies the old pathname of the file which is
     332:  00:E991                      ;            to be renamed.  This command must be immediately followed by
     333:  00:E991                      ;            a "rename to" command specifying the new file pathname.
     334:  00:E991                      ;
     335:  00:E991                      ;         RENAME TO (RNTO)
     336:  00:E991                      ;
     337:  00:E991                      ;            This command specifies the new pathname of the file
     338:  00:E991                      ;            specified in the immediately preceding "rename from"
     339:  00:E991                      ;            command.  Together the two commands cause a file to be
     340:  00:E991                      ;            renamed.
     341:  00:E991                      ;
     342:  00:E991                      ;         ABORT (ABOR)
     343:  00:E991                      ;
     344:  00:E991                      ;            This command tells the server to abort the previous FTP
     345:  00:E991                      ;            service command and any associated transfer of data.  The
     346:  00:E991                      ;            abort command may require "special action", as discussed in
     347:  00:E991                      ;            the Section on FTP Commands, to force recognition by the
     348:  00:E991                      ;            server.  No action is to be taken if the previous command
     349:  00:E991                      ;            has been completed (including data transfer).  The control
     350:  00:E991                      ;            connection is not to be closed by the server, but the data
     351:  00:E991                      ;            connection must be closed.
     352:  00:E991                      ;
     353:  00:E991                      ;            There are two cases for the server upon receipt of this
     354:  00:E991                      ;            command: (1) the FTP service command was already completed,
     355:  00:E991                      ;            or (2) the FTP service command is still in progress.
     356:  00:E991                      ;
     357:  00:E991                      ;               In the first case, the server closes the data connection
     358:  00:E991                      ;               (if it is open) and responds with a 226 reply, indicating
     359:  00:E991                      ;               that the abort command was successfully processed.
     360:  00:E991                      ;
     361:  00:E991                      ;               In the second case, the server aborts the FTP service in
     362:  00:E991                      ;               progress and closes the data connection, returning a 426
     363:  00:E991                      ;               reply to indicate that the service request terminated
     364:  00:E991                      ;               abnormally.  The server then sends a 226 reply,
     365:  00:E991                      ;               indicating that the abort command was successfully
     366:  00:E991                      ;               processed.
     367:  00:E991                      ;
     368:  00:E991                      ;         DELETE (DELE)
     369:  00:E991                      ;
     370:  00:E991                      ;            This command causes the file specified in the pathname to be
     371:  00:E991                      ;            deleted at the server site.  If an extra level of protection
     372:  00:E991                      ;            is desired (such as the query, "Do you really wish to
     373:  00:E991                      ;            delete?"), it should be provided by the user-FTP process.
     374:  00:E991                      ;
     375:  00:E991                      ;         REMOVE DIRECTORY (RMD)
     376:  00:E991                      ;
     377:  00:E991                      ;            This command causes the directory specified in the pathname
     378:  00:E991                      ;            to be removed as a directory (if the pathname is absolute)
     379:  00:E991                      ;            or as a subdirectory of the current working directory (if
     380:  00:E991                      ;            the pathname is relative).  See Appendix II.
     381:  00:E991                      ;
     382:  00:E991                      ;         MAKE DIRECTORY (MKD)
     383:  00:E991                      ;
     384:  00:E991                      ;            This command causes the directory specified in the pathname
     385:  00:E991                      ;            to be created as a directory (if the pathname is absolute)
     386:  00:E991                      ;            or as a subdirectory of the current working directory (if
     387:  00:E991                      ;            the pathname is relative).  See Appendix II.
     388:  00:E991                      ;
     389:  00:E991                      ;         PRINT WORKING DIRECTORY (PWD)
     390:  00:E991                      ;
     391:  00:E991                      ;            This command causes the name of the current working
     392:  00:E991                      ;            directory to be returned in the reply.  See Appendix II.
     393:  00:E991                      ;
     394:  00:E991                      ;         LIST (LIST)
     395:  00:E991                      ;
     396:  00:E991                      ;            This command causes a list to be sent from the server to the
     397:  00:E991                      ;            passive DTP.  If the pathname specifies a directory or other
     398:  00:E991                      ;            group of files, the server should transfer a list of files
     399:  00:E991                      ;            in the specified directory.  If the pathname specifies a
     400:  00:E991                      ;            file then the server should send current information on the
     401:  00:E991                      ;            file.  A null argument implies the user's current working or
     402:  00:E991                      ;            default directory.  The data transfer is over the data
     403:  00:E991                      ;            connection in type ASCII or type EBCDIC.  (The user must
     404:  00:E991                      ;            ensure that the TYPE is appropriately ASCII or EBCDIC).
     405:  00:E991                      ;            Since the information on a file may vary widely from system
     406:  00:E991                      ;            to system, this information may be hard to use automatically
     407:  00:E991                      ;            in a program, but may be quite useful to a human user.
     408:  00:E991                      ;
     409:  00:E991                      ;         NAME LIST (NLST)
     410:  00:E991                      ;
     411:  00:E991                      ;            This command causes a directory listing to be sent from
     412:  00:E991                      ;            server to user site.  The pathname should specify a
     413:  00:E991                      ;            directory or other system-specific file group descriptor; a
     414:  00:E991                      ;            null argument implies the current directory.  The server
     415:  00:E991                      ;            will return a stream of names of files and no other
     416:  00:E991                      ;            information.  The data will be transferred in ASCII or
     417:  00:E991                      ;            EBCDIC type over the data connection as valid pathname
     418:  00:E991                      ;            strings separated by <CRLF> or <NL>.  (Again the user must
     419:  00:E991                      ;            ensure that the TYPE is correct.)  This command is intended
     420:  00:E991                      ;            to return information that can be used by a program to
     421:  00:E991                      ;            further process the files automatically.  For example, in
     422:  00:E991                      ;            the implementation of a "multiple get" function.
     423:  00:E991                      ;
     424:  00:E991                      ;         SITE PARAMETERS (SITE)
     425:  00:E991                      ;
     426:  00:E991                      ;            This command is used by the server to provide services
     427:  00:E991                      ;            specific to his system that are essential to file transfer
     428:  00:E991                      ;            but not sufficiently universal to be included as commands in
     429:  00:E991                      ;            the protocol.  The nature of these services and the
     430:  00:E991                      ;            specification of their syntax can be stated in a reply to
     431:  00:E991                      ;            the HELP SITE command.
     432:  00:E991                      ;
     433:  00:E991                      ;         SYSTEM (SYST)
     434:  00:E991                      ;
     435:  00:E991                      ;            This command is used to find out the type of operating
     436:  00:E991                      ;            system at the server.  The reply shall have as its first
     437:  00:E991                      ;            word one of the system names listed in the current version
     438:  00:E991                      ;            of the Assigned Numbers document [4].
     439:  00:E991                      ;
     440:  00:E991                      ;         STATUS (STAT)
     441:  00:E991                      ;
     442:  00:E991                      ;            This command shall cause a status response to be sent over
     443:  00:E991                      ;            the control connection in the form of a reply.  The command
     444:  00:E991                      ;            may be sent during a file transfer (along with the Telnet IP
     445:  00:E991                      ;            and Synch signals--see the Section on FTP Commands) in which
     446:  00:E991                      ;            case the server will respond with the status of the
     447:  00:E991                      ;            operation in progress, or it may be sent between file
     448:  00:E991                      ;            transfers.  In the latter case, the command may have an
     449:  00:E991                      ;            argument field.  If the argument is a pathname, the command
     450:  00:E991                      ;            is analogous to the "list" command except that data shall be
     451:  00:E991                      ;            transferred over the control connection.  If a partial
     452:  00:E991                      ;            pathname is given, the server may respond with a list of
     453:  00:E991                      ;            file names or attributes associated with that specification.
     454:  00:E991                      ;            If no argument is given, the server should return general
     455:  00:E991                      ;            status information about the server FTP process.  This
     456:  00:E991                      ;            should include current values of all transfer parameters and
     457:  00:E991                      ;            the status of connections.
     458:  00:E991                      ;
     459:  00:E991                      ;         HELP (HELP)
     460:  00:E991                      ;
     461:  00:E991                      ;            This command shall cause the server to send helpful
     462:  00:E991                      ;            information regarding its implementation status over the
     463:  00:E991                      ;            control connection to the user.  The command may take an
     464:  00:E991                      ;            argument (e.g., any command name) and return more specific
     465:  00:E991                      ;            information as a response.  The reply is type 211 or 214.
     466:  00:E991                      ;            It is suggested that HELP be allowed before entering a USER
     467:  00:E991                      ;            command. The server may use this reply to specify
     468:  00:E991                      ;            site-dependent parameters, e.g., in response to HELP SITE.
     469:  00:E991                      ;
     470:  00:E991                      ;         NOOP (NOOP)
     471:  00:E991                      ;
     472:  00:E991                      ;            This command does not affect any parameters or previously
     473:  00:E991                      ;            entered commands. It specifies no action other than that the
     474:  00:E991                      ;            server send an OK reply.
     475:  00:E991                      ;
     476:  00:E991                      ;   The File Transfer Protocol follows the specifications of the Telnet
     477:  00:E991                      ;   protocol for all communications over the control connection.  Since
     478:  00:E991                      ;   the language used for Telnet communication may be a negotiated
     479:  00:E991                      ;   option, all references in the next two sections will be to the
     480:  00:E991                      ;   "Telnet language" and the corresponding "Telnet end-of-line code".
     481:  00:E991                      ;   Currently, one may take these to mean NVT-ASCII and <CRLF>.  No other
     482:  00:E991                      ;   specifications of the Telnet protocol will be cited.
     483:  00:E991                      ;
     484:  00:E991                      ;   FTP commands are "Telnet strings" terminated by the "Telnet end of
     485:  00:E991                      ;   line code".  The command codes themselves are alphabetic characters
     486:  00:E991                      ;   terminated by the character <SP> (Space) if parameters follow and
     487:  00:E991                      ;   Telnet-EOL otherwise.  The command codes and the semantics of
     488:  00:E991                      ;   commands are described in this section; the detailed syntax of
     489:  00:E991                      ;   commands is specified in the Section on Commands, the reply sequences
     490:  00:E991                      ;   are discussed in the Section on Sequencing of Commands and Replies,
     491:  00:E991                      ;   and scenarios illustrating the use of commands are provided in the
     492:  00:E991                      ;   Section on Typical FTP Scenarios.
     493:  00:E991                      ;
     494:  00:E991                      ;   FTP commands may be partitioned as those specifying access-control
     495:  00:E991                      ;   identifiers, data transfer parameters, or FTP service requests.
     496:  00:E991                      ;   Certain commands (such as ABOR, STAT, QUIT) may be sent over the
     497:  00:E991                      ;   control connection while a data transfer is in progress.  Some
     498:  00:E991                      ;   servers may not be able to monitor the control and data connections
     499:  00:E991                      ;   simultaneously, in which case some special action will be necessary
     500:  00:E991                      ;   to get the server's attention.  The following ordered format is
     501:  00:E991                      ;   tentatively recommended:
     502:  00:E991                      ;
     503:  00:E991                      ;      1. User system inserts the Telnet "Interrupt Process" (IP) signal
     504:  00:E991                      ;      in the Telnet stream.
     505:  00:E991                      ;
     506:  00:E991                      ;      2. User system sends the Telnet "Synch" signal.
     507:  00:E991                      ;
     508:  00:E991                      ;      3. User system inserts the command (e.g., ABOR) in the Telnet
     509:  00:E991                      ;      stream.
     510:  00:E991                      ;
     511:  00:E991                      ;      4. Server PI, after receiving "IP", scans the Telnet stream for
     512:  00:E991                      ;      EXACTLY ONE FTP command.
     513:  00:E991                      ;
     514:  00:E991                      ;   (For other servers this may not be necessary but the actions listed
     515:  00:E991                      ;   above should have no unusual effect.)
     516:  00:E991                      ;
     517:  00:E991                      ;   4.2.  FTP REPLIES
     518:  00:E991                      ;
     519:  00:E991                      ;      Replies to File Transfer Protocol commands are devised to ensure
     520:  00:E991                      ;      the synchronization of requests and actions in the process of file
     521:  00:E991                      ;      transfer, and to guarantee that the user process always knows the
     522:  00:E991                      ;      state of the Server.  Every command must generate at least one
     523:  00:E991                      ;      reply, although there may be more than one; in the latter case,
     524:  00:E991                      ;      the multiple replies must be easily distinguished.  In addition,
     525:  00:E991                      ;      some commands occur in sequential groups, such as USER, PASS and
     526:  00:E991                      ;      ACCT, or RNFR and RNTO.  The replies show the existence of an
     527:  00:E991                      ;      intermediate state if all preceding commands have been successful.
     528:  00:E991                      ;      A failure at any point in the sequence necessitates the repetition
     529:  00:E991                      ;      of the entire sequence from the beginning.
     530:  00:E991                      ;
     531:  00:E991                      ;         The details of the command-reply sequence are made explicit in
     532:  00:E991                      ;         a set of state diagrams below.
     533:  00:E991                      ;
     534:  00:E991                      ;      An FTP reply consists of a three digit number (transmitted as
     535:  00:E991                      ;      three alphanumeric characters) followed by some text.  The number
     536:  00:E991                      ;      is intended for use by automata to determine what state to enter
     537:  00:E991                      ;      next; the text is intended for the human user.  It is intended
     538:  00:E991                      ;      that the three digits contain enough encoded information that the
     539:  00:E991                      ;      user-process (the User-PI) will not need to examine the text and
     540:  00:E991                      ;      may either discard it or pass it on to the user, as appropriate.
     541:  00:E991                      ;      In particular, the text may be server-dependent, so there are
     542:  00:E991                      ;      likely to be varying texts for each reply code.
     543:  00:E991                      ;
     544:  00:E991                      ;      A reply is defined to contain the 3-digit code, followed by Space
     545:  00:E991                      ;      <SP>, followed by one line of text (where some maximum line length
     546:  00:E991                      ;      has been specified), and terminated by the Telnet end-of-line
     547:  00:E991                      ;      code.  There will be cases however, where the text is longer than
     548:  00:E991                      ;      a single line.  In these cases the complete text must be bracketed
     549:  00:E991                      ;      so the User-process knows when it may stop reading the reply (i.e.
     550:  00:E991                      ;      stop processing input on the control connection) and go do other
     551:  00:E991                      ;      things.  This requires a special format on the first line to
     552:  00:E991                      ;      indicate that more than one line is coming, and another on the
     553:  00:E991                      ;      last line to designate it as the last.  At least one of these must
     554:  00:E991                      ;      contain the appropriate reply code to indicate the state of the
     555:  00:E991                      ;      transaction.  To satisfy all factions, it was decided that both
     556:  00:E991                      ;      the first and last line codes should be the same.
     557:  00:E991                      ;
     558:  00:E991                      ;         Thus the format for multi-line replies is that the first line
     559:  00:E991                      ;         will begin with the exact required reply code, followed
     560:  00:E991                      ;         immediately by a Hyphen, "-" (also known as Minus), followed by
     561:  00:E991                      ;         text.  The last line will begin with the same code, followed
     562:  00:E991                      ;         immediately by Space <SP>, optionally some text, and the Telnet
     563:  00:E991                      ;         end-of-line code.
     564:  00:E991                      ;
     565:  00:E991                      ;            For example:
     566:  00:E991                      ;                                123-First line
     567:  00:E991                      ;                                Second line
     568:  00:E991                      ;                                  234 A line beginning with numbers
     569:  00:E991                      ;                                123 The last line
     570:  00:E991                      ;
     571:  00:E991                      ;         The user-process then simply needs to search for the second
     572:  00:E991                      ;         occurrence of the same reply code, followed by <SP> (Space), at
     573:  00:E991                      ;         the beginning of a line, and ignore all intermediary lines.  If
     574:  00:E991                      ;         an intermediary line begins with a 3-digit number, the Server
     575:  00:E991                      ;         must pad the front  to avoid confusion.
     576:  00:E991                      ;
     577:  00:E991                      ;            This scheme allows standard system routines to be used for
     578:  00:E991                      ;            reply information (such as for the STAT reply), with
     579:  00:E991                      ;            "artificial" first and last lines tacked on.  In rare cases
     580:  00:E991                      ;            where these routines are able to generate three digits and a
     581:  00:E991                      ;            Space at the beginning of any line, the beginning of each
     582:  00:E991                      ;            text line should be offset by some neutral text, like Space.
     583:  00:E991                      ;
     584:  00:E991                      ;         This scheme assumes that multi-line replies may not be nested.
     585:  00:E991                      ;
     586:  00:E991                      ;      The three digits of the reply each have a special significance.
     587:  00:E991                      ;      This is intended to allow a range of very simple to very
     588:  00:E991                      ;      sophisticated responses by the user-process.  The first digit
     589:  00:E991                      ;      denotes whether the response is good, bad or incomplete.
     590:  00:E991                      ;      (Referring to the state diagram), an unsophisticated user-process
     591:  00:E991                      ;      will be able to determine its next action (proceed as planned,
     592:  00:E991                      ;      redo, retrench, etc.) by simply examining this first digit.  A
     593:  00:E991                      ;      user-process that wants to know approximately what kind of error
     594:  00:E991                      ;      occurred (e.g. file system error, command syntax error) may
     595:  00:E991                      ;      examine the second digit, reserving the third digit for the finest
     596:  00:E991                      ;      gradation of information (e.g., RNTO command without a preceding
     597:  00:E991                      ;      RNFR).
     598:  00:E991                      ;
     599:  00:E991                      ;         There are five values for the first digit of the reply code:
     600:  00:E991                      ;
     601:  00:E991                      ;            1yz   Positive Preliminary reply
     602:  00:E991                      ;
     603:  00:E991                      ;               The requested action is being initiated; expect another
     604:  00:E991                      ;               reply before proceeding with a new command.  (The
     605:  00:E991                      ;               user-process sending another command before the
     606:  00:E991                      ;               completion reply would be in violation of protocol; but
     607:  00:E991                      ;               server-FTP processes should queue any commands that
     608:  00:E991                      ;               arrive while a preceding command is in progress.)  This
     609:  00:E991                      ;               type of reply can be used to indicate that the command
     610:  00:E991                      ;               was accepted and the user-process may now pay attention
     611:  00:E991                      ;               to the data connections, for implementations where
     612:  00:E991                      ;               simultaneous monitoring is difficult.  The server-FTP
     613:  00:E991                      ;               process may send at most, one 1yz reply per command.
     614:  00:E991                      ;
     615:  00:E991                      ;            2yz   Positive Completion reply
     616:  00:E991                      ;
     617:  00:E991                      ;               The requested action has been successfully completed.  A
     618:  00:E991                      ;               new request may be initiated.
     619:  00:E991                      ;
     620:  00:E991                      ;            3yz   Positive Intermediate reply
     621:  00:E991                      ;
     622:  00:E991                      ;               The command has been accepted, but the requested action
     623:  00:E991                      ;               is being held in abeyance, pending receipt of further
     624:  00:E991                      ;               information.  The user should send another command
     625:  00:E991                      ;               specifying this information.  This reply is used in
     626:  00:E991                      ;               command sequence groups.
     627:  00:E991                      ;
     628:  00:E991                      ;            4yz   Transient Negative Completion reply
     629:  00:E991                      ;
     630:  00:E991                      ;               The command was not accepted and the requested action did
     631:  00:E991                      ;               not take place, but the error condition is temporary and
     632:  00:E991                      ;               the action may be requested again.  The user should
     633:  00:E991                      ;               return to the beginning of the command sequence, if any.
     634:  00:E991                      ;               It is difficult to assign a meaning to "transient",
     635:  00:E991                      ;               particularly when two distinct sites (Server- and
     636:  00:E991                      ;               User-processes) have to agree on the interpretation.
     637:  00:E991                      ;               Each reply in the 4yz category might have a slightly
     638:  00:E991                      ;               different time value, but the intent is that the
     639:  00:E991                      ;               user-process is encouraged to try again.  A rule of thumb
     640:  00:E991                      ;               in determining if a reply fits into the 4yz or the 5yz
     641:  00:E991                      ;               (Permanent Negative) category is that replies are 4yz if
     642:  00:E991                      ;               the commands can be repeated without any change in
     643:  00:E991                      ;               command form or in properties of the User or Server
     644:  00:E991                      ;               (e.g., the command is spelled the same with the same
     645:  00:E991                      ;               arguments used; the user does not change his file access
     646:  00:E991                      ;               or user name; the server does not put up a new
     647:  00:E991                      ;               implementation.)
     648:  00:E991                      ;
     649:  00:E991                      ;            5yz   Permanent Negative Completion reply
     650:  00:E991                      ;
     651:  00:E991                      ;               The command was not accepted and the requested action did
     652:  00:E991                      ;               not take place.  The User-process is discouraged from
     653:  00:E991                      ;               repeating the exact request (in the same sequence).  Even
     654:  00:E991                      ;               some "permanent" error conditions can be corrected, so
     655:  00:E991                      ;               the human user may want to direct his User-process to
     656:  00:E991                      ;               reinitiate the command sequence by direct action at some
     657:  00:E991                      ;               point in the future (e.g., after the spelling has been
     658:  00:E991                      ;               changed, or the user has altered his directory status.)
     659:  00:E991                      ;
     660:  00:E991                      ;         The following function groupings are encoded in the second
     661:  00:E991                      ;         digit:
     662:  00:E991                      ;
     663:  00:E991                      ;            x0z   Syntax - These replies refer to syntax errors,
     664:  00:E991                      ;                  syntactically correct commands that don't fit any
     665:  00:E991                      ;                  functional category, unimplemented or superfluous
     666:  00:E991                      ;                  commands.
     667:  00:E991                      ;
     668:  00:E991                      ;            x1z   Information -  These are replies to requests for
     669:  00:E991                      ;                  information, such as status or help.
     670:  00:E991                      ;
     671:  00:E991                      ;            x2z   Connections - Replies referring to the control and
     672:  00:E991                      ;                  data connections.
     673:  00:E991                      ;
     674:  00:E991                      ;            x3z   Authentication and accounting - Replies for the login
     675:  00:E991                      ;                  process and accounting procedures.
     676:  00:E991                      ;
     677:  00:E991                      ;            x4z   Unspecified as yet.
     678:  00:E991                      ;
     679:  00:E991                      ;            x5z   File system - These replies indicate the status of the
     680:  00:E991                      ;                  Server file system vis-a-vis the requested transfer or
     681:  00:E991                      ;                  other file system action.
     682:  00:E991                      ;
     683:  00:E991                      ;         The third digit gives a finer gradation of meaning in each of
     684:  00:E991                      ;         the function categories, specified by the second digit.  The
     685:  00:E991                      ;         list of replies below will illustrate this.  Note that the text
     686:  00:E991                      ;         associated with each reply is recommended, rather than
     687:  00:E991                      ;         mandatory, and may even change according to the command with
     688:  00:E991                      ;         which it is associated.  The reply codes, on the other hand,
     689:  00:E991                      ;         must strictly follow the specifications in the last section;
     690:  00:E991                      ;         that is, Server implementations should not invent new codes for
     691:  00:E991                      ;         situations that are only slightly different from the ones
     692:  00:E991                      ;         described here, but rather should adapt codes already defined.
     693:  00:E991                      ;
     694:  00:E991                      ;            A command such as TYPE or ALLO whose successful execution
     695:  00:E991                      ;            does not offer the user-process any new information will
     696:  00:E991                      ;            cause a 200 reply to be returned.  If the command is not
     697:  00:E991                      ;            implemented by a particular Server-FTP process because it
     698:  00:E991                      ;            has no relevance to that computer system, for example ALLO
     699:  00:E991                      ;            at a TOPS20 site, a Positive Completion reply is still
     700:  00:E991                      ;            desired so that the simple User-process knows it can proceed
     701:  00:E991                      ;            with its course of action.  A 202 reply is used in this case
     702:  00:E991                      ;            with, for example, the reply text:  "No storage allocation
     703:  00:E991                      ;            necessary."  If, on the other hand, the command requests a
     704:  00:E991                      ;            non-site-specific action and is unimplemented, the response
     705:  00:E991                      ;            is 502.  A refinement of that is the 504 reply for a command
     706:  00:E991                      ;            that is implemented, but that requests an unimplemented
     707:  00:E991                      ;            parameter.
     708:  00:E991                      ;
     709:  00:E991                      ;      4.2.1  Reply Codes by Function Groups
     710:  00:E991                      ;
     711:  00:E991                      ;         200 Command okay.
     712:  00:E991                      ;         500 Syntax error, command unrecognized.
     713:  00:E991                      ;             This may include errors such as command line too long.
     714:  00:E991                      ;         501 Syntax error in parameters or arguments.
     715:  00:E991                      ;         202 Command not implemented, superfluous at this site.
     716:  00:E991                      ;         502 Command not implemented.
     717:  00:E991                      ;         503 Bad sequence of commands.
     718:  00:E991                      ;         504 Command not implemented for that parameter.
     719:  00:E991                      ;          
     720:  00:E991                      ;         110 Restart marker reply.
     721:  00:E991                      ;             In this case, the text is exact and not left to the
     722:  00:E991                      ;             particular implementation; it must read:
     723:  00:E991                      ;                  MARK yyyy = mmmm
     724:  00:E991                      ;             Where yyyy is User-process data stream marker, and mmmm
     725:  00:E991                      ;             server's equivalent marker (note the spaces between markers
     726:  00:E991                      ;             and "=").
     727:  00:E991                      ;         211 System status, or system help reply.
     728:  00:E991                      ;         212 Directory status.
     729:  00:E991                      ;         213 File status.
     730:  00:E991                      ;         214 Help message.
     731:  00:E991                      ;             On how to use the server or the meaning of a particular
     732:  00:E991                      ;             non-standard command.  This reply is useful only to the
     733:  00:E991                      ;             human user.
     734:  00:E991                      ;         215 NAME system type.
     735:  00:E991                      ;             Where NAME is an official system name from the list in the
     736:  00:E991                      ;             Assigned Numbers document.
     737:  00:E991                      ;          
     738:  00:E991                      ;         120 Service ready in nnn minutes.
     739:  00:E991                      ;         220 Service ready for new user.
     740:  00:E991                      ;         221 Service closing control connection.
     741:  00:E991                      ;             Logged out if appropriate.
     742:  00:E991                      ;         421 Service not available, closing control connection.
     743:  00:E991                      ;             This may be a reply to any command if the service knows it
     744:  00:E991                      ;             must shut down.
     745:  00:E991                      ;         125 Data connection already open; transfer starting.
     746:  00:E991                      ;         225 Data connection open; no transfer in progress.
     747:  00:E991                      ;         425 Can't open data connection.
     748:  00:E991                      ;         226 Closing data connection.
     749:  00:E991                      ;             Requested file action successful (for example, file
     750:  00:E991                      ;             transfer or file abort).
     751:  00:E991                      ;         426 Connection closed; transfer aborted.
     752:  00:E991                      ;         227 Entering Passive Mode (h1,h2,h3,h4,p1,p2).
     753:  00:E991                      ;          
     754:  00:E991                      ;         230 User logged in, proceed.
     755:  00:E991                      ;         530 Not logged in.
     756:  00:E991                      ;         331 User name okay, need password.
     757:  00:E991                      ;         332 Need account for login.
     758:  00:E991                      ;         532 Need account for storing files.
     759:  00:E991                      ;          
     760:  00:E991                      ;         150 File status okay; about to open data connection.
     761:  00:E991                      ;         250 Requested file action okay, completed.
     762:  00:E991                      ;         257 "PATHNAME" created.
     763:  00:E991                      ;         350 Requested file action pending further information.
     764:  00:E991                      ;         450 Requested file action not taken.
     765:  00:E991                      ;             File unavailable (e.g., file busy).
     766:  00:E991                      ;         550 Requested action not taken.
     767:  00:E991                      ;             File unavailable (e.g., file not found, no access).
     768:  00:E991                      ;         451 Requested action aborted. Local error in processing.
     769:  00:E991                      ;         551 Requested action aborted. Page type unknown.
     770:  00:E991                      ;         452 Requested action not taken.
     771:  00:E991                      ;             Insufficient storage space in system.
     772:  00:E991                      ;         552 Requested file action aborted.
     773:  00:E991                      ;             Exceeded storage allocation (for current directory or
     774:  00:E991                      ;             dataset).
     775:  00:E991                      ;         553 Requested action not taken.
     776:  00:E991                      ;             File name not allowed.
     777:  00:E991                      ;         
     778:  00:E991                      ;
     779:  00:E991                      ;      4.2.2 Numeric  Order List of Reply Codes
     780:  00:E991                      ;
     781:  00:E991                      ;         110 Restart marker reply.
     782:  00:E991                      ;             In this case, the text is exact and not left to the
     783:  00:E991                      ;             particular implementation; it must read:
     784:  00:E991                      ;                  MARK yyyy = mmmm
     785:  00:E991                      ;             Where yyyy is User-process data stream marker, and mmmm
     786:  00:E991                      ;             server's equivalent marker (note the spaces between markers
     787:  00:E991                      ;             and "=").
     788:  00:E991                      ;         120 Service ready in nnn minutes.
     789:  00:E991                      ;         125 Data connection already open; transfer starting.
     790:  00:E991                      ;         150 File status okay; about to open data connection.
     791:  00:E991                      ;         200 Command okay.
     792:  00:E991                      ;         202 Command not implemented, superfluous at this site.
     793:  00:E991                      ;         211 System status, or system help reply.
     794:  00:E991                      ;         212 Directory status.
     795:  00:E991                      ;         213 File status.
     796:  00:E991                      ;         214 Help message.
     797:  00:E991                      ;             On how to use the server or the meaning of a particular
     798:  00:E991                      ;             non-standard command.  This reply is useful only to the
     799:  00:E991                      ;             human user.
     800:  00:E991                      ;         215 NAME system type.
     801:  00:E991                      ;             Where NAME is an official system name from the list in the
     802:  00:E991                      ;             Assigned Numbers document.
     803:  00:E991                      ;         220 Service ready for new user.
     804:  00:E991                      ;         221 Service closing control connection.
     805:  00:E991                      ;             Logged out if appropriate.
     806:  00:E991                      ;         225 Data connection open; no transfer in progress.
     807:  00:E991                      ;         226 Closing data connection.
     808:  00:E991                      ;             Requested file action successful (for example, file
     809:  00:E991                      ;             transfer or file abort).
     810:  00:E991                      ;         227 Entering Passive Mode (h1,h2,h3,h4,p1,p2).
     811:  00:E991                      ;         230 User logged in, proceed.
     812:  00:E991                      ;         250 Requested file action okay, completed.
     813:  00:E991                      ;         257 "PATHNAME" created.
     814:  00:E991                      ;          
     815:  00:E991                      ;         331 User name okay, need password.
     816:  00:E991                      ;         332 Need account for login.
     817:  00:E991                      ;         350 Requested file action pending further information.
     818:  00:E991                      ;          
     819:  00:E991                      ;         421 Service not available, closing control connection.
     820:  00:E991                      ;             This may be a reply to any command if the service knows it
     821:  00:E991                      ;             must shut down.
     822:  00:E991                      ;         425 Can't open data connection.
     823:  00:E991                      ;         426 Connection closed; transfer aborted.
     824:  00:E991                      ;         450 Requested file action not taken.
     825:  00:E991                      ;             File unavailable (e.g., file busy).
     826:  00:E991                      ;         451 Requested action aborted: local error in processing.
     827:  00:E991                      ;         452 Requested action not taken.
     828:  00:E991                      ;             Insufficient storage space in system.
     829:  00:E991                      ;         500 Syntax error, command unrecognized.
     830:  00:E991                      ;             This may include errors such as command line too long.
     831:  00:E991                      ;         501 Syntax error in parameters or arguments.
     832:  00:E991                      ;         502 Command not implemented.
     833:  00:E991                      ;         503 Bad sequence of commands.
     834:  00:E991                      ;         504 Command not implemented for that parameter.
     835:  00:E991                      ;         530 Not logged in.
     836:  00:E991                      ;         532 Need account for storing files.
     837:  00:E991                      ;         550 Requested action not taken.
     838:  00:E991                      ;             File unavailable (e.g., file not found, no access).
     839:  00:E991                      ;         551 Requested action aborted: page type unknown.
     840:  00:E991                      ;         552 Requested file action aborted.
     841:  00:E991                      ;             Exceeded storage allocation (for current directory or
     842:  00:E991                      ;             dataset).
     843:  00:E991                      ;         553 Requested action not taken.
     844:  00:E991                      ;             File name not allowed.
     845:  00:E991                      ;         
     846:  00:E991                      ;
     847:  00:E991                      ; 5.  DECLARATIVE SPECIFICATIONS
     848:  00:E991                      ;
     849:  00:E991                      ;   5.1.  MINIMUM IMPLEMENTATION
     850:  00:E991                      ;
     851:  00:E991                      ;      In order to make FTP workable without needless error messages, the
     852:  00:E991                      ;      following minimum implementation is required for all servers:
     853:  00:E991                      ;
     854:  00:E991                      ;         TYPE - ASCII Non-print
     855:  00:E991                      ;         MODE - Stream
     856:  00:E991                      ;         STRUCTURE - File, Record
     857:  00:E991                      ;         COMMANDS - USER, QUIT, PORT,
     858:  00:E991                      ;                    TYPE, MODE, STRU,
     859:  00:E991                      ;                      for the default values
     860:  00:E991                      ;                    RETR, STOR,
     861:  00:E991                      ;                    NOOP.
     862:  00:E991                      ;
     863:  00:E991                      ;      The default values for transfer parameters are:
     864:  00:E991                      ;
     865:  00:E991                      ;         TYPE - ASCII Non-print
     866:  00:E991                      ;         MODE - Stream
     867:  00:E991                      ;         STRU - File
     868:  00:E991                      ;
     869:  00:E991                      ;      All hosts must accept the above as the standard defaults.
     870:  00:E991                      ;
     871:  00:E991                      ;   5.2.  CONNECTIONS
     872:  00:E991                      ;
     873:  00:E991                      ;      The server protocol interpreter shall "listen" on Port L.  The
     874:  00:E991                      ;      user or user protocol interpreter shall initiate the full-duplex
     875:  00:E991                      ;      control connection.  Server- and user- processes should follow the
     876:  00:E991                      ;      conventions of the Telnet protocol as specified in the
     877:  00:E991                      ;      ARPA-Internet Protocol Handbook [1].  Servers are under no
     878:  00:E991                      ;      obligation to provide for editing of command lines and may require
     879:  00:E991                      ;      that it be done in the user host.  The control connection shall be
     880:  00:E991                      ;      closed by the server at the user's request after all transfers and
     881:  00:E991                      ;      replies are completed.
     882:  00:E991                      ;
     883:  00:E991                      ;      The user-DTP must "listen" on the specified data port; this may be
     884:  00:E991                      ;      the default user port (U) or a port specified in the PORT command.
     885:  00:E991                      ;      The server shall initiate the data connection from his own default
     886:  00:E991                      ;      data port (L-1) using the specified user data port.  The direction
     887:  00:E991                      ;      of the transfer and the port used will be determined by the FTP
     888:  00:E991                      ;      service command.
     889:  00:E991                      ;
     890:  00:E991                      ;      Note that all FTP implementation must support data transfer using
     891:  00:E991                      ;      the default port, and that only the USER-PI may initiate the use
     892:  00:E991                      ;      of non-default ports.
     893:  00:E991                      ;
     894:  00:E991                      ;      When data is to be transferred between two servers, A and B (refer
     895:  00:E991                      ;      to Figure 2), the user-PI, C, sets up control connections with
     896:  00:E991                      ;      both server-PI's.  One of the servers, say A, is then sent a PASV
     897:  00:E991                      ;      command telling him to "listen" on his data port rather than
     898:  00:E991                      ;      initiate a connection when he receives a transfer service command.
     899:  00:E991                      ;      When the user-PI receives an acknowledgment to the PASV command,
     900:  00:E991                      ;      which includes the identity of the host and port being listened
     901:  00:E991                      ;      on, the user-PI then sends A's port, a, to B in a PORT command; a
     902:  00:E991                      ;      reply is returned.  The user-PI may then send the corresponding
     903:  00:E991                      ;      service commands to A and B.  Server B initiates the connection
     904:  00:E991                      ;      and the transfer proceeds.  The command-reply sequence is listed
     905:  00:E991                      ;      below where the messages are vertically synchronous but
     906:  00:E991                      ;      horizontally asynchronous:
     907:  00:E991                      ;
     908:  00:E991                      ;         User-PI - Server A                User-PI - Server B
     909:  00:E991                      ;         ------------------                ------------------
     910:  00:E991                      ;         
     911:  00:E991                      ;         C->A : Connect                    C->B : Connect
     912:  00:E991                      ;         C->A : PASV
     913:  00:E991                      ;         A->C : 227 Entering Passive Mode. A1,A2,A3,A4,a1,a2
     914:  00:E991                      ;                                           C->B : PORT A1,A2,A3,A4,a1,a2
     915:  00:E991                      ;                                           B->C : 200 Okay
     916:  00:E991                      ;         C->A : STOR                       C->B : RETR
     917:  00:E991                      ;                    B->A : Connect to HOST-A, PORT-a
     918:  00:E991                      ;
     919:  00:E991                      ;                                Figure 3
     920:  00:E991                      ;
     921:  00:E991                      ;      The data connection shall be closed by the server under the
     922:  00:E991                      ;      conditions described in the Section on Establishing Data
     923:  00:E991                      ;      Connections.  If the data connection is to be closed following a
     924:  00:E991                      ;      data transfer where closing the connection is not required to
     925:  00:E991                      ;      indicate the end-of-file, the server must do so immediately.
     926:  00:E991                      ;      Waiting until after a new transfer command is not permitted
     927:  00:E991                      ;      because the user-process will have already tested the data
     928:  00:E991                      ;      connection to see if it needs to do a "listen"; (remember that the
     929:  00:E991                      ;      user must "listen" on a closed data port BEFORE sending the
     930:  00:E991                      ;      transfer request).  To prevent a race condition here, the server
     931:  00:E991                      ;      sends a reply (226) after closing the data connection (or if the
     932:  00:E991                      ;      connection is left open, a "file transfer completed" reply (250)
     933:  00:E991                      ;      and the user-PI should wait for one of these replies before
     934:  00:E991                      ;      issuing a new transfer command).
     935:  00:E991                      ;
     936:  00:E991                      ;      Any time either the user or server see that the connection is
     937:  00:E991                      ;      being closed by the other side, it should promptly read any
     938:  00:E991                      ;      remaining data queued on the connection and issue the close on its
     939:  00:E991                      ;      own side.
     940:  00:E991                      ;
     941:  00:E991                      ;   5.3.  COMMANDS
     942:  00:E991                      ;
     943:  00:E991                      ;      The commands are Telnet character strings transmitted over the
     944:  00:E991                      ;      control connections as described in the Section on FTP Commands.
     945:  00:E991                      ;      The command functions and semantics are described in the Section
     946:  00:E991                      ;      on Access Control Commands, Transfer Parameter Commands, FTP
     947:  00:E991                      ;      Service Commands, and Miscellaneous Commands.  The command syntax
     948:  00:E991                      ;      is specified here.
     949:  00:E991                      ;
     950:  00:E991                      ;      The commands begin with a command code followed by an argument
     951:  00:E991                      ;      field.  The command codes are four or fewer alphabetic characters.
     952:  00:E991                      ;      Upper and lower case alphabetic characters are to be treated
     953:  00:E991                      ;      identically.  Thus, any of the following may represent the
     954:  00:E991                      ;      retrieve command:
     955:  00:E991                      ;
     956:  00:E991                      ;                  RETR    Retr    retr    ReTr    rETr
     957:  00:E991                      ;
     958:  00:E991                      ;      This also applies to any symbols representing parameter values,
     959:  00:E991                      ;      such as A or a for ASCII TYPE.  The command codes and the argument
     960:  00:E991                      ;      fields are separated by one or more spaces.
     961:  00:E991                      ;
     962:  00:E991                      ;      The argument field consists of a variable length character string
     963:  00:E991                      ;      ending with the character sequence <CRLF> (Carriage Return, Line
     964:  00:E991                      ;      Feed) for NVT-ASCII representation; for other negotiated languages
     965:  00:E991                      ;      a different end of line character might be used.  It should be
     966:  00:E991                      ;      noted that the server is to take no action until the end of line
     967:  00:E991                      ;      code is received.
     968:  00:E991                      ;
     969:  00:E991                      ;      The syntax is specified below in NVT-ASCII.  All characters in the
     970:  00:E991                      ;      argument field are ASCII characters including any ASCII
     971:  00:E991                      ;      represented decimal integers.  Square brackets denote an optional
     972:  00:E991                      ;      argument field.  If the option is not taken, the appropriate
     973:  00:E991                      ;      default is implied.
     974:  00:E991                      ;
     975:  00:E991                      ;      5.3.1.  FTP COMMANDS
     976:  00:E991                      ;
     977:  00:E991                      ;         The following are the FTP commands:
     978:  00:E991                      ;
     979:  00:E991                      ;            USER <SP> <username> <CRLF>
     980:  00:E991                      ;            PASS <SP> <password> <CRLF>
     981:  00:E991                      ;            ACCT <SP> <account-information> <CRLF>
     982:  00:E991                      ;            CWD  <SP> <pathname> <CRLF>
     983:  00:E991                      ;            CDUP <CRLF>
     984:  00:E991                      ;            SMNT <SP> <pathname> <CRLF>
     985:  00:E991                      ;            QUIT <CRLF>
     986:  00:E991                      ;            REIN <CRLF>
     987:  00:E991                      ;            PORT <SP> <host-port> <CRLF>
     988:  00:E991                      ;            PASV <CRLF>
     989:  00:E991                      ;            TYPE <SP> <type-code> <CRLF>
     990:  00:E991                      ;            STRU <SP> <structure-code> <CRLF>
     991:  00:E991                      ;            MODE <SP> <mode-code> <CRLF>
     992:  00:E991                      ;            RETR <SP> <pathname> <CRLF>
     993:  00:E991                      ;            STOR <SP> <pathname> <CRLF>
     994:  00:E991                      ;            STOU <CRLF>
     995:  00:E991                      ;            APPE <SP> <pathname> <CRLF>
     996:  00:E991                      ;            ALLO <SP> <decimal-integer>
     997:  00:E991                      ;                [<SP> R <SP> <decimal-integer>] <CRLF>
     998:  00:E991                      ;            REST <SP> <marker> <CRLF>
     999:  00:E991                      ;            RNFR <SP> <pathname> <CRLF>
    1000:  00:E991                      ;            RNTO <SP> <pathname> <CRLF>
    1001:  00:E991                      ;            ABOR <CRLF>
    1002:  00:E991                      ;            DELE <SP> <pathname> <CRLF>
    1003:  00:E991                      ;            RMD  <SP> <pathname> <CRLF>
    1004:  00:E991                      ;            MKD  <SP> <pathname> <CRLF>
    1005:  00:E991                      ;            PWD  <CRLF>
    1006:  00:E991                      ;            LIST [<SP> <pathname>] <CRLF>
    1007:  00:E991                      ;            NLST [<SP> <pathname>] <CRLF>
    1008:  00:E991                      ;            SITE <SP> <string> <CRLF>
    1009:  00:E991                      ;            SYST <CRLF>
    1010:  00:E991                      ;            STAT [<SP> <pathname>] <CRLF>
    1011:  00:E991                      ;            HELP [<SP> <string>] <CRLF>
    1012:  00:E991                      ;            NOOP <CRLF>
    1013:  00:E991                      ;
    1014:  00:E991                      ;      5.3.2.  FTP COMMAND ARGUMENTS
    1015:  00:E991                      ;
    1016:  00:E991                      ;         The syntax of the above argument fields (using BNF notation
    1017:  00:E991                      ;         where applicable) is:
    1018:  00:E991                      ;
    1019:  00:E991                      ;            <username> ::= <string>
    1020:  00:E991                      ;            <password> ::= <string>
    1021:  00:E991                      ;            <account-information> ::= <string>
    1022:  00:E991                      ;            <string> ::= <char> | <char><string>
    1023:  00:E991                      ;            <char> ::= any of the 128 ASCII characters except <CR> and
    1024:  00:E991                      ;            <LF>
    1025:  00:E991                      ;            <marker> ::= <pr-string>
    1026:  00:E991                      ;            <pr-string> ::= <pr-char> | <pr-char><pr-string>
    1027:  00:E991                      ;            <pr-char> ::= printable characters, any
    1028:  00:E991                      ;                          ASCII code 33 through 126
    1029:  00:E991                      ;            <byte-size> ::= <number>
    1030:  00:E991                      ;            <host-port> ::= <host-number>,<port-number>
    1031:  00:E991                      ;            <host-number> ::= <number>,<number>,<number>,<number>
    1032:  00:E991                      ;            <port-number> ::= <number>,<number>
    1033:  00:E991                      ;            <number> ::= any decimal integer 1 through 255
    1034:  00:E991                      ;            <form-code> ::= N | T | C
    1035:  00:E991                      ;            <type-code> ::= A [<sp> <form-code>]
    1036:  00:E991                      ;                          | E [<sp> <form-code>]
    1037:  00:E991                      ;                          | I
    1038:  00:E991                      ;                          | L <sp> <byte-size>
    1039:  00:E991                      ;            <structure-code> ::= F | R | P
    1040:  00:E991                      ;            <mode-code> ::= S | B | C
    1041:  00:E991                      ;            <pathname> ::= <string>
    1042:  00:E991                      ;            <decimal-integer> ::= any decimal integer
    1043:  00:E991                      ;
    1044:  00:E991                      ;   5.4.  SEQUENCING OF COMMANDS AND REPLIES
    1045:  00:E991                      ;
    1046:  00:E991                      ;      The communication between the user and server is intended to be an
    1047:  00:E991                      ;      alternating dialogue.  As such, the user issues an FTP command and
    1048:  00:E991                      ;      the server responds with a prompt primary reply.  The user should
    1049:  00:E991                      ;      wait for this initial primary success or failure response before
    1050:  00:E991                      ;      sending further commands.
    1051:  00:E991                      ;
    1052:  00:E991                      ;      Certain commands require a second reply for which the user should
    1053:  00:E991                      ;      also wait.  These replies may, for example, report on the progress
    1054:  00:E991                      ;      or completion of file transfer or the closing of the data
    1055:  00:E991                      ;      connection.  They are secondary replies to file transfer commands.
    1056:  00:E991                      ;
    1057:  00:E991                      ;      One important group of informational replies is the connection
    1058:  00:E991                      ;      greetings.  Under normal circumstances, a server will send a 220
    1059:  00:E991                      ;      reply, "awaiting input", when the connection is completed.  The
    1060:  00:E991                      ;      user should wait for this greeting message before sending any
    1061:  00:E991                      ;      commands.  If the server is unable to accept input right away, a
    1062:  00:E991                      ;      120 "expected delay" reply should be sent immediately and a 220
    1063:  00:E991                      ;      reply when ready.  The user will then know not to hang up if there
    1064:  00:E991                      ;      is a delay.
    1065:  00:E991                      ;
    1066:  00:E991                      ;      Spontaneous Replies
    1067:  00:E991                      ;
    1068:  00:E991                      ;         Sometimes "the system" spontaneously has a message to be sent
    1069:  00:E991                      ;         to a user (usually all users).  For example, "System going down
    1070:  00:E991                      ;         in 15 minutes".  There is no provision in FTP for such
    1071:  00:E991                      ;         spontaneous information to be sent from the server to the user.
    1072:  00:E991                      ;         It is recommended that such information be queued in the
    1073:  00:E991                      ;         server-PI and delivered to the user-PI in the next reply
    1074:  00:E991                      ;         (possibly making it a multi-line reply).
    1075:  00:E991                      ;
    1076:  00:E991                      ;      The table below lists alternative success and failure replies for
    1077:  00:E991                      ;      each command.  These must be strictly adhered to; a server may
    1078:  00:E991                      ;      substitute text in the replies, but the meaning and action implied
    1079:  00:E991                      ;      by the code numbers and by the specific command reply sequence
    1080:  00:E991                      ;      cannot be altered.
    1081:  00:E991                      ;
    1082:  00:E991                      ;      Command-Reply Sequences
    1083:  00:E991                      ;
    1084:  00:E991                      ;         In this section, the command-reply sequence is presented.  Each
    1085:  00:E991                      ;         command is listed with its possible replies; command groups are
    1086:  00:E991                      ;         listed together.  Preliminary replies are listed first (with
    1087:  00:E991                      ;         their succeeding replies indented and under them), then
    1088:  00:E991                      ;         positive and negative completion, and finally intermediary
    1089:  00:E991                      ;         replies with the remaining commands from the sequence
    1090:  00:E991                      ;         following.  This listing forms the basis for the state
    1091:  00:E991                      ;         diagrams, which will be presented separately.
    1092:  00:E991                      ;
    1093:  00:E991                      ;            Connection Establishment
    1094:  00:E991                      ;               120
    1095:  00:E991                      ;                  220
    1096:  00:E991                      ;               220
    1097:  00:E991                      ;               421
    1098:  00:E991                      ;            Login
    1099:  00:E991                      ;               USER
    1100:  00:E991                      ;                  230
    1101:  00:E991                      ;                  530
    1102:  00:E991                      ;                  500, 501, 421
    1103:  00:E991                      ;                  331, 332
    1104:  00:E991                      ;               PASS
    1105:  00:E991                      ;                  230
    1106:  00:E991                      ;                  202
    1107:  00:E991                      ;                  530
    1108:  00:E991                      ;                  500, 501, 503, 421
    1109:  00:E991                      ;                  332
    1110:  00:E991                      ;               ACCT
    1111:  00:E991                      ;                  230
    1112:  00:E991                      ;                  202
    1113:  00:E991                      ;                  530
    1114:  00:E991                      ;                  500, 501, 503, 421
    1115:  00:E991                      ;               CWD
    1116:  00:E991                      ;                  250
    1117:  00:E991                      ;                  500, 501, 502, 421, 530, 550
    1118:  00:E991                      ;               CDUP
    1119:  00:E991                      ;                  200
    1120:  00:E991                      ;                  500, 501, 502, 421, 530, 550
    1121:  00:E991                      ;               SMNT
    1122:  00:E991                      ;                  202, 250
    1123:  00:E991                      ;                  500, 501, 502, 421, 530, 550
    1124:  00:E991                      ;            Logout
    1125:  00:E991                      ;               REIN
    1126:  00:E991                      ;                  120
    1127:  00:E991                      ;                     220
    1128:  00:E991                      ;                  220
    1129:  00:E991                      ;                  421
    1130:  00:E991                      ;                  500, 502
    1131:  00:E991                      ;               QUIT
    1132:  00:E991                      ;                  221
    1133:  00:E991                      ;                  500
    1134:  00:E991                      ;            Transfer parameters
    1135:  00:E991                      ;               PORT
    1136:  00:E991                      ;                  200
    1137:  00:E991                      ;                  500, 501, 421, 530
    1138:  00:E991                      ;               PASV
    1139:  00:E991                      ;                  227
    1140:  00:E991                      ;                  500, 501, 502, 421, 530
    1141:  00:E991                      ;               MODE
    1142:  00:E991                      ;                  200
    1143:  00:E991                      ;                  500, 501, 504, 421, 530
    1144:  00:E991                      ;               TYPE
    1145:  00:E991                      ;                  200
    1146:  00:E991                      ;                  500, 501, 504, 421, 530
    1147:  00:E991                      ;               STRU
    1148:  00:E991                      ;                  200
    1149:  00:E991                      ;                  500, 501, 504, 421, 530
    1150:  00:E991                      ;            File action commands
    1151:  00:E991                      ;               ALLO
    1152:  00:E991                      ;                  200
    1153:  00:E991                      ;                  202
    1154:  00:E991                      ;                  500, 501, 504, 421, 530
    1155:  00:E991                      ;               REST
    1156:  00:E991                      ;                  500, 501, 502, 421, 530
    1157:  00:E991                      ;                  350
    1158:  00:E991                      ;               STOR
    1159:  00:E991                      ;                  125, 150
    1160:  00:E991                      ;                     (110)
    1161:  00:E991                      ;                     226, 250
    1162:  00:E991                      ;                     425, 426, 451, 551, 552
    1163:  00:E991                      ;                  532, 450, 452, 553
    1164:  00:E991                      ;                  500, 501, 421, 530
    1165:  00:E991                      ;               STOU
    1166:  00:E991                      ;                  125, 150
    1167:  00:E991                      ;                     (110)
    1168:  00:E991                      ;                     226, 250
    1169:  00:E991                      ;                     425, 426, 451, 551, 552
    1170:  00:E991                      ;                  532, 450, 452, 553
    1171:  00:E991                      ;                  500, 501, 421, 530
    1172:  00:E991                      ;               RETR
    1173:  00:E991                      ;                  125, 150
    1174:  00:E991                      ;                     (110)
    1175:  00:E991                      ;                     226, 250
    1176:  00:E991                      ;                     425, 426, 451
    1177:  00:E991                      ;                  450, 550
    1178:  00:E991                      ;                  500, 501, 421, 530
    1179:  00:E991                      ;               LIST
    1180:  00:E991                      ;                  125, 150
    1181:  00:E991                      ;                     226, 250
    1182:  00:E991                      ;                     425, 426, 451
    1183:  00:E991                      ;                  450
    1184:  00:E991                      ;                  500, 501, 502, 421, 530
    1185:  00:E991                      ;               NLST
    1186:  00:E991                      ;                  125, 150
    1187:  00:E991                      ;                     226, 250
    1188:  00:E991                      ;                     425, 426, 451
    1189:  00:E991                      ;                  450
    1190:  00:E991                      ;                  500, 501, 502, 421, 530
    1191:  00:E991                      ;               APPE
    1192:  00:E991                      ;                  125, 150
    1193:  00:E991                      ;                     (110)
    1194:  00:E991                      ;                     226, 250
    1195:  00:E991                      ;                     425, 426, 451, 551, 552
    1196:  00:E991                      ;                  532, 450, 550, 452, 553
    1197:  00:E991                      ;                  500, 501, 502, 421, 530
    1198:  00:E991                      ;               RNFR
    1199:  00:E991                      ;                  450, 550
    1200:  00:E991                      ;                  500, 501, 502, 421, 530
    1201:  00:E991                      ;                  350
    1202:  00:E991                      ;               RNTO
    1203:  00:E991                      ;                  250
    1204:  00:E991                      ;                  532, 553
    1205:  00:E991                      ;                  500, 501, 502, 503, 421, 530
    1206:  00:E991                      ;               DELE
    1207:  00:E991                      ;                  250
    1208:  00:E991                      ;                  450, 550
    1209:  00:E991                      ;                  500, 501, 502, 421, 530
    1210:  00:E991                      ;               RMD
    1211:  00:E991                      ;                  250
    1212:  00:E991                      ;                  500, 501, 502, 421, 530, 550
    1213:  00:E991                      ;               MKD
    1214:  00:E991                      ;                  257
    1215:  00:E991                      ;                  500, 501, 502, 421, 530, 550
    1216:  00:E991                      ;               PWD
    1217:  00:E991                      ;                  257
    1218:  00:E991                      ;                  500, 501, 502, 421, 550
    1219:  00:E991                      ;               ABOR
    1220:  00:E991                      ;                  225, 226
    1221:  00:E991                      ;                  500, 501, 502, 421
    1222:  00:E991                      ;            Informational commands
    1223:  00:E991                      ;               SYST
    1224:  00:E991                      ;                  215
    1225:  00:E991                      ;                  500, 501, 502, 421
    1226:  00:E991                      ;               STAT
    1227:  00:E991                      ;                  211, 212, 213
    1228:  00:E991                      ;                  450
    1229:  00:E991                      ;                  500, 501, 502, 421, 530
    1230:  00:E991                      ;               HELP
    1231:  00:E991                      ;                  211, 214
    1232:  00:E991                      ;                  500, 501, 502, 421
    1233:  00:E991                      ;            Miscellaneous commands
    1234:  00:E991                      ;               SITE
    1235:  00:E991                      ;                  200
    1236:  00:E991                      ;                  202
    1237:  00:E991                      ;                  500, 501, 530
    1238:  00:E991                      ;               NOOP
    1239:  00:E991                      ;                  200
    1240:  00:E991                      ;                  500 421
    1241:  00:E991                      ;
    1242:  00:E991                      ; 7.  TYPICAL FTP SCENARIO
    1243:  00:E991                      ;
    1244:  00:E991                      ;   User at host U wanting to transfer files to/from host S:
    1245:  00:E991                      ;
    1246:  00:E991                      ;   In general, the user will communicate to the server via a mediating
    1247:  00:E991                      ;   user-FTP process.  The following may be a typical scenario.  The
    1248:  00:E991                      ;   user-FTP prompts are shown in parentheses, '---->' represents
    1249:  00:E991                      ;   commands from host U to host S, and '<----' represents replies from
    1250:  00:E991                      ;   host S to host U.
    1251:  00:E991                      ;
    1252:  00:E991                      ;      LOCAL COMMANDS BY USER              ACTION INVOLVED
    1253:  00:E991                      ;
    1254:  00:E991                      ;      ftp (host) multics<CR>         Connect to host S, port L,
    1255:  00:E991                      ;                                     establishing control connections.
    1256:  00:E991                      ;                                     <---- 220 Service ready <CRLF>.
    1257:  00:E991                      ;      username Doe <CR>              USER Doe<CRLF>---->
    1258:  00:E991                      ;                                     <---- 331 User name ok,
    1259:  00:E991                      ;                                               need password<CRLF>.
    1260:  00:E991                      ;      password mumble <CR>           PASS mumble<CRLF>---->
    1261:  00:E991                      ;                                     <---- 230 User logged in<CRLF>.
    1262:  00:E991                      ;      retrieve (local type) ASCII<CR>
    1263:  00:E991                      ;      (local pathname) test 1 <CR>   User-FTP opens local file in ASCII.
    1264:  00:E991                      ;      (for. pathname) test.pl1<CR>   RETR test.pl1<CRLF> ---->
    1265:  00:E991                      ;                                     <---- 150 File status okay;
    1266:  00:E991                      ;                                           about to open data
    1267:  00:E991                      ;                                           connection<CRLF>.
    1268:  00:E991                      ;                                     Server makes data connection
    1269:  00:E991                      ;                                     to port U.
    1270:  00:E991                      ;      
    1271:  00:E991                      ;                                     <---- 226 Closing data connection,
    1272:  00:E991                      ;                                         file transfer successful<CRLF>.
    1273:  00:E991                      ;      type Image<CR>                 TYPE I<CRLF> ---->
    1274:  00:E991                      ;                                     <---- 200 Command OK<CRLF>
    1275:  00:E991                      ;      store (local type) image<CR>
    1276:  00:E991                      ;      (local pathname) file dump<CR> User-FTP opens local file in Image.
    1277:  00:E991                      ;      (for.pathname) >udd>cn>fd<CR>  STOR >udd>cn>fd<CRLF> ---->
    1278:  00:E991                      ;                                     <---- 550 Access denied<CRLF>
    1279:  00:E991                      ;      terminate                      QUIT <CRLF> ---->
    1280:  00:E991                      ;                                     Server closes all
    1281:  00:E991                      ;                                     connections.
    1282:  00:E991                      ;
    1283:  00:E991                      ; 8.  CONNECTION ESTABLISHMENT
    1284:  00:E991                      ;
    1285:  00:E991                      ;   The FTP control connection is established via TCP between the user
    1286:  00:E991                      ;   process port U and the server process port L.  This protocol is
    1287:  00:E991                      ;   assigned the service port 21 (25 octal), that is L=21.
    1288:  00:E991                      ;
    1289:  00:E991                      ;==============================================================================
    1290:  00:E991                      ;
    1291:  00:E991                      ;
    1292:  00:E991  (00:0015)           CONTROL_DPORT	equ	21		; Server listens on port 21
    1293:  00:E991  (00:0016)           CONTROL_SPORT	equ	22		; Our port
    1294:  00:E991                      ;
    1295:  00:E991                      ;
    1296:  00:E991                      ; open_control
    1297:  00:E991                      ;
    1298:  00:E991                      ; Opens the control session to the FTP server
    1299:  00:E991                      ;
    1300:  00:E991                      ; In:   A=socket number
    1301:  00:E991                      ;      HL->ip address to connect to
    1302:  00:E991                      ; Out: NC if successful
    1303:  00:E991                      ;
    1304:  00:E991  32 57 40            open_control:	ld	(vars.ftp.socket),a
    1305:  00:E994                      ;
    1306:  00:E994  FD CB 00 5E         		bit	vars.trace.ftp,(iy+vars._trace)
    1307:  00:E998  28 11               		jr	z,.notrace
    1308:  00:E99A                      ;
    1309:  00:E99A  11 52 D5            		ld	de,trace.ftp.open
    1310:  00:E99D  CD E7 EC            		call	trace
    1311:  00:E9A0                      ;
    1312:  00:E9A0  E5                  		push	hl
    1313:  00:E9A1  CD 85 CF            		 call	io.ip
    1314:  00:E9A4  CD 36 D2            		 call	trace.dots
    1315:  00:E9A7  E1                  		pop	hl		; HL->server IP
    1316:  00:E9A8                      ;
    1317:  00:E9A8  3A 57 40            		ld	a,(vars.ftp.socket)
    1318:  00:E9AB                      ;
    1319:  00:E9AB  E5                  .notrace:	push	hl		; Save ->IP address
    1320:  00:E9AC  21 16 00            		 ld	hl,CONTROL_SPORT; HL=our port number
    1321:  00:E9AF  11 57 EE            		 ld	de,owner_str
    1322:  00:E9B2  CD 6E DF            		 call	tcp.open
    1323:  00:E9B5  D1                  		pop	de		; DE->IP address
    1324:  00:E9B6  38 09               		jr	c,.done
    1325:  00:E9B8                      ;
    1326:  00:E9B8  21 15 00            		ld	hl,CONTROL_DPORT; HL=server port no.
    1327:  00:E9BB  3A 57 40            		ld	a,(vars.ftp.socket)
    1328:  00:E9BE  CD 8E E1            		call	tcp.connect
    1329:  00:E9C1                      ;
    1330:  00:E9C1  FD CB 00 5E         .done:		bit	vars.trace.ftp,(iy+vars._trace)
    1331:  00:E9C5  C8                  		ret	z
    1332:  00:E9C6                      ;
    1333:  00:E9C6  C3 3E D2            		jp	trace.is_error
    1334:  00:E9C9                      ;
    1335:  00:E9C9                      ;------------------------------------------------------------------------------
    1336:  00:E9C9                      ; login
    1337:  00:E9C9                      ;
    1338:  00:E9C9                      ; Called after open_control to read the hello string from the server and send
    1339:  00:E9C9                      ; login commands
    1340:  00:E9C9                      ;
    1341:  00:E9C9                      ; In:  vars.ftp.socket contains the socket number if called immediately
    1342:  00:E9C9                      ;      after open_control
    1343:  00:E9C9                      ;      DE->user name, length byte first
    1344:  00:E9C9                      ; Out: Cy=>error, not logged in
    1345:  00:E9C9                      ;
    1346:  00:E9C9                      login:
    1347:  00:E9C9  FD CB 00 5E         		bit	vars.trace.ftp,(iy+vars._trace)
    1348:  00:E9CD  28 08               		jr	z,.notrace
    1349:  00:E9CF                      ;
    1350:  00:E9CF  D5                  		push	de
    1351:  00:E9D0  11 5E D5            		 ld	de,trace.ftp.login
    1352:  00:E9D3  CD E7 EC            		 call	trace
    1353:  00:E9D6  D1                  		pop	de
    1354:  00:E9D7                      .notrace:
    1355:  00:E9D7                      		; Copy user name arg to buffer
    1356:  00:E9D7  EB                  		ex	de,hl		; HL->user name arg
    1357:  00:E9D8  11 60 41            		ld	de,vars.ftp.user
    1358:  00:E9DB  D5                  		push	de		; Save -> user name buffer
    1359:  00:E9DC  4E                  		 ld	c,(hl)		; Get length byte
    1360:  00:E9DD  0C                  		 inc	c		; Include length byte
    1361:  00:E9DE  3E 27               		 ld	a,vars.ftp.user_size-1
    1362:  00:E9E0  B9                  		 cp	c
    1363:  00:E9E1  30 01               		 jr	nc,.lenok
    1364:  00:E9E3  4F                  		 ld	c,a
    1365:  00:E9E4  06 00               .lenok:		 ld	b,0
    1366:  00:E9E6  ED B0               		 ldir
    1367:  00:E9E8                      ;
    1368:  00:E9E8  CD 6B EB            		 call	get_response	; Wait for "hello message" from server
    1369:  00:E9EB  E1                  		pop	hl		; HL->vars.ftp.user
    1370:  00:E9EC  D8                  		ret	c
    1371:  00:E9ED                      ;
    1372:  00:E9ED  7E                  		ld	a,(hl)		; Got user name?
    1373:  00:E9EE  B7                  		or	a
    1374:  00:E9EF  20 1A               		jr	nz,.gotuser	; Go if username given on command line
    1375:  00:E9F1                      ;
    1376:  00:E9F1  11 62 EA            		ld	de,userprompt_str
    1377:  00:E9F4  0E 28               		ld	c,vars.ftp.user_size
    1378:  00:E9F6  E5                  		push	hl		; Save -> user name buffer
    1379:  00:E9F7  CD 77 D0            		 call	io.input	; Prompt user for user name
    1380:  00:E9FA  E1                  		pop	hl		; HL->user name buffer
    1381:  00:E9FB  D8                  		ret	c
    1382:  00:E9FC                      ;
    1383:  00:E9FC  7E                  		ld	a,(hl)
    1384:  00:E9FD  B7                  		or	a
    1385:  00:E9FE  20 0B               		jr	nz,.gotuser
    1386:  00:EA00                      ;
    1387:  00:EA00  E5                  		push	hl		; Save -> user name buffer
    1388:  00:EA01  EB                  		ex	de,hl		; DE->username buffer
    1389:  00:EA02  21 49 EA            		ld	hl,anonymous_str
    1390:  00:EA05  01 0A 00            		ld	bc,anonymous_str_size
    1391:  00:EA08  ED B0               		ldir			; Copy default username
    1392:  00:EA0A  E1                  		pop	hl		; HL->user name buffer
    1393:  00:EA0B                      ;
    1394:  00:EA0B  EB                  .gotuser:	ex	de,hl		; DE->user name
    1395:  00:EA0C  21 2A EE            		ld	hl,user_str
    1396:  00:EA0F  CD 5F EB            		call	issue_arg
    1397:  00:EA12  D8                  		ret	c
    1398:  00:EA13                      ;
    1399:  00:EA13  11 4B 01            		ld	de,331		; Password required
    1400:  00:EA16  B7                  		or	a
    1401:  00:EA17  ED 52               		sbc	hl,de
    1402:  00:EA19  C0                  		ret	nz
    1403:  00:EA1A                      ;
    1404:  00:EA1A  21 88 41            		ld	hl,vars.ftp.pass
    1405:  00:EA1D  11 7A EA            		ld	de,passprompt_str
    1406:  00:EA20  0E 28               		ld	c,vars.ftp.pass_size
    1407:  00:EA22  E5                  		push	hl
    1408:  00:EA23  CD 77 D0            		 call	io.input	; Prompt usert for password
    1409:  00:EA26  E1                  		pop	hl		; HL->password buffer
    1410:  00:EA27  D8                  		ret	c
    1411:  00:EA28                      ;
    1412:  00:EA28  7E                  		ld	a,(hl)
    1413:  00:EA29  B7                  		or	a
    1414:  00:EA2A  20 0B               		jr	nz,.gotpass
    1415:  00:EA2C                      ;
    1416:  00:EA2C  E5                  		push	hl		; Save -> password buffer
    1417:  00:EA2D  EB                  		ex	de,hl		; DE->password buffer
    1418:  00:EA2E  21 53 EA            		ld	hl,localhost_str
    1419:  00:EA31  01 0F 00            		ld	bc,localhost_str_size
    1420:  00:EA34  ED B0               		ldir			; Copy default password
    1421:  00:EA36  E1                  		pop	hl		; HL->password buffer
    1422:  00:EA37                      ;
    1423:  00:EA37  EB                  .gotpass:	ex	de,hl		; DE->password
    1424:  00:EA38  21 30 EE            		ld	hl,pass_str
    1425:  00:EA3B  11 88 41            		ld	de,vars.ftp.pass
    1426:  00:EA3E  CD 5F EB            		call	issue_arg
    1427:  00:EA41  D8                  		ret	c
    1428:  00:EA42                      ;
    1429:  00:EA42  11 90 01            		ld	de,400		; <400 ok, >=400 =>error
    1430:  00:EA45  ED 52               		sbc	hl,de
    1431:  00:EA47  3F                  		ccf
    1432:  00:EA48  C9                  		ret
    1433:  00:EA49                      ;
    1434:  00:EA49                      ;
    1435:  00:EA49                      anonymous_str:		db	9,"anonymous"
    1435:  00:EA49  09 61 6E 6F 6E 79 6D 6F 75 73 
    1436:  00:EA53  (00:000A)           anonymous_str_size	equ	$-anonymous_str		; Includes length byte
    1437:  00:EA53                      ;
    1438:  00:EA53                      localhost_str:		db	14,"anon@localhost"
    1438:  00:EA53  0E 61 6E 6F 6E 40 6C 6F 63 61 6C 68 6F 73 74 
    1439:  00:EA62  (00:000F)           localhost_str_size	equ	$-localhost_str		; Includes length byte
    1440:  00:EA62                      ;
    1441:  00:EA62                      userprompt_str:		db	"User name [anonymous]: ",0
    1441:  00:EA62  55 73 65 72 20 6E 61 6D 65 20 5B 61 6E 6F 6E 79 
    1441:  00:EA72  6D 6F 75 73 5D 3A 20 00 
    1442:  00:EA7A                      passprompt_str:		db	"Password [anon@localhost]: ",0
    1442:  00:EA7A  50 61 73 73 77 6F 72 64 20 5B 61 6E 6F 6E 40 6C 
    1442:  00:EA8A  6F 63 61 6C 68 6F 73 74 5D 3A 20 00 
    1443:  00:EA96                      ;
    1444:  00:EA96                      ;
    1445:  00:EA96                      ;------------------------------------------------------------------------------
    1446:  00:EA96                      ; logout
    1447:  00:EA96                      ;
    1448:  00:EA96                      ; This is called to cleanly log out of the FTP session.
    1449:  00:EA96                      ;
    1450:  00:EA96                      ; In:  A=socket number
    1451:  00:EA96                      ;
    1452:  00:EA96  32 57 40            logout:		ld	(vars.ftp.socket),a
    1453:  00:EA99                      ;
    1454:  00:EA99  21 52 EE            		ld	hl,quit_str
    1455:  00:EA9C  C3 5C EB            		jp	issue
    1456:  00:EA9F                      ;
    1457:  00:EA9F                      ;
    1458:  00:EA9F                      ;------------------------------------------------------------------------------
    1459:  00:EA9F                      ; dir
    1460:  00:EA9F                      ;
    1461:  00:EA9F                      ; Issues an FTP LIST command
    1462:  00:EA9F                      ;
    1463:  00:EA9F                      ; DIR is more complicated than most of the commands because the response to
    1464:  00:EA9F                      ; the LIST command is sent to the FTP data connection, so we have to issue
    1465:  00:EA9F                      ; a PASV command, open the channel...
    1466:  00:EA9F                      ;
    1467:  00:EA9F                      ; In:  A=socket number
    1468:  00:EA9F                      ;     DE->argment, length byte first
    1469:  00:EA9F                      ; Out: A=EXOS error code
    1470:  00:EA9F                      ;
    1471:  00:EA9F  32 57 40            dir:		ld	(vars.ftp.socket),a
    1472:  00:EAA2                      ;
    1473:  00:EAA2  D5                  		push	de		; Save ->arg
    1474:  00:EAA3  CD BD EB            		 call	open_data	; Open data connection
    1475:  00:EAA6  D1                  		pop	de		; DE->arg
    1476:  00:EAA7  3E 65               		ld	a,exos.ERR_FTPDATA
    1477:  00:EAA9  DA D1 CA            		jp	c,exos.check_stop
    1478:  00:EAAC                      ;
    1479:  00:EAAC  21 3B EE            		ld	hl,list_str
    1480:  00:EAAF  CD 5F EB            		call	issue_arg	; Send LIST command
    1481:  00:EAB2  38 36               		jr	c,.timeout	; Go with Cy if timeout
    1482:  00:EAB4                      ;
    1483:  00:EAB4  AF                  		xor	a		; Socket 0
    1484:  00:EAB5  CD DD EB            		call	read		; Read data from socket
    1485:  00:EAB8  38 30               		jr	c,.timeout	; Go with Cy if timeout
    1486:  00:EABA                      ;
    1487:  00:EABA  E5                  .print:		push	hl		; Save buffer start
    1488:  00:EABB  09                  		 add	hl,bc		; Point to last byte read
    1489:  00:EABC  36 00               		 ld	(hl),0		; Terminate it
    1490:  00:EABE  E1                  		pop	hl		; HL->response
    1491:  00:EABF                      ;
    1492:  00:EABF  EB                  		ex	de,hl		; DE->data
    1493:  00:EAC0  CD 36 D0            		call	io.str		; Print it
    1494:  00:EAC3                      ;
    1495:  00:EAC3  AF                  		xor	a		; Socket 0
    1496:  00:EAC4  CD FC DD            		call	socket.get_rx_size; More than 1 buffer full?
    1497:  00:EAC7  7C                  		ld	a,h
    1498:  00:EAC8  B5                  		or	l
    1499:  00:EAC9  28 1A               		jr	z,.done		; Go if not
    1500:  00:EACB                      ;
    1501:  00:EACB  4D                  		ld	c,l
    1502:  00:EACC  44                  		ld	b,h		; BC=remainder size
    1503:  00:EACD  21 FE 00            		ld	hl,vars.ftp.buffer_size-2; See if it will fit in buffer
    1504:  00:EAD0  B7                  		or	a
    1505:  00:EAD1  ED 42               		sbc	hl,bc
    1506:  00:EAD3  30 03               		jr	nc,.doread	; Go if it will fit in buffer
    1507:  00:EAD5                      ;
    1508:  00:EAD5  01 FE 00            		ld	bc,vars.ftp.buffer_size-2; Else limit to buffer size
    1509:  00:EAD8  21 60 40            .doread:	ld	hl,vars.ftp.buffer
    1510:  00:EADB  E5                  		push	hl		; Save start of buffer
    1511:  00:EADC  C5                  		push	bc		; Save bytes that will be in buffer
    1512:  00:EADD  AF                  		 xor	a
    1513:  00:EADE  CD DA DA            		 call	socket.read	; Read response
    1514:  00:EAE1  C1                  		pop	bc		; BC=size of response
    1515:  00:EAE2  E1                  		pop	hl		; HL->response
    1516:  00:EAE3  18 D5               		jr	.print
    1517:  00:EAE5                      ;
    1518:  00:EAE5  AF                  .done:		xor	a
    1519:  00:EAE6  CD A8 DB            		call	socket.read_end
    1520:  00:EAE9                      
    1521:  00:EAE9  B7                  		or	a		; NC=>No error
    1522:  00:EAEA  9F                  .timeout:	sbc	a,a		; ff=>error, 0 => ok
    1523:  00:EAEB  E6 6A               		and	exos.ERR_TIMEOUT; Error code or 0
    1524:  00:EAED  F5                  .close:		push	af
    1525:  00:EAEE  AF                  		xor	a
    1526:  00:EAEF  CD D1 E1            		call	tcp.close	; Close data channel
    1527:  00:EAF2  F1                  		pop	af
    1528:  00:EAF3  C0                  		ret	nz		; Return if error
    1529:  00:EAF4                      ;
    1530:  00:EAF4  3A 57 40            		ld	a,(vars.ftp.socket)
    1531:  00:EAF7  CD 64 EB            		call	is_response	; Get any response after data
    1532:  00:EAFA                      ;
    1533:  00:EAFA  AF                  		xor	a		; 0=>no error
    1534:  00:EAFB  C9                  		ret
    1535:  00:EAFC                      ;
    1536:  00:EAFC                      ;
    1537:  00:EAFC                      ;------------------------------------------------------------------------------
    1538:  00:EAFC                      ; status
    1539:  00:EAFC                      ;
    1540:  00:EAFC                      ; Issues an FTP SYST command
    1541:  00:EAFC                      ;
    1542:  00:EAFC                      ; In:  A=socket number
    1543:  00:EAFC                      ;
    1544:  00:EAFC                      status:
    1545:  00:EAFC  32 57 40            		ld	(vars.ftp.socket),a
    1546:  00:EAFF                      ;
    1547:  00:EAFF  21 4D EE            		ld	hl,syst_str
    1548:  00:EB02  18 26               		jr	issue_print
    1549:  00:EB04                      ;
    1550:  00:EB04                      ;
    1551:  00:EB04                      ;------------------------------------------------------------------------------
    1552:  00:EB04                      ; chdir
    1553:  00:EB04                      ;
    1554:  00:EB04                      ; Issues an FTP PWD, CWD or CDUP command depending on the argument.
    1555:  00:EB04                      ;
    1556:  00:EB04                      ; In:  A=socket number
    1557:  00:EB04                      ;     DE->argment, length byte first
    1558:  00:EB04                      ;
    1559:  00:EB04  32 57 40            chdir:		ld	(vars.ftp.socket),a
    1560:  00:EB07                      ;
    1561:  00:EB07  1A                  		ld	a,(de)
    1562:  00:EB08  B7                  		or	a
    1563:  00:EB09  28 1C               		jr	z,.pwd		; No arg - just print current directory
    1564:  00:EB0B                      ;
    1565:  00:EB0B  FE 02               		cp	2
    1566:  00:EB0D  20 0E               		jr	nz,.cd		; Not ".." - cd to specified directory
    1567:  00:EB0F                      ;
    1568:  00:EB0F  13                  		inc	de
    1569:  00:EB10  1A                  		ld	a,(de)
    1570:  00:EB11  FE 2E               		cp	'.'
    1571:  00:EB13  20 07               		jr	nz,.deccd
    1572:  00:EB15  13                  		inc	de
    1573:  00:EB16  1A                  		ld	a,(de)
    1574:  00:EB17  FE 2E               		cp	'.'
    1575:  00:EB19  28 07               		jr	z,.cdup
    1576:  00:EB1B  1B                  		dec	de
    1577:  00:EB1C  1B                  .deccd:		dec	de
    1578:  00:EB1D                      ;
    1579:  00:EB1D  21 00 EE            .cd:		ld	hl,cwd_str	; Send CWD <dir> command
    1580:  00:EB20  18 3D               		jr	issue_arg
    1581:  00:EB22                      ;
    1582:  00:EB22  21 09 EE            .cdup:		ld	hl,cdup_str	; Send CDUP command
    1583:  00:EB25  18 35               		jr	issue
    1584:  00:EB27                      ;
    1585:  00:EB27  21 05 EE            .pwd:		ld	hl,pwd_str	; Send PWD command
    1586:  00:EB2A  CD 5C EB            issue_print:	call	issue
    1587:  00:EB2D  11 60 40            		ld	de,vars.ftp.buffer	; Print response
    1588:  00:EB30  C3 36 D0            		jp	io.str
    1589:  00:EB33                      ;
    1590:  00:EB33                      ;
    1591:  00:EB33                      ;------------------------------------------------------------------------------
    1592:  00:EB33                      ; mkdir
    1593:  00:EB33                      ;
    1594:  00:EB33                      ; Issues an FTP MKD command
    1595:  00:EB33                      ;
    1596:  00:EB33                      ; In:  A=socket number
    1597:  00:EB33                      ;     DE->pathname, length byte first
    1598:  00:EB33                      ;
    1599:  00:EB33  32 57 40            mkdir:		ld	(vars.ftp.socket),a
    1600:  00:EB36                      ;
    1601:  00:EB36  21 0E EE            		ld	hl,mkd_str
    1602:  00:EB39  18 24               		jr	issue_arg		; Issue command and arg
    1603:  00:EB3B                      ;
    1604:  00:EB3B                      ;
    1605:  00:EB3B                      ;------------------------------------------------------------------------------
    1606:  00:EB3B                      ; rmdir
    1607:  00:EB3B                      ;
    1608:  00:EB3B                      ; Issues an FTP RMD command
    1609:  00:EB3B                      ;
    1610:  00:EB3B                      ; In:  A=socket number
    1611:  00:EB3B                      ;     DE->pathname, length byte first
    1612:  00:EB3B                      ;
    1613:  00:EB3B                      rmdir:
    1614:  00:EB3B  32 57 40            		ld	(vars.ftp.socket),a
    1615:  00:EB3E                      ;
    1616:  00:EB3E  21 13 EE            		ld	hl,rmd_str
    1617:  00:EB41  18 1C               		jr	issue_arg		; Issue command and arg
    1618:  00:EB43                      ;
    1619:  00:EB43                      ;
    1620:  00:EB43                      ;------------------------------------------------------------------------------
    1621:  00:EB43                      ; del
    1622:  00:EB43                      ;
    1623:  00:EB43                      ; Issues an FTP DELE command
    1624:  00:EB43                      ;
    1625:  00:EB43                      ; In:  A=socket number
    1626:  00:EB43                      ;     DE->pathname, length byte first
    1627:  00:EB43                      ;
    1628:  00:EB43                      del:
    1629:  00:EB43  32 57 40            		ld	(vars.ftp.socket),a
    1630:  00:EB46                      ;
    1631:  00:EB46  21 18 EE            		ld	hl,dele_str
    1632:  00:EB49  18 14               		jr	issue_arg		; Issue command and arg
    1633:  00:EB4B                      
    1634:  00:EB4B                      ;------------------------------------------------------------------------------
    1635:  00:EB4B                      ; ren
    1636:  00:EB4B                      ;
    1637:  00:EB4B                      ; Issues FTP RNFR and RNTO commands
    1638:  00:EB4B                      ;
    1639:  00:EB4B                      ; In:  A=socket number
    1640:  00:EB4B                      ;     DE->from name, length byte first
    1641:  00:EB4B                      ;     HL->to name, length byte first
    1642:  00:EB4B                      ;
    1643:  00:EB4B                      ren:
    1644:  00:EB4B  32 57 40            		ld	(vars.ftp.socket),a
    1645:  00:EB4E                      ;
    1646:  00:EB4E  E5                  		push	hl		; Save to name
    1647:  00:EB4F  21 1E EE            		 ld	hl,rnfr_str
    1648:  00:EB52  CD 5F EB            		 call	issue_arg	; Issue command and arg
    1649:  00:EB55  D1                  		pop	de		; DE->to name
    1650:  00:EB56  D8                  		ret	c
    1651:  00:EB57                      ;
    1652:  00:EB57  21 24 EE            		ld	hl,rnto_str
    1653:  00:EB5A  18 03               		jr	issue_arg	; Issue command and arg
    1654:  00:EB5C                      ;
    1655:  00:EB5C                      ;
    1656:  00:EB5C                      ;------------------------------------------------------------------------------
    1657:  00:EB5C                      ; get_response
    1658:  00:EB5C                      ;
    1659:  00:EB5C                      ; After issuing an FTP command reads the response with timeout, and returns
    1660:  00:EB5C                      ; the response code
    1661:  00:EB5C                      ;
    1662:  00:EB5C                      ; Out: Cy=>we didn't get a response
    1663:  00:EB5C                      ;      HL=response code
    1664:  00:EB5C                      ;       A=EXOS error code corresponding to the FTP response code
    1665:  00:EB5C  11 00 00            issue:		ld	de,0
    1666:  00:EB5F  CD 4C EC            issue_arg:	call	issue_cmd
    1667:  00:EB62  18 07               		jr	get_response
    1668:  00:EB64                      ;
    1669:  00:EB64  3A 57 40            is_response:	ld	a,(vars.ftp.socket)	; See if any response yet
    1670:  00:EB67  CD A4 DA            		call	socket.available
    1671:  00:EB6A  C8                  		ret	z
    1672:  00:EB6B                      get_response:
    1673:  00:EB6B  3A 57 40            		ld	a,(vars.ftp.socket)	; See if any response yet
    1674:  00:EB6E  CD DD EB            		call	read
    1675:  00:EB71  3E 6A               		ld	a,exos.ERR_TIMEOUT
    1676:  00:EB73  DA D1 CA            		jp	c,exos.check_stop
    1677:  00:EB76                      ;
    1678:  00:EB76                      .noerr:
    1679:  00:EB76  E5                  		push	hl			; Save buffer start
    1680:  00:EB77  09                  		 add	hl,bc			; Point to last byte read
    1681:  00:EB78  36 00               		 ld	(hl),0			; Terminate it
    1682:  00:EB7A  C5                  		 push	bc
    1683:  00:EB7B  3A 57 40            		  ld	a,(vars.ftp.socket)
    1684:  00:EB7E  CD A8 DB            		  call	socket.read_end
    1685:  00:EB81  C1                  		 pop	bc
    1686:  00:EB82  E1                  		pop	hl			; HL->response
    1687:  00:EB83                      ;
    1688:  00:EB83  FD CB 00 5E         		bit	vars.trace.ftp,(iy+vars._trace)
    1689:  00:EB87  28 0E               		jr	z,.donetrace
    1690:  00:EB89                      ;
    1691:  00:EB89  E5                  		push	hl			; Save->response string
    1692:  00:EB8A  C5                  		push	bc			; Save #bytes
    1693:  00:EB8B  11 6B D5            		 ld	de,trace.ftp.rx
    1694:  00:EB8E  CD E7 EC            		 call	trace
    1695:  00:EB91  EB                  		 ex	de,hl			; DE->response string
    1696:  00:EB92  CD 36 D0            		 call	io.str
    1697:  00:EB95  C1                  		pop	bc			; BC=byte count
    1698:  00:EB96  E1                  		pop	hl			; HL->response string
    1699:  00:EB97                      .donetrace:
    1700:  00:EB97                      ;
    1701:  00:EB97  E5                  		push	hl			; Save->response string
    1702:  00:EB98  C5                  		push	bc			; Save byte count
    1703:  00:EB99  CD 29 EC            		 call	read_code		; HL=response error/status code
    1704:  00:EB9C  C1                  		pop	bc			; BC=byte count
    1705:  00:EB9D  D1                  		pop	de			; DE->response string
    1706:  00:EB9E                      ;
    1707:  00:EB9E  E5                  		push	hl			; Save FTP response code
    1708:  00:EB9F  CD D9 ED            		 call	ftp_to_exos		; A=equivalent EXOS error code
    1709:  00:EBA2  E1                  		pop	hl			; HL=FTP response code
    1710:  00:EBA3                      ;
    1711:  00:EBA3  FD CB 00 5E         		bit	vars.trace.ftp,(iy+vars._trace)
    1712:  00:EBA7  C8                  		ret	z
    1713:  00:EBA8                      ;
    1714:  00:EBA8  F5                  		push	af			; Save EXOS error & NC
    1715:  00:EBA9  D5                  		push	de			; Save ->response code
    1716:  00:EBAA  E5                  		 push	hl			; Save response code
    1717:  00:EBAB  11 7B D5            		   ld	de,trace.ftp.code		;      "Rx code="
    1718:  00:EBAE  CD E7 EC            		   call	trace			; "FTPn:"
    1719:  00:EBB1  E1                  		 pop	hl			; HL=response code
    1720:  00:EBB2                      ;
    1721:  00:EBB2  E5                  		 push	hl			; Save response code again
    1722:  00:EBB3  CD AA CF            		  call	io.int			; Print it
    1723:  00:EBB6  CD 21 D0            		  call	io.crlf
    1724:  00:EBB9  E1                  		 pop	hl			; HL=response code
    1725:  00:EBBA  D1                  		pop	de			; DE->buffer
    1726:  00:EBBB  F1                  		pop	af			; A=EXOS error, F=NC
    1727:  00:EBBC                      ;
    1728:  00:EBBC  C9                  		ret
    1729:  00:EBBD                      ;
    1730:  00:EBBD                      ;
    1731:  00:EBBD                      ;------------------------------------------------------------------------------
    1732:  00:EBBD                      ; open_data
    1733:  00:EBBD                      ;
    1734:  00:EBBD                      ; opens and reads a FTP data channel
    1735:  00:EBBD                      ;
    1736:  00:EBBD  CD 8A EC            open_data:	call	send_pasv	; First get PASV parameters
    1737:  00:EBC0  D8                  		ret	c
    1738:  00:EBC1                      ;
    1739:  00:EBC1  AF                  		xor	a		; Socket 0
    1740:  00:EBC2  21 42 42            		ld	hl,4242h	; Our port number, any?
    1741:  00:EBC5  11 5B EE            		ld	de,owner_data_str
    1742:  00:EBC8  CD 6E DF            		call	tcp.open
    1743:  00:EBCB  D8                  		ret	c
    1744:  00:EBCC                      ;
    1745:  00:EBCC  AF                  		xor	a		; Socket 0
    1746:  00:EBCD  2A 5E 40            		ld	hl,(vars.ftp.data_port)
    1747:  00:EBD0  11 5A 40            		ld	de,vars.ftp.data_ip
    1748:  00:EBD3  CD 8E E1            		call	tcp.connect
    1749:  00:EBD6  D0                  		ret	nc
    1750:  00:EBD7                      ;
    1751:  00:EBD7  AF                  		xor	a
    1752:  00:EBD8  CD D1 E1            		call	tcp.close
    1753:  00:EBDB  37                  		scf
    1754:  00:EBDC  C9                  		ret
    1755:  00:EBDD                      ;
    1756:  00:EBDD                      ;
    1757:  00:EBDD                      ;------------------------------------------------------------------------------
    1758:  00:EBDD                      ; read
    1759:  00:EBDD                      ;
    1760:  00:EBDD                      ; reads from an FTP socket into a buffer
    1761:  00:EBDD                      ; The caller must call socket.read_end afterwards
    1762:  00:EBDD                      ;
    1763:  00:EBDD                      ; In:  A=socket number
    1764:  00:EBDD                      ; Out: Cy=>timeout waiting for data
    1765:  00:EBDD                      ;      HL->data read
    1766:  00:EBDD                      ;      BC=size of data
    1767:  00:EBDD                      read:
    1768:  00:EBDD  2A 0E 40            		ld	hl,(vars.ticks)
    1769:  00:EBE0  22 58 40            		ld	(vars.ftp.start),hl
    1770:  00:EBE3                      ;
    1771:  00:EBE3                      .loop:
    1772:  00:EBE3  F5                  		push	af			; Save socket number
    1773:  00:EBE4  CD 74 DF            		 call	tcp.header		; Packet received?
    1774:  00:EBE7  20 26               		 jr	nz,.readit		; Go & read it if yes
    1775:  00:EBE9                      ;
    1776:  00:EBE9  F1                  		pop	af			; A=socket number
    1777:  00:EBEA  F5                  		push	af			; Save socket number
    1778:  00:EBEB  CD B8 DA            		 call	socket.is_closed	; Check socket not closed
    1779:  00:EBEE  20 03               		 jr	nz,.notclosed		; Go if ok
    1780:  00:EBF0                      ;
    1781:  00:EBF0  F1                  		pop	af			; Drop saved socket number
    1782:  00:EBF1  37                  		scf
    1783:  00:EBF2  C9                  		ret
    1784:  00:EBF3                      ;
    1785:  00:EBF3                      .notclosed:
    1786:  00:EBF3  CD C3 D0            		call	status.waiting		; Flash status indicator
    1787:  00:EBF6                      ;
    1788:  00:EBF6  F1                  		pop	af			; A=socket number
    1789:  00:EBF7  CD C3 CA            		call	exos.is_stop
    1790:  00:EBFA  D8                  		ret	c
    1791:  00:EBFB                      ;
    1792:  00:EBFB  2A 0E 40            		ld	hl,(vars.ticks)
    1793:  00:EBFE  ED 4B 58 40         		ld	bc,(vars.ftp.start)
    1794:  00:EC02  B7                  		or	a
    1795:  00:EC03  ED 42               		sbc	hl,bc			; HL=duration in ticks
    1796:  00:EC05  01 B8 0B            		ld	bc,TICKS_1m		; 1 minute timeout
    1797:  00:EC08  B7                  		or	a
    1798:  00:EC09  ED 42               		sbc	hl,bc
    1799:  00:EC0B  38 D6               		jr	c,.loop
    1800:  00:EC0D                      ;
    1801:  00:EC0D  37                  		scf				; Timed out
    1802:  00:EC0E  C9                  		ret
    1803:  00:EC0F                      ;
    1804:  00:EC0F  F1                  .readit:	pop	af			; A=socket number
    1805:  00:EC10                      ;
    1806:  00:EC10  4D                  		ld	c,l
    1807:  00:EC11  44                  		ld	b,h			; BC=response size
    1808:  00:EC12  21 FE 00            		ld	hl,vars.ftp.buffer_size-2; See if it will fit in buffer
    1809:  00:EC15  B7                  		or	a
    1810:  00:EC16  ED 42               		sbc	hl,bc
    1811:  00:EC18  30 03               		jr	nc,.doread		; Go if it will fit in buffer
    1812:  00:EC1A                      ;
    1813:  00:EC1A  01 FE 00            		ld	bc,vars.ftp.buffer_size-2; Else limit to buffer size
    1814:  00:EC1D  21 60 40            .doread:	ld	hl,vars.ftp.buffer
    1815:  00:EC20  E5                  		push	hl			; Save start of buffer
    1816:  00:EC21  C5                  		push	bc			; Save response size
    1817:  00:EC22  CD DA DA            		 call	socket.read		; Read response
    1818:  00:EC25  C1                  		pop	bc			; BC=size of response
    1819:  00:EC26  E1                  		pop	hl			; HL->response
    1820:  00:EC27                      ;
    1821:  00:EC27  B7                  		or	a			; No error
    1822:  00:EC28  C9                  		ret
    1823:  00:EC29                      ;
    1824:  00:EC29                      ;
    1825:  00:EC29                      ;------------------------------------------------------------------------------
    1826:  00:EC29                      ; read_code
    1827:  00:EC29                      ;
    1828:  00:EC29                      ; Finds the response/error number at the beginning of the line in an
    1829:  00:EC29                      ; FTP response. We don't just find the first one - if there is more than one
    1830:  00:EC29                      ; line we return the last (ie most recent) one
    1831:  00:EC29                      ; In:  HL->FTP response string
    1832:  00:EC29                      ; Out: HL=code
    1833:  00:EC29                      ;
    1834:  00:EC29                      read_code:
    1835:  00:EC29  5D                  		ld	e,l		; DE->response
    1836:  00:EC2A  54                  		ld	d,h
    1837:  00:EC2B                      ;
    1838:  00:EC2B  B7                  		or	a
    1839:  00:EC2C  ED 62               		sbc	hl,hl		; HL=0 (last code found)
    1840:  00:EC2E                      
    1841:  00:EC2E                      		; At this point we are at the beginning of the line
    1842:  00:EC2E  CD BE D1            .first:		call	util.get_num16
    1843:  00:EC31                      ;
    1844:  00:EC31                      		; We've done one line - now find the start of the next
    1845:  00:EC31  1A                  .nextline:	ld	a,(de)		; Get char from response
    1846:  00:EC32  13                  		inc	de
    1847:  00:EC33  B7                  		or	a
    1848:  00:EC34  C8                  		ret	z		; Ret if end of response
    1849:  00:EC35                      ;
    1850:  00:EC35  FE 0D               		cp	CR		; If it's a CR we've found end of line
    1851:  00:EC37  28 04               		jr	z,.skip
    1852:  00:EC39                      ;
    1853:  00:EC39  FE 0A               		cp	LF		; Ditto LF
    1854:  00:EC3B  20 F4               		jr	nz,.nextline
    1855:  00:EC3D                      ;
    1856:  00:EC3D                      		; Found first CR or LF, now skip all CRs & LFs
    1857:  00:EC3D  1A                  .skip:		ld	a,(de)
    1858:  00:EC3E  13                  		inc	de
    1859:  00:EC3F  B7                  		or	a
    1860:  00:EC40  C8                  		ret	z
    1861:  00:EC41                      ;
    1862:  00:EC41  FE 0D               		cp	CR
    1863:  00:EC43  28 F8               		jr	z,.skip
    1864:  00:EC45                      ;
    1865:  00:EC45  FE 0A               		cp	LF
    1866:  00:EC47  28 F4               		jr	z,.skip
    1867:  00:EC49                      ;
    1868:  00:EC49  1B                  		dec	de
    1869:  00:EC4A  18 E2               		jr	.first		; First non-CRLF = start of line
    1870:  00:EC4C                      ;
    1871:  00:EC4C                      ;
    1872:  00:EC4C                      ;------------------------------------------------------------------------------
    1873:  00:EC4C                      ; issue_cmd
    1874:  00:EC4C                      ;
    1875:  00:EC4C                      ; Sends an ftp command with optional argument from command line
    1876:  00:EC4C                      ;
    1877:  00:EC4C                      ; In:  HL->FTP command
    1878:  00:EC4C                      ;      DE->arg, length byte first, or 0 if none
    1879:  00:EC4C                      ;      vars.ftp.socket
    1880:  00:EC4C                      ;
    1881:  00:EC4C  D5                  issue_cmd:	push	de		; Save ->arg
    1882:  00:EC4D  11 60 40            		 ld	de,vars.ftp.buffer
    1883:  00:EC50  CD F1 D0            		 call	util.copystr	; Copy command string at (HL)
    1884:  00:EC53  E1                  		pop	hl		; HL->arg
    1885:  00:EC54  7C                  		ld	a,h
    1886:  00:EC55  B5                  		or	l
    1887:  00:EC56  C4 F9 D0            		call	nz,util.copyarg	; Add arg to command string
    1888:  00:EC59                      ;
    1889:  00:EC59  FD CB 00 5E         		bit	vars.trace.ftp,(iy+vars._trace)
    1890:  00:EC5D  28 11               		jr	z,.notrace
    1891:  00:EC5F                      ;
    1892:  00:EC5F  D5                  		push	de		; Save end of command in buffer
    1893:  00:EC60  11 67 D5            		 ld	de,trace.ftp.tx	;      "Tx "
    1894:  00:EC63  CD E7 EC            		 call	trace		; "FTPn:"
    1895:  00:EC66                      ;
    1896:  00:EC66  11 60 40            		 ld	de,vars.ftp.buffer
    1897:  00:EC69  CD 36 D0            		 call	io.str		; Print FTP command before CRLF added
    1898:  00:EC6C  CD 21 D0            		 call	io.crlf
    1899:  00:EC6F  D1                  		pop	de		; DE->end of command in buffer
    1900:  00:EC70                      ;
    1901:  00:EC70  21 87 EC            .notrace:	ld	hl,crlf_str	; FTP commands end in CRLF
    1902:  00:EC73  CD F1 D0            		call	util.copystr
    1903:  00:EC76                      
    1904:  00:EC76  21 60 40            		ld	hl,vars.ftp.buffer
    1905:  00:EC79  CD 0E D1            		call	util.strlen	; BC=total length of command, HL->start
    1906:  00:EC7C                      ;
    1907:  00:EC7C  3A 57 40            		ld	a,(vars.ftp.socket)
    1908:  00:EC7F  F5                  		push	af
    1909:  00:EC80  CD C0 DB            		 call	socket.write
    1910:  00:EC83  F1                  		pop	af
    1911:  00:EC84                      ;
    1912:  00:EC84  C3 60 E1            		jp	tcp.send
    1913:  00:EC87                      ;
    1914:  00:EC87  0D 0A 00            crlf_str:	db	CR,LF,0
    1915:  00:EC8A                      ;
    1916:  00:EC8A                      ;
    1917:  00:EC8A                      ;------------------------------------------------------------------------------
    1918:  00:EC8A                      ; send_pasv
    1919:  00:EC8A                      ;
    1920:  00:EC8A                      ; Sends an FTP PASV command and parses the result
    1921:  00:EC8A                      ;
    1922:  00:EC8A                      ; Out:  Cy=>error
    1923:  00:EC8A                      ;       vars.ftp.data_ip and vars.ftp.data_port filled in
    1924:  00:EC8A                      ;
    1925:  00:EC8A  21 36 EE            send_pasv:	ld	hl,pasv_str
    1926:  00:EC8D  CD 5C EB            		call	issue
    1927:  00:EC90  D8                  		ret	c
    1928:  00:EC91                      ;
    1929:  00:EC91  11 63 40            		ld	de,vars.ftp.buffer+3	; Point passed response code
    1930:  00:EC94  CD DC EC            		call	findnum		; DE->next number in message
    1931:  00:EC97  6B                  		ld	l,e
    1932:  00:EC98  62                  		ld	h,d		; HL->remaining message
    1933:  00:EC99  CD 0E D1            		call	util.strlen	; BC=length of remaining message
    1934:  00:EC9C  41                  		ld	b,c		; B=length of remaing message		
    1935:  00:EC9D  1B                  		dec	de		; Pretend to point to length byte
    1936:  00:EC9E  21 5A 40            		ld	hl,vars.ftp.data_ip
    1937:  00:ECA1  CD 71 D1            		call	util.get_ip	; Interpret IP address
    1938:  00:ECA4  CD DC EC            		call	findnum		; DE->first number after IP
    1939:  00:ECA7  CD BE D1            		call	util.get_num16	; Assume port H for data connection
    1940:  00:ECAA  1A                  		ld	a,(de)
    1941:  00:ECAB  FE 2C               		cp	','		; Skip likely separators
    1942:  00:ECAD  28 08               		jr	z,.gotsep
    1943:  00:ECAF  FE 2E               		cp	'.'
    1944:  00:ECB1  28 04               		jr	z,.gotsep
    1945:  00:ECB3  FE 20               		cp	' '
    1946:  00:ECB5  20 07               		jr	nz,.notsep
    1947:  00:ECB7                      ;
    1948:  00:ECB7  E5                  .gotsep:	push	hl		; Save port num H
    1949:  00:ECB8  13                  		inc	de		; Skip separator
    1950:  00:ECB9  CD BE D1            		call	util.get_num16	; HL=port num L
    1951:  00:ECBC  C1                  		pop	bc		; BC=port num H
    1952:  00:ECBD  61                  		ld	h,c		; HL=port number
    1953:  00:ECBE  22 5E 40            .notsep:	ld	(vars.ftp.data_port),hl
    1954:  00:ECC1                      ;
    1955:  00:ECC1  FD CB 00 5E         		bit	vars.trace.ftp,(iy+vars._trace)
    1956:  00:ECC5  C8                  		ret	z
    1957:  00:ECC6                      ;
    1958:  00:ECC6  11 75 D5            		ld	de,trace.ftp.pasv	;      "pasv="
    1959:  00:ECC9  CD E7 EC            		call	trace			; "FTPn:"
    1960:  00:ECCC                      ;
    1961:  00:ECCC  E5                  		push	hl		; Save port number
    1962:  00:ECCD  21 5A 40            		 ld	hl,vars.ftp.data_ip
    1963:  00:ECD0  CD 85 CF            		 call	io.ip		; Print ip address
    1964:  00:ECD3  3E 3A               		 ld	a,':'
    1965:  00:ECD5  CD F9 CF            		 call	io.char
    1966:  00:ECD8  E1                  		pop	hl
    1967:  00:ECD9  C3 AA CF            		jp	io.int		; And port no.
    1968:  00:ECDC                      ;
    1969:  00:ECDC                      ;
    1970:  00:ECDC                      ;
    1971:  00:ECDC  1B                  findnum:	dec	de
    1972:  00:ECDD  13                  .loop:		inc	de		; Look for first numerical digit
    1973:  00:ECDE  1A                  		ld	a,(de)
    1974:  00:ECDF  B7                  		or	a
    1975:  00:ECE0  C8                  		ret	z
    1976:  00:ECE1                      ;
    1977:  00:ECE1  CD B7 D1            		call	util.isdig
    1978:  00:ECE4  38 F7               		jr	c,.loop
    1979:  00:ECE6                      ;
    1980:  00:ECE6  C9                  		ret			; HL->first digit
    1981:  00:ECE7                      ;
    1982:  00:ECE7                      ;
    1983:  00:ECE7                      ;------------------------------------------------------------------------------
    1984:  00:ECE7                      ; trace_start
    1985:  00:ECE7                      ;
    1986:  00:ECE7                      ; Outputs "FTPn:<str>" at start of trace line
    1987:  00:ECE7                      ;
    1988:  00:ECE7                      ; In:  DE->str
    1989:  00:ECE7                      ;
    1990:  00:ECE7  CD 1C D0            trace:		call	io.start
    1991:  00:ECEA  3E 46               		ld	a,'F'
    1992:  00:ECEC  CD F9 CF            		call	io.char
    1993:  00:ECEF  3E 54               		ld	a,'T'
    1994:  00:ECF1  CD F9 CF            		call	io.char
    1995:  00:ECF4  3E 50               		ld	a,'P'
    1996:  00:ECF6  CD F9 CF            		call	io.char
    1997:  00:ECF9  3A 57 40            		ld	a,(vars.ftp.socket)
    1998:  00:ECFC  C6 30               		add	a,'0'
    1999:  00:ECFE  CD F9 CF            		call	io.char
    2000:  00:ED01  3E 3A               		ld	a,':'
    2001:  00:ED03  CD F9 CF            		call	io.char
    2002:  00:ED06  C3 36 D0            		jp	io.str
    2003:  00:ED09                      ;
    2004:  00:ED09                      ;
    2005:  00:ED09                      ;==============================================================================
    2006:  00:ED09                      ; The following functions are called by the EXOS FTP: device
    2007:  00:ED09                      ;
    2008:  00:ED09                      ;
    2009:  00:ED09                      ; This is the data kept in EXOS channel RAM.
    2010:  00:ED09                      ;
    2011:  00:ED09                      ; EXOS channel RAM is accessed at (ix-1), (ix-2)...etc so our data here is
    2012:  00:ED09                      ; accessed with (ix-1-<item>) eg (ix-1-socket). But it must be paged in first
    2013:  00:ED09                      ; - the segment in in L'.
    2014:  00:ED09                      ;
    2015:  00:ED09                      ; socket must be first as some of the generic device code expects it here.
    2016:  00:ED09                      ;
    2017:  00:ED09                      		struct	ftp_channel	; Variables in EXOS channel RAM
    2018:  00:ED09                    < socket		 byte			; WIZ socket # for this channel
    2019:  00:ED09                    < data		 byte			; NZ=>data socket is open
    2020:  00:ED09                    < 		ends
    2021:  00:ED09                      ;
    2022:  00:ED09                      ;
    2023:  00:ED09                      ;------------------------------------------------------------------------------
    2024:  00:ED09                      ; device_open
    2025:  00:ED09                      ;
    2026:  00:ED09                      ; This is called by the EXOS device open function call
    2027:  00:ED09                      ;
    2028:  00:ED09                      ; In:  DE->filename, length byte first
    2029:  00:ED09                      ;      IX->EXOS channel RAM
    2030:  00:ED09                      ;       A=socket number
    2031:  00:ED09                      ; Out: A=EXOS error code, Z not necessarily set appropriately
    2032:  00:ED09                      ;
    2033:  00:ED09                      device_open:
    2034:  00:ED09  21 41 EE            		ld	hl,retr_str
    2035:  00:ED0C  18 03               		jr	opencreate
    2036:  00:ED0E                      		
    2037:  00:ED0E                      ;
    2038:  00:ED0E                      ;
    2039:  00:ED0E                      ;------------------------------------------------------------------------------
    2040:  00:ED0E                      ; device_create
    2041:  00:ED0E                      ;
    2042:  00:ED0E                      ; This is called by the EXOS device create function call
    2043:  00:ED0E                      ; In:   A=socket number (control)
    2044:  00:ED0E                      ;      DE->filename, length byte first
    2045:  00:ED0E                      ;      IX->EXOS channel RAM
    2046:  00:ED0E                      ; Out: A=EXOS error code
    2047:  00:ED0E                      ;
    2048:  00:ED0E                      device_create:
    2049:  00:ED0E  21 47 EE            		ld	hl,stor_str
    2050:  00:ED11                      
    2051:  00:ED11                      		; Open and create are identical except for the FTP command
    2052:  00:ED11                      		; string
    2053:  00:ED11                      opencreate:
    2054:  00:ED11                      ;		
    2055:  00:ED11  32 57 40            		ld	(vars.ftp.socket),a
    2056:  00:ED14  D9                  		exx
    2057:  00:ED15  ED 69               		out	(c),l		; Page in channel RAM
    2058:  00:ED17  DD 77 FF            		ld	(ix-1-ftp_channel.socket),a	; Save socket
    2059:  00:ED1A  DD 36 FE 00         		ld	(ix-1-ftp_channel.data),0; 0=>no data channel open
    2060:  00:ED1E  ED 41               		out	(c),b		; Page our variables back in
    2061:  00:ED20  D9                  		exx
    2062:  00:ED21                      ;
    2063:  00:ED21  CD AE D0            		call	status.start	; Start activity indicator
    2064:  00:ED24                      ;
    2065:  00:ED24  E5                  		push	hl		; Save FTP command
    2066:  00:ED25  D5                  		push	de		; Save ->arg
    2067:  00:ED26  CD BD EB            		 call	open_data	; Open data connection
    2068:  00:ED29  D1                  		pop	de		; DE->arg
    2069:  00:ED2A  E1                  		pop	hl		; HL->FTP command
    2070:  00:ED2B  3E 6B               		ld	a,exos.ERR_NOCON
    2071:  00:ED2D  38 13               		jr	c,.ret
    2072:  00:ED2F                      ;
    2073:  00:ED2F  AF                  		xor	a		; Data channel socket always 0
    2074:  00:ED30  D9                  		exx
    2075:  00:ED31  ED 69               		out	(c),l		; Page in channel RAM
    2076:  00:ED33  DD 36 FE FF         		ld	(ix-1-ftp_channel.data),0xff;	; NZ=>data socket open
    2077:  00:ED37  ED 41               		out	(c),b		; Page our variables back in
    2078:  00:ED39  D9                  		exx
    2079:  00:ED3A                      ;
    2080:  00:ED3A  CD 5F EB            		call	issue_arg	; Send FTP command, HL=response code
    2081:  00:ED3D  3E 6A               		ld	a,exos.ERR_TIMEOUT
    2082:  00:ED3F  D4 D9 ED            		call	nc,ftp_to_exos
    2083:  00:ED42  F5                  .ret:		push	af
    2084:  00:ED43  CD A2 D0            	 	 call	status.stop	; Stop activity indicator
    2085:  00:ED46  F1                  		pop	af
    2086:  00:ED47  C9                  		ret
    2087:  00:ED48                      ;
    2088:  00:ED48                      ;
    2089:  00:ED48                      ;------------------------------------------------------------------------------
    2090:  00:ED48                      ; device_close
    2091:  00:ED48                      ;
    2092:  00:ED48                      ; This is called by the EXOS device close function call
    2093:  00:ED48                      ;
    2094:  00:ED48                      ; In:   A=socket number (control)
    2095:  00:ED48                      ;      IX->EXOS channel RAM
    2096:  00:ED48                      ; Out: A=EXOS error code
    2097:  00:ED48                      ;
    2098:  00:ED48                      device_close:
    2099:  00:ED48  32 57 40            		ld	(vars.ftp.socket),a
    2100:  00:ED4B                      ;
    2101:  00:ED4B  CD AE D0            		call	status.start	; Start activity indicator
    2102:  00:ED4E                      
    2103:  00:ED4E  AF                  		xor	a		; Socket 0
    2104:  00:ED4F  D9                  		exx
    2105:  00:ED50  ED 69               		out	(c),l		; Page in channel RAM
    2106:  00:ED52  DD CB FE 46         		bit	0,(ix-1-ftp_channel.data);
    2107:  00:ED56  ED 41               		out	(c),b		; Page our variables back in
    2108:  00:ED58  D9                  		exx
    2109:  00:ED59  C4 D1 E1            		call	nz,tcp.close	; Close data socket (socket = 0)
    2110:  00:ED5C                      ;
    2111:  00:ED5C  D9                  		exx
    2112:  00:ED5D  ED 69               		out	(c),l		; Page in channel RAM
    2113:  00:ED5F  DD 36 FE 00         		ld	(ix-1-ftp_channel.data),0; Not open now
    2114:  00:ED63  ED 41               		out	(c),b		; Page our variables back in
    2115:  00:ED65  D9                  		exx
    2116:  00:ED66                      ;
    2117:  00:ED66  CD 64 EB            		call	is_response	; Read any final reponse to RETR/STOR
    2118:  00:ED69  CD A2 D0            	 	call	status.stop	; Stop activity indicator
    2119:  00:ED6C  AF                  		xor	a		; No error
    2120:  00:ED6D  C9                  		ret
    2121:  00:ED6E                      ;
    2122:  00:ED6E                      ;
    2123:  00:ED6E                      ;------------------------------------------------------------------------------
    2124:  00:ED6E                      ; device_read_byte
    2125:  00:ED6E                      ;
    2126:  00:ED6E                      ; This is called by the EXOS device read_byte function call
    2127:  00:ED6E                      ;
    2128:  00:ED6E                      ; In:   A=socket number (control)
    2129:  00:ED6E                      ;      IX->EXOS channel RAM
    2130:  00:ED6E                      ; Out:  B=byte
    2131:  00:ED6E                      ;       A=EXOS error code
    2132:  00:ED6E                      ;
    2133:  00:ED6E                      device_read_byte:
    2134:  00:ED6E                      ;
    2135:  00:ED6E  32 57 40            		ld	(vars.ftp.socket),a
    2136:  00:ED71                      ;
    2137:  00:ED71  CD AE D0            		call	status.start		; Start activity indicator
    2138:  00:ED74                      ;
    2139:  00:ED74  D9                  		exx
    2140:  00:ED75  50                  		ld	d,b			; Use our variable page
    2141:  00:ED76  D9                  		exx
    2142:  00:ED77                      ;
    2143:  00:ED77  11 16 40            		ld	de,vars.device.byte	; 1 byte buffer
    2144:  00:ED7A  01 01 00            		ld	bc,1
    2145:  00:ED7D  AF                  		xor	a			; Socket 0 for data
    2146:  00:ED7E  CD BA DF            		call	tcp.read_block		; Read 1 byte
    2147:  00:ED81  FD 46 0F            		ld	b,(iy+vars.device._byte)	; Return 1 byte in B
    2148:  00:ED84  F5                  		push	af
    2149:  00:ED85  CD A2 D0            	 	 call	status.stop		; Stop activity indicator
    2150:  00:ED88  F1                  		pop	af
    2151:  00:ED89                      
    2152:  00:ED89  18 0A               		jr	read_ret
    2153:  00:ED8B                      ;		
    2154:  00:ED8B                      ;
    2155:  00:ED8B                      ;------------------------------------------------------------------------------
    2156:  00:ED8B                      ; device_read_block
    2157:  00:ED8B                      ;
    2158:  00:ED8B                      ; This is called by the EXOS device read_block function call
    2159:  00:ED8B                      ;
    2160:  00:ED8B                      ; In:   A=socket number (control)
    2161:  00:ED8B                      ;      IX->EXOS channel RAM
    2162:  00:ED8B                      ;      DE->user's buffer
    2163:  00:ED8B                      ;      BC=byte count
    2164:  00:ED8B                      ; Out: A=EXOS error code
    2165:  00:ED8B                      ;
    2166:  00:ED8B                      device_read_block:
    2167:  00:ED8B                      ;
    2168:  00:ED8B  32 57 40            		ld	(vars.ftp.socket),a
    2169:  00:ED8E  21 BA DF            		ld	hl,tcp.read_block
    2170:  00:ED91  AF                  		xor	a		; Data socket always 0
    2171:  00:ED92  CD 0C CF            		call	device.block
    2172:  00:ED95                      ;
    2173:  00:ED95  D0                  read_ret:	ret	nc
    2174:  00:ED96                      ;
    2175:  00:ED96  D6 02               		sub	2
    2176:  00:ED98  3E E4               		ld	a,exos.ERR_EOF
    2177:  00:ED9A  F8                  		ret	m		; Code 1=>socket closed
    2178:  00:ED9B                      ;
    2179:  00:ED9B  3E E5               		ld	a,exos.ERR_STOP
    2180:  00:ED9D  C8                  		ret	z		; Code 2=>STOP pressed
    2181:  00:ED9E                      ;
    2182:  00:ED9E  3E 6A               		ld	a,exos.ERR_TIMEOUT; Code 3=>timeout
    2183:  00:EDA0  C9                  		ret
    2184:  00:EDA1                      ;
    2185:  00:EDA1                      ;
    2186:  00:EDA1                      ;------------------------------------------------------------------------------
    2187:  00:EDA1                      ; device_write_byte
    2188:  00:EDA1                      ;
    2189:  00:EDA1                      ; This is called by the EXOS device write_byte function call
    2190:  00:EDA1                      ;
    2191:  00:EDA1                      ; In:   A=socket number (control)
    2192:  00:EDA1                      ;       B=byte
    2193:  00:EDA1                      ;      IX->EXOS channel RAM
    2194:  00:EDA1                      ; Out: A=EXOS error code
    2195:  00:EDA1                      ;
    2196:  00:EDA1                      device_write_byte:
    2197:  00:EDA1  32 57 40            		ld	(vars.ftp.socket),a
    2198:  00:EDA4                      ;
    2199:  00:EDA4  CD AE D0            		call	status.start	; Start activity indicator
    2200:  00:EDA7                      ;
    2201:  00:EDA7  D9                  		exx
    2202:  00:EDA8  50                  		ld	d,b			; Use our page
    2203:  00:EDA9  D9                  		exx
    2204:  00:EDAA                      ;
    2205:  00:EDAA  11 16 40            		ld	de,vars.device.byte	; 1 byte buffer
    2206:  00:EDAD  78                  		ld	a,b
    2207:  00:EDAE  12                  		ld	(de),a
    2208:  00:EDAF  01 01 00            		ld	bc,1
    2209:  00:EDB2  AF                  		xor	a			; Socket 0 for data
    2210:  00:EDB3  CD 9B E0            		call	tcp.write_block		; Write 1 byte
    2211:  00:EDB6  9F                  		sbc	a,a			; Cy->FF, NC->0
    2212:  00:EDB7  E6 6A               		and	exos.ERR_TIMEOUT	; Cy->error code, 0 if no error
    2213:  00:EDB9                      ;
    2214:  00:EDB9  F5                  		push	af
    2215:  00:EDBA  CD A2 D0            	 	 call	status.stop		; Stop activity indicator
    2216:  00:EDBD  F1                  		pop	af
    2217:  00:EDBE  C9                  		ret
    2218:  00:EDBF                      ;		
    2219:  00:EDBF                      ;
    2220:  00:EDBF                      ;------------------------------------------------------------------------------
    2221:  00:EDBF                      ; device_write_block
    2222:  00:EDBF                      ;
    2223:  00:EDBF                      ; This is called by the EXOS device write_block function call
    2224:  00:EDBF                      ;
    2225:  00:EDBF                      ; In:   A=socket number (control)
    2226:  00:EDBF                      ;      IX->EXOS channel RAM
    2227:  00:EDBF                      ; Out: A=EXOS error code
    2228:  00:EDBF                      ;
    2229:  00:EDBF                      device_write_block:
    2230:  00:EDBF  32 57 40            		ld	(vars.ftp.socket),a
    2231:  00:EDC2  21 9B E0            		ld	hl,tcp.write_block
    2232:  00:EDC5  AF                  		xor	a			; Data socket always 0
    2233:  00:EDC6  CD 0C CF            		call	device.block
    2234:  00:EDC9  9F                  		sbc	a,a			; Cy->FF, NC->0
    2235:  00:EDCA  E6 6A               		and	exos.ERR_TIMEOUT	; Cy->error code, 0 if no error
    2236:  00:EDCC  C9                  		ret
    2237:  00:EDCD                      ;
    2238:  00:EDCD                      ;
    2239:  00:EDCD                      ;------------------------------------------------------------------------------
    2240:  00:EDCD                      ; device_status
    2241:  00:EDCD                      ;
    2242:  00:EDCD                      ; This is called by the EXOS device get_read_status function call
    2243:  00:EDCD                      ;
    2244:  00:EDCD                      ; In:  A=socket number (control)
    2245:  00:EDCD                      ;     IX->EXOS channel RAM
    2246:  00:EDCD                      ; Out: A=EXOS error code
    2247:  00:EDCD                      ;      C=0=>byte ready, FF=>end of file, 1 otherwise
    2248:  00:EDCD                      ;
    2249:  00:EDCD                      device_status:
    2250:  00:EDCD  32 57 40            		ld	(vars.ftp.socket),a
    2251:  00:EDD0                      ;
    2252:  00:EDD0  AF                  		xor	a		; Data socket 0
    2253:  00:EDD1  CD 2B E1            		call	tcp.status
    2254:  00:EDD4  4F                  		ld	c,a
    2255:  00:EDD5  9F                  		sbc	a,a
    2256:  00:EDD6  E6 6A               		and	exos.ERR_TIMEOUT
    2257:  00:EDD8  C9                  		ret
    2258:  00:EDD9                      ;
    2259:  00:EDD9                      ;
    2260:  00:EDD9                      ;------------------------------------------------------------------------------
    2261:  00:EDD9                      ; ftp_to_exos
    2262:  00:EDD9                      ;
    2263:  00:EDD9                      ; Converts FTP response/error codes to EXOS error codes
    2264:  00:EDD9                      ;
    2265:  00:EDD9                      ; In:  HL=FTP response code
    2266:  00:EDD9                      ; Out:  A=EXOS error code if fatal, else 0
    2267:  00:EDD9                      ;      Cy set if A <> 0
    2268:  00:EDD9                      ;
    2269:  00:EDD9  4D                  ftp_to_exos:	ld	c,l
    2270:  00:EDDA  44                  		ld	b,h		; BC=FTP response code
    2271:  00:EDDB  21 FA ED            		ld	hl,responses
    2272:  00:EDDE  5E                  .loop:		ld	e,(hl)
    2273:  00:EDDF  23                  		inc	hl
    2274:  00:EDE0  56                  		ld	d,(hl)		; DE=response code form table
    2275:  00:EDE1  23                  		inc	hl
    2276:  00:EDE2  7E                  		ld	a,(hl)		; A=equivalent EXOS code
    2277:  00:EDE3  23                  		inc	hl
    2278:  00:EDE4  B7                  		or	a
    2279:  00:EDE5  28 09               		jr	z,.notintable	; Go with NC if end of table
    2280:  00:EDE7                      ;
    2281:  00:EDE7  EB                  		ex	de,hl		; DE->table, HL=response code from table
    2282:  00:EDE8  B7                  		or	a
    2283:  00:EDE9  ED 42               		sbc	hl,bc		; Found matching response?
    2284:  00:EDEB  37                  		scf
    2285:  00:EDEC  C8                  		ret	z		; Ret with EXOS code in A if yes
    2286:  00:EDED                      ;
    2287:  00:EDED  EB                  		ex	de,hl		; HL->table
    2288:  00:EDEE  18 EE               		jr	.loop		; Try next entry
    2289:  00:EDF0                      ;
    2290:  00:EDF0                      .notintable:				; NC here
    2291:  00:EDF0  21 8F 01            		ld	hl,399		; >=400 are generally fatal
    2292:  00:EDF3  ED 42               		sbc	hl,bc
    2293:  00:EDF5  3E 69               		ld	a,exos.ERR_FTP
    2294:  00:EDF7  D8                  		ret	c		; Return with EXOS error if >=400
    2295:  00:EDF8                      ;
    2296:  00:EDF8  AF                  		xor	a		; Else no EXOS error
    2297:  00:EDF9  C9                  		ret
    2298:  00:EDFA                      ;
    2299:  00:EDFA  26 02               responses:	dw	550
    2300:  00:EDFC  68                  		db	exos.ERR_NOFIL
    2301:  00:EDFD                      ;
    2302:  00:EDFD  00 00               		dw	0
    2303:  00:EDFF  00                  		db	0
    2304:  00:EE00                      ;
    2305:  00:EE00                      ;
    2306:  00:EE00                      ;------------------------------------------------------------------------------
    2307:  00:EE00                      ; FTP commands that are sent
    2308:  00:EE00                      ;
    2309:  00:EE00  43 57 44 20 00      cwd_str:	db	"CWD ",0
    2310:  00:EE05  50 57 44 00         pwd_str:	db	"PWD",0
    2311:  00:EE09  43 44 55 50 00      cdup_str:	db	"CDUP",0
    2312:  00:EE0E  4D 4B 44 20 00      mkd_str:	db	"MKD ",0
    2313:  00:EE13  52 4D 44 20 00      rmd_str:	db	"RMD ",0
    2314:  00:EE18  44 45 4C 45 20 00   dele_str:	db	"DELE ",0
    2315:  00:EE1E  52 4E 46 52 20 00   rnfr_str:	db	"RNFR ",0
    2316:  00:EE24  52 4E 54 4F 20 00   rnto_str:	db	"RNTO ",0
    2317:  00:EE2A  55 53 45 52 20 00   user_str:	db	"USER ",0
    2318:  00:EE30  50 41 53 53 20 00   pass_str:	db	"PASS ",0
    2319:  00:EE36  50 41 53 56 00      pasv_str:	db	"PASV",0
    2320:  00:EE3B  4C 49 53 54 20 00   list_str:	db	"LIST ",0
    2321:  00:EE41  52 45 54 52 20 00   retr_str:	db	"RETR ",0
    2322:  00:EE47  53 54 4F 52 20 00   stor_str:	db	"STOR ",0
    2323:  00:EE4D  53 59 53 54 00      syst_str:	db	"SYST",0
    2324:  00:EE52  51 55 49 54 00      quit_str:	db	"QUIT",0
    2325:  00:EE57                      ;
    2326:  00:EE57                      ;
    2327:  00:EE57  46 54 50 00         owner_str:	db	"FTP",0
    2328:  00:EE5B  44 41 54 41 00      owner_data_str:	db	"DATA",0
    2329:  00:EE60                      ;
    2330:  00:EE60                      ;
    2331:  00:EE60                      ;
    2332:  00:EE60                      		endmodule
     111.  00:EE60                      	include http.asm
       1:  00:EE60                      ; HTTP
       2:  00:EE60                      ;
       3:  00:EE60                      ; This module implements EPNET's HTTP protocol
       4:  00:EE60                      ;
       5:  00:EE60                      		module	http
       6:  00:EE60                      ;
       7:  00:EE60                      ;==============================================================================
       8:  00:EE60                      ;
       9:  00:EE60                      ; This file is part of the EPNET software
      10:  00:EE60                      ;
      11:  00:EE60                      ; Copyright (C) 2015  Bruce Tanner
      12:  00:EE60                      ;
      13:  00:EE60                      ;    This program is free software: you can redistribute it and/or modify
      14:  00:EE60                      ;    it under the terms of the GNU General Public License as published by
      15:  00:EE60                      ;    the Free Software Foundation, either version 3 of the License, or
      16:  00:EE60                      ;    (at your option) any later version.
      17:  00:EE60                      ;
      18:  00:EE60                      ;    This program is distributed in the hope that it will be useful,
      19:  00:EE60                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      20:  00:EE60                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      21:  00:EE60                      ;    GNU General Public License for more details.
      22:  00:EE60                      ;
      23:  00:EE60                      ;    You should have received a copy of the GNU General Public License
      24:  00:EE60                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      25:  00:EE60                      ;
      26:  00:EE60                      ; If you do use or modify this file, either for its original purpose or for
      27:  00:EE60                      ; something new, I'd love to hear about it! I can be contacted by email at:
      28:  00:EE60                      ;
      29:  00:EE60                      ; brucetanner@btopenworld.com
      30:  00:EE60                      ;
      31:  00:EE60                      ;==============================================================================
      32:  00:EE60                      ;
      33:  00:EE60                      ; For reference, this is the format of an HTTP 1.0 message (from RFC 1945):
      34:  00:EE60                      ;
      35:  00:EE60                      ; 4.  HTTP Message
      36:  00:EE60                      ;
      37:  00:EE60                      ; 4.1  Message Types
      38:  00:EE60                      ;
      39:  00:EE60                      ;   HTTP messages consist of requests from client to server and responses
      40:  00:EE60                      ;   from server to client.
      41:  00:EE60                      ;
      42:  00:EE60                      ;       HTTP-message   = Simple-Request           ; HTTP/0.9 messages
      43:  00:EE60                      ;                      | Simple-Response
      44:  00:EE60                      ;                      | Full-Request             ; HTTP/1.0 messages
      45:  00:EE60                      ;                      | Full-Response
      46:  00:EE60                      ;
      47:  00:EE60                      ;   Full-Request and Full-Response use the generic message format of RFC
      48:  00:EE60                      ;   822 [7] for transferring entities. Both messages may include optional
      49:  00:EE60                      ;   header fields (also known as "headers") and an entity body. The
      50:  00:EE60                      ;   entity body is separated from the headers by a null line (i.e., a
      51:  00:EE60                      ;   line with nothing preceding the CRLF).
      52:  00:EE60                      ;
      53:  00:EE60                      ;       Full-Request   = Request-Line             ; Section 5.1
      54:  00:EE60                      ;                        *( General-Header        ; Section 4.3
      55:  00:EE60                      ;                         | Request-Header        ; Section 5.2
      56:  00:EE60                      ;                         | Entity-Header )       ; Section 7.1
      57:  00:EE60                      ;                        CRLF
      58:  00:EE60                      ;                        [ Entity-Body ]          ; Section 7.2
      59:  00:EE60                      ;
      60:  00:EE60                      ;       Full-Response  = Status-Line              ; Section 6.1
      61:  00:EE60                      ;                        *( General-Header        ; Section 4.3
      62:  00:EE60                      ;                         | Response-Header       ; Section 6.2
      63:  00:EE60                      ;                         | Entity-Header )       ; Section 7.1
      64:  00:EE60                      ;                        CRLF
      65:  00:EE60                      ;                        [ Entity-Body ]          ; Section 7.2
      66:  00:EE60                      ;
      67:  00:EE60                      ;   Simple-Request and Simple-Response do not allow the use of any header
      68:  00:EE60                      ;   information and are limited to a single request method (GET).
      69:  00:EE60                      ;
      70:  00:EE60                      ;       Simple-Request  = "GET" SP Request-URI CRLF
      71:  00:EE60                      ;
      72:  00:EE60                      ;       Simple-Response = [ Entity-Body ]
      73:  00:EE60                      ;
      74:  00:EE60                      ;   Use of the Simple-Request format is discouraged because it prevents
      75:  00:EE60                      ;   the server from identifying the media type of the returned entity.
      76:  00:EE60                      ;
      77:  00:EE60                      ; 4.2  Message Headers
      78:  00:EE60                      ;
      79:  00:EE60                      ;   HTTP header fields, which include General-Header (Section 4.3),
      80:  00:EE60                      ;   Request-Header (Section 5.2), Response-Header (Section 6.2), and
      81:  00:EE60                      ;   Entity-Header (Section 7.1) fields, follow the same generic format as
      82:  00:EE60                      ;   that given in Section 3.1 of RFC 822 [7]. Each header field consists
      83:  00:EE60                      ;   of a name followed immediately by a colon (":"), a single space (SP)
      84:  00:EE60                      ;   character, and the field value. Field names are case-insensitive.
      85:  00:EE60                      ;   Header fields can be extended over multiple lines by preceding each
      86:  00:EE60                      ;   extra line with at least one SP or HT, though this is not
      87:  00:EE60                      ;   recommended.
      88:  00:EE60                      ;
      89:  00:EE60                      ;       HTTP-header    = field-name ":" [ field-value ] CRLF
      90:  00:EE60                      ;
      91:  00:EE60                      ;       field-name     = token
      92:  00:EE60                      ;       field-value    = *( field-content | LWS )
      93:  00:EE60                      ;
      94:  00:EE60                      ;       field-content  = <the OCTETs making up the field-value
      95:  00:EE60                      ;                        and consisting of either *TEXT or combinations
      96:  00:EE60                      ;                        of token, tspecials, and quoted-string>
      97:  00:EE60                      ;
      98:  00:EE60                      ;   The order in which header fields are received is not significant.
      99:  00:EE60                      ;   However, it is "good practice" to send General-Header fields first,
     100:  00:EE60                      ;   followed by Request-Header or Response-Header fields prior to the
     101:  00:EE60                      ;   Entity-Header fields.
     102:  00:EE60                      ;
     103:  00:EE60                      ;   Multiple HTTP-header fields with the same field-name may be present
     104:  00:EE60                      ;   in a message if and only if the entire field-value for that header
     105:  00:EE60                      ;   field is defined as a comma-separated list [i.e., #(values)]. It must
     106:  00:EE60                      ;   be possible to combine the multiple header fields into one "field-
     107:  00:EE60                      ;   name: field-value" pair, without changing the semantics of the
     108:  00:EE60                      ;   message, by appending each subsequent field-value to the first, each
     109:  00:EE60                      ;   separated by a comma.
     110:  00:EE60                      ;
     111:  00:EE60                      ; 4.3  General Header Fields
     112:  00:EE60                      ;
     113:  00:EE60                      ;   There are a few header fields which have general applicability for
     114:  00:EE60                      ;   both request and response messages, but which do not apply to the
     115:  00:EE60                      ;   entity being transferred. These headers apply only to the message
     116:  00:EE60                      ;   being transmitted.
     117:  00:EE60                      ;
     118:  00:EE60                      ;       General-Header = Date                     ; Section 10.6
     119:  00:EE60                      ;                      | Pragma                   ; Section 10.12
     120:  00:EE60                      ;
     121:  00:EE60                      ;   General header field names can be extended reliably only in
     122:  00:EE60                      ;   combination with a change in the protocol version. However, new or
     123:  00:EE60                      ;   experimental header fields may be given the semantics of general
     124:  00:EE60                      ;   header fields if all parties in the communication recognize them to
     125:  00:EE60                      ;   be general header fields. Unrecognized header fields are treated as
     126:  00:EE60                      ;   Entity-Header fields.
     127:  00:EE60                      ;
     128:  00:EE60                      ; 5. Request
     129:  00:EE60                      ;
     130:  00:EE60                      ;   A request message from a client to a server includes, within the
     131:  00:EE60                      ;   first line of that message, the method to be applied to the resource,
     132:  00:EE60                      ;   the identifier of the resource, and the protocol version in use. For
     133:  00:EE60                      ;   backwards compatibility with the more limited HTTP/0.9 protocol,
     134:  00:EE60                      ;   there are two valid formats for an HTTP request:
     135:  00:EE60                      ;
     136:  00:EE60                      ;       Request        = Simple-Request | Full-Request
     137:  00:EE60                      ;
     138:  00:EE60                      ;       Simple-Request = "GET" SP Request-URI CRLF
     139:  00:EE60                      ;
     140:  00:EE60                      ;       Full-Request   = Request-Line             ; Section 5.1
     141:  00:EE60                      ;                        *( General-Header        ; Section 4.3
     142:  00:EE60                      ;                         | Request-Header        ; Section 5.2
     143:  00:EE60                      ;                         | Entity-Header )       ; Section 7.1
     144:  00:EE60                      ;                        CRLF
     145:  00:EE60                      ;                        [ Entity-Body ]          ; Section 7.2
     146:  00:EE60                      ;
     147:  00:EE60                      ;   If an HTTP/1.0 server receives a Simple-Request, it must respond with
     148:  00:EE60                      ;   an HTTP/0.9 Simple-Response. An HTTP/1.0 client capable of receiving
     149:  00:EE60                      ;   a Full-Response should never generate a Simple-Request.
     150:  00:EE60                      ;
     151:  00:EE60                      ; 5.1  Request-Line
     152:  00:EE60                      ;
     153:  00:EE60                      ;   The Request-Line begins with a method token, followed by the
     154:  00:EE60                      ;   Request-URI and the protocol version, and ending with CRLF. The
     155:  00:EE60                      ;   elements are separated by SP characters. No CR or LF are allowed
     156:  00:EE60                      ;   except in the final CRLF sequence.
     157:  00:EE60                      ;
     158:  00:EE60                      ;       Request-Line = Method SP Request-URI SP HTTP-Version CRLF
     159:  00:EE60                      ;
     160:  00:EE60                      ;   Note that the difference between a Simple-Request and the Request-
     161:  00:EE60                      ;   Line of a Full-Request is the presence of the HTTP-Version field and
     162:  00:EE60                      ;   the availability of methods other than GET.
     163:  00:EE60                      ;
     164:  00:EE60                      ; 5.1.1 Method
     165:  00:EE60                      ;
     166:  00:EE60                      ;   The Method token indicates the method to be performed on the resource
     167:  00:EE60                      ;   identified by the Request-URI. The method is case-sensitive.
     168:  00:EE60                      ;
     169:  00:EE60                      ;       Method         = "GET"                    ; Section 8.1
     170:  00:EE60                      ;                      | "HEAD"                   ; Section 8.2
     171:  00:EE60                      ;                      | "POST"                   ; Section 8.3
     172:  00:EE60                      ;                      | extension-method
     173:  00:EE60                      ;
     174:  00:EE60                      ;       extension-method = token
     175:  00:EE60                      ;
     176:  00:EE60                      ;   The list of methods acceptable by a specific resource can change
     177:  00:EE60                      ;   dynamically; the client is notified through the return code of the
     178:  00:EE60                      ;   response if a method is not allowed on a resource. Servers should
     179:  00:EE60                      ;   return the status code 501 (not implemented) if the method is
     180:  00:EE60                      ;   unrecognized or not implemented.
     181:  00:EE60                      ;
     182:  00:EE60                      ;   The methods commonly used by HTTP/1.0 applications are fully defined
     183:  00:EE60                      ;   in Section 8.
     184:  00:EE60                      ;
     185:  00:EE60                      ; 5.1.2 Request-URI
     186:  00:EE60                      ;
     187:  00:EE60                      ;   The Request-URI is a Uniform Resource Identifier (Section 3.2) and
     188:  00:EE60                      ;   identifies the resource upon which to apply the request.
     189:  00:EE60                      ;
     190:  00:EE60                      ;       Request-URI    = absoluteURI | abs_path
     191:  00:EE60                      ;
     192:  00:EE60                      ;   The two options for Request-URI are dependent on the nature of the
     193:  00:EE60                      ;   request.
     194:  00:EE60                      ;
     195:  00:EE60                      ;   The absoluteURI form is only allowed when the request is being made
     196:  00:EE60                      ;   to a proxy. The proxy is requested to forward the request and return
     197:  00:EE60                      ;   the response. If the request is GET or HEAD and a prior response is
     198:  00:EE60                      ;   cached, the proxy may use the cached message if it passes any
     199:  00:EE60                      ;   restrictions in the Expires header field. Note that the proxy may
     200:  00:EE60                      ;   forward the request on to another proxy or directly to the server
     201:  00:EE60                      ;   specified by the absoluteURI. In order to avoid request loops, a
     202:  00:EE60                      ;   proxy must be able to recognize all of its server names, including
     203:  00:EE60                      ;   any aliases, local variations, and the numeric IP address. An example
     204:  00:EE60                      ;   Request-Line would be:
     205:  00:EE60                      ;
     206:  00:EE60                      ;       GET http://www.w3.org/pub/WWW/TheProject.html HTTP/1.0
     207:  00:EE60                      ;
     208:  00:EE60                      ;   The most common form of Request-URI is that used to identify a
     209:  00:EE60                      ;   resource on an origin server or gateway. In this case, only the
     210:  00:EE60                      ;   absolute path of the URI is transmitted (see Section 3.2.1,
     211:  00:EE60                      ;   abs_path). For example, a client wishing to retrieve the resource
     212:  00:EE60                      ;   above directly from the origin server would create a TCP connection
     213:  00:EE60                      ;   to port 80 of the host "www.w3.org" and send the line:
     214:  00:EE60                      ;
     215:  00:EE60                      ;       GET /pub/WWW/TheProject.html HTTP/1.0
     216:  00:EE60                      ;
     217:  00:EE60                      ;   followed by the remainder of the Full-Request. Note that the absolute
     218:  00:EE60                      ;   path cannot be empty; if none is present in the original URI, it must
     219:  00:EE60                      ;   be given as "/" (the server root).
     220:  00:EE60                      ;
     221:  00:EE60                      ;   The Request-URI is transmitted as an encoded string, where some
     222:  00:EE60                      ;   characters may be escaped using the "% HEX HEX" encoding defined by
     223:  00:EE60                      ;   RFC 1738 [4]. The origin server must decode the Request-URI in order
     224:  00:EE60                      ;   to properly interpret the request.
     225:  00:EE60                      ;
     226:  00:EE60                      ; 5.2  Request Header Fields
     227:  00:EE60                      ;
     228:  00:EE60                      ;   The request header fields allow the client to pass additional
     229:  00:EE60                      ;   information about the request, and about the client itself, to the
     230:  00:EE60                      ;   server. These fields act as request modifiers, with semantics
     231:  00:EE60                      ;   equivalent to the parameters on a programming language method
     232:  00:EE60                      ;   (procedure) invocation.
     233:  00:EE60                      ;
     234:  00:EE60                      ;       Request-Header = Authorization            ; Section 10.2
     235:  00:EE60                      ;                      | From                     ; Section 10.8
     236:  00:EE60                      ;                      | If-Modified-Since        ; Section 10.9
     237:  00:EE60                      ;                      | Referer                  ; Section 10.13
     238:  00:EE60                      ;                      | User-Agent               ; Section 10.15
     239:  00:EE60                      ;
     240:  00:EE60                      ;   Request-Header field names can be extended reliably only in
     241:  00:EE60                      ;   combination with a change in the protocol version. However, new or
     242:  00:EE60                      ;   experimental header fields may be given the semantics of request
     243:  00:EE60                      ;   header fields if all parties in the communication recognize them to
     244:  00:EE60                      ;   be request header fields. Unrecognized header fields are treated as
     245:  00:EE60                      ;   Entity-Header fields.
     246:  00:EE60                      ;
     247:  00:EE60                      ; 6.  Response
     248:  00:EE60                      ;
     249:  00:EE60                      ;   After receiving and interpreting a request message, a server responds
     250:  00:EE60                      ;   in the form of an HTTP response message.
     251:  00:EE60                      ;
     252:  00:EE60                      ;       Response        = Simple-Response | Full-Response
     253:  00:EE60                      ;
     254:  00:EE60                      ;       Simple-Response = [ Entity-Body ]
     255:  00:EE60                      ;
     256:  00:EE60                      ;       Full-Response   = Status-Line             ; Section 6.1
     257:  00:EE60                      ;                         *( General-Header       ; Section 4.3
     258:  00:EE60                      ;                          | Response-Header      ; Section 6.2
     259:  00:EE60                      ;                          | Entity-Header )      ; Section 7.1
     260:  00:EE60                      ;                         CRLF
     261:  00:EE60                      ;                         [ Entity-Body ]         ; Section 7.2
     262:  00:EE60                      ;
     263:  00:EE60                      ;   A Simple-Response should only be sent in response to an HTTP/0.9
     264:  00:EE60                      ;   Simple-Request or if the server only supports the more limited
     265:  00:EE60                      ;   HTTP/0.9 protocol. If a client sends an HTTP/1.0 Full-Request and
     266:  00:EE60                      ;   receives a response that does not begin with a Status-Line, it should
     267:  00:EE60                      ;   assume that the response is a Simple-Response and parse it
     268:  00:EE60                      ;   accordingly. Note that the Simple-Response consists only of the
     269:  00:EE60                      ;   entity body and is terminated by the server closing the connection.
     270:  00:EE60                      ;
     271:  00:EE60                      ; 6.1  Status-Line
     272:  00:EE60                      ;
     273:  00:EE60                      ;   The first line of a Full-Response message is the Status-Line,
     274:  00:EE60                      ;   consisting of the protocol version followed by a numeric status code
     275:  00:EE60                      ;   and its associated textual phrase, with each element separated by SP
     276:  00:EE60                      ;   characters. No CR or LF is allowed except in the final CRLF sequence.
     277:  00:EE60                      ;
     278:  00:EE60                      ;       Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
     279:  00:EE60                      ;
     280:  00:EE60                      ;   Since a status line always begins with the protocol version and
     281:  00:EE60                      ;   status code
     282:  00:EE60                      ;
     283:  00:EE60                      ;       "HTTP/" 1*DIGIT "." 1*DIGIT SP 3DIGIT SP
     284:  00:EE60                      ;
     285:  00:EE60                      ;   (e.g., "HTTP/1.0 200 "), the presence of that expression is
     286:  00:EE60                      ;   sufficient to differentiate a Full-Response from a Simple-Response.
     287:  00:EE60                      ;   Although the Simple-Response format may allow such an expression to
     288:  00:EE60                      ;   occur at the beginning of an entity body, and thus cause a
     289:  00:EE60                      ;   misinterpretation of the message if it was given in response to a
     290:  00:EE60                      ;   Full-Request, most HTTP/0.9 servers are limited to responses of type
     291:  00:EE60                      ;   "text/html" and therefore would never generate such a response.
     292:  00:EE60                      ;
     293:  00:EE60                      ; 6.1.1 Status Code and Reason Phrase
     294:  00:EE60                      ;
     295:  00:EE60                      ;   The Status-Code element is a 3-digit integer result code of the
     296:  00:EE60                      ;   attempt to understand and satisfy the request. The Reason-Phrase is
     297:  00:EE60                      ;   intended to give a short textual description of the Status-Code. The
     298:  00:EE60                      ;   Status-Code is intended for use by automata and the Reason-Phrase is
     299:  00:EE60                      ;   intended for the human user. The client is not required to examine or
     300:  00:EE60                      ;   display the Reason-Phrase.
     301:  00:EE60                      ;
     302:  00:EE60                      ;   The first digit of the Status-Code defines the class of response. The
     303:  00:EE60                      ;   last two digits do not have any categorization role. There are 5
     304:  00:EE60                      ;   values for the first digit:
     305:  00:EE60                      ;
     306:  00:EE60                      ;      o 1xx: Informational - Not used, but reserved for future use
     307:  00:EE60                      ;
     308:  00:EE60                      ;      o 2xx: Success - The action was successfully received,
     309:  00:EE60                      ;             understood, and accepted.
     310:  00:EE60                      ;
     311:  00:EE60                      ;      o 3xx: Redirection - Further action must be taken in order to
     312:  00:EE60                      ;             complete the request
     313:  00:EE60                      ;
     314:  00:EE60                      ;      o 4xx: Client Error - The request contains bad syntax or cannot
     315:  00:EE60                      ;             be fulfilled
     316:  00:EE60                      ;
     317:  00:EE60                      ;      o 5xx: Server Error - The server failed to fulfill an apparently
     318:  00:EE60                      ;             valid request
     319:  00:EE60                      ;
     320:  00:EE60                      ;   The individual values of the numeric status codes defined for
     321:  00:EE60                      ;   HTTP/1.0, and an example set of corresponding Reason-Phrase's, are
     322:  00:EE60                      ;   presented below. The reason phrases listed here are only recommended
     323:  00:EE60                      ;   -- they may be replaced by local equivalents without affecting the
     324:  00:EE60                      ;   protocol. These codes are fully defined in Section 9.
     325:  00:EE60                      ;
     326:  00:EE60                      ;       Status-Code    = "200"   ; OK
     327:  00:EE60                      ;                      | "201"   ; Created
     328:  00:EE60                      ;                      | "202"   ; Accepted
     329:  00:EE60                      ;                      | "204"   ; No Content
     330:  00:EE60                      ;                      | "301"   ; Moved Permanently
     331:  00:EE60                      ;                      | "302"   ; Moved Temporarily
     332:  00:EE60                      ;                      | "304"   ; Not Modified
     333:  00:EE60                      ;                      | "400"   ; Bad Request
     334:  00:EE60                      ;                      | "401"   ; Unauthorized
     335:  00:EE60                      ;                      | "403"   ; Forbidden
     336:  00:EE60                      ;                      | "404"   ; Not Found
     337:  00:EE60                      ;                      | "500"   ; Internal Server Error
     338:  00:EE60                      ;                      | "501"   ; Not Implemented
     339:  00:EE60                      ;                      | "502"   ; Bad Gateway
     340:  00:EE60                      ;                      | "503"   ; Service Unavailable
     341:  00:EE60                      ;                      | extension-code
     342:  00:EE60                      ;
     343:  00:EE60                      ;       extension-code = 3DIGIT
     344:  00:EE60                      ;
     345:  00:EE60                      ;       Reason-Phrase  = *<TEXT, excluding CR, LF>
     346:  00:EE60                      ;
     347:  00:EE60                      ;   HTTP status codes are extensible, but the above codes are the only
     348:  00:EE60                      ;   ones generally recognized in current practice. HTTP applications are
     349:  00:EE60                      ;   not required to understand the meaning of all registered status
     350:  00:EE60                      ;   codes, though such understanding is obviously desirable. However,
     351:  00:EE60                      ;   applications must understand the class of any status code, as
     352:  00:EE60                      ;   indicated by the first digit, and treat any unrecognized response as
     353:  00:EE60                      ;   being equivalent to the x00 status code of that class, with the
     354:  00:EE60                      ;   exception that an unrecognized response must not be cached. For
     355:  00:EE60                      ;   example, if an unrecognized status code of 431 is received by the
     356:  00:EE60                      ;   client, it can safely assume that there was something wrong with its
     357:  00:EE60                      ;   request and treat the response as if it had received a 400 status
     358:  00:EE60                      ;   code. In such cases, user agents should present to the user the
     359:  00:EE60                      ;   entity returned with the response, since that entity is likely to
     360:  00:EE60                      ;   include human-readable information which will explain the unusual
     361:  00:EE60                      ;   status.
     362:  00:EE60                      ;
     363:  00:EE60                      ; 6.2  Response Header Fields
     364:  00:EE60                      ;
     365:  00:EE60                      ;   The response header fields allow the server to pass additional
     366:  00:EE60                      ;   information about the response which cannot be placed in the Status-
     367:  00:EE60                      ;   Line. These header fields give information about the server and about
     368:  00:EE60                      ;   further access to the resource identified by the Request-URI.
     369:  00:EE60                      ;
     370:  00:EE60                      ;       Response-Header = Location                ; Section 10.11
     371:  00:EE60                      ;                       | Server                  ; Section 10.14
     372:  00:EE60                      ;                       | WWW-Authenticate        ; Section 10.16
     373:  00:EE60                      ;
     374:  00:EE60                      ;   Response-Header field names can be extended reliably only in
     375:  00:EE60                      ;   combination with a change in the protocol version. However, new or
     376:  00:EE60                      ;   experimental header fields may be given the semantics of response
     377:  00:EE60                      ;   header fields if all parties in the communication recognize them to
     378:  00:EE60                      ;    be response header fields. Unrecognized header fields are treated as
     379:  00:EE60                      ;   Entity-Header fields.
     380:  00:EE60                      ;
     381:  00:EE60                      ; 7.  Entity
     382:  00:EE60                      ;
     383:  00:EE60                      ;   Full-Request and Full-Response messages may transfer an entity within
     384:  00:EE60                      ;   some requests and responses. An entity consists of Entity-Header
     385:  00:EE60                      ;   fields and (usually) an Entity-Body. In this section, both sender and
     386:  00:EE60                      ;   recipient refer to either the client or the server, depending on who
     387:  00:EE60                      ;   sends and who receives the entity.
     388:  00:EE60                      ;
     389:  00:EE60                      ;
     390:  00:EE60                      ; 7.1  Entity Header Fields
     391:  00:EE60                      ;
     392:  00:EE60                      ;   Entity-Header fields define optional metainformation about the
     393:  00:EE60                      ;   Entity-Body or, if no body is present, about the resource identified
     394:  00:EE60                      ;   by the request.
     395:  00:EE60                      ;
     396:  00:EE60                      ;       Entity-Header  = Allow                    ; Section 10.1
     397:  00:EE60                      ;                      | Content-Encoding         ; Section 10.3
     398:  00:EE60                      ;                      | Content-Length           ; Section 10.4
     399:  00:EE60                      ;                      | Content-Type             ; Section 10.5
     400:  00:EE60                      ;                      | Expires                  ; Section 10.7
     401:  00:EE60                      ;                      | Last-Modified            ; Section 10.10
     402:  00:EE60                      ;                      | extension-header
     403:  00:EE60                      ;
     404:  00:EE60                      ;       extension-header = HTTP-header
     405:  00:EE60                      ;
     406:  00:EE60                      ;   The extension-header mechanism allows additional Entity-Header fields
     407:  00:EE60                      ;   to be defined without changing the protocol, but these fields cannot
     408:  00:EE60                      ;   be assumed to be recognizable by the recipient. Unrecognized header
     409:  00:EE60                      ;   fields should be ignored by the recipient and forwarded by proxies.
     410:  00:EE60                      ;
     411:  00:EE60                      ; 7.2  Entity Body
     412:  00:EE60                      ;
     413:  00:EE60                      ;   The entity body (if any) sent with an HTTP request or response is in
     414:  00:EE60                      ;   a format and encoding defined by the Entity-Header fields.
     415:  00:EE60                      ;
     416:  00:EE60                      ;       Entity-Body    = *OCTET
     417:  00:EE60                      ;
     418:  00:EE60                      ;   An entity body is included with a request message only when the
     419:  00:EE60                      ;   request method calls for one. The presence of an entity body in a
     420:  00:EE60                      ;   request is signaled by the inclusion of a Content-Length header field
     421:  00:EE60                      ;   in the request message headers. HTTP/1.0 requests containing an
     422:  00:EE60                      ;   entity body must include a valid Content-Length header field.
     423:  00:EE60                      ;
     424:  00:EE60                      ;   For response messages, whether or not an entity body is included with
     425:  00:EE60                      ;   a message is dependent on both the request method and the response
     426:  00:EE60                      ;   code. All responses to the HEAD request method must not include a
     427:  00:EE60                      ;   body, even though the presence of entity header fields may lead one
     428:  00:EE60                      ;   to believe they do. All 1xx (informational), 204 (no content), and
     429:  00:EE60                      ;   304 (not modified) responses must not include a body. All other
     430:  00:EE60                      ;   responses must include an entity body or a Content-Length header
     431:  00:EE60                      ;   field defined with a value of zero (0).
     432:  00:EE60                      ;
     433:  00:EE60                      ; 7.2.1 Type
     434:  00:EE60                      ;
     435:  00:EE60                      ;   When an Entity-Body is included with a message, the data type of that
     436:  00:EE60                      ;   body is determined via the header fields Content-Type and Content-
     437:  00:EE60                      ;   Encoding. These define a two-layer, ordered encoding model:
     438:  00:EE60                      ;
     439:  00:EE60                      ;       entity-body := Content-Encoding( Content-Type( data ) )
     440:  00:EE60                      ;
     441:  00:EE60                      ;   A Content-Type specifies the media type of the underlying data. A
     442:  00:EE60                      ;   Content-Encoding may be used to indicate any additional content
     443:  00:EE60                      ;   coding applied to the type, usually for the purpose of data
     444:  00:EE60                      ;   compression, that is a property of the resource requested. The
     445:  00:EE60                      ;   default for the content encoding is none (i.e., the identity
     446:  00:EE60                      ;   function).
     447:  00:EE60                      ;
     448:  00:EE60                      ;   Any HTTP/1.0 message containing an entity body should include a
     449:  00:EE60                      ;   Content-Type header field defining the media type of that body. If
     450:  00:EE60                      ;   and only if the media type is not given by a Content-Type header, as
     451:  00:EE60                      ;   is the case for Simple-Response messages, the recipient may attempt
     452:  00:EE60                      ;   to guess the media type via inspection of its content and/or the name
     453:  00:EE60                      ;   extension(s) of the URL used to identify the resource. If the media
     454:  00:EE60                      ;   type remains unknown, the recipient should treat it as type
     455:  00:EE60                      ;   "application/octet-stream".
     456:  00:EE60                      ;
     457:  00:EE60                      ; 7.2.2 Length
     458:  00:EE60                      ;
     459:  00:EE60                      ;   When an Entity-Body is included with a message, the length of that
     460:  00:EE60                      ;   body may be determined in one of two ways. If a Content-Length header
     461:  00:EE60                      ;   field is present, its value in bytes represents the length of the
     462:  00:EE60                      ;   Entity-Body. Otherwise, the body length is determined by the closing
     463:  00:EE60                      ;   of the connection by the server.
     464:  00:EE60                      ;
     465:  00:EE60                      ;   Closing the connection cannot be used to indicate the end of a
     466:  00:EE60                      ;   request body, since it leaves no possibility for the server to send
     467:  00:EE60                      ;   back a response. Therefore, HTTP/1.0 requests containing an entity
     468:  00:EE60                      ;   body must include a valid Content-Length header field. If a request
     469:  00:EE60                      ;   contains an entity body and Content-Length is not specified, and the
     470:  00:EE60                      ;   server does not recognize or cannot calculate the length from other
     471:  00:EE60                      ;   fields, then the server should send a 400 (bad request) response.
     472:  00:EE60                      ;
     473:  00:EE60                      ;      Note: Some older servers supply an invalid Content-Length when
     474:  00:EE60                      ;      sending a document that contains server-side includes dynamically
     475:  00:EE60                      ;      inserted into the data stream. It must be emphasized that this
     476:  00:EE60                      ;      will not be tolerated by future versions of HTTP. Unless the
     477:  00:EE60                      ;      client knows that it is receiving a response from a compliant
     478:  00:EE60                      ;      server, it should not depend on the Content-Length value being
     479:  00:EE60                      ;      correct.
     480:  00:EE60                      ;
     481:  00:EE60                      ; 8.  Method Definitions
     482:  00:EE60                      ;
     483:  00:EE60                      ;   The set of common methods for HTTP/1.0 is defined below. Although
     484:  00:EE60                      ;   this set can be expanded, additional methods cannot be assumed to
     485:  00:EE60                      ;   share the same semantics for separately extended clients and servers.
     486:  00:EE60                      ;
     487:  00:EE60                      ; 8.1  GET
     488:  00:EE60                      ;
     489:  00:EE60                      ;   The GET method means retrieve whatever information (in the form of an
     490:  00:EE60                      ;   entity) is identified by the Request-URI. If the Request-URI refers
     491:  00:EE60                      ;   to a data-producing process, it is the produced data which shall be
     492:  00:EE60                      ;   returned as the entity in the response and not the source text of the
     493:  00:EE60                      ;   process, unless that text happens to be the output of the process.
     494:  00:EE60                      ;
     495:  00:EE60                      ;   The semantics of the GET method changes to a "conditional GET" if the
     496:  00:EE60                      ;   request message includes an If-Modified-Since header field. A
     497:  00:EE60                      ;   conditional GET method requests that the identified resource be
     498:  00:EE60                      ;   transferred only if it has been modified since the date given by the
     499:  00:EE60                      ;   If-Modified-Since header, as described in Section 10.9. The
     500:  00:EE60                      ;   conditional GET method is intended to reduce network usage by
     501:  00:EE60                      ;   allowing cached entities to be refreshed without requiring multiple
     502:  00:EE60                      ;   requests or transferring unnecessary data.
     503:  00:EE60                      ;
     504:  00:EE60                      ; 8.2  HEAD
     505:  00:EE60                      ;
     506:  00:EE60                      ;   The HEAD method is identical to GET except that the server must not
     507:  00:EE60                      ;   return any Entity-Body in the response. The metainformation contained
     508:  00:EE60                      ;   in the HTTP headers in response to a HEAD request should be identical
     509:  00:EE60                      ;   to the information sent in response to a GET request. This method can
     510:  00:EE60                      ;   be used for obtaining metainformation about the resource identified
     511:  00:EE60                      ;   by the Request-URI without transferring the Entity-Body itself. This
     512:  00:EE60                      ;   method is often used for testing hypertext links for validity,
     513:  00:EE60                      ;   accessibility, and recent modification.
     514:  00:EE60                      ;
     515:  00:EE60                      ;   There is no "conditional HEAD" request analogous to the conditional
     516:  00:EE60                      ;   GET. If an If-Modified-Since header field is included with a HEAD
     517:  00:EE60                      ;   request, it should be ignored.
     518:  00:EE60                      ;
     519:  00:EE60                      ; 8.3  POST
     520:  00:EE60                      ;
     521:  00:EE60                      ;   The POST method is used to request that the destination server accept
     522:  00:EE60                      ;   the entity enclosed in the request as a new subordinate of the
     523:  00:EE60                      ;   resource identified by the Request-URI in the Request-Line. POST is
     524:  00:EE60                      ;   designed to allow a uniform method to cover the following functions:
     525:  00:EE60                      ;
     526:  00:EE60                      ;      o Annotation of existing resources;
     527:  00:EE60                      ;
     528:  00:EE60                      ;      o Posting a message to a bulletin board, newsgroup, mailing list,
     529:  00:EE60                      ;        or similar group of articles;
     530:  00:EE60                      ;
     531:  00:EE60                      ;      o Providing a block of data, such as the result of submitting a
     532:  00:EE60                      ;        form [3], to a data-handling process;
     533:  00:EE60                      ;
     534:  00:EE60                      ;      o Extending a database through an append operation.
     535:  00:EE60                      ;
     536:  00:EE60                      ;   The actual function performed by the POST method is determined by the
     537:  00:EE60                      ;   server and is usually dependent on the Request-URI. The posted entity
     538:  00:EE60                      ;   is subordinate to that URI in the same way that a file is subordinate
     539:  00:EE60                      ;   to a directory containing it, a news article is subordinate to a
     540:  00:EE60                      ;   newsgroup to which it is posted, or a record is subordinate to a
     541:  00:EE60                      ;   database.
     542:  00:EE60                      ;
     543:  00:EE60                      ;   A successful POST does not require that the entity be created as a
     544:  00:EE60                      ;   resource on the origin server or made accessible for future
     545:  00:EE60                      ;   reference. That is, the action performed by the POST method might not
     546:  00:EE60                      ;   result in a resource that can be identified by a URI. In this case,
     547:  00:EE60                      ;   either 200 (ok) or 204 (no content) is the appropriate response
     548:  00:EE60                      ;   status, depending on whether or not the response includes an entity
     549:  00:EE60                      ;   that describes the result.
     550:  00:EE60                      ;
     551:  00:EE60                      ;   If a resource has been created on the origin server, the response
     552:  00:EE60                      ;   should be 201 (created) and contain an entity (preferably of type
     553:  00:EE60                      ;   "text/html") which describes the status of the request and refers to
     554:  00:EE60                      ;   the new resource.
     555:  00:EE60                      ;
     556:  00:EE60                      ;   A valid Content-Length is required on all HTTP/1.0 POST requests. An
     557:  00:EE60                      ;   HTTP/1.0 server should respond with a 400 (bad request) message if it
     558:  00:EE60                      ;   cannot determine the length of the request message's content.
     559:  00:EE60                      ;
     560:  00:EE60                      ;   Applications must not cache responses to a POST request because the
     561:  00:EE60                      ;   application has no way of knowing that the server would return an
     562:  00:EE60                      ;   equivalent response on some future request.
     563:  00:EE60                      ;
     564:  00:EE60                      ; 9.  Status Code Definitions
     565:  00:EE60                      ;
     566:  00:EE60                      ;   Each Status-Code is described below, including a description of which
     567:  00:EE60                      ;   method(s) it can follow and any metainformation required in the
     568:  00:EE60                      ;   response.
     569:  00:EE60                      ;
     570:  00:EE60                      ; 9.1  Informational 1xx
     571:  00:EE60                      ;
     572:  00:EE60                      ;   This class of status code indicates a provisional response,
     573:  00:EE60                      ;   consisting only of the Status-Line and optional headers, and is
     574:  00:EE60                      ;   terminated by an empty line. HTTP/1.0 does not define any 1xx status
     575:  00:EE60                      ;   codes and they are not a valid response to a HTTP/1.0 request.
     576:  00:EE60                      ;   However, they may be useful for experimental applications which are
     577:  00:EE60                      ;   outside the scope of this specification.
     578:  00:EE60                      ;
     579:  00:EE60                      ; 9.2  Successful 2xx
     580:  00:EE60                      ;
     581:  00:EE60                      ;   This class of status code indicates that the client's request was
     582:  00:EE60                      ;   successfully received, understood, and accepted.
     583:  00:EE60                      ;
     584:  00:EE60                      ;   200 OK
     585:  00:EE60                      ;
     586:  00:EE60                      ;   The request has succeeded. The information returned with the
     587:  00:EE60                      ;   response is dependent on the method used in the request, as follows:
     588:  00:EE60                      ;
     589:  00:EE60                      ;   GET    an entity corresponding to the requested resource is sent
     590:  00:EE60                      ;          in the response;
     591:  00:EE60                      ;
     592:  00:EE60                      ;   HEAD   the response must only contain the header information and
     593:  00:EE60                      ;          no Entity-Body;
     594:  00:EE60                      ;
     595:  00:EE60                      ;   POST   an entity describing or containing the result of the action.
     596:  00:EE60                      ;
     597:  00:EE60                      ;   201 Created
     598:  00:EE60                      ;
     599:  00:EE60                      ;   The request has been fulfilled and resulted in a new resource being
     600:  00:EE60                      ;   created. The newly created resource can be referenced by the URI(s)
     601:  00:EE60                      ;   returned in the entity of the response. The origin server should
     602:  00:EE60                      ;   create the resource before using this Status-Code. If the action
     603:  00:EE60                      ;   cannot be carried out immediately, the server must include in the
     604:  00:EE60                      ;   response body a description of when the resource will be available;
     605:  00:EE60                      ;   otherwise, the server should respond with 202 (accepted).
     606:  00:EE60                      ;
     607:  00:EE60                      ;   Of the methods defined by this specification, only POST can create a
     608:  00:EE60                      ;   resource.
     609:  00:EE60                      ;
     610:  00:EE60                      ;   202 Accepted
     611:  00:EE60                      ;
     612:  00:EE60                      ;   The request has been accepted for processing, but the processing
     613:  00:EE60                      ;   has not been completed. The request may or may not eventually be
     614:  00:EE60                      ;   acted upon, as it may be disallowed when processing actually takes
     615:  00:EE60                      ;   place. There is no facility for re-sending a status code from an
     616:  00:EE60                      ;   asynchronous operation such as this.
     617:  00:EE60                      ;
     618:  00:EE60                      ;   The 202 response is intentionally non-committal. Its purpose is to
     619:  00:EE60                      ;   allow a server to accept a request for some other process (perhaps
     620:  00:EE60                      ;   a batch-oriented process that is only run once per day) without
     621:  00:EE60                      ;   requiring that the user agent's connection to the server persist
     622:  00:EE60                      ;   until the process is completed. The entity returned with this
     623:  00:EE60                      ;   response should include an indication of the request's current
     624:  00:EE60                      ;   status and either a pointer to a status monitor or some estimate of
     625:  00:EE60                      ;   when the user can expect the request to be fulfilled.
     626:  00:EE60                      ;
     627:  00:EE60                      ;   204 No Content
     628:  00:EE60                      ;
     629:  00:EE60                      ;   The server has fulfilled the request but there is no new
     630:  00:EE60                      ;   information to send back. If the client is a user agent, it should
     631:  00:EE60                      ;   not change its document view from that which caused the request to
     632:  00:EE60                      ;   be generated. This response is primarily intended to allow input
     633:  00:EE60                      ;   for scripts or other actions to take place without causing a change
     634:  00:EE60                      ;   to the user agent's active document view. The response may include
     635:  00:EE60                      ;   new metainformation in the form of entity headers, which should
     636:  00:EE60                      ;   apply to the document currently in the user agent's active view.
     637:  00:EE60                      ;
     638:  00:EE60                      ; 9.3  Redirection 3xx
     639:  00:EE60                      ;
     640:  00:EE60                      ;   This class of status code indicates that further action needs to be
     641:  00:EE60                      ;   taken by the user agent in order to fulfill the request. The action
     642:  00:EE60                      ;   required may be carried out by the user agent without interaction
     643:  00:EE60                      ;   with the user if and only if the method used in the subsequent
     644:  00:EE60                      ;   request is GET or HEAD. A user agent should never automatically
     645:  00:EE60                      ;   redirect a request more than 5 times, since such redirections usually
     646:  00:EE60                      ;   indicate an infinite loop.
     647:  00:EE60                      ;
     648:  00:EE60                      ;   300 Multiple Choices
     649:  00:EE60                      ;
     650:  00:EE60                      ;   This response code is not directly used by HTTP/1.0 applications,
     651:  00:EE60                      ;   but serves as the default for interpreting the 3xx class of
     652:  00:EE60                      ;   responses.
     653:  00:EE60                      ;
     654:  00:EE60                      ;   The requested resource is available at one or more locations.
     655:  00:EE60                      ;   Unless it was a HEAD request, the response should include an entity
     656:  00:EE60                      ;   containing a list of resource characteristics and locations from
     657:  00:EE60                      ;   which the user or user agent can choose the one most appropriate.
     658:  00:EE60                      ;   If the server has a preferred choice, it should include the URL in
     659:  00:EE60                      ;   a Location field; user agents may use this field value for
     660:  00:EE60                      ;   automatic redirection.
     661:  00:EE60                      ;
     662:  00:EE60                      ;   301 Moved Permanently
     663:  00:EE60                      ;
     664:  00:EE60                      ;   The requested resource has been assigned a new permanent URL and
     665:  00:EE60                      ;   any future references to this resource should be done using that
     666:  00:EE60                      ;   URL. Clients with link editing capabilities should automatically
     667:  00:EE60                      ;   relink references to the Request-URI to the new reference returned
     668:  00:EE60                      ;   by the server, where possible.
     669:  00:EE60                      ;
     670:  00:EE60                      ;   The new URL must be given by the Location field in the response.
     671:  00:EE60                      ;   Unless it was a HEAD request, the Entity-Body of the response
     672:  00:EE60                      ;   should contain a short note with a hyperlink to the new URL.
     673:  00:EE60                      ;
     674:  00:EE60                      ;   If the 301 status code is received in response to a request using
     675:  00:EE60                      ;   the POST method, the user agent must not automatically redirect the
     676:  00:EE60                      ;   request unless it can be confirmed by the user, since this might
     677:  00:EE60                      ;   change the conditions under which the request was issued.
     678:  00:EE60                      ;
     679:  00:EE60                      ;       Note: When automatically redirecting a POST request after
     680:  00:EE60                      ;       receiving a 301 status code, some existing user agents will
     681:  00:EE60                      ;       erroneously change it into a GET request.
     682:  00:EE60                      ;
     683:  00:EE60                      ;   302 Moved Temporarily
     684:  00:EE60                      ;
     685:  00:EE60                      ;   The requested resource resides temporarily under a different URL.
     686:  00:EE60                      ;   Since the redirection may be altered on occasion, the client should
     687:  00:EE60                      ;   continue to use the Request-URI for future requests.
     688:  00:EE60                      ;
     689:  00:EE60                      ;   The URL must be given by the Location field in the response. Unless
     690:  00:EE60                      ;   it was a HEAD request, the Entity-Body of the response should
     691:  00:EE60                      ;   contain a short note with a hyperlink to the new URI(s).
     692:  00:EE60                      ;
     693:  00:EE60                      ;   If the 302 status code is received in response to a request using
     694:  00:EE60                      ;   the POST method, the user agent must not automatically redirect the
     695:  00:EE60                      ;   request unless it can be confirmed by the user, since this might
     696:  00:EE60                      ;   change the conditions under which the request was issued.
     697:  00:EE60                      ;
     698:  00:EE60                      ;       Note: When automatically redirecting a POST request after
     699:  00:EE60                      ;       receiving a 302 status code, some existing user agents will
     700:  00:EE60                      ;       erroneously change it into a GET request.
     701:  00:EE60                      ;
     702:  00:EE60                      ;   304 Not Modified
     703:  00:EE60                      ;
     704:  00:EE60                      ;   If the client has performed a conditional GET request and access is
     705:  00:EE60                      ;   allowed, but the document has not been modified since the date and
     706:  00:EE60                      ;   time specified in the If-Modified-Since field, the server must
     707:  00:EE60                      ;   respond with this status code and not send an Entity-Body to the
     708:  00:EE60                      ;   client. Header fields contained in the response should only include
     709:  00:EE60                      ;   information which is relevant to cache managers or which may have
     710:  00:EE60                      ;   changed independently of the entity's Last-Modified date. Examples
     711:  00:EE60                      ;   of relevant header fields include: Date, Server, and Expires. A
     712:  00:EE60                      ;   cache should update its cached entity to reflect any new field
     713:  00:EE60                      ;   values given in the 304 response.
     714:  00:EE60                      ;
     715:  00:EE60                      ;9.4  Client Error 4xx
     716:  00:EE60                      ;
     717:  00:EE60                      ;   The 4xx class of status code is intended for cases in which the
     718:  00:EE60                      ;   client seems to have erred. If the client has not completed the
     719:  00:EE60                      ;   request when a 4xx code is received, it should immediately cease
     720:  00:EE60                      ;   sending data to the server. Except when responding to a HEAD request,
     721:  00:EE60                      ;   the server should include an entity containing an explanation of the
     722:  00:EE60                      ;   error situation, and whether it is a temporary or permanent
     723:  00:EE60                      ;   condition. These status codes are applicable to any request method.
     724:  00:EE60                      ;
     725:  00:EE60                      ;      Note: If the client is sending data, server implementations on TCP
     726:  00:EE60                      ;      should be careful to ensure that the client acknowledges receipt
     727:  00:EE60                      ;      of the packet(s) containing the response prior to closing the
     728:  00:EE60                      ;      input connection. If the client continues sending data to the
     729:  00:EE60                      ;      server after the close, the server's controller will send a reset
     730:  00:EE60                      ;      packet to the client, which may erase the client's unacknowledged
     731:  00:EE60                      ;      input buffers before they can be read and interpreted by the HTTP
     732:  00:EE60                      ;      application.
     733:  00:EE60                      ;
     734:  00:EE60                      ;   400 Bad Request
     735:  00:EE60                      ;
     736:  00:EE60                      ;   The request could not be understood by the server due to malformed
     737:  00:EE60                      ;   syntax. The client should not repeat the request without
     738:  00:EE60                      ;   modifications.
     739:  00:EE60                      ;
     740:  00:EE60                      ;   401 Unauthorized
     741:  00:EE60                      ;
     742:  00:EE60                      ;   The request requires user authentication. The response must include
     743:  00:EE60                      ;   a WWW-Authenticate header field (Section 10.16) containing a
     744:  00:EE60                      ;   challenge applicable to the requested resource. The client may
     745:  00:EE60                      ;   repeat the request with a suitable Authorization header field
     746:  00:EE60                      ;   (Section 10.2). If the request already included Authorization
     747:  00:EE60                      ;   credentials, then the 401 response indicates that authorization has
     748:  00:EE60                      ;   been refused for those credentials. If the 401 response contains
     749:  00:EE60                      ;   the same challenge as the prior response, and the user agent has
     750:  00:EE60                      ;   already attempted authentication at least once, then the user
     751:  00:EE60                      ;   should be presented the entity that was given in the response,
     752:  00:EE60                      ;   since that entity may include relevant diagnostic information. HTTP
     753:  00:EE60                      ;   access authentication is explained in Section 11.
     754:  00:EE60                      ;
     755:  00:EE60                      ;   403 Forbidden
     756:  00:EE60                      ;
     757:  00:EE60                      ;   The server understood the request, but is refusing to fulfill it.
     758:  00:EE60                      ;   Authorization will not help and the request should not be repeated.
     759:  00:EE60                      ;   If the request method was not HEAD and the server wishes to make
     760:  00:EE60                      ;   public why the request has not been fulfilled, it should describe
     761:  00:EE60                      ;   the reason for the refusal in the entity body. This status code is
     762:  00:EE60                      ;   commonly used when the server does not wish to reveal exactly why
     763:  00:EE60                      ;   the request has been refused, or when no other response is
     764:  00:EE60                      ;   applicable.
     765:  00:EE60                      ;
     766:  00:EE60                      ;   404 Not Found
     767:  00:EE60                      ;
     768:  00:EE60                      ;   The server has not found anything matching the Request-URI. No
     769:  00:EE60                      ;   indication is given of whether the condition is temporary or
     770:  00:EE60                      ;   permanent. If the server does not wish to make this information
     771:  00:EE60                      ;   available to the client, the status code 403 (forbidden) can be
     772:  00:EE60                      ;   used instead.
     773:  00:EE60                      ;
     774:  00:EE60                      ; 9.5  Server Error 5xx
     775:  00:EE60                      ;
     776:  00:EE60                      ;   Response status codes beginning with the digit "5" indicate cases in
     777:  00:EE60                      ;   which the server is aware that it has erred or is incapable of
     778:  00:EE60                      ;   performing the request. If the client has not completed the request
     779:  00:EE60                      ;   when a 5xx code is received, it should immediately cease sending data
     780:  00:EE60                      ;   to the server. Except when responding to a HEAD request, the server
     781:  00:EE60                      ;   should include an entity containing an explanation of the error
     782:  00:EE60                      ;   situation, and whether it is a temporary or permanent condition.
     783:  00:EE60                      ;   These response codes are applicable to any request method and there
     784:  00:EE60                      ;   are no required header fields.
     785:  00:EE60                      ;
     786:  00:EE60                      ;   500 Internal Server Error
     787:  00:EE60                      ;
     788:  00:EE60                      ;   The server encountered an unexpected condition which prevented it
     789:  00:EE60                      ;   from fulfilling the request.
     790:  00:EE60                      ;
     791:  00:EE60                      ;   501 Not Implemented
     792:  00:EE60                      ;
     793:  00:EE60                      ;   The server does not support the functionality required to fulfill
     794:  00:EE60                      ;   the request. This is the appropriate response when the server does
     795:  00:EE60                      ;   not recognize the request method and is not capable of supporting
     796:  00:EE60                      ;   it for any resource.
     797:  00:EE60                      ;
     798:  00:EE60                      ;   502 Bad Gateway
     799:  00:EE60                      ;
     800:  00:EE60                      ;   The server, while acting as a gateway or proxy, received an invalid
     801:  00:EE60                      ;   response from the upstream server it accessed in attempting to
     802:  00:EE60                      ;   fulfill the request.
     803:  00:EE60                      ;
     804:  00:EE60                      ;   503 Service Unavailable
     805:  00:EE60                      ;
     806:  00:EE60                      ;   The server is currently unable to handle the request due to a
     807:  00:EE60                      ;   temporary overloading or maintenance of the server. The implication
     808:  00:EE60                      ;   is that this is a temporary condition which will be alleviated
     809:  00:EE60                      ;   after some delay.
     810:  00:EE60                      ;
     811:  00:EE60                      ;       Note: The existence of the 503 status code does not imply
     812:  00:EE60                      ;       that a server must use it when becoming overloaded. Some
     813:  00:EE60                      ;       servers may wish to simply refuse the connection.
     814:  00:EE60                      ;
     815:  00:EE60                      ; 10.  Header Field Definitions
     816:  00:EE60                      ;
     817:  00:EE60                      ;   This section defines the syntax and semantics of all commonly used
     818:  00:EE60                      ;   HTTP/1.0 header fields. For general and entity header fields, both
     819:  00:EE60                      ;   sender and recipient refer to either the client or the server,
     820:  00:EE60                      ;   depending on who sends and who receives the message.
     821:  00:EE60                      ;
     822:  00:EE60                      ; 10.1  Allow
     823:  00:EE60                      ;
     824:  00:EE60                      ;   The Allow entity-header field lists the set of methods supported by
     825:  00:EE60                      ;   the resource identified by the Request-URI. The purpose of this field
     826:  00:EE60                      ;   is strictly to inform the recipient of valid methods associated with
     827:  00:EE60                      ;   the resource. The Allow header field is not permitted in a request
     828:  00:EE60                      ;   using the POST method, and thus should be ignored if it is received
     829:  00:EE60                      ;   as part of a POST entity.
     830:  00:EE60                      ;
     831:  00:EE60                      ;       Allow          = "Allow" ":" 1#method
     832:  00:EE60                      ;
     833:  00:EE60                      ;    Example of use:
     834:  00:EE60                      ;
     835:  00:EE60                      ;       Allow: GET, HEAD
     836:  00:EE60                      ;
     837:  00:EE60                      ;   This field cannot prevent a client from trying other methods.
     838:  00:EE60                      ;   However, the indications given by the Allow header field value should
     839:  00:EE60                      ;   be followed. The actual set of allowed methods is defined by the
     840:  00:EE60                      ;   origin server at the time of each request.
     841:  00:EE60                      ;
     842:  00:EE60                      ;   A proxy must not modify the Allow header field even if it does not
     843:  00:EE60                      ;   understand all the methods specified, since the user agent may have
     844:  00:EE60                      ;   other means of communicating with the origin server.
     845:  00:EE60                      ;
     846:  00:EE60                      ;   The Allow header field does not indicate what methods are implemented
     847:  00:EE60                      ;   by the server.
     848:  00:EE60                      ;
     849:  00:EE60                      ; 10.2  Authorization
     850:  00:EE60                      ;
     851:  00:EE60                      ;   A user agent that wishes to authenticate itself with a server--
     852:  00:EE60                      ;   usually, but not necessarily, after receiving a 401 response--may do
     853:  00:EE60                      ;   so by including an Authorization request-header field with the
     854:  00:EE60                      ;   request. The Authorization field value consists of credentials
     855:  00:EE60                      ;   containing the authentication information of the user agent for the
     856:  00:EE60                      ;   realm of the resource being requested.
     857:  00:EE60                      ;
     858:  00:EE60                      ;       Authorization  = "Authorization" ":" credentials
     859:  00:EE60                      ;
     860:  00:EE60                      ;   HTTP access authentication is described in Section 11. If a request
     861:  00:EE60                      ;   is authenticated and a realm specified, the same credentials should
     862:  00:EE60                      ;   be valid for all other requests within this realm.
     863:  00:EE60                      ;
     864:  00:EE60                      ;   Responses to requests containing an Authorization field are not
     865:  00:EE60                      ;   cachable.
     866:  00:EE60                      ;
     867:  00:EE60                      ; 10.3  Content-Encoding
     868:  00:EE60                      ;
     869:  00:EE60                      ;   The Content-Encoding entity-header field is used as a modifier to the
     870:  00:EE60                      ;   media-type. When present, its value indicates what additional content
     871:  00:EE60                      ;   coding has been applied to the resource, and thus what decoding
     872:  00:EE60                      ;   mechanism must be applied in order to obtain the media-type
     873:  00:EE60                      ;   referenced by the Content-Type header field. The Content-Encoding is
     874:  00:EE60                      ;   primarily used to allow a document to be compressed without losing
     875:  00:EE60                      ;   the identity of its underlying media type.
     876:  00:EE60                      ;
     877:  00:EE60                      ;       Content-Encoding = "Content-Encoding" ":" content-coding
     878:  00:EE60                      ;
     879:  00:EE60                      ;   Content codings are defined in Section 3.5. An example of its use is
     880:  00:EE60                      ;
     881:  00:EE60                      ;       Content-Encoding: x-gzip
     882:  00:EE60                      ;
     883:  00:EE60                      ;   The Content-Encoding is a characteristic of the resource identified
     884:  00:EE60                      ;   by the Request-URI. Typically, the resource is stored with this
     885:  00:EE60                      ;   encoding and is only decoded before rendering or analogous usage.
     886:  00:EE60                      ;
     887:  00:EE60                      ; 10.4  Content-Length
     888:  00:EE60                      ;
     889:  00:EE60                      ;   The Content-Length entity-header field indicates the size of the
     890:  00:EE60                      ;   Entity-Body, in decimal number of octets, sent to the recipient or,
     891:  00:EE60                      ;   in the case of the HEAD method, the size of the Entity-Body that
     892:  00:EE60                      ;   would have been sent had the request been a GET.
     893:  00:EE60                      ;
     894:  00:EE60                      ;       Content-Length = "Content-Length" ":" 1*DIGIT
     895:  00:EE60                      ;
     896:  00:EE60                      ;   An example is
     897:  00:EE60                      ;
     898:  00:EE60                      ;       Content-Length: 3495
     899:  00:EE60                      ;
     900:  00:EE60                      ;   Applications should use this field to indicate the size of the
     901:  00:EE60                      ;   Entity-Body to be transferred, regardless of the media type of the
     902:  00:EE60                      ;   entity. A valid Content-Length field value is required on all
     903:  00:EE60                      ;   HTTP/1.0 request messages containing an entity body.
     904:  00:EE60                      ;
     905:  00:EE60                      ;   Any Content-Length greater than or equal to zero is a valid value.
     906:  00:EE60                      ;   Section 7.2.2 describes how to determine the length of a response
     907:  00:EE60                      ;   entity body if a Content-Length is not given.
     908:  00:EE60                      ;
     909:  00:EE60                      ;      Note: The meaning of this field is significantly different from
     910:  00:EE60                      ;      the corresponding definition in MIME, where it is an optional
     911:  00:EE60                      ;      field used within the "message/external-body" content-type. In
     912:  00:EE60                      ;      HTTP, it should be used whenever the entity's length can be
     913:  00:EE60                      ;      determined prior to being transferred.
     914:  00:EE60                      ;
     915:  00:EE60                      ; 10.5  Content-Type
     916:  00:EE60                      ;
     917:  00:EE60                      ;   The Content-Type entity-header field indicates the media type of the
     918:  00:EE60                      ;   Entity-Body sent to the recipient or, in the case of the HEAD method,
     919:  00:EE60                      ;   the media type that would have been sent had the request been a GET.
     920:  00:EE60                      ;
     921:  00:EE60                      ;       Content-Type   = "Content-Type" ":" media-type
     922:  00:EE60                      ;
     923:  00:EE60                      ;   Media types are defined in Section 3.6. An example of the field is
     924:  00:EE60                      ;
     925:  00:EE60                      ;       Content-Type: text/html
     926:  00:EE60                      ;
     927:  00:EE60                      ;   Further discussion of methods for identifying the media type of an
     928:  00:EE60                      ;   entity is provided in Section 7.2.1.
     929:  00:EE60                      ;
     930:  00:EE60                      ; 10.6  Date
     931:  00:EE60                      ;
     932:  00:EE60                      ;   The Date general-header field represents the date and time at which
     933:  00:EE60                      ;   the message was originated, having the same semantics as orig-date in
     934:  00:EE60                      ;   RFC 822. The field value is an HTTP-date, as described in Section
     935:  00:EE60                      ;   3.3.
     936:  00:EE60                      ;
     937:  00:EE60                      ;       Date           = "Date" ":" HTTP-date
     938:  00:EE60                      ;
     939:  00:EE60                      ;   An example is
     940:  00:EE60                      ;
     941:  00:EE60                      ;       Date: Tue, 15 Nov 1994 08:12:31 GMT
     942:  00:EE60                      ;
     943:  00:EE60                      ;   If a message is received via direct connection with the user agent
     944:  00:EE60                      ;   (in the case of requests) or the origin server (in the case of
     945:  00:EE60                      ;   responses), then the date can be assumed to be the current date at
     946:  00:EE60                      ;   the receiving end. However, since the date--as it is believed by the
     947:  00:EE60                      ;   origin--is important for evaluating cached responses, origin servers
     948:  00:EE60                      ;   should always include a Date header. Clients should only send a Date
     949:  00:EE60                      ;   header field in messages that include an entity body, as in the case
     950:  00:EE60                      ;   of the POST request, and even then it is optional. A received message
     951:  00:EE60                      ;   which does not have a Date header field should be assigned one by the
     952:  00:EE60                      ;   recipient if the message will be cached by that recipient or
     953:  00:EE60                      ;   gatewayed via a protocol which requires a Date.
     954:  00:EE60                      ;
     955:  00:EE60                      ;   In theory, the date should represent the moment just before the
     956:  00:EE60                      ;   entity is generated. In practice, the date can be generated at any
     957:  00:EE60                      ;   time during the message origination without affecting its semantic
     958:  00:EE60                      ;   value.
     959:  00:EE60                      ;
     960:  00:EE60                      ;      Note: An earlier version of this document incorrectly specified
     961:  00:EE60                      ;      that this field should contain the creation date of the enclosed
     962:  00:EE60                      ;      Entity-Body. This has been changed to reflect actual (and proper)
     963:  00:EE60                      ;      usage.
     964:  00:EE60                      ;
     965:  00:EE60                      ; 10.7  Expires
     966:  00:EE60                      ;
     967:  00:EE60                      ;   The Expires entity-header field gives the date/time after which the
     968:  00:EE60                      ;   entity should be considered stale. This allows information providers
     969:  00:EE60                      ;   to suggest the volatility of the resource, or a date after which the
     970:  00:EE60                      ;   information may no longer be valid. Applications must not cache this
     971:  00:EE60                      ;   entity beyond the date given. The presence of an Expires field does
     972:  00:EE60                      ;   not imply that the original resource will change or cease to exist
     973:  00:EE60                      ;   at, before, or after that time. However, information providers that
     974:  00:EE60                      ;   know or even suspect that a resource will change by a certain date
     975:  00:EE60                      ;   should include an Expires header with that date. The format is an
     976:  00:EE60                      ;   absolute date and time as defined by HTTP-date in Section 3.3.
     977:  00:EE60                      ;
     978:  00:EE60                      ;       Expires        = "Expires" ":" HTTP-date
     979:  00:EE60                      ;
     980:  00:EE60                      ;   An example of its use is
     981:  00:EE60                      ;
     982:  00:EE60                      ;       Expires: Thu, 01 Dec 1994 16:00:00 GMT
     983:  00:EE60                      ;
     984:  00:EE60                      ;   If the date given is equal to or earlier than the value of the Date
     985:  00:EE60                      ;   header, the recipient must not cache the enclosed entity. If a
     986:  00:EE60                      ;   resource is dynamic by nature, as is the case with many data-
     987:  00:EE60                      ;   producing processes, entities from that resource should be given an
     988:  00:EE60                      ;   appropriate Expires value which reflects that dynamism.
     989:  00:EE60                      ;
     990:  00:EE60                      ;   The Expires field cannot be used to force a user agent to refresh its
     991:  00:EE60                      ;   display or reload a resource; its semantics apply only to caching
     992:  00:EE60                      ;   mechanisms, and such mechanisms need only check a resource's
     993:  00:EE60                      ;   expiration status when a new request for that resource is initiated.
     994:  00:EE60                      ;
     995:  00:EE60                      ;   User agents often have history mechanisms, such as "Back" buttons and
     996:  00:EE60                      ;   history lists, which can be used to redisplay an entity retrieved
     997:  00:EE60                      ;   earlier in a session. By default, the Expires field does not apply to
     998:  00:EE60                      ;   history mechanisms. If the entity is still in storage, a history
     999:  00:EE60                      ;   mechanism should display it even if the entity has expired, unless
    1000:  00:EE60                      ;   the user has specifically configured the agent to refresh expired
    1001:  00:EE60                      ;   history documents.
    1002:  00:EE60                      ;
    1003:  00:EE60                      ;      Note: Applications are encouraged to be tolerant of bad or
    1004:  00:EE60                      ;      misinformed implementations of the Expires header. A value of zero
    1005:  00:EE60                      ;      (0) or an invalid date format should be considered equivalent to
    1006:  00:EE60                      ;      an "expires immediately." Although these values are not legitimate
    1007:  00:EE60                      ;      for HTTP/1.0, a robust implementation is always desirable.
    1008:  00:EE60                      ;
    1009:  00:EE60                      ; 10.8  From
    1010:  00:EE60                      ;
    1011:  00:EE60                      ;   The From request-header field, if given, should contain an Internet
    1012:  00:EE60                      ;   e-mail address for the human user who controls the requesting user
    1013:  00:EE60                      ;   agent. The address should be machine-usable, as defined by mailbox in
    1014:  00:EE60                      ;   RFC 822 [7] (as updated by RFC 1123 [6]):
    1015:  00:EE60                      ;
    1016:  00:EE60                      ;       From           = "From" ":" mailbox
    1017:  00:EE60                      ;
    1018:  00:EE60                      ;   An example is:
    1019:  00:EE60                      ;
    1020:  00:EE60                      ;       From: webmaster@w3.org
    1021:  00:EE60                      ;
    1022:  00:EE60                      ;   This header field may be used for logging purposes and as a means for
    1023:  00:EE60                      ;   identifying the source of invalid or unwanted requests. It should not
    1024:  00:EE60                      ;   be used as an insecure form of access protection. The interpretation
    1025:  00:EE60                      ;   of this field is that the request is being performed on behalf of the
    1026:  00:EE60                      ;   person given, who accepts responsibility for the method performed. In
    1027:  00:EE60                      ;   particular, robot agents should include this header so that the
    1028:  00:EE60                      ;   person responsible for running the robot can be contacted if problems
    1029:  00:EE60                      ;   occur on the receiving end.
    1030:  00:EE60                      ;
    1031:  00:EE60                      ;   The Internet e-mail address in this field may be separate from the
    1032:  00:EE60                      ;   Internet host which issued the request. For example, when a request
    1033:  00:EE60                      ;   is passed through a proxy, the original issuer's address should be
    1034:  00:EE60                      ;   used.
    1035:  00:EE60                      ;
    1036:  00:EE60                      ;      Note: The client should not send the From header field without the
    1037:  00:EE60                      ;      user's approval, as it may conflict with the user's privacy
    1038:  00:EE60                      ;      interests or their site's security policy. It is strongly
    1039:  00:EE60                      ;      recommended that the user be able to disable, enable, and modify
    1040:  00:EE60                      ;      the value of this field at any time prior to a request.
    1041:  00:EE60                      ;
    1042:  00:EE60                      ; 10.9  If-Modified-Since
    1043:  00:EE60                      ;
    1044:  00:EE60                      ;   The If-Modified-Since request-header field is used with the GET
    1045:  00:EE60                      ;   method to make it conditional: if the requested resource has not been
    1046:  00:EE60                      ;   modified since the time specified in this field, a copy of the
    1047:  00:EE60                      ;   resource will not be returned from the server; instead, a 304 (not
    1048:  00:EE60                      ;   modified) response will be returned without any Entity-Body.
    1049:  00:EE60                      ;
    1050:  00:EE60                      ;       If-Modified-Since = "If-Modified-Since" ":" HTTP-date
    1051:  00:EE60                      ;
    1052:  00:EE60                      ;   An example of the field is:
    1053:  00:EE60                      ;
    1054:  00:EE60                      ;       If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT
    1055:  00:EE60                      ;
    1056:  00:EE60                      ;   A conditional GET method requests that the identified resource be
    1057:  00:EE60                      ;   transferred only if it has been modified since the date given by the
    1058:  00:EE60                      ;   If-Modified-Since header. The algorithm for determining this includes
    1059:  00:EE60                      ;   the following cases:
    1060:  00:EE60                      ;
    1061:  00:EE60                      ;      a) If the request would normally result in anything other than
    1062:  00:EE60                      ;         a 200 (ok) status, or if the passed If-Modified-Since date
    1063:  00:EE60                      ;         is invalid, the response is exactly the same as for a
    1064:  00:EE60                      ;         normal GET. A date which is later than the server's current
    1065:  00:EE60                      ;         time is invalid.
    1066:  00:EE60                      ;
    1067:  00:EE60                      ;      b) If the resource has been modified since the
    1068:  00:EE60                      ;         If-Modified-Since date, the response is exactly the same as
    1069:  00:EE60                      ;         for a normal GET.
    1070:  00:EE60                      ;
    1071:  00:EE60                      ;      c) If the resource has not been modified since a valid
    1072:  00:EE60                      ;         If-Modified-Since date, the server shall return a 304 (not
    1073:  00:EE60                      ;         modified) response.
    1074:  00:EE60                      ;
    1075:  00:EE60                      ;   The purpose of this feature is to allow efficient updates of cached
    1076:  00:EE60                      ;   information with a minimum amount of transaction overhead.
    1077:  00:EE60                      ;
    1078:  00:EE60                      ; 10.10  Last-Modified
    1079:  00:EE60                      ;
    1080:  00:EE60                      ;   The Last-Modified entity-header field indicates the date and time at
    1081:  00:EE60                      ;   which the sender believes the resource was last modified. The exact
    1082:  00:EE60                      ;   semantics of this field are defined in terms of how the recipient
    1083:  00:EE60                      ;   should interpret it:  if the recipient has a copy of this resource
    1084:  00:EE60                      ;   which is older than the date given by the Last-Modified field, that
    1085:  00:EE60                      ;   copy should be considered stale.
    1086:  00:EE60                      ;
    1087:  00:EE60                      ;       Last-Modified  = "Last-Modified" ":" HTTP-date
    1088:  00:EE60                      ;
    1089:  00:EE60                      ;   An example of its use is
    1090:  00:EE60                      ;
    1091:  00:EE60                      ;       Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT
    1092:  00:EE60                      ;
    1093:  00:EE60                      ;   The exact meaning of this header field depends on the implementation
    1094:  00:EE60                      ;   of the sender and the nature of the original resource. For files, it
    1095:  00:EE60                      ;   may be just the file system last-modified time. For entities with
    1096:  00:EE60                      ;   dynamically included parts, it may be the most recent of the set of
    1097:  00:EE60                      ;   last-modify times for its component parts. For database gateways, it
    1098:  00:EE60                      ;   may be the last-update timestamp of the record. For virtual objects,
    1099:  00:EE60                      ;   it may be the last time the internal state changed.
    1100:  00:EE60                      ;
    1101:  00:EE60                      ;   An origin server must not send a Last-Modified date which is later
    1102:  00:EE60                      ;   than the server's time of message origination. In such cases, where
    1103:  00:EE60                      ;   the resource's last modification would indicate some time in the
    1104:  00:EE60                      ;   future, the server must replace that date with the message
    1105:  00:EE60                      ;   origination date.
    1106:  00:EE60                      ;
    1107:  00:EE60                      ; 10.11  Location
    1108:  00:EE60                      ;
    1109:  00:EE60                      ;   The Location response-header field defines the exact location of the
    1110:  00:EE60                      ;   resource that was identified by the Request-URI. For 3xx responses,
    1111:  00:EE60                      ;   the location must indicate the server's preferred URL for automatic
    1112:  00:EE60                      ;   redirection to the resource. Only one absolute URL is allowed.
    1113:  00:EE60                      ;
    1114:  00:EE60                      ;       Location       = "Location" ":" absoluteURI
    1115:  00:EE60                      ;
    1116:  00:EE60                      ;   An example is
    1117:  00:EE60                      ;
    1118:  00:EE60                      ;       Location: http://www.w3.org/hypertext/WWW/NewLocation.html
    1119:  00:EE60                      ;
    1120:  00:EE60                      ; 10.12  Pragma
    1121:  00:EE60                      ;
    1122:  00:EE60                      ;   The Pragma general-header field is used to include implementation-
    1123:  00:EE60                      ;   specific directives that may apply to any recipient along the
    1124:  00:EE60                      ;   request/response chain. All pragma directives specify optional
    1125:  00:EE60                      ;   behavior from the viewpoint of the protocol; however, some systems
    1126:  00:EE60                      ;   may require that behavior be consistent with the directives.
    1127:  00:EE60                      ;
    1128:  00:EE60                      ;       Pragma           = "Pragma" ":" 1#pragma-directive
    1129:  00:EE60                      ;
    1130:  00:EE60                      ;       pragma-directive = "no-cache" | extension-pragma
    1131:  00:EE60                      ;       extension-pragma = token [ "=" word ]
    1132:  00:EE60                      ;
    1133:  00:EE60                      ;   When the "no-cache" directive is present in a request message, an
    1134:  00:EE60                      ;   application should forward the request toward the origin server even
    1135:  00:EE60                      ;   if it has a cached copy of what is being requested. This allows a
    1136:  00:EE60                      ;   client to insist upon receiving an authoritative response to its
    1137:  00:EE60                      ;   request. It also allows a client to refresh a cached copy which is
    1138:  00:EE60                      ;   known to be corrupted or stale.
    1139:  00:EE60                      ;
    1140:  00:EE60                      ;   Pragma directives must be passed through by a proxy or gateway
    1141:  00:EE60                      ;   application, regardless of their significance to that application,
    1142:  00:EE60                      ;   since the directives may be applicable to all recipients along the
    1143:  00:EE60                      ;   request/response chain. It is not possible to specify a pragma for a
    1144:  00:EE60                      ;   specific recipient; however, any pragma directive not relevant to a
    1145:  00:EE60                      ;   recipient should be ignored by that recipient.
    1146:  00:EE60                      ;
    1147:  00:EE60                      ; 10.13  Referer
    1148:  00:EE60                      ;
    1149:  00:EE60                      ;   The Referer request-header field allows the client to specify, for
    1150:  00:EE60                      ;   the server's benefit, the address (URI) of the resource from which
    1151:  00:EE60                      ;   the Request-URI was obtained. This allows a server to generate lists
    1152:  00:EE60                      ;   of back-links to resources for interest, logging, optimized caching,
    1153:  00:EE60                      ;   etc. It also allows obsolete or mistyped links to be traced for
    1154:  00:EE60                      ;   maintenance. The Referer field must not be sent if the Request-URI
    1155:  00:EE60                      ;   was obtained from a source that does not have its own URI, such as
    1156:  00:EE60                      ;   input from the user keyboard.
    1157:  00:EE60                      ;
    1158:  00:EE60                      ;       Referer        = "Referer" ":" ( absoluteURI | relativeURI )
    1159:  00:EE60                      ;
    1160:  00:EE60                      ;   Example:
    1161:  00:EE60                      ;
    1162:  00:EE60                      ;       Referer: http://www.w3.org/hypertext/DataSources/Overview.html
    1163:  00:EE60                      ;
    1164:  00:EE60                      ;   If a partial URI is given, it should be interpreted relative to the
    1165:  00:EE60                      ;   Request-URI. The URI must not include a fragment.
    1166:  00:EE60                      ;
    1167:  00:EE60                      ;      Note: Because the source of a link may be private information or
    1168:  00:EE60                      ;      may reveal an otherwise private information source, it is strongly
    1169:  00:EE60                      ;      recommended that the user be able to select whether or not the
    1170:  00:EE60                      ;      Referer field is sent. For example, a browser client could have a
    1171:  00:EE60                      ;      toggle switch for browsing openly/anonymously, which would
    1172:  00:EE60                      ;      respectively enable/disable the sending of Referer and From
    1173:  00:EE60                      ;      information.
    1174:  00:EE60                      ;
    1175:  00:EE60                      ; 10.14  Server
    1176:  00:EE60                      ;
    1177:  00:EE60                      ;   The Server response-header field contains information about the
    1178:  00:EE60                      ;   software used by the origin server to handle the request. The field
    1179:  00:EE60                      ;   can contain multiple product tokens (Section 3.7) and comments
    1180:  00:EE60                      ;   identifying the server and any significant subproducts. By
    1181:  00:EE60                      ;   convention, the product tokens are listed in order of their
    1182:  00:EE60                      ;   significance for identifying the application.
    1183:  00:EE60                      ;
    1184:  00:EE60                      ;       Server         = "Server" ":" 1*( product | comment )
    1185:  00:EE60                      ;
    1186:  00:EE60                      ;   Example:
    1187:  00:EE60                      ;
    1188:  00:EE60                      ;       Server: CERN/3.0 libwww/2.17
    1189:  00:EE60                      ;
    1190:  00:EE60                      ;   If the response is being forwarded through a proxy, the proxy
    1191:  00:EE60                      ;   application must not add its data to the product list.
    1192:  00:EE60                      ;
    1193:  00:EE60                      ;      Note: Revealing the specific software version of the server may
    1194:  00:EE60                      ;      allow the server machine to become more vulnerable to attacks
    1195:  00:EE60                      ;      against software that is known to contain security holes. Server
    1196:  00:EE60                      ;      implementors are encouraged to make this field a configurable
    1197:  00:EE60                      ;      option.
    1198:  00:EE60                      ;
    1199:  00:EE60                      ;      Note: Some existing servers fail to restrict themselves to the
    1200:  00:EE60                      ;      product token syntax within the Server field.
    1201:  00:EE60                      ;
    1202:  00:EE60                      ; 10.15  User-Agent
    1203:  00:EE60                      ;
    1204:  00:EE60                      ;   The User-Agent request-header field contains information about the
    1205:  00:EE60                      ;   user agent originating the request. This is for statistical purposes,
    1206:  00:EE60                      ;   the tracing of protocol violations, and automated recognition of user
    1207:  00:EE60                      ;   agents for the sake of tailoring responses to avoid particular user
    1208:  00:EE60                      ;   agent limitations. Although it is not required, user agents should
    1209:  00:EE60                      ;   include this field with requests. The field can contain multiple
    1210:  00:EE60                      ;   product tokens (Section 3.7) and comments identifying the agent and
    1211:  00:EE60                      ;   any subproducts which form a significant part of the user agent. By
    1212:  00:EE60                      ;   convention, the product tokens are listed in order of their
    1213:  00:EE60                      ;   significance for identifying the application.
    1214:  00:EE60                      ;
    1215:  00:EE60                      ;       User-Agent     = "User-Agent" ":" 1*( product | comment )
    1216:  00:EE60                      ;
    1217:  00:EE60                      ;   Example:
    1218:  00:EE60                      ;
    1219:  00:EE60                      ;       User-Agent: CERN-LineMode/2.15 libwww/2.17b3
    1220:  00:EE60                      ;
    1221:  00:EE60                      ;       Note: Some current proxy applications append their product
    1222:  00:EE60                      ;       information to the list in the User-Agent field. This is not
    1223:  00:EE60                      ;       recommended, since it makes machine interpretation of these
    1224:  00:EE60                      ;       fields ambiguous.
    1225:  00:EE60                      ;
    1226:  00:EE60                      ;       Note: Some existing clients fail to restrict themselves to
    1227:  00:EE60                      ;       the product token syntax within the User-Agent field.
    1228:  00:EE60                      ;
    1229:  00:EE60                      ; 10.16  WWW-Authenticate
    1230:  00:EE60                      ;
    1231:  00:EE60                      ;   The WWW-Authenticate response-header field must be included in 401
    1232:  00:EE60                      ;   (unauthorized) response messages. The field value consists of at
    1233:  00:EE60                      ;   least one challenge that indicates the authentication scheme(s) and
    1234:  00:EE60                      ;   parameters applicable to the Request-URI.
    1235:  00:EE60                      ;
    1236:  00:EE60                      ;       WWW-Authenticate = "WWW-Authenticate" ":" 1#challenge
    1237:  00:EE60                      ;
    1238:  00:EE60                      ;   The HTTP access authentication process is described in Section 11.
    1239:  00:EE60                      ;   User agents must take special care in parsing the WWW-Authenticate
    1240:  00:EE60                      ;   field value if it contains more than one challenge, or if more than
    1241:  00:EE60                      ;   one WWW-Authenticate header field is provided, since the contents of
    1242:  00:EE60                      ;   a challenge may itself contain a comma-separated list of
    1243:  00:EE60                      ;   authentication parameters.
    1244:  00:EE60                      				;
    1245:  00:EE60                      				;
    1246:  00:EE60                      				;
    1247:  00:EE60                      ; D.  Additional Features
    1248:  00:EE60                      ;
    1249:  00:EE60                      ;   This appendix documents protocol elements used by some existing HTTP
    1250:  00:EE60                      ;   implementations, but not consistently and correctly across most
    1251:  00:EE60                      ;   HTTP/1.0 applications. Implementors should be aware of these
    1252:  00:EE60                      ;   features, but cannot rely upon their presence in, or interoperability
    1253:  00:EE60                      ;   with, other HTTP/1.0 applications.
    1254:  00:EE60                      ;
    1255:  00:EE60                      ; D.1  Additional Request Methods
    1256:  00:EE60                      ;
    1257:  00:EE60                      ; D.1.1 PUT
    1258:  00:EE60                      ;
    1259:  00:EE60                      ;   The PUT method requests that the enclosed entity be stored under the
    1260:  00:EE60                      ;   supplied Request-URI. If the Request-URI refers to an already
    1261:  00:EE60                      ;   existing resource, the enclosed entity should be considered as a
    1262:  00:EE60                      ;   modified version of the one residing on the origin server. If the
    1263:  00:EE60                      ;   Request-URI does not point to an existing resource, and that URI is
    1264:  00:EE60                      ;   capable of being defined as a new resource by the requesting user
    1265:  00:EE60                      ;   agent, the origin server can create the resource with that URI.
    1266:  00:EE60                      ;
    1267:  00:EE60                      ;   The fundamental difference between the POST and PUT requests is
    1268:  00:EE60                      ;   reflected in the different meaning of the Request-URI. The URI in a
    1269:  00:EE60                      ;   POST request identifies the resource that will handle the enclosed
    1270:  00:EE60                      ;   entity as data to be processed. That resource may be a data-accepting
    1271:  00:EE60                      ;   process, a gateway to some other protocol, or a separate entity that
    1272:  00:EE60                      ;   accepts annotations. In contrast, the URI in a PUT request identifies
    1273:  00:EE60                      ;   the entity enclosed with the request -- the user agent knows what URI
    1274:  00:EE60                      ;   is intended and the server should not apply the request to some other
    1275:  00:EE60                      ;   resource.
    1276:  00:EE60                      ;
    1277:  00:EE60                      ; D.1.2 DELETE
    1278:  00:EE60                      ;
    1279:  00:EE60                      ;   The DELETE method requests that the origin server delete the resource
    1280:  00:EE60                      ;   identified by the Request-URI.
    1281:  00:EE60                      ;
    1282:  00:EE60                      ; D.1.3 LINK
    1283:  00:EE60                      ;
    1284:  00:EE60                      ;   The LINK method establishes one or more Link relationships between
    1285:  00:EE60                      ;   the existing resource identified by the Request-URI and other
    1286:  00:EE60                      ;   existing resources.
    1287:  00:EE60                      ;
    1288:  00:EE60                      ; D.1.4 UNLINK
    1289:  00:EE60                      ;
    1290:  00:EE60                      ;   The UNLINK method removes one or more Link relationships from the
    1291:  00:EE60                      ;   existing resource identified by the Request-URI.
    1292:  00:EE60                      ;
    1293:  00:EE60                      ; D.2  Additional Header Field Definitions
    1294:  00:EE60                      ;
    1295:  00:EE60                      ; D.2.1 Accept
    1296:  00:EE60                      ;
    1297:  00:EE60                      ;   The Accept request-header field can be used to indicate a list of
    1298:  00:EE60                      ;   media ranges which are acceptable as a response to the request. The
    1299:  00:EE60                      ;   asterisk "*" character is used to group media types into ranges, with
    1300:  00:EE60                      ;   "*/*" indicating all media types and "type/*" indicating all subtypes
    1301:  00:EE60                      ;   of that type. The set of ranges given by the client should represent
    1302:  00:EE60                      ;   what types are acceptable given the context of the request.
    1303:  00:EE60                      ;
    1304:  00:EE60                      ; D.2.2 Accept-Charset
    1305:  00:EE60                      ;
    1306:  00:EE60                      ;   The Accept-Charset request-header field can be used to indicate a
    1307:  00:EE60                      ;   list of preferred character sets other than the default US-ASCII and
    1308:  00:EE60                      ;   ISO-8859-1. This field allows clients capable of understanding more
    1309:  00:EE60                      ;   comprehensive or special-purpose character sets to signal that
    1310:  00:EE60                      ;   capability to a server which is capable of representing documents in
    1311:  00:EE60                      ;   those character sets.
    1312:  00:EE60                      ;
    1313:  00:EE60                      ; D.2.3 Accept-Encoding
    1314:  00:EE60                      ;
    1315:  00:EE60                      ;   The Accept-Encoding request-header field is similar to Accept, but
    1316:  00:EE60                      ;   restricts the content-coding values which are acceptable in the
    1317:  00:EE60                      ;   response.
    1318:  00:EE60                      ;
    1319:  00:EE60                      ; D.2.4 Accept-Language
    1320:  00:EE60                      ;
    1321:  00:EE60                      ;   The Accept-Language request-header field is similar to Accept, but
    1322:  00:EE60                      ;   restricts the set of natural languages that are preferred as a
    1323:  00:EE60                      ;   response to the request.
    1324:  00:EE60                      ;
    1325:  00:EE60                      ; D.2.5 Content-Language
    1326:  00:EE60                      ;
    1327:  00:EE60                      ;   The Content-Language entity-header field describes the natural
    1328:  00:EE60                      ;   language(s) of the intended audience for the enclosed entity. Note
    1329:  00:EE60                      ;   that this may not be equivalent to all the languages used within the
    1330:  00:EE60                      ;   entity.
    1331:  00:EE60                      ;
    1332:  00:EE60                      ; D.2.6 Link
    1333:  00:EE60                      ;
    1334:  00:EE60                      ;   The Link entity-header field provides a means for describing a
    1335:  00:EE60                      ;   relationship between the entity and some other resource. An entity
    1336:  00:EE60                      ;   may include multiple Link values. Links at the metainformation level
    1337:  00:EE60                      ;   typically indicate relationships like hierarchical structure and
    1338:  00:EE60                      ;   navigation paths.
    1339:  00:EE60                      ;
    1340:  00:EE60                      ; D.2.7 MIME-Version
    1341:  00:EE60                      ;
    1342:  00:EE60                      ;   HTTP messages may include a single MIME-Version general-header field
    1343:  00:EE60                      ;   to indicate what version of the MIME protocol was used to construct
    1344:  00:EE60                      ;   the message. Use of the MIME-Version header field, as defined by RFC
    1345:  00:EE60                      ;   1521 [5], should indicate that the message is MIME-conformant.
    1346:  00:EE60                      ;   Unfortunately, some older HTTP/1.0 servers send it indiscriminately,
    1347:  00:EE60                      ;   and thus this field should be ignored.
    1348:  00:EE60                      ;
    1349:  00:EE60                      ; D.2.8 Retry-After
    1350:  00:EE60                      ;
    1351:  00:EE60                      ;   The Retry-After response-header field can be used with a 503 (service
    1352:  00:EE60                      ;   unavailable) response to indicate how long the service is expected to
    1353:  00:EE60                      ;   be unavailable to the requesting client. The value of this field can
    1354:  00:EE60                      ;   be either an HTTP-date or an integer number of seconds (in decimal)
    1355:  00:EE60                      ;   after the time of the response.
    1356:  00:EE60                      ;
    1357:  00:EE60                      ; D.2.9 Title
    1358:  00:EE60                      ;
    1359:  00:EE60                      ;   The Title entity-header field indicates the title of the entity.
    1360:  00:EE60                      ;
    1361:  00:EE60                      ; D.2.10 URI
    1362:  00:EE60                      ;
    1363:  00:EE60                      ;   The URI entity-header field may contain some or all of the Uniform
    1364:  00:EE60                      ;   Resource Identifiers (Section 3.2) by which the Request-URI resource
    1365:  00:EE60                      ;   can be identified. There is no guarantee that the resource can be
    1366:  00:EE60                      ;   accessed using the URI(s) specified.
    1367:  00:EE60                      ;
    1368:  00:EE60                      ;==============================================================================
    1369:  00:EE60                      ;
    1370:  00:EE60  (00:0003)           HTTP_SOCKET	equ	3
    1371:  00:EE60  (00:0050)           HTTP_PORT	equ	80		; Dest port always 80 for HTTP protocol
    1372:  00:EE60                      ;
    1373:  00:EE60                      ;
    1374:  00:EE60                      ; This is the data kept in EXOS channel RAM.
    1375:  00:EE60                      ;
    1376:  00:EE60                      ; EXOS channel RAM is accessed at (ix-1), (ix-2)...etc so our data here is
    1377:  00:EE60                      ; accessed with (ix-1-<item>) eg (ix-1-http_channel.socket). But it must
    1378:  00:EE60                      ; first be paged into page 1 - the page in kept in L'.
    1379:  00:EE60                      ;
    1380:  00:EE60                      ; socket must be first as some of the generic device code expects it here.
    1381:  00:EE60                      ;
    1382:  00:EE60                      		struct	http_channel	; Variables in EXOS channel RAM
    1383:  00:EE60                    < socket		 byte			; WIZ socket # for this channel
    1384:  00:EE60                    < size_H		 byte			; File size
    1385:  00:EE60                    < size_L		 byte
    1386:  00:EE60                    < 		ends
    1387:  00:EE60                      ;
    1388:  00:EE60                      ;
    1389:  00:EE60                      ;------------------------------------------------------------------------------
    1390:  00:EE60                      ; device_open
    1391:  00:EE60                      ;
    1392:  00:EE60                      ; This implements the open code for the EXOS device.
    1393:  00:EE60                      ;
    1394:  00:EE60                      ; In:  vars.device.ip = ip address
    1395:  00:EE60                      ;      DE->"filename", NOT null terminated
    1396:  00:EE60                      ;       B=length of filename
    1397:  00:EE60                      ; Out: A=EXOS error code
    1398:  00:EE60                      ;
    1399:  00:EE60                      device_open:
    1400:  00:EE60  D9                  		exx
    1401:  00:EE61  ED 69               		out	(c),l		; Channel RAM page
    1402:  00:EE63  DD 36 FF 03         		ld	 (ix-1-http_channel.socket),HTTP_SOCKET
    1403:  00:EE67  ED 41               		out	(c),b		; Back to our page
    1404:  00:EE69  D9                  		exx
    1405:  00:EE6A                      ;
    1406:  00:EE6A  FD CB 00 6E         		bit	vars.trace.http,(iy+vars._trace)
    1407:  00:EE6E  28 1A               		jr	z,.donetrace
    1408:  00:EE70                      ;
    1409:  00:EE70  D5                  		push	de
    1410:  00:EE71  C5                  		push	bc
    1411:  00:EE72  11 32 D5            		 ld	de,trace.http.open
    1412:  00:EE75  CD 02 F0            		 call	trace
    1413:  00:EE78                      ;
    1414:  00:EE78  21 1E 40            		 ld	hl,vars.device.ip; DE->ip address
    1415:  00:EE7B  CD 85 CF            		 call	io.ip
    1416:  00:EE7E  3E 3A               		 ld	a,':'
    1417:  00:EE80  CD F9 CF            		 call	io.char
    1418:  00:EE83  3E 50               		 ld	a,HTTP_PORT
    1419:  00:EE85  CD A7 CF            		 call	io.short
    1420:  00:EE88  C1                  		pop	bc
    1421:  00:EE89  D1                  		pop	de
    1422:  00:EE8A                      ;
    1423:  00:EE8A  CD AE D0            .donetrace:	call	status.start
    1424:  00:EE8D                      
    1425:  00:EE8D  D5                  		push	de
    1426:  00:EE8E  C5                  		push	bc
    1427:  00:EE8F  21 2A 00            		 ld	hl,42		; Source port
    1428:  00:EE92                      ;
    1429:  00:EE92  D9                  		 exx
    1430:  00:EE93  ED 69               		 out	(c),l		; Channel RAM page
    1431:  00:EE95  DD 7E FF            		 ld	a,(ix-1-http_channel.socket)	; Get socket number
    1432:  00:EE98  ED 41               		 out	(c),b		; Back to our page
    1433:  00:EE9A  D9                  		 exx
    1434:  00:EE9B                      ;
    1435:  00:EE9B  11 8C F0            		 ld	de,owner_str	; Our name
    1436:  00:EE9E  F5                  		 push	af		; Save socket number
    1437:  00:EE9F  CD 6E DF            		  call	tcp.open
    1438:  00:EEA2  C1                  		 pop	bc		; B=socket number
    1439:  00:EEA3  78                  		 ld	a,b		; A=socket number without corrupting F
    1440:  00:EEA4  21 50 00            		 ld	hl,HTTP_PORT	; HL=dest port
    1441:  00:EEA7  11 1E 40            		 ld	de,vars.device.ip; DE->ip address
    1442:  00:EEAA  D4 8E E1            		 call	nc,tcp.connect	; Connect to server
    1443:  00:EEAD  9F                  		 sbc	a,a		; Error (Cy)->FF, no error (NC)->0
    1444:  00:EEAE  E6 6B               		 and	exos.ERR_NOCON	; Error & NZ or 0 & Z
    1445:  00:EEB0  C1                  		pop	bc
    1446:  00:EEB1  D1                  		pop	de
    1447:  00:EEB2  20 44               		jr	nz,.ret		; Go if error
    1448:  00:EEB4                      ;
    1449:  00:EEB4  CD 8B EF            		call	send		; Send a "GET" request
    1450:  00:EEB7  20 3F               		jr	nz,.ret
    1451:  00:EEB9                      ;
    1452:  00:EEB9                      		; We should get an HTTP reply, which consists of a header
    1453:  00:EEB9                      		; with a variable number of variable length ASCII lines ending
    1454:  00:EEB9                      		; in CR,LF. The end of the header is marked by a blank line
    1455:  00:EEB9                      		; (ie a double CR,LF pair). Assuming the retirn code is
    1456:  00:EEB9                      		; 200 OK the file itself should follow the header.
    1457:  00:EEB9  CD 3D EF            		call	readline	; Get first header line
    1458:  00:EEBC  B7                  		or	a
    1459:  00:EEBD  20 39               		jr	nz,.ret
    1460:  00:EEBF                      ;
    1461:  00:EEBF  11 34 F0            		ld	de,http_1.0_str	; Make sure it starts with HTTP...
    1462:  00:EEC2  06 08               		ld	b,http_1.0_str_len
    1463:  00:EEC4  CD 2D D1            		call	util.memcmp
    1464:  00:EEC7  20 2D               		jr	nz,.badpacket
    1465:  00:EEC9                      ;
    1466:  00:EEC9  23                  .unspace:	inc	hl
    1467:  00:EECA  7E                  		ld	a,(hl)			; Skip spaces
    1468:  00:EECB  FE 20               		cp	' '
    1469:  00:EECD  28 FA               		jr	z,.unspace
    1470:  00:EECF                      ;
    1471:  00:EECF                      		; Next should come the response code
    1472:  00:EECF  EB                  		ex	de,hl		; DE->code in packet
    1473:  00:EED0  CD BE D1            		call	util.get_num16
    1474:  00:EED3  FD CB 00 6E         		bit	vars.trace.http,(iy+vars._trace)
    1475:  00:EED7  28 0B               		jr	z,.donecodetrace
    1476:  00:EED9                      ;
    1477:  00:EED9  11 46 D5            		ld	de,trace.http.code
    1478:  00:EEDC  CD 02 F0            		call	trace
    1479:  00:EEDF  E5                  		push	hl
    1480:  00:EEE0  CD AA CF            		 call	io.int
    1481:  00:EEE3  E1                  		pop	hl
    1482:  00:EEE4                      ;		
    1483:  00:EEE4  01 C8 00            .donecodetrace:	ld	bc,200		; Should be "200 OK"
    1484:  00:EEE7  B7                  		or	a
    1485:  00:EEE8  ED 42               		sbc	hl,bc
    1486:  00:EEEA  28 12               		jr	z,.nextline
    1487:  00:EEEC                      ;
    1488:  00:EEEC  B7                  		or	a
    1489:  00:EEED  01 CC 00            		ld	bc,404-200	; 404 => not found
    1490:  00:EEF0  ED 42               		sbc	hl,bc
    1491:  00:EEF2  3E 68               		ld	a,exos.ERR_NOFIL
    1492:  00:EEF4  28 02               		jr	z,.ret
    1493:  00:EEF6                      ;
    1494:  00:EEF6  3E 64               .badpacket:	ld	a,exos.ERR_BADHTTP
    1495:  00:EEF8  F5                  .ret:		push	af
    1496:  00:EEF9  CD A2 D0            		 call	status.stop
    1497:  00:EEFC  F1                  		pop	af
    1498:  00:EEFD  C9                  		ret
    1499:  00:EEFE                      ;
    1500:  00:EEFE                      		; Now we read and discard all other lines until we reach the
    1501:  00:EEFE                      		; end of the header
    1502:  00:EEFE  CD 3D EF            .nextline:	call	readline
    1503:  00:EF01  B7                  		or	a
    1504:  00:EF02  20 F4               		jr	nz,.ret
    1505:  00:EF04                      ;
    1506:  00:EF04  7E                  		ld	a,(hl)		; See if blank line
    1507:  00:EF05  B7                  		or	a
    1508:  00:EF06  28 F0               		jr	z,.ret		; Finished reading header if yes
    1509:  00:EF08                      ;
    1510:  00:EF08  11 7E F0            		ld	de,content_length_str	; See if length field
    1511:  00:EF0B  06 0E               		ld	b,content_length_str_len
    1512:  00:EF0D  CD 2D D1            		call	util.memcmp
    1513:  00:EF10  20 EC               		jr	nz,.nextline		; Go & read naext line if not
    1514:  00:EF12                      ;
    1515:  00:EF12  23                  .unspace2:	inc	hl			; Skip spaces after
    1516:  00:EF13  7E                  		ld	a,(hl)
    1517:  00:EF14  FE 20               		cp	' '
    1518:  00:EF16  28 FA               		jr	z,.unspace2
    1519:  00:EF18                      ;
    1520:  00:EF18  EB                  		ex	de,hl			; DE->length in packet
    1521:  00:EF19  CD BE D1            		call	util.get_num16		; HL=size
    1522:  00:EF1C                      ;
    1523:  00:EF1C                      		; Save size to channel RAM
    1524:  00:EF1C  E5                  		push	hl
    1525:  00:EF1D  D9                  		 exx
    1526:  00:EF1E  ED 69               		 out	(c),l			; Channel RAM page
    1527:  00:EF20  E1                  		pop	hl			; HL=size
    1528:  00:EF21  DD 75 FD            		ld	(ix-1-http_channel.size_L),l; Save size of packet body
    1529:  00:EF24  DD 74 FE            		ld	(ix-1-http_channel.size_H),h
    1530:  00:EF27  ED 68               		in	l,(c)			; Restore seg normally in L'
    1531:  00:EF29  ED 41               		out	(c),b			; Back to our page
    1532:  00:EF2B  D9                  		exx
    1533:  00:EF2C                      ;
    1534:  00:EF2C  FD CB 00 6E         		bit	vars.trace.http,(iy+vars._trace)
    1535:  00:EF30  28 09               		jr	z,.donelentrace
    1536:  00:EF32                      ;
    1537:  00:EF32  11 4C D5            		ld	de,trace.http.size	; Print size read from packet
    1538:  00:EF35  CD 02 F0            		call	trace
    1539:  00:EF38  CD AA CF            		call	io.int
    1540:  00:EF3B                      ;
    1541:  00:EF3B  18 C1               .donelentrace:	jr	.nextline		; Finish reading header
    1542:  00:EF3D                      ;
    1543:  00:EF3D                      ;
    1544:  00:EF3D                      
    1545:  00:EF3D                      ; Out: HL->vars.http.packet
    1546:  00:EF3D                      ;
    1547:  00:EF3D                      readline:
    1548:  00:EF3D  11 00 43            		ld	de,vars.http.packet
    1549:  00:EF40  D5                  		push	de
    1550:  00:EF41  1B                  		 dec	de		; Compensate for initial inc de
    1551:  00:EF42                      ;
    1552:  00:EF42  13                  .next:		 inc	de
    1553:  00:EF43  D5                  .ignore:	 push	de		; Save ->current byte
    1554:  00:EF44  01 01 00            		  ld	bc,1		; Read 1 byte
    1555:  00:EF47                      ;
    1556:  00:EF47  D9                  		  exx
    1557:  00:EF48  ED 69               		  out	(c),l		; Channel RAM page
    1558:  00:EF4A  DD 7E FF            		  ld	a,(ix-1-http_channel.socket)
    1559:  00:EF4D  ED 41               		  out	(c),b		; Back to our page
    1560:  00:EF4F  D9                  		  exx
    1561:  00:EF50                      ;
    1562:  00:EF50  CD BA DF            		  call	tcp.read_block
    1563:  00:EF53  D1                  		 pop	de		; DE->current byte
    1564:  00:EF54  38 1E               		 jr	c,.err
    1565:  00:EF56                      ;
    1566:  00:EF56  1A                  		 ld	a,(de)
    1567:  00:EF57  FE 0D               		 cp	CR		; Just ignore CRs
    1568:  00:EF59  28 E8               		 jr	z,.ignore
    1569:  00:EF5B                      ;
    1570:  00:EF5B  D6 0A               		 sub	LF		; End of line?
    1571:  00:EF5D  20 E3               		 jr	nz,.next	; Read next char if not
    1572:  00:EF5F                      ;
    1573:  00:EF5F  12                  		 ld	(de),a		; Turn into a null-terminated string
    1574:  00:EF60                      ;
    1575:  00:EF60  FD CB 00 6E         		 bit	vars.trace.http,(iy+vars._trace)
    1576:  00:EF64  28 0B               		 jr	z,.donetrace
    1577:  00:EF66                      ;
    1578:  00:EF66  11 42 D5            		 ld	de,trace.http.rx
    1579:  00:EF69  CD 02 F0            		 call	trace
    1580:  00:EF6C                      ;
    1581:  00:EF6C  D1                  		pop	de
    1582:  00:EF6D  D5                  		push	de
    1583:  00:EF6E  CD 36 D0            		 call	io.str
    1584:  00:EF71                      ;
    1585:  00:EF71  E1                  .donetrace:	pop	hl		; Return HL->line
    1586:  00:EF72  AF                  		xor	a		; No error
    1587:  00:EF73  C9                  		ret
    1588:  00:EF74                      ;
    1589:  00:EF74  E1                  .err:		pop	hl
    1590:  00:EF75                      ;
    1591:  00:EF75  FD CB 00 6E         		bit	vars.trace.http,(iy+vars._trace)
    1592:  00:EF79  28 05               		jr	z,.donetrace3
    1593:  00:EF7B                      ;
    1594:  00:EF7B  F5                  		push	af
    1595:  00:EF7C  DC 4D D2            		 call	c,trace.error
    1596:  00:EF7F  F1                  		pop	af
    1597:  00:EF80                      ;
    1598:  00:EF80                      .donetrace3:
    1599:  00:EF80  D6 02               		sub	2
    1600:  00:EF82  3E E4               		ld	a,exos.ERR_EOF
    1601:  00:EF84  F8                  		ret	m		; Code 1=>socket closed
    1602:  00:EF85                      ;
    1603:  00:EF85  3E E5               		ld	a,exos.ERR_STOP
    1604:  00:EF87  C8                  		ret	z		; Code 2=>STOP pressed
    1605:  00:EF88                      ;
    1606:  00:EF88  3E 6A               		ld	a,exos.ERR_TIMEOUT	; Code 3=>timeout
    1607:  00:EF8A  C9                  		ret
    1608:  00:EF8B                      ;
    1609:  00:EF8B                      ;
    1610:  00:EF8B                      ;------------------------------------------------------------------------------
    1611:  00:EF8B                      ; send
    1612:  00:EF8B                      ;
    1613:  00:EF8B                      ; sends an HTTP "GET" request.
    1614:  00:EF8B                      ;
    1615:  00:EF8B                      ; DE->"filename", no null
    1616:  00:EF8B                      ; B=length of filename
    1617:  00:EF8B                      ;
    1618:  00:EF8B  D5                  send:		push	de
    1619:  00:EF8C  C5                  		push	bc
    1620:  00:EF8D  11 00 43            		 ld	de,vars.http.packet	; Build packet here
    1621:  00:EF90                      ;
    1622:  00:EF90  21 2F F0            		 ld	hl,get_str	; "GET "
    1623:  00:EF93  01 04 00            		 ld	bc,get_str_len
    1624:  00:EF96  ED B0               		 ldir			; Copy GET to packet
    1625:  00:EF98  C1                  		pop	bc		; B="filename" length
    1626:  00:EF99  E1                  		pop	hl		; HL->"filename"
    1627:  00:EF9A                      ;
    1628:  00:EF9A  48                  		ld	c,b		; C=length
    1629:  00:EF9B  AF                  		xor	a
    1630:  00:EF9C  47                  		ld	b,a		; BC=length
    1631:  00:EF9D  B1                  		or	c
    1632:  00:EF9E  28 02               		jr	z,.donefn	; Just in case!
    1633:  00:EFA0                      ;
    1634:  00:EFA0  ED B0               		ldir			; Copy filename to packet
    1635:  00:EFA2  21 33 F0            .donefn:	ld	hl,_http_header_str	; " HTTP/1.0" etc
    1636:  00:EFA5  01 4B 00            		ld	bc,_http_header_str_len
    1637:  00:EFA8  ED B0               		ldir			; Copy protocol etc to packet
    1638:  00:EFAA                      ;
    1639:  00:EFAA  21 60 40            		ld	hl,vars.device.host
    1640:  00:EFAD  CD F1 D0            		call	util.copystr	; Copy host name to packet
    1641:  00:EFB0                      ;
    1642:  00:EFB0  EB                  		ex	de,hl		; HL->end of packet
    1643:  00:EFB1                      ;
    1644:  00:EFB1  FD CB 00 6E         		bit	vars.trace.http,(iy+vars._trace)
    1645:  00:EFB5  28 17               		jr	z,.donetrace
    1646:  00:EFB7                      ;
    1647:  00:EFB7  36 00               		ld	(hl),0		; Null terminate so we can print it
    1648:  00:EFB9                      ;
    1649:  00:EFB9  11 00 43            		ld	de,vars.http.packet
    1650:  00:EFBC  D5                  .loop:		push	de		; Save ->string in packet
    1651:  00:EFBD  11 3E D5            		 ld	de,trace.http.tx
    1652:  00:EFC0  CD 02 F0            		 call	trace		; Start trace line
    1653:  00:EFC3  D1                  		pop	de		; DE->string in packet
    1654:  00:EFC4  CD 32 D0            		call	io.line		; Print one line
    1655:  00:EFC7  1A                  		ld	a,(de)		; See if more lines
    1656:  00:EFC8  B7                  		or	a
    1657:  00:EFC9  20 F1               		jr	nz,.loop	; Print if yes
    1658:  00:EFCB                      ;
    1659:  00:EFCB  CD 36 D2            		call	trace.dots
    1660:  00:EFCE                      ;
    1661:  00:EFCE  36 0D               .donetrace:	ld	(hl),CR		; Add CR,LF now we've done trace
    1662:  00:EFD0  23                  		inc	hl
    1663:  00:EFD1  36 0A               		ld	(hl),LF
    1664:  00:EFD3  23                  		inc	hl
    1665:  00:EFD4                      ;
    1666:  00:EFD4  36 0D               		ld	(hl),CR		; Add final CR, LF to mark end of header
    1667:  00:EFD6  23                  		inc	hl
    1668:  00:EFD7  36 0A               		ld	(hl),LF
    1669:  00:EFD9  23                  		inc	hl
    1670:  00:EFDA                      ;
    1671:  00:EFDA  11 00 43            		ld	de,vars.http.packet	; DE->start of packet
    1672:  00:EFDD  B7                  		or	a
    1673:  00:EFDE  ED 52               		sbc	hl,de		; HL=length of packet
    1674:  00:EFE0  4D                  		ld	c,l
    1675:  00:EFE1  44                  		ld	b,h		; BC=length of packet
    1676:  00:EFE2  EB                  		ex	de,hl		; HL->packet
    1677:  00:EFE3                      ;
    1678:  00:EFE3  D9                  		exx
    1679:  00:EFE4  ED 69               		out	(c),l		; Channel RAM page
    1680:  00:EFE6  DD 7E FF            		ld	a,(ix-1-http_channel.socket)	; Gert socket number
    1681:  00:EFE9  ED 41               		out	(c),b		; Back to our page
    1682:  00:EFEB  D9                  		exx
    1683:  00:EFEC                      ;
    1684:  00:EFEC  F5                  		push	af		; Save socket number
    1685:  00:EFED  CD C0 DB            		call	socket.write
    1686:  00:EFF0  C1                  		pop	bc		; B=socket number
    1687:  00:EFF1  78                  		ld	a,b		; A=socket number without corrupting Cy
    1688:  00:EFF2  D4 60 E1            		call	nc,tcp.send
    1689:  00:EFF5                      ;
    1690:  00:EFF5  FD CB 00 6E         		bit	vars.trace.http,(iy+vars._trace)
    1691:  00:EFF9  28 03               		jr	z,.dt2
    1692:  00:EFFB                      ;
    1693:  00:EFFB  CD 3E D2            		call	trace.is_error
    1694:  00:EFFE                      ;
    1695:  00:EFFE  9F                  .dt2:		sbc	a,a
    1696:  00:EFFF  E6 6A               		and	exos.ERR_TIMEOUT
    1697:  00:F001  C9                  		ret
    1698:  00:F002                      ;
    1699:  00:F002                      ;
    1700:  00:F002                      ;------------------------------------------------------------------------------
    1701:  00:F002                      ; trace
    1702:  00:F002                      ;
    1703:  00:F002                      ; Starts a line of trace output
    1704:  00:F002                      ;
    1705:  00:F002                      ; In:  DE->str
    1706:  00:F002                      ;
    1707:  00:F002  CD 1C D0            trace:		call	io.start
    1708:  00:F005  3E 48               		ld	a,'H'
    1709:  00:F007  CD F9 CF            		call	io.char
    1710:  00:F00A  3E 54               		ld	a,'T'
    1711:  00:F00C  CD F9 CF            		call	io.char
    1712:  00:F00F  3E 54               		ld	a,'T'
    1713:  00:F011  CD F9 CF            		call	io.char
    1714:  00:F014  3E 50               		ld	a,'P'
    1715:  00:F016  CD F9 CF            		call	io.char
    1716:  00:F019  D9                  		exx
    1717:  00:F01A  ED 69               		out	(c),l		; Channel RAM page
    1718:  00:F01C  DD 7E FF            		ld	a,(ix-1-http_channel.socket)
    1719:  00:F01F  ED 41               		out	(c),b		; Back to our page
    1720:  00:F021  D9                  		exx
    1721:  00:F022  C6 30               		add	a,'0'
    1722:  00:F024  CD F9 CF            		call	io.char
    1723:  00:F027  3E 3A               		ld	a,':'
    1724:  00:F029  CD F9 CF            		call	io.char
    1725:  00:F02C  C3 36 D0            		jp	io.str
    1726:  00:F02F                      ;
    1727:  00:F02F                      ;
    1728:  00:F02F  47 45 54 20         get_str:	db	"GET "
    1729:  00:F033  (00:0004)           get_str_len	equ	$-get_str
    1730:  00:F033                      ;
    1731:  00:F033  20                  _http_header_str:db	" "
    1732:  00:F034                      http_1.0_str:	db	"HTTP/1.0"
    1732:  00:F034  48 54 54 50 2F 31 2E 30 
    1733:  00:F03C  (00:0008)           http_1.0_str_len equ	$-http_1.0_str
    1734:  00:F03C  0D 0A               		db	CR,LF
    1735:  00:F03E                      		db	"Connection: Close",CR,LF
    1735:  00:F03E  43 6F 6E 6E 65 63 74 69 6F 6E 3A 20 43 6C 6F 73 
    1735:  00:F04E  65 0D 0A 
    1736:  00:F051                      		db	"User-Agent: Z80 Enterprise EPNET/"
    1736:  00:F051  55 73 65 72 2D 41 67 65 6E 74 3A 20 5A 38 30 20 
    1736:  00:F061  45 6E 74 65 72 70 72 69 73 65 20 45 50 4E 45 54 
    1736:  00:F071  2F 
    1737:  00:F072  30 2E 31 32 0D 0A   		db	version.major, ".", version.minor, version.revision,CR,LF
    1738:  00:F078  48 6F 73 74 3A 20   		db	"Host: "
    1739:  00:F07E  (00:004B)           _http_header_str_len equ	$-_http_header_str
    1740:  00:F07E                      ;
    1741:  00:F07E                      content_length_str:	db	"Content-Length"
    1741:  00:F07E  43 6F 6E 74 65 6E 74 2D 4C 65 6E 67 74 68 
    1742:  00:F08C  (00:000E)           content_length_str_len	equ	$-content_length_str
    1743:  00:F08C                      ;
    1744:  00:F08C                      ;
    1745:  00:F08C  48 54 54 50 3A 00   owner_str:	db	"HTTP:",0
    1746:  00:F092                      ;
    1747:  00:F092                      ;
    1748:  00:F092                      ;
    1749:  00:F092                      		endmodule
     112.  00:F092                      ;
     113.  00:F092                      ;	include vars.asm
     102   00:F092                      ;
     103   00:F092                      		; Miss RAM on H/W V1
     104   00:F092                      ;		ASSERT	$<0f000h
     105   00:F092                      
     106   00:F092                      		; Pad to end of ROM
     107   00:F092  FF (3950)                           ds	65536-$,0ffh	; Pad to end of ROM with FF
     108   00!0000                      ;
     109   00!0000                      		output	nul		; We don't want variables in ROM output
     110   00:4007                      		include	vars.asm	; Include variable declarations
       1.  00:4007                      ; VARS
       2.  00:4007                      ;
       3.  00:4007                      ; Contains all the program RAM variables
       4.  00:4007                      ;
       5.  00:4007                      		module	vars
       6.  00:4007                      ;
       7.  00:4007                      ;==============================================================================
       8.  00:4007                      ;
       9.  00:4007                      ; This file is part of the EPNET software
      10.  00:4007                      ;
      11.  00:4007                      ; Copyright (C) 2015  Bruce Tanner
      12.  00:4007                      ;
      13.  00:4007                      ;    This program is free software: you can redistribute it and/or modify
      14.  00:4007                      ;    it under the terms of the GNU General Public License as published by
      15.  00:4007                      ;    the Free Software Foundation, either version 3 of the License, or
      16.  00:4007                      ;    (at your option) any later version.
      17.  00:4007                      ;
      18.  00:4007                      ;    This program is distributed in the hope that it will be useful,
      19.  00:4007                      ;    but WITHOUT ANY WARRANTY; without even the implied warranty of
      20.  00:4007                      ;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      21.  00:4007                      ;    GNU General Public License for more details.
      22.  00:4007                      ;
      23.  00:4007                      ;    You should have received a copy of the GNU General Public License
      24.  00:4007                      ;    along with this program.  If not, see <http://www.gnu.org/licenses/>.
      25.  00:4007                      ;
      26.  00:4007                      ; If you do use or modify this file, either for its original purpose or for
      27.  00:4007                      ; something new, I'd love to hear about it! I can be contacted by email at:
      28.  00:4007                      ;
      29.  00:4007                      ; brucetanner@btopenworld.com
      30.  00:4007                      ;
      31.  00:4007                      ;==============================================================================
      32.  00:4007                      prog_end:
      33.  00:4007                      ;------------------------------------------------------------------------------
      34.  00:4007                      ; vars
      35.  00:4007                      ;
      36.  00:4007                      ; These are all the variables, buffers etc.
      37.  00:4007                      ;
      38.  00:4007                      ; Throughout the program, IY points to the variables and the variables can
      39.  00:4007                      ; be accessed either directly, as in LD A,(variable), or via IY as in
      40.  00:4007                      ; LD C,(IY+offset to variable). This is particularly useful for global flags
      41.  00:4007                      ; which can be tested with BIT n,(IY+offset), allowing a flag to be tested
      42.  00:4007                      ; without corrupting A (or any other registers).
      43.  00:4007                      ;
      44.  00:4007                      		org	4007h
      45.  00:4007                      ;
      46.  00:4007                      @vars:
      47.  00:4007                      ;
      48.  00:4007                      ;
      49.  00:4007  (00:0000)           _trace		equ	$-vars		; Offset from @vars
      50.  00:4007  00 (1)              trace		ds	1		; Trace flags, as follows:
      51.  00:4008  (00:0000)           trace.diag	equ	0		; Bits in trace
      52.  00:4008  (00:0001)           trace.socket	equ	1
      53.  00:4008  (00:0002)           trace.dhcp	equ	2
      54.  00:4008  (00:0003)           trace.ftp	equ	3
      55.  00:4008  (00:0004)           trace.ntp	equ	4
      56.  00:4008  (00:0005)           trace.http	equ	5
      57.  00:4008  (00:0007)           trace.raw	equ	7
      58.  00:4008                      ;
      59.  00:4008  (00:0001)           trace.diag_mask	equ	01h		; Above bits as bitmasks
      60.  00:4008  (00:0002)           trace.socket_mask equ	02h
      61.  00:4008  (00:0004)           trace.dhcp_mask	equ	04h
      62.  00:4008  (00:0008)           trace.ftp_mask	equ	08h
      63.  00:4008  (00:0010)           trace.ntp_mask	equ	10h
      64.  00:4008  (00:0020)           trace.http_mask	equ	20h
      65.  00:4008  (00:0080)           trace.raw_mask	equ	80h
      66.  00:4008                      ;
      67.  00:4008  (00:007E)           trace.all_mask	equ	low ~(trace.diag_mask or trace.raw_mask)
      68.  00:4008                      ;
      69.  00:4008                      ;
      70.  00:4008  (00:0001)           _io		equ	$-vars		; io as an offset from vars
      71.  00:4008  00 (1)              io:		ds	1		; Our base I/O address+2
      72.  00:4009                      ;
      73.  00:4009                      ;
      74.  00:4009  00 (1)              trace.cols	ds	1		; # cols on screen
      75.  00:400A                      ;
      76.  00:400A                      ;
      77.  00:400A  (00:0003)           _init		equ	$-vars
      78.  00:400A  00 (1)              init		ds	1		; Initialization flags
      79.  00:400B                      ;
      80.  00:400B  (00:0000)           init.wiz	equ	0		; Bits in init
      81.  00:400B  (00:0001)           init.dhcp	equ	1
      82.  00:400B  (00:0002)           init.lease	equ	2
      83.  00:400B                      ;
      84.  00:400B  (00:0001)           init.wiz_mask	equ	01h		; Above bits as bitmasks
      85.  00:400B  (00:0002)           init.dhcp_mask	equ	02h
      86.  00:400B  (00:0004)           init.lease_mask	equ	04h
      87.  00:400B                      ;
      88.  00:400B                      ;
      89.  00:400B  (00:0004)           _socket.flushing equ	$-vars
      90.  00:400B  00 (1)              socket.flushing	ds	1		;NZ=>don't dump, we're flushing (!)
      91.  00:400C  00 (1)              socket.last:	ds	1		; Last socket opened
      92.  00:400D                      ;
      93.  00:400D                      ;
      94.  00:400D  (00:0006)           _io.col		equ	$-vars		; Offset from vars
      95.  00:400D  00 (1)              io.col:		ds	1		; Output column
      96.  00:400E                      ;
      97.  00:400E                      ;
      98.  00:400E  00 (2)              ticks:		ds	2		; 20mS tick count
      99.  00:4010  00 (2)              dhcp.ticks:	ds	2
     100.  00:4012  (00:0032)           @TICKS_1s	equ	50		; No. ticks in 1s
     101.  00:4012  (00:0BB8)           @TICKS_1m	equ	TICKS_1s*60	; No ticks in 1m
     102.  00:4012                      ;
     103.  00:4012                      ;
     104.  00:4012  (00:000B)           status._ticks	equ	$-vars		; Offset from vars
     105.  00:4012  00 (1)              status.ticks:	ds	1		; Tick count for timing flashing blob
     106.  00:4013  00 (2)              status.pos:	ds	2		; ->our position on status line
     107.  00:4015  00 (1)              status.byte:	ds	1		; Saved byte at our pos on status line
     108.  00:4016                      ;
     109.  00:4016                      ;
     110.  00:4016  (00:000F)           device._byte	equ	$-vars		; As offset from vars
     111.  00:4016  00 (1)              device.byte	ds	1		; Single byte buffer for byte read/write
     112.  00:4017  00 (1)              mem.seg		ds	1		; MEM: device segment
     113.  00:4018  00 (2)              mem.rd		ds	2		; MEM: device read pointer
     114.  00:401A  00 (2)              mem.wr		ds	2		; MEM: device write pointer
     115.  00:401C                      ;
     116.  00:401C                      ;
     117.  00:401C  00 (2)              tcp.start:	ds	2		; Start tick count for timeouts
     118.  00:401E                      ;
     119.  00:401E                      ;
     120.  00:401E                      diag.buffer:	;ds	6		; Enough for a MAC address
     121.  00:401E                      					; Overlays buffer below!
     122.  00:401E                      ;
     123.  00:401E                      command.ip:
     124.  00:401E                      device.ip:
     125.  00:401E                      icmp.header:				; ICMP header overlays UDP header
     126.  00:401E                      udp.header:
     127.  00:401E                      icmp.ip:
     128.  00:401E  00 (4)              udp.ip:		ds	4		; IP address
     129.  00:4022                      icmp.size:
     130.  00:4022  00 (2)              udp.port:	ds	2		; Port #
     131.  00:4024  (00:0006)           icmp.header_size equ	$-icmp.header
     132.  00:4024                      ping.start:				; Start time for timeouts
     133.  00:4024                      tcp.header:
     134.  00:4024                      tcp.size:
     135.  00:4024  00 (2)              udp.size:	ds	2		; #bytes in body
     136.  00:4026  (00:0008)           udp.header_size equ	$-udp.header
     137.  00:4026  (00:0002)           tcp.header_size	equ	$-tcp.header
     138.  00:4026                      ;
     139.  00:4026                      ntp.timeout:
     140.  00:4026                      ping.start_ticks:
     141.  00:4026  00 (2)              dhcp.timeout:	ds	2		; Initial secs for timeout
     142.  00:4028                      ping.end_ticks:
     143.  00:4028                      ntp.retries:
     144.  00:4028  00 (1)              dhcp.retries:	ds	1		; Retry count before giving up
     145.  00:4029                      ;
     146.  00:4029                      dhcp.values:				; Parameters obtained via DHCP
     147.  00:4029  00 (4)              dhcp.ip:	ds	4
     148.  00:402D  00 (4)              dhcp.subnet:	ds	4
     149.  00:4031  00 (4)              dhcp.gateway:	ds	4
     150.  00:4035  00 (4)              dhcp.server:	ds	4
     151.  00:4039  00 (4)              dhcp.dns:	ds	4
     152.  00:403D  00 (4)              dhcp.ntp:	ds	4
     153.  00:4041  00 (4)              dhcp.lease:	ds	4		; Lease duration
     154.  00:4045  00 (4)              dhcp.start:	ds	4		; Start secs of lease
     155.  00:4049  (00:0020)           dhcp.values_size equ	$-dhcp.values
     156.  00:4049                      ;
     157.  00:4049                      ping.ip:				; Overlays dhcp values
     158.  00:4049  00 (4)              dhcp.xid:		ds	4		; Our current transaction id
     159.  00:404D  (00:0004)           dhcp.xid_len		equ	$-dhcp.xid
     160.  00:404D                      ping.seq:
     161.  00:404D  00 (2)              dhcp.secs:		ds	2		; Seconds elapsed
     162.  00:404F  (00:0002)           dhcp.secs_len:		equ	$-dhcp.secs
     163.  00:404F  00 (4)              dhcp.packet_xid:	ds	4	; Transaction xid from rx packet
     164.  00:4053                      ;
     165.  00:4053                      ;
     166.  00:4053  00 (4)              ftp.ip:			ds	4
     167.  00:4057  00 (1)              ftp.socket:		ds	1	; Socket for control session
     168.  00:4058  00 (2)              ftp.start:		ds	2	; Starts secs fortimeout
     169.  00:405A  00 (4)              ftp.data_ip:		ds	4	; IP address for data connection
     170.  00:405E  00 (2)              ftp.data_port:		ds	2	; Port #for data connection
     171.  00:4060                      device.host:				; Host name
     172.  00:4060  00 (256)            ftp.buffer:		ds	256	; Buffer for input line
     173.  00:4160  (00:0100)           ftp.buffer_size		equ	$-ftp.buffer
     174.  00:4160  00 (40)             ftp.user:		ds	40
     175.  00:4188  (00:0028)           ftp.user_size		equ	$-ftp.user
     176.  00:4188  00 (40)             ftp.pass:		ds	40
     177.  00:41B0  (00:0028)           ftp.pass_size		equ	$-ftp.pass
     178.  00:41B0                      ;
     179.  00:41B0                      ;
     180.  00:41B0                      ; Per-socket variables, must be on a 256-byte page boundary.
     181.  00:41B0                      ; See socket.asm for access methods
     182.  00:41B0                      ;
     183.  00:41B0                      			org	(vars AND 0ff00h)+200h
     184.  00:4200                      ;
     185.  00:4200                      sockets:				; Per-socket variables
     186.  00:4200                      ;
     187.  00:4200  (00:0020)           socket_size		equ	20h	; Size of each per-socket variable area
     188.  00:4200                      ;
     189.  00:4200  00 (32)             socket0:		ds	socket_size
     190.  00:4220  00 (32)             socket1:		ds	socket_size
     191.  00:4240  00 (32)             socket2:		ds	socket_size
     192.  00:4260  00 (32)             socket3:		ds	socket_size
     193.  00:4280  00 (32)             socket4:		ds	socket_size
     194.  00:42A0  00 (32)             socket5:		ds	socket_size
     195.  00:42C0  00 (32)             socket6:		ds	socket_size
     196.  00:42E0  00 (32)             socket7:		ds	socket_size
     197.  00:4300                      ;
     198.  00:4300                      			ASSERT	socket.vars <= socket_size
     199.  00:4300                      ;
     200.  00:4300                      ;
     201.  00:4300                      ; Packet buffer for tx/rx packets
     202.  00:4300                      ;
     203.  00:4300                      http.packet:
     204.  00:4300                      ping.packet:				; Ping packet overlays DHCP packet!
     205.  00:4300                      dhcp.packet:				; Must not go over 256-byte page!
     206.  00:4300                      ntp.packet:				; NTP packet overlays FTP buffer
     207.  00:4300                      ping.packet.type:
     208.  00:4300                      ntp.packet.livnmode:
     209.  00:4300  00 (1)              dhcp.packet.op:		ds	1	; Message type
     210.  00:4301                      ping.packet.code:
     211.  00:4301                      ntp.packet.stratum:
     212.  00:4301  00 (1)              dhcp.packet.htype:	ds	1	; Hardware address type	
     213.  00:4302                      ping.packet.csum:
     214.  00:4302                      ntp.packet.poll:
     215.  00:4302  00 (1)              dhcp.packet.hlen:	ds	1	; Hardware address length
     216.  00:4303                      ntp.packet.precision:
     217.  00:4303  00 (1)              dhcp.packet.hops:	ds	1
     218.  00:4304                      ping.packet.id:
     219.  00:4304                      ntp.packet.delay:
     220.  00:4304  00 (2)              dhcp.packet.xid:	ds	2	; Transaction id
     221.  00:4306                      ping.packet.seq:
     222.  00:4306  00 (2)              dhcp.packet.xid2:	ds	2	; Transaction id
     223.  00:4308  (00:0008)           ping.packet_size	equ	$-ping.packet
     224.  00:4308                      ntp.packet.dispersion:
     225.  00:4308  00 (2)              dhcp.packet.secs:	ds	2	; Secs elapsed since start of DHCP process
     226.  00:430A  00 (2)              dhcp.packet.flags:	ds	2
     227.  00:430C                      ntp.packet.identifier:
     228.  00:430C  00 (4)              dhcp.packet.ciaddr:	ds	4	; Client IP
     229.  00:4310                      ntp.packet.reference:
     230.  00:4310  00 (4)              dhcp.packet.yiaddr:	ds	4	; Your IP (client's)
     231.  00:4314  00 (4)              dhcp.packet.siaddr:	ds	4	; Next server IP
     232.  00:4318                      ntp.packet.originate:
     233.  00:4318  00 (4)              dhcp.packet.giaddr:	ds	4	; Relay agent IP
     234.  00:431C  00 (4)              dhcp.packet.chaddr:	ds	4	; Client hardware address (16 bytes)
     235.  00:4320  00 (8)              ntp.packet.receive:	ds	8
     236.  00:4328  00 (4)              ntp.packet.transmit:	ds	4
     237.  00:432C                      dhcp.packet_end:
     238.  00:432C  (00:002C)           dhcp.packet_size	equ	$-dhcp.packet
     239.  00:432C  00 (4)              			ds	4
     240.  00:4330                      ntp.packet_end:
     241.  00:4330  (00:0030)           ntp.packet_size		equ	$-ntp.packet
     242.  00:4330                      ;
     243.  00:4330                      		ASSERT	high $ = high dhcp.packet	; Must fit in a page
     244.  00:4330                      		ASSERT dhcp.packet_size > 32	; Used as a 32 byte buffer!
     245.  00:4330                      ;
     246.  00:4330  00 (208)            			ds	256-($-http.packet)
     247.  00:4400  (00:0100)           http.packet_size	equ	$-http.packet
     248.  00:4400                      ;
     249.  00:4400                      
     250.  00:4400                      ;
     251.  00:4400                      ;
     252.  00:4400  (00:03F9)           varsize		equ	$-vars
     253.  00:4400                      ;
     254.  00:4400                      		org	prog_end
     255.  00:4007                      ;
     256.  00:4007                      ;
     257.  00:4007                      ;
     258.  00:4007                      		endmodule
     111   00:4007                      ;
     112   00:4007                      ;
     113   00:4007                      ;
     114   00:4007                                      END

    LABELS
-------------------------------------------------
00:0000C00D   io
00:0000C00E   mac
00:0000C014   entry
00:0000C036   cold_reset
00:0000C03C   ram_allocation
00:00000030   version.major
00:00000031   version.minor
00:00000032   version.revision
00:0000C043 X byte
00:0000C04C   nib
00:0000C056   char
00:000000B0 X ep.P0
00:000000B1   ep.P1
00:000000B2 X ep.P2
00:000000B3   ep.P3
00:0000C064   command.help
00:0000C076   command.help.nothelpnet
00:0000C080   command.get_help
00:0000C086   command.helpnet
00:0000C089   command.helpout
00:0000C08F   command.nethelp
00:0000C094   command.specific
00:0000C0A6   command.notnethelpnet
00:0000C0B3   command.command
00:0000C0C9   command.jp_cmd
00:0000C0CD   jphl
00:0000C0CE   command.compare
00:0000C0D5   command.compare.loop
00:0000C0E0   command.compare.notequal
00:0000C0E3   command.find
00:0000C0E4   command.find.loop
00:0000C0F6   command.find.end
00:0000C0FA   command.find.gotcmd
00:0000C107   command.skip
00:0000C10F   command.skip.skipinc
00:0000C115 X command.unspace
00:0000C116   command.unspace.loop
00:0000C11F   command.unspace.setlen
00:0000C126   command.unspace.count
00:0000C131   command.unspace.ret
00:0000C133   command.net
00:0000C146   command.net.badnet
00:0000C14B   command.net.nonet
00:0000C154   command.net_diag
00:0000C164   command.net_start
00:0000C168   command.netstart
00:0000C16D X command.do_dhcp
00:0000C182   command.do_dhcp.chk_stop
00:0000C185   command.do_dhcp.ret
00:0000C18B   command.ftp
00:0000C1AB   command.ftp.badcmd
00:0000C1B0   command.ftp.noftp
00:0000C1B7 X command.ftp.ret
00:0000C1BA   command.ftp_login
00:0000C1E1   command.ftp_login.ret
00:0000C1EC   command.ftp_logout
00:0000C1F9   command.ftp_status
00:0000C201   command.ftp_cd
00:0000C209   command.ftp_md
00:0000C211   command.ftp_rd
00:0000C219   command.ftp_del
00:0000C221   command.ftp_ren
00:0000C232   command.ftp_dir
00:0000C23A   command.ping
00:0000C263   command.ping.ret
00:0000C266   command.ping.noping
00:0000C26F   command.trace
00:0000C282   command.trace.noarg
00:0000C288   command.trace.badcmd
00:0000C28D   command.trace_str_tab
00:0000C295   command.trace_value_tab
00:0000C298   command.on_str
00:0000C29C   command.off_str
00:0000C2A1   command.raw_str
00:0000C2A6   command.status
00:0000C2B6 X command.status.ret
00:0000C2B9   command.status.badopt
00:0000C2BE   command.status.doit
00:0000C2F3   command.status.loop
00:0000C310   command.status.doneowner
00:0000C321   command.status.nostr
00:0000C343   command.status.doneone
00:0000C34F   command.status.easteregg_str
00:0000C364   command.status.surprise_str
00:0000C367   command.status.mac_str
00:0000C36D   command.status.ip_str
00:0000C372   command.status.subnet_str
00:0000C37B   command.status.gateway_str
00:0000C384   command.status.heading
00:0000C3A6   command.status.to_str
00:0000C3AB   command.time
00:0000C3BA   command.time.ret
00:0000C3BD   command.special
00:0000C3C9   command.special.gotio
00:0000C3CD   command.main_tab
00:0000C3D7   command.main_help_tab
00:0000C3DF   command.main_cmd_tab
00:0000C3E7   command.net_tab
00:0000C3F9   command.net_help_tab
00:0000C409   command.net_cmd_tab
00:0000C419   command.ftp_tab
00:0000C437   command.ftp_cmd_tab
00:0000C453   command.login_str
00:0000C459   command.logout_str
00:0000C460   command.dir_str
00:0000C464   command.cd_str
00:0000C467   command.del_str
00:0000C46B   command.era_str
00:0000C46F   command.erase_str
00:0000C475   command.ren_str
00:0000C479   command.rename_str
00:0000C480   command.md_str
00:0000C483   command.mkdir_str
00:0000C489   command.rd_str
00:0000C48C   command.rmdir_str
00:0000C492   command.version_str
00:0000C4A6   command.special_help_str
00:0000C4A7   command.help_help_str
00:0000C4A7   command.net_help_str
00:0000C667   command.diag_help_str
00:0000C6A8   command.start_help_str
00:0000C6EF   command.ftp_help_str
00:0000C8F0   command.ping_help_str
00:0000C955   command.trace_help_str
00:0000CA04   command.status_help_str
00:0000CA46   command.time_help_str
00:0000CA8D   command.net_str
00:00000003   command.net_str_len
00:0000CA91   command.ftp_str
00:0000CA95   command.diag_str
00:0000CA9A   command.start_str
00:0000CAA0   command.ping_str
00:0000CAA5   command.trace_str
00:0000CAAB   command.status_str
00:0000CAB2   command.time_str
00:0000CAB7   command.help_str
00:0000CABC   command.special_str
00:0000BFFF X exos.USR_P3
00:0000BFFE X exos.USR_P2
00:0000BFFD X exos.USR_P1
00:0000BFFC   exos.USR_P0
00:0000BFFA X exos.STACK_LIMIT
00:0000BFF8 X exos.RST_ADDR
00:0000BFF6   exos.ST_POINTER
00:0000BFF4 X exos.LP_POINTER
00:0000BFF3 X exos.PORTB5
00:0000BFF2   exos.FLAG_SOFT_IRQ
00:0000BFF0 X exos.SEC_COUNTER
00:0000BFEE X exos.CR_DISP
00:0000BFED X exos.USER_ISR
00:00000000 X exos.FN_RESET
00:00000001 X exos.FN_OPEN
00:00000002 X exos.FN_CREATE
00:00000003 X exos.FN_CLOSE
00:00000004 X exos.FN_DEST
00:00000005   exos.FN_RDCH
00:00000006 X exos.FN_RDBLK
00:00000007   exos.FN_WRCH
00:00000008   exos.FN_WRBLK
00:00000009 X exos.FN_RSTAT
00:0000000A X exos.FN_SSTAT
00:0000000B   exos.FN_SFUNC
00:00000010   exos.FN_EVAR
00:00000011 X exos.FN_CAPT
00:00000012 X exos.FN_REDIR
00:00000013 X exos.FN_DDEV
00:00000014 X exos.FN_SYSS
00:00000015 X exos.FN_LINK
00:00000016 X exos.FN_READB
00:00000017 X exos.FN_SETB
00:00000018 X exos.FN_ALLOC
00:00000019 X exos.FN_FREE
00:0000001A   exos.FN_ROMS
00:0000001B   exos.FN_BUFF
00:0000001C X exos.FN_ERRMSG
00:0000001D X exos.FN_LD
00:0000001E X exos.FN_REL
00:0000001F X exos.FN_STIME
00:00000020 X exos.FN_RTIME
00:00000021 X exos.FN_SDATE
00:00000022 X exos.FN_RDATE
00:000000FF X exos.ERR_IFUNC
00:000000FE X exos.ERR_ILLFN
00:000000FD X exos.ERR_INAME
00:000000FC X exos.ERR_STACK
00:000000FB X exos.ERR_ICHAN
00:000000FA X exos.ERR_NODEV
00:000000F9 X exos.ERR_CHANX
00:000000F8 X exos.ERR_NOBUF
00:000000F7 X exos.ERR_NORAM
00:000000F6 X exos.ERR_NOVID
00:000000F5 X exos.ERR_NOSEG
00:000000F4 X exos.ERR_ISEG
00:000000F3 X exos.ERR_IBOUN
00:000000F2 X exos.ERR_IVAR
00:000000F1 X exos.ERR_IDESC
00:000000F0 X exos.ERR_NOSTR
00:000000EF X exos.ERR_ASCII
00:000000EE X exos.ERR_ITYPE
00:000000ED X exos.ERR_IREL
00:000000EC X exos.ERR_NOMOD
00:000000EB X exos.ERR_ITIME
00:000000EA X exos.ERR_ISPEC
00:000000E9 X exos.ERR_CH2ND
00:000000E8 X exos.ERR_IUNIT
00:000000E7   exos.ERR_NOFN
00:000000E6 X exos.ERR_ESC
00:000000E5   exos.ERR_STOP
00:000000E4   exos.ERR_EOF
00:000000E3 X exos.ERR_PROT
00:000000E2 X exos.ERR_KFSPC
00:000000E1 X exos.ERR_SENV
00:000000E0 X exos.ERR_SENBF
00:000000DF X exos.ERR_SQFUL
00:000000DE X exos.ERR_VSIZE
00:000000DD X exos.ERR_VMODE
00:000000DC X exos.ERR_VDISP
00:000000DB X exos.ERR_VLOAD
00:000000DA X exos.ERR_VROW
00:000000D9 X exos.ERR_VCURS
00:000000D8 X exos.ERR_VBEAM
00:000000D7 X exos.ERR_SEROP
00:000000D6 X exos.ERR_NOADR
00:000000D5 X exos.ERR_NETOP
00:000000D4 X exos.ERR_EVID
00:000000D3 X exos.ERR_EKEY
00:000000D2 X exos.ERR_EDINV
00:000000D1 X exos.ERR_EDBUF
00:000000D0 X exos.ERR_CCRC
00:0000006F   exos.ERR_LAST
00:0000006F   exos.ERR_DHCP
00:0000006E   exos.ERR_NONET
00:0000006D   exos.ERR_BADIP
00:0000006C   exos.ERR_BADOPT
00:0000006B   exos.ERR_NOCON
00:0000006A   exos.ERR_TIMEOUT
00:00000069   exos.ERR_FTP
00:00000068   exos.ERR_NOFIL
00:00000067   exos.ERR_NOTIME
00:00000066   exos.ERR_DUPIP
00:00000065   exos.ERR_FTPDATA
00:00000064   exos.ERR_BADHTTP
00:00000063 X exos.ERR_SOCK
00:00000063   exos.ERR_FIRST
00:0000007F X exos.ERR_SHARE
00:00000000 X exos.VAR_IRQ_ENABLE
00:00000001 X exos.VAR_FLAG_SIRQ
00:00000002 X exos.VAR_CODE_SIRQ
00:00000003 X exos.VAR_DEF_TYPE
00:00000004 X exos.VAR_DEF_CHAN
00:00000005 X exos.VAR_TIMER
00:00000006 X exos.VAR_LOCK_KEY
00:00000007 X exos.VAR_CLICK_KEY
00:00000008 X exos.VAR_STOP_IRQ
00:00000009 X exos.VAR_KEY_IRQ
00:0000000A X exos.VAR_RATE_KEY
00:0000000B X exos.VAR_DELAY_KEY
00:0000000C X exos.VAR_TAPE_SND
00:0000000D X exos.VAR_WAIT_SND
00:0000000E X exos.VAR_MUTE_SND
00:0000000F X exos.VAR_BUF_SND
00:00000010 X exos.VAR_BAUD_SER
00:00000011 X exos.VAR_FORM_SER
00:00000012 X exos.VAR_ADDR_NET
00:00000013 X exos.VAR_NET_IRQ
00:00000014 X exos.VAR_CHAN_NET
00:00000015 X exos.VAR_MACH_NET
00:00000016 X exos.VAR_MODE_VID
00:00000017 X exos.VAR_COLR_VID
00:00000018 X exos.VAR_X_SIZ_VID
00:00000019 X exos.VAR_Y_SIZ_VID
00:0000001A X exos.VAR_ST_FLAG
00:0000001B X exos.VAR_BORD_VID
00:0000001C X exos.VAR_BIAS_VID
00:0000001D X exos.VAR_VID_EDIT
00:0000001E X exos.VAR_KEY_EDIT
00:0000001F X exos.VAR_BUF_EDIT
00:00000020   exos.VAR_FLG_EDIT
00:00000021 X exos.VAR_SP_TAPE
00:00000022 X exos.VAR_PROTECT
00:00000023 X exos.VAR_LV_TAPE
00:00000024 X exos.VAR_REM1
00:00000025 X exos.VAR_REM2
00:00000026 X exos.VAR_SPRITE
00:00000027 X exos.VAR_RANDOM
00:00000010 X exos.INT_FKEY
00:00000020 X exos.INT_STOP
00:00000021 X exos.INT_KEY
00:00000030 X exos.INT_NET
00:00000040 X exos.INT_TIME
00:00000001 X exos.FN_VID_DISP
00:00000002   exos.FN_VID_SIZE
00:00000003 X exos.FN_VID_ADDR
00:00000004 X exos.FN_VID_FONT
00:00000008 X exos.FN_KEY_FKEY
00:00000009 X exos.FN_KEY_JOY
00:00000010 X exos.FN_NET_FLSH
00:00000011 X exos.FN_NET_CLR
00:00000018 X exos.FN_ED_MARG
00:00000019 X exos.FN_ED_CHLD
00:0000001A X exos.FN_ED_CHSV
00:00000020 X exos.FN_MEM_SEG
00:00000000 X exos.ACT_NULL
00:00000001 X exos.ACT_COLD
00:00000002 X exos.ACT_STR
00:00000003 X exos.ACT_HELP
00:00000004 X exos.ACT_EVAR
00:00000005 X exos.ACT_ERR
00:00000006 X exos.ACT_LOAD
00:00000007 X exos.ACT_RAM
00:00000008 X exos.ACT_INIT
00:00000000 X exos.MOD_ASCII
00:00000001 X exos.MOD_4TH
00:00000002 X exos.MOD_REL
00:00000003 X exos.MOD_XBAS
00:00000004 X exos.MOD_BAS
00:00000005 X exos.MOD_APP
00:00000006 X exos.MOD_XABS
00:00000007 X exos.MOD_XREL
00:00000008 X exos.MOD_EDIT
00:00000009 X exos.MOD_LISP
00:0000000A X exos.MOD_EOF
00:0000000B X exos.MOD_VID
00:00000007   exos.DEVICE_SEG_START
00:0000CAC3   exos.is_stop
00:0000CACE   exos.is_stop.scfret
00:0000CAD1   exos.check_stop
00:0000CADA   exos.explain
00:0000CAF2   exos.messages
00:0000CB0C   exos.SOCK_str
00:0000000F   exos.SOCK_str_len
00:0000CB1C   exos.DHCP_str
00:00000023   exos.DHCP_str_len
00:0000CB40   exos.NONET_str
00:0000001D   exos.NONET_str_len
00:0000CB5E   exos.BADIP_str
00:00000012   exos.BADIP_str_len
00:0000CB71   exos.BADOPT_str
00:0000000E   exos.BADOPT_str_len
00:0000CB80   exos.NOCON_str
00:0000000E   exos.NOCON_str_len
00:0000CB8F   exos.TIMEOUT_str
00:00000017   exos.TIMEOUT_str_len
00:0000CBA7   exos.FTP_str
00:00000014   exos.FTP_str_len
00:0000CBBC   exos.NOFIL_str
00:0000001F   exos.NOFIL_str_len
00:0000CBDC   exos.NOTIME_str
00:0000001F   exos.NOTIME_str_len
00:0000CBFC   exos.DUPIP_str
00:0000001F   exos.DUPIP_str_len
00:0000CC1C   exos.FTPDATA_str
00:0000001C   exos.FTPDATA_str_len
00:0000CC39   exos.BADHTTP_str
00:00000018   exos.BADHTTP_str_len
00:00000000   device.device.seg
00:00000001   device.device
00:00000000   device.channel.socket
00:00000001   device.channel
00:0000CC56   device.ftp_type
00:0000CC61   device.devices
00:0000CC61 X device.ftp_descriptor
00:0000CC62   device.ftp_entry
00:0000CC7E   device.ftp_interrupt
00:0000CC9A   device.ftp_interrupt.doneticks
00:0000CCA0   device.ftp_open
00:0000CCB6   device.ftp_create
00:0000CCCC   device.ftp_close
00:0000CCE1   device.ftp_read_byte
00:0000CCF6   device.ftp_read_block
00:0000CD07   device.ftp_write_byte
00:0000CD18   device.ftp_write_block
00:0000CD29   device.ftp_read_status
00:0000CD3E   device.tcp_type
00:0000CD49   device.tcp_descriptor
00:0000CD4A   device.tcp_entry
00:00000002   device.TCP_SOCKET
00:0000CD66   device.tcp_open
00:0000CD98   device.tcp_open.ret
00:0000CD9B   device.tcp_create
00:0000CDB4   device.http_type
00:0000CDC0   device.http_descriptor
00:0000CDC1   device.http_entry
00:0000CDDD   device.http_open
00:0000CDED   device.http_open.slash.loop
00:0000CDFA   device.http_open.slash.done
00:0000CE02   device.http_open.host.loop
00:0000CE0E   device.http_open.host.djnz
00:0000CE10   device.http_open.host.done
00:0000CE23 X device.http_create
00:0000CE26   device.opencreate
00:0000CE41   device.entry
00:0000CE53   device.read_byte
00:0000CE6F   device.read_block
00:0000CE83   device.read_ret
00:0000CE96   device.write_byte
00:0000CEB7   device.write_block
00:0000CED1   device.writeret
00:0000CEDD   device.read_status
00:0000CEEE   device.write_status
00:0000CEEE   device.nofn
00:0000CEF1   device.special
00:0000CEF4   device.close
00:0000CF0C   device.block
00:0000CF10   device.block.loop
00:0000CF2B   device.block.bcok
00:0000CF50   device.block.skipjphl
00:0000CF5A   device.block.ret
00:0000CF60   device.init
00:0000CF76   device.moved
00:0000CF76   device.interrupt
00:0000CF77   device.tcp_owner_str
00:0000000D   CR
00:0000000A   LF
00:0000CF7B   io.mac
00:0000CF7D   io.mac.loop
00:0000CF85   io.ip
00:0000CF8E   io.ip.dotnum
00:0000CF93   io.ip.num
00:0000CF9B   io.ip_port
00:0000CFA7   io.short
00:0000CFAA   io.int
00:0000CFC9   io.int.divout
00:0000CFD3   io.int.out
00:0000CFD7   io.int.div16
00:0000CFDA   io.int.loop
00:0000CFE1   io.word
00:0000CFE6   io.byte
00:0000CFEF   io.nib
00:0000CFF9   io.nib.nothex
00:0000CFF9   io.char
00:0000D006   io.char.col0
00:0000D00A   io.char.notcol0
00:0000D016   io.ipcrlf
00:0000D01C   io.start
00:0000D021   io.crlf
00:0000D02A   io.space
00:0000D02E   io.tab
00:0000D032   io.line
00:0000D036   io.str
00:0000D038   io._str
00:0000D040   io._str.col0
00:0000D044   io._str.loop
00:0000D047   io._str.start
00:0000D059   io._str.end
00:0000D063   io.cols
00:0000D065   io.cols.loop
00:0000D072   io.cols.next
00:0000D077   io.input
00:0000D087   io.input.loop
00:0000D095 X io.input.notcr
00:0000D09F   io.input.end
00:00000027   status.STATUS_POS
00:0000001F   status.STATUS_BLOB_L
00:0000000E   status.STATUS_BLOB_S
00:00000010   status.DELAY
00:0000D0A2   status.stop
00:0000D0AE   status.start
00:0000D0C3   status.waiting
00:0000D0CE   status.blob
00:0000D0DB   status.blob_char
00:0000D0E2   status.activity
00:0000D0EA   status.inactivity
00:0000D0F1   util.copystr
00:0000D0F9   util.copyarg
00:0000D101   util.copyarg.loop
00:0000D10B   util.copyarg.ret
00:0000D10E   util.strlen
00:0000D112   util.strlen.loop
00:0000D11A   util.varszero
00:0000D120   util.memzero
00:0000D121 X util.memset
00:0000D12B   util.ipcmp
00:0000D12D   util.memcmp
00:0000D135   util.upper
00:0000D13E   util.get_ip_port
00:0000D159   util._get_port
00:0000D15C   util._get_port.loop
00:0000D171   util.get_ip
00:0000D17B   util._get_ip
00:0000D189   util.inc_get_num8_dot
00:0000D18A   util.get_num8_dot
00:0000D19B   util.inc_get_num8
00:0000D19C   util.get_num8
00:0000D1A2   util.get_num8.loop
00:0000D1B6   util.get_dig
00:0000D1B7   util.isdig
00:0000D1BE   util.get_num16
00:0000D1C5   util.get_num16.loop
00:0000D1D7   trace.diag.ok
00:0000D1DC   trace.diag.err
00:0000D1E1   trace.diag.dots
00:0000D1E6   trace.diag.startstr
00:0000D1E9   trace.diag.str
00:0000D1F1   trace.diag.start
00:0000D1FB X trace.diag.crlf
00:0000D202   trace.diag.char
00:0000D20A   trace.diag.byte
00:0000D212   trace.diag.word
00:0000D21A   trace.diag.mac
00:0000D222   trace.diag.ip
00:0000D22A   trace.bytes
00:0000D236   trace.dots
00:0000D23C   trace.is_timeout
00:0000D23E   trace.is_error
00:0000D240   trace.ok
00:0000D248   trace.timeout
00:0000D24D   trace.error
00:0000D250   trace.err
00:0000D258   trace.err.notstop
00:0000D25D   trace.dumpbytes
00:0000D25D   trace.dumpbytes.loop
00:0000D275   trace.dumpchars
00:0000D275   trace.dumpchars.loop
00:0000D28B   trace.dumpchars.dot
00:0000D28D   trace.dumpchars.ascii
00:0000D294   trace.set_cols
00:0000D29F   trace.diag.reset
00:0000D2B6   trace.diag.id
00:0000D2BF   trace.diag.writemac
00:0000D2D0   trace.diag.writeip
00:0000D2E0   trace.diag.subnet
00:0000D2F1   trace.diag.gateway
00:0000D306   trace.diag.errmsg
00:0000D311   trace.diag.memory
00:0000D324   trace.diag.memerr
00:0000D32A   trace.diag.expected
00:0000D335   trace.diag.at
00:0000D33A   trace.diag.timeout
00:0000D348   trace.diag.dhcp
00:0000D36A   trace.diag.ntp
00:0000D38A   trace.socket.connect
00:0000D396   trace.socket.disconnect
00:0000D3A4   trace.socket.close
00:0000D3AD   trace.socket.open
00:0000D3B3   trace.socket.udp
00:0000D3B7   trace.socket.ipraw
00:0000D3BA   trace.socket.tcp
00:0000D3BE   trace.socket.unknown
00:0000D3C2   trace.socket.port
00:0000D3C9   trace.socket.by
00:0000D3CE   trace.udp.rx
00:0000D3DB   trace.udp.tx
00:0000D3E6 X trace.udp.errmsg
00:0000D3F2   trace.tcp.rx
00:0000D3F9   trace.tcp.tx
00:0000D400   trace.ipraw.rx
00:0000D40F   trace.ipraw.tx
00:0000D41C   trace.dhcp.start
00:0000D42A   trace.dhcp.discover
00:0000D43C   trace.dhcp.request
00:0000D44D   trace.dhcp.rx
00:0000D456   trace.dhcp.gotip
00:0000D45B   trace.dhcp.gotsubnet
00:0000D464   trace.dhcp.gotgateway
00:0000D46E   trace.dhcp.gotserver
00:0000D477   trace.dhcp.gotlease
00:0000D47F   trace.dhcp.gotdns
00:0000D485   trace.dhcp.gotntp
00:0000D48B   trace.dhcp.offer
00:0000D492   trace.dhcp.decline
00:0000D49B   trace.dhcp.ack
00:0000D4A0   trace.dhcp.nak
00:0000D4A5   trace.dhcp.type
00:0000D4B0   trace.dhcp.end
00:0000D4C0 X trace.dhcp.errmsg
00:0000D4CB   trace.dhcp.small
00:0000D4D5   trace.dhcp.port
00:0000D4DE   trace.dhcp.op
00:0000D4E5   trace.dhcp.addr
00:0000D4EE   trace.dhcp.xid
00:0000D4F6   trace.dhcp.cookie
00:0000D501   trace.dhcp.eop
00:0000D50C   trace.ping.pinging
00:0000D515   trace.ntp.tx
00:0000D528   trace.ntp.rx
00:0000D532   trace.http.open
00:0000D53E   trace.http.tx
00:0000D542   trace.http.rx
00:0000D546   trace.http.code
00:0000D54C   trace.http.size
00:0000D552   trace.ftp.open
00:0000D55E   trace.ftp.login
00:0000D567   trace.ftp.tx
00:0000D56B   trace.ftp.rx
00:0000D56F X trace.ftp.close
00:0000D575   trace.ftp.pasv
00:0000D57B   trace.ftp.code
00:0000D581 X trace.ftp.error_str
00:0000D58B   trace.ok_str
00:0000D590   trace.timeout_str
00:0000D59A   trace.error_str
00:0000D5A2   trace.stop_str
00:0000D5A9   trace.dots_str
00:0000D5AD   trace.bytes_str
00:00000000 X w5300.MR0
00:00000001 X w5300.MR1
00:00000020   w5300.MR0_WDF2
00:00000010   w5300.MR0_WDF1
00:00000008   w5300.MR0_WDF0
00:00000080   w5300.MR1_RST
00:00000020   w5300.MR1_MT
00:00000001   w5300.MR1_IND
00:00000002 X w5300.IDM_AR0
00:00000003 X w5300.IDM_AR1
00:00000004 X w5300.IDM_DR0
00:00000005 X w5300.IDM_DR1
00:00000002   w5300.IR
00:00000002   w5300.IR0
00:00000003 X w5300.IR1
00:00000004   w5300.IMR
00:00000004 X w5300.IMR0
00:00000005 X w5300.IMR1
00:00000008   w5300.SHAR
00:00000008 X w5300.SHAR0
00:00000009 X w5300.SHAR1
00:0000000A X w5300.SHAR2
00:0000000B X w5300.SHAR3
00:0000000C X w5300.SHAR4
00:0000000D X w5300.SHAR5
00:00000010   w5300.GAR
00:00000010 X w5300.GAR0
00:00000011 X w5300.GAR1
00:00000012 X w5300.GAR2
00:00000013 X w5300.GAR3
00:00000014   w5300.SUBR
00:00000014 X w5300.SUBR0
00:00000015 X w5300.SUBR1
00:00000016 X w5300.SUBR2
00:00000017 X w5300.SUBR3
00:00000018   w5300.SIPR
00:00000018 X w5300.SIPR0
00:00000019 X w5300.SIPR1
00:0000001A X w5300.SIPR2
00:0000001B X w5300.SIPR3
00:0000001C   w5300.RTR
00:0000001C X w5300.RTR0
00:0000001D X w5300.RTR1
00:0000001F X w5300.RCR1
00:00000020   w5300.TMS01R
00:00000020 X w5300.TMSR0
00:00000021 X w5300.TMSR1
00:00000022   w5300.TMS23R
00:00000022 X w5300.TMSR2
00:00000023 X w5300.TMSR3
00:00000024   w5300.TMS45R
00:00000024 X w5300.TMSR4
00:00000025 X w5300.TMSR5
00:00000026   w5300.TMS67R
00:00000026 X w5300.TMSR6
00:00000027 X w5300.TMSR7
00:00000028   w5300.RMS01R
00:00000028 X w5300.RMSR0
00:00000029 X w5300.RMSR1
00:0000002A   w5300.RMS23R
00:0000002A X w5300.RMSR2
00:0000002B X w5300.RMSR3
00:0000002C   w5300.RMS45R
00:0000002C X w5300.RMSR4
00:0000002D X w5300.RMSR5
00:0000002E   w5300.RMS67R
00:0000002E X w5300.RMSR6
00:0000002F X w5300.RMSR7
00:00000030   w5300.MTYPER
00:00000030 X w5300.MTYPER0
00:00000031 X w5300.MTYPER1
00:00000032 X w5300.PATR0
00:00000033 X w5300.PATR1
00:00000037 X w5300.PTIMER1
00:00000038 X w5300.PMAGICR0
00:00000039 X w5300.PMAGICR1
00:0000003C X w5300.PSIDR0
00:0000003D X w5300.PSIDR1
00:00000040 X w5300.PDHAR0
00:00000041 X w5300.PHARD1
00:00000042 X w5300.PHARD2
00:00000043 X w5300.PHARD3
00:00000044 X w5300.PHARD4
00:00000045 X w5300.PHARD5
00:00000048 X w5300.UIPR0
00:00000049 X w5300.UIPR1
00:0000004A X w5300.UIPR2
00:0000004B X w5300.UIPR3
00:0000004C X w5300.UPORTR0
00:0000004D X w5300.UPORTR1
00:0000004E X w5300.FMTUR0
00:0000004F X w5300.FMTUR1
00:00000061 X w5300.P0_BRDYR1
00:00000062 X w5300.P0_BDPTHR0
00:00000063 X w5300.P0_BDPTHR1
00:00000065 X w5300.P1_BRDYR1
00:00000066 X w5300.P1_BDPTHR0
00:00000067 X w5300.P1_BDPTHR1
00:00000069 X w5300.P2_BRDYR1
00:0000006A X w5300.P2_BDPTHR0
00:0000006B X w5300.P2_BDPTHR1
00:0000006D X w5300.P3_BRDYR1
00:0000006E X w5300.P3_BDPTHR0
00:0000006F X w5300.P3_BDPTHR1
00:000000FE   w5300.IDR
00:000000FE X w5300.IDR0
00:000000FF X w5300.IDR1
00:00000200   w5300.SOCKETS
00:00000200   w5300.SOCKET0
00:00000240   w5300.SOCKET1
00:00000280   w5300.SOCKET2
00:000002C0   w5300.SOCKET3
00:00000300   w5300.SOCKET4
00:00000340   w5300.SOCKET5
00:00000380   w5300.SOCKET6
00:000003C0 X w5300.SOCKET7
00:00000000   w5300.Sn_MR
00:00000000 X w5300.Sn_MR0
00:00000001 X w5300.Sn_MR1
00:00000000 X w5300.Sn_MR_CLOSED
00:00000001   w5300.Sn_MR_TCP
00:00000002   w5300.Sn_MR_UDP
00:00000003   w5300.Sn_MR_IPRAW
00:00000004 X w5300.Sn_MR_MACRAW
00:00000005 X w5300.Sn_MR_PPPoE
00:00000020   w5300.Sn_MR_ND
00:00000002   w5300.Sn_CR
00:00000002 X w5300.Sn_CR0
00:00000003 X w5300.Sn_CR1
00:00000001   w5300.Sn_CR_OPEN
00:00000002 X w5300.Sn_CR_LISTEN
00:00000004   w5300.Sn_CR_CONNECT
00:00000008   w5300.Sn_CR_DISCON
00:00000010   w5300.Sn_CR_CLOSE
00:00000020   w5300.Sn_CR_SEND
00:00000021 X w5300.Sn_CR_SEND_MAC
00:00000022 X w5300.Sn_CR_SEND_KEEP
00:00000040   w5300.Sn_CR_RECV
00:00000004   w5300.Sn_IMR
00:00000004 X w5300.Sn_IMR0
00:00000005 X w5300.Sn_IMR1
00:00000006   w5300.Sn_IR
00:00000007 X w5300.Sn_IR1
00:00000080 X w5300.Sn_IR_PRECV
00:00000040 X w5300.Sn_IR_PFAIL
00:00000020 X w5300.Sn_IR_PNEXT
00:00000010   w5300.Sn_IR_SENDOK
00:00000008   w5300.Sn_IR_TIMEOUT
00:00000004 X w5300.Sn_IR_RECV
00:00000002 X w5300.Sn_IR_DISCON
00:00000001 X w5300.Sn_IR_CON
00:00000008   w5300.Sn_SSR
00:00000009 X w5300.Sn_SSR1
00:00000000   w5300.Sn_SSR_CLOSED
00:00000013   w5300.Sn_SSR_INIT
00:00000014   w5300.Sn_SSR_LISTEN
00:00000017   w5300.Sn_SSR_ESTAB
00:0000001C   w5300.Sn_SSR_WAIT
00:00000022   w5300.Sn_SSR_UDP
00:00000032   w5300.Sn_SSR_IPRAW
00:00000042   w5300.Sn_SSR_MACRAW
00:0000005F   w5300.Sn_SSR_PPPoE
00:00000015   w5300.Sn_SSR_SYNSENT
00:00000016   w5300.Sn_SSR_SYNRECV
00:00000018   w5300.Sn_SSR_FIN_WAIT
00:0000001B   w5300.Sn_SSR_TIME_WAIT
00:0000001D   w5300.Sn_SSR_LAST_ACK
00:00000001   w5300.Sn_SSR_ARP
00:0000000A   w5300.Sn_PORTR
00:0000000C X w5300.Sn_DHAR
00:00000012   w5300.Sn_DPORTR
00:00000014   w5300.Sn_DIPR
00:00000016   w5300.Sn_DIPR2
00:00000018 X w5300.Sn_MSSR
00:0000001A   w5300.Sn_PORTOR
00:0000001C X w5300.Sn_TOSR
00:0000001E X w5300.Sn_TTLR
00:00000020   w5300.Sn_TX_WRSR
00:00000022   w5300.Sn_TX_WRSR2
00:00000024 X w5300.Sn_TX_FSR
00:00000026   w5300.Sn_TX_FSR2
00:00000028 X w5300.Sn_RX_RSR
00:0000002A   w5300.Sn_RX_RSR2
00:0000002C X w5300.Sn_FRAGR
00:0000002E   w5300.Sn_TX_FIFOR
00:00000030   w5300.Sn_RX_FIFOR
00:00000008   wiz.SOCKETS
00:0000D5B4   wiz.read_reg
00:0000D5C3   wiz.write_reg
00:0000D5D2   wiz.write_IP
00:0000D5D6   wiz.write_MAC
00:0000D5D8   wiz.writeloop
00:0000D5EB   wiz.read_IP
00:0000D5EF   wiz.read_MAC
00:0000D5F1   wiz.readloop
00:0000D604   wiz.init_mem
00:0000D610   wiz.init_mem.write_x4
00:0000D613   wiz.init_mem.write_x2
00:0000D616   wiz.init_mem.write_x1
00:0000D61C   wiz.init
00:0000D635   wiz.init.gotio
00:0000D678   wiz.init.badid
00:0000D67B   wiz.diagerr
00:0000D680   wiz.diagtimeout
00:0000D688   wiz.idok
00:0000D6CA   wiz.idok.wloop
00:0000D6E1   wiz.idok.rloop
00:0000D71A   wiz.idok.rok
00:0000D723   wiz.idok.finish
00:0000D768   wiz.idok.macloop
00:0000D775   wiz.idok.badmac
00:0000D77E   wiz.idok.macok
00:0000D783   wiz.check_ip
00:0000D78F   wiz.delay
00:0000D794   wiz.delay.loopstart
00:0000D79D   wiz.delay.loopend
00:0000D7A6   wiz.wait_SSR
00:0000D7A8   wiz.wait_SSR.wait_CR
00:0000D7BA   wiz.wait_SSR.done_CR
00:0000D7BC   wiz.wait_SSR.wait_SSR
00:0000D7CD   wiz.get_MAC
00:0000D7D9   wiz.set_ip
00:0000D7E4   wiz.get_ip
00:0000D7E7   wiz.getip
00:0000D7F0   wiz.set_subnet
00:0000D7FB   wiz.get_subnet
00:0000D800   wiz.set_gateway
00:0000D809   wiz.setip
00:0000D825   wiz.setip.loop
00:0000D832   wiz.setip.badip
00:0000D83B   wiz.get_gateway
00:00000000   socket.vars.owner
00:00000002   socket.vars.tcp_connected
00:00000003   socket.vars.rx_size
00:00000005   socket.vars.rx_inhand
00:00000007   socket.vars.tx_size
00:00000009   socket.vars.tx_inhand
00:0000000B   socket.vars.DPORTR
00:0000000D   socket.vars
00:0000D840   socket.read_reg
00:0000D850   socket.write_reg
00:0000D860   socket._read_FIFO
00:0000D87A   socket._read_FIFO.loop
00:0000D88D   socket._write_FIFO
00:0000D8A7   socket._write_FIFO.loop
00:0000D8BA X socket.read_header_0
00:0000D8BD   socket.read_header
00:0000D8CA X socket.read_FIFO_0
00:0000D8CD   socket.read_FIFO
00:0000D8D5   socket.rd_FIFO
00:0000D8E0   socket.dump
00:0000D924   socket.dump.gotcols
00:0000D92E   socket.dump.ge
00:0000D941   socket.dump.stop
00:0000D953   socket.dump.done
00:0000D957   socket.write_FIFO
00:0000D966   socket.tomask
00:0000D970   socket.masktab
00:0000D978   socket.open
00:0000D9A9   socket.open.protocol
00:0000D9C7   socket.open.tracedone
00:0000DA10   socket.open.ok
00:0000DA18   socket.connect
00:0000DA34   socket.connect.tracedone
00:0000DA47   socket.connect.error
00:0000DA52 X socket.disconnect
00:0000DA5E   socket._disconnect
00:0000DA6F   socket._disconnect.donetrace
00:0000DA77 X socket._disconnect.donedisc
00:0000DA7F   socket.write_CR
00:0000DA86   socket.write_CR.loop
00:0000DA9A   socket.write_CR.wait
00:0000DAA3   socket.available_0
00:0000DAA4   socket.available
00:0000DAB0   socket._available
00:0000DAB8   socket.is_closed
00:0000DAC4   socket._is_closed
00:0000DAD9   socket.read_0
00:0000DADA   socket.read
00:0000DAE6   socket._read
00:0000DAE9   socket._readx
00:0000DB0E   socket._readx.donesize
00:0000DB10   socket.read_byte_0
00:0000DB11 X socket.read_byte
00:0000DB32   socket.read_byte.notgot
00:0000DB54   socket.read_byte.got1
00:0000DB55   socket.read_byte.okret
00:0000DB56   socket.read_byte.ret
00:0000DB59   socket.read_flush_0
00:0000DB5A X socket.read_flush
00:0000DB66   socket._read_flush
00:0000DB72   socket._read_flush.loop
00:0000DB84   socket._read_flush.sizeok
00:0000DB93   socket._read_flush.done
00:0000DBA7   socket.read_end_0
00:0000DBA8   socket.read_end
00:0000DBB4   socket._read_end
00:0000DBB7   socket._recv
00:0000DBBF   socket.write_0
00:0000DBC0   socket.write
00:0000DBCC X socket._write
00:0000DBD8 X socket._write.bigenough
00:0000DBE0   socket.add_tx_size
00:0000DBF3 X socket.write_DIPR_0
00:0000DBF4   socket.write_DIPR
00:0000DC0B   socket.write_DIPR.doone
00:0000DC13   socket.write_DPORTR
00:0000DC1F   socket.read_DIPR
00:0000DC32   socket.read_DIPR.doone
00:0000DC3E   socket.read_DPORTR
00:0000DC43   socket.read_FSR
00:0000DC4B   socket._send
00:0000DC65   socket._send.loop
00:0000DC84   socket._send.timeout
00:0000DC8A   socket._send.sendok
00:0000DC8E   socket._send.ret
00:0000DC9D   socket._send.end
00:0000DCA8   socket.close_0
00:0000DCA9   socket.close
00:0000DCED X socket.find
00:0000DCF1   socket.find.inc
00:0000DD01   socket.status
00:0000DD12   socket.status_str
00:0000DD2D   socket.status_str.val_tab
00:0000000F   socket.status_str.val_tab_num
00:0000DD3C   socket.status_str.str_tab
00:0000DD5A   socket.status_str.str_CLOSED
00:0000DD61   socket.status_str.str_INIT
00:0000DD6E   socket.status_str.str_LISTEN
00:0000DD78   socket.status_str.str_ESTAB
00:0000DD82   socket.status_str.str_WAIT
00:0000DD8A   socket.status_str.str_UDP
00:0000DD8E   socket.status_str.str_IPRAW
00:0000DD95   socket.status_str.str_MACRAW
00:0000DD9D   socket.status_str.str_PPPoE
00:0000DDA3   socket.status_str.str_SYNSENT
00:0000DDAC   socket.status_str.str_SYNRECV
00:0000DDB9   socket.status_str.str_FIN_WAIT
00:0000DDC2   socket.status_str.str_TIME_WAIT
00:0000DDCC   socket.status_str.str_LAST_ACK
00:0000DDD5   socket.status_str.str_ARP
00:0000DDE1   socket.byteswapword
00:0000DDEA   socket.set_word
00:0000DDFC   socket.get_rx_size
00:0000DE0A   socket.get_word
00:0000DE18   socket.get_owner
00:0000DE28   socket.trace_msg
00:0000DE30   socket.trace
00:0000DE3C   socket._trace
00:0000DE54   ipraw.open_0
00:0000DE55 X ipraw.open
00:0000DE5B   ipraw.header_0
00:0000DE5C X ipraw.header
00:0000DE9A   ipraw.header.ret
00:0000DEA0   ipraw.send_0
00:0000DEA1 X ipraw.send
00:0000DED4   ipraw.send.notrace
00:0000DEDA   udp.open_0
00:0000DEDB X udp.open
00:0000DEE1   udp.header_0
00:0000DEE2 X udp.header
00:0000DEE6 X udp.header.gotdata
00:0000DF24   udp.header.ret
00:0000DF2A   udp.send_0
00:0000DF2B X udp.send
00:0000DF5F   udp.send.notrace
00:0000DF6E   tcp.open
00:0000DF74   tcp.header
00:0000DF80   tcp._header
00:0000DFB4   tcp._header.ret
00:0000DFBA   tcp.read_block
00:0000DFC7   tcp.read_block.loop
00:0000DFDD   tcp.read_block.putbyte
00:0000DFEA   tcp.read_block.no_inhand
00:0000E004   tcp.read_block.wait
00:0000E030   tcp.read_block.ret
00:0000E034   tcp.read_block.got_packet
00:0000E053   tcp.read_block.all
00:0000E074   tcp.read_block.odd
00:0000E09B   tcp.write_block
00:0000E0CC   tcp.write_block.nobuf
00:0000E0F5   tcp._write_block
00:0000E0F8   tcp._write_blockx
00:0000E0FA   tcp._write_blockx.loop
00:0000E109   tcp._write_blockx.donesend
00:0000E117   tcp._write_blockx.notlast
00:0000E12B   tcp.status
00:0000E160   tcp.send
00:0000E16C   tcp._send
00:0000E18E   tcp.connect
00:0000E1A0 X tcp.disconnect
00:0000E1AC   tcp._disconnect
00:0000E1C0   tcp._disconnect.readall
00:0000E1D1   tcp.close
00:0000E205   tcp.close.doneinhand
00:00000001   dhcp.DHCP_OP.BOOTREQUEST
00:00000002 X dhcp.DHCP_OP.BOOTREPLY
00:00000001   dhcp.DHCP_HTYPE.10MB
00:00000002 X dhcp.DHCP_HTYPE.100MB
00:00000006   dhcp.DHCP_HLEN.ETHERNET
00:00000000   dhcp.DHCP.HOPS
00:00008000   dhcp.DHCP_FLAGS.BROADCAST
00:00000000 X dhcp.DHCP_OPT.PAD
00:000000FF   dhcp.DHCP_OPT.END
00:00000001   dhcp.DHCP_OPT.SUBNET
00:00000003   dhcp.DHCP_OPT.ROUTER
00:00000006   dhcp.DHCP_OPT.DNS
00:0000000C   dhcp.DHCP_OPT.HOST
00:0000000F   dhcp.DHCP_OPT.DOMAIN
00:0000002A   dhcp.DHCP_OPT.NTP
00:00000032   dhcp.DHCP_OPT.IP
00:00000033   dhcp.DHCP_OPT.LEASE
00:00000035   dhcp.DHCP_OPT.TYPE
00:00000001   dhcp.DHCP_TYPE.DISCOVER
00:00000002   dhcp.DHCP_TYPE.OFFER
00:00000003   dhcp.DHCP_TYPE.REQUEST
00:00000004   dhcp.DHCP_TYPE.DECLINE
00:00000005   dhcp.DHCP_TYPE.ACK
00:00000006   dhcp.DHCP_TYPE.NAK
00:00000007 X dhcp.DHCP_TYPE.RELEASE
00:00000008 X dhcp.DHCP_TYPE.INFORM
00:00000036   dhcp.DHCP_OPT.SERVER
00:00000037   dhcp.DHCP_OPT.PARAM
00:0000003A   dhcp.DHCP_OPT.T1
00:0000003B   dhcp.DHCP_OPT.T2
00:0000003D   dhcp.DHCP_OPT.CLIENT
00:00000043   dhcp.DHCP_SERVER_PORT
00:00000044   dhcp.DHCP_CLIENT_PORT
00:0000E232   dhcp.init
00:0000E244   dhcp.init.loop
00:0000E249   dhcp.init.do_dhcp
00:0000E266   dhcp.init.donetrace
00:0000E27A   dhcp.restart
00:0000E27F   dhcp.donetrace
00:0000E293   dhcp.init.error
00:0000E29A   dhcp.init.abort
00:0000E2A2   dhcp.init.startok
00:0000E2A9 X dhcp.start
00:0000E2CE   dhcp.start.donetrace
00:0000E30D   dhcp.start.dontr2
00:0000E348   dhcp.send
00:0000E34E   dhcp.send.loop
00:0000E398   dhcp.send.writezeros
00:00000004   dhcp.send.LEN_COOKIE
00:00000003   dhcp.send.LEN_TYPE
00:00000009   dhcp.send.LEN_CLIENT
00:0000000A   dhcp.send.LEN_HOST
00:0000001A   dhcp.send.packet_size
00:0000E3E8   dhcp.send.error
00:0000E3F0   dhcp.send.noerror
00:0000E40F   dhcp.send.notreq
00:0000E441   dhcp.read
00:0000E449   dhcp.read.eop
00:0000E44C   dhcp.read.badpacket
00:0000E453 X dhcp.read.retry
00:0000E456   dhcp.read.loop
00:0000E474   dhcp.read.errret
00:0000E47B   dhcp.read.gotpacket
00:0000E48A   dhcp.read.donetrace
00:0000E4CD   dhcp.read.xiderrnz
00:0000E4EC X dhcp.read.xidok
00:0000E4F9   dhcp.read.readlots
00:0000E525   dhcp.read.cookiebad
00:0000E52B   dhcp.read.cookieok
00:0000E52F   dhcp.read.ret
00:0000E53C   dhcp.read.nextopt
00:0000E587   dhcp.read.tracetype
00:0000E59E   dhcp.read.not53
00:0000E5B6   dhcp.read.not1
00:0000E5D2   dhcp.read.not3
00:0000E5E8   dhcp.read.traceip
00:0000E5EC   dhcp.read.skip4
00:0000E5F2   dhcp.read.not6
00:0000E60A   dhcp.read.not42
00:0000E623   dhcp.read.not54
00:0000E646   dhcp.read.not51
00:0000E646   dhcp.read.skipopt
00:0000E64A   dhcp.read.skiploop
00:0000E652   dhcp.read.skipped
00:0000E655   dhcp.read_ip
00:0000E65B   dhcp.read_ip.loop
00:0000E664   dhcp.traceip
00:0000E679   dhcp.packet_write
00:0000E682   dhcp.packet_init
00:0000E68B   dhcp.packet_mac
00:0000E696   dhcp.packet_ip
00:0000E6A1   dhcp.packet_byte
00:0000E6AB   dhcp.packet_nibble
00:0000E6B5   dhcp.packet_nibble.done
00:0000E6B8   dhcp.interrupt
00:0000E6DA   dhcp.interrupt.loop
00:0000E6EA   dhcp.owner_str
00:00004242   ping.OUR_ID
00:0000E6EF   ping.init
00:0000E715   ping.init.loop
00:0000E71E   ping.init.end
00:0000E724   ping.do_ping
00:0000E73D   ping.do_ping.wait
00:0000E758   ping.do_ping.loop
00:0000E777   ping.do_ping.timeout
00:0000E77A   ping.do_ping.okret
00:0000E77E   ping.do_ping.ret
00:0000E784   ping.do_ping.gotreply
00:0000E7B6   ping.do_ping.rejectheader
00:0000E7B6 X ping.do_ping.readrest
00:0000E804   ping.do_ping.printmS
00:0000E807   ping.lt20mS_str
00:0000E80A   ping.mS_str
00:0000E80F   ping.build
00:0000E83A   ping.packet
00:00000008   ping.packet_size
00:0000E842   ping.checksum
00:0000E846   ping.checksum.loop
00:0000E85D   ping.owner_str
00:0000007B   ntp.NTP_CLIENT_PORT
00:0000007B   ntp.NTP_SERVER_PORT
00:0000E862   ntp.init
00:0000E87C   ntp.init.error
00:0000E883   ntp.init.abort
00:0000E88B   ntp.init.start
00:0000E89F   ntp.init.loop
00:0000E8C6   ntp.init.badpacket
00:0000E8CF   ntp.init.gotpacket
00:0000E8DE   ntp.init.donetrace
00:0000E91C   ntp.init.donetrace2
00:0000E924   ntp.send
00:0000E92E   ntp.send.gotntp
00:0000E95F   ntp.send.donetrace
00:0000E989   ntp.broadcast_ip
00:0000E98D   ntp.owner_str
00:00000015   ftp.CONTROL_DPORT
00:00000016   ftp.CONTROL_SPORT
00:0000E991   ftp.open_control
00:0000E9AB   ftp.open_control.notrace
00:0000E9C1   ftp.open_control.done
00:0000E9C9   ftp.login
00:0000E9D7   ftp.login.notrace
00:0000E9E4   ftp.login.lenok
00:0000EA0B   ftp.login.gotuser
00:0000EA37   ftp.login.gotpass
00:0000EA49   ftp.anonymous_str
00:0000000A   ftp.anonymous_str_size
00:0000EA53   ftp.localhost_str
00:0000000F   ftp.localhost_str_size
00:0000EA62   ftp.userprompt_str
00:0000EA7A   ftp.passprompt_str
00:0000EA96   ftp.logout
00:0000EA9F   ftp.dir
00:0000EABA   ftp.dir.print
00:0000EAD8   ftp.dir.doread
00:0000EAE5   ftp.dir.done
00:0000EAEA   ftp.dir.timeout
00:0000EAED X ftp.dir.close
00:0000EAFC   ftp.status
00:0000EB04   ftp.chdir
00:0000EB1C   ftp.chdir.deccd
00:0000EB1D   ftp.chdir.cd
00:0000EB22   ftp.chdir.cdup
00:0000EB27   ftp.chdir.pwd
00:0000EB2A   ftp.issue_print
00:0000EB33   ftp.mkdir
00:0000EB3B   ftp.rmdir
00:0000EB43   ftp.del
00:0000EB4B   ftp.ren
00:0000EB5C   ftp.issue
00:0000EB5F   ftp.issue_arg
00:0000EB64   ftp.is_response
00:0000EB6B   ftp.get_response
00:0000EB76 X ftp.get_response.noerr
00:0000EB97   ftp.get_response.donetrace
00:0000EBBD   ftp.open_data
00:0000EBDD   ftp.read
00:0000EBE3   ftp.read.loop
00:0000EBF3   ftp.read.notclosed
00:0000EC0F   ftp.read.readit
00:0000EC1D   ftp.read.doread
00:0000EC29   ftp.read_code
00:0000EC2E   ftp.read_code.first
00:0000EC31   ftp.read_code.nextline
00:0000EC3D   ftp.read_code.skip
00:0000EC4C   ftp.issue_cmd
00:0000EC70   ftp.issue_cmd.notrace
00:0000EC87   ftp.crlf_str
00:0000EC8A   ftp.send_pasv
00:0000ECB7   ftp.send_pasv.gotsep
00:0000ECBE   ftp.send_pasv.notsep
00:0000ECDC   ftp.findnum
00:0000ECDD   ftp.findnum.loop
00:0000ECE7   ftp.trace
00:00000000   ftp.ftp_channel.socket
00:00000001   ftp.ftp_channel.data
00:00000002   ftp.ftp_channel
00:0000ED09   ftp.device_open
00:0000ED0E   ftp.device_create
00:0000ED11   ftp.opencreate
00:0000ED42   ftp.opencreate.ret
00:0000ED48   ftp.device_close
00:0000ED6E   ftp.device_read_byte
00:0000ED8B   ftp.device_read_block
00:0000ED95   ftp.read_ret
00:0000EDA1   ftp.device_write_byte
00:0000EDBF   ftp.device_write_block
00:0000EDCD   ftp.device_status
00:0000EDD9   ftp.ftp_to_exos
00:0000EDDE   ftp.ftp_to_exos.loop
00:0000EDF0   ftp.ftp_to_exos.notintable
00:0000EDFA   ftp.responses
00:0000EE00   ftp.cwd_str
00:0000EE05   ftp.pwd_str
00:0000EE09   ftp.cdup_str
00:0000EE0E   ftp.mkd_str
00:0000EE13   ftp.rmd_str
00:0000EE18   ftp.dele_str
00:0000EE1E   ftp.rnfr_str
00:0000EE24   ftp.rnto_str
00:0000EE2A   ftp.user_str
00:0000EE30   ftp.pass_str
00:0000EE36   ftp.pasv_str
00:0000EE3B   ftp.list_str
00:0000EE41   ftp.retr_str
00:0000EE47   ftp.stor_str
00:0000EE4D   ftp.syst_str
00:0000EE52   ftp.quit_str
00:0000EE57   ftp.owner_str
00:0000EE5B   ftp.owner_data_str
00:00000003   http.HTTP_SOCKET
00:00000050   http.HTTP_PORT
00:00000000   http.http_channel.socket
00:00000001   http.http_channel.size_H
00:00000002   http.http_channel.size_L
00:00000003   http.http_channel
00:0000EE60   http.device_open
00:0000EE8A   http.device_open.donetrace
00:0000EEC9   http.device_open.unspace
00:0000EEE4   http.device_open.donecodetrace
00:0000EEF6   http.device_open.badpacket
00:0000EEF8   http.device_open.ret
00:0000EEFE   http.device_open.nextline
00:0000EF12   http.device_open.unspace2
00:0000EF3B   http.device_open.donelentrace
00:0000EF3D   http.readline
00:0000EF42   http.readline.next
00:0000EF43   http.readline.ignore
00:0000EF71   http.readline.donetrace
00:0000EF74   http.readline.err
00:0000EF80   http.readline.donetrace3
00:0000EF8B   http.send
00:0000EFA2   http.send.donefn
00:0000EFBC   http.send.loop
00:0000EFCE   http.send.donetrace
00:0000EFFE   http.send.dt2
00:0000F002   http.trace
00:0000F02F   http.get_str
00:00000004   http.get_str_len
00:0000F033   http._http_header_str
00:0000F034   http.http_1.0_str
00:00000008   http.http_1.0_str_len
00:0000004B   http._http_header_str_len
00:0000F07E   http.content_length_str
00:0000000E   http.content_length_str_len
00:0000F08C   http.owner_str
00:00004007   vars.prog_end
00:00004007   vars
00:00000000   vars._trace
00:00004007   vars.trace
00:00000000   vars.trace.diag
00:00000001   vars.trace.socket
00:00000002   vars.trace.dhcp
00:00000003   vars.trace.ftp
00:00000004   vars.trace.ntp
00:00000005   vars.trace.http
00:00000007   vars.trace.raw
00:00000001   vars.trace.diag_mask
00:00000002 X vars.trace.socket_mask
00:00000004 X vars.trace.dhcp_mask
00:00000008 X vars.trace.ftp_mask
00:00000010 X vars.trace.ntp_mask
00:00000020 X vars.trace.http_mask
00:00000080   vars.trace.raw_mask
00:0000007E   vars.trace.all_mask
00:00000001   vars._io
00:00004008   vars.io
00:00004009   vars.trace.cols
00:00000003   vars._init
00:0000400A   vars.init
00:00000000   vars.init.wiz
00:00000001   vars.init.dhcp
00:00000002   vars.init.lease
00:00000001 X vars.init.wiz_mask
00:00000002 X vars.init.dhcp_mask
00:00000004 X vars.init.lease_mask
00:00000004   vars._socket.flushing
00:0000400B X vars.socket.flushing
00:0000400C   vars.socket.last
00:00000006   vars._io.col
00:0000400D   vars.io.col
00:0000400E   vars.ticks
00:00004010   vars.dhcp.ticks
00:00000032   TICKS_1s
00:00000BB8   TICKS_1m
00:0000000B   vars.status._ticks
00:00004012   vars.status.ticks
00:00004013   vars.status.pos
00:00004015   vars.status.byte
00:0000000F   vars.device._byte
00:00004016   vars.device.byte
00:00004017 X vars.mem.seg
00:00004018 X vars.mem.rd
00:0000401A X vars.mem.wr
00:0000401C   vars.tcp.start
00:0000401E   vars.diag.buffer
00:0000401E   vars.command.ip
00:0000401E   vars.device.ip
00:0000401E   vars.icmp.header
00:0000401E   vars.udp.header
00:0000401E   vars.icmp.ip
00:0000401E   vars.udp.ip
00:00004022   vars.icmp.size
00:00004022   vars.udp.port
00:00000006   vars.icmp.header_size
00:00004024 X vars.ping.start
00:00004024   vars.tcp.header
00:00004024   vars.tcp.size
00:00004024   vars.udp.size
00:00000008   vars.udp.header_size
00:00000002   vars.tcp.header_size
00:00004026   vars.ntp.timeout
00:00004026   vars.ping.start_ticks
00:00004026   vars.dhcp.timeout
00:00004028   vars.ping.end_ticks
00:00004028   vars.ntp.retries
00:00004028   vars.dhcp.retries
00:00004029   vars.dhcp.values
00:00004029   vars.dhcp.ip
00:0000402D   vars.dhcp.subnet
00:00004031   vars.dhcp.gateway
00:00004035   vars.dhcp.server
00:00004039   vars.dhcp.dns
00:0000403D   vars.dhcp.ntp
00:00004041   vars.dhcp.lease
00:00004045 X vars.dhcp.start
00:00000020   vars.dhcp.values_size
00:00004049   vars.ping.ip
00:00004049   vars.dhcp.xid
00:00000004 X vars.dhcp.xid_len
00:0000404D   vars.ping.seq
00:0000404D   vars.dhcp.secs
00:00000002 X vars.dhcp.secs_len
00:0000404F   vars.dhcp.packet_xid
00:00004053   vars.ftp.ip
00:00004057   vars.ftp.socket
00:00004058   vars.ftp.start
00:0000405A   vars.ftp.data_ip
00:0000405E   vars.ftp.data_port
00:00004060   vars.device.host
00:00004060   vars.ftp.buffer
00:00000100   vars.ftp.buffer_size
00:00004160   vars.ftp.user
00:00000028   vars.ftp.user_size
00:00004188   vars.ftp.pass
00:00000028   vars.ftp.pass_size
00:00004200   vars.sockets
00:00000020   vars.socket_size
00:00004200 X vars.socket0
00:00004220 X vars.socket1
00:00004240 X vars.socket2
00:00004260 X vars.socket3
00:00004280 X vars.socket4
00:000042A0 X vars.socket5
00:000042C0 X vars.socket6
00:000042E0 X vars.socket7
00:00004300   vars.http.packet
00:00004300   vars.ping.packet
00:00004300   vars.dhcp.packet
00:00004300   vars.ntp.packet
00:00004300   vars.ping.packet.type
00:00004300 X vars.ntp.packet.livnmode
00:00004300   vars.dhcp.packet.op
00:00004301   vars.ping.packet.code
00:00004301 X vars.ntp.packet.stratum
00:00004301 X vars.dhcp.packet.htype
00:00004302   vars.ping.packet.csum
00:00004302 X vars.ntp.packet.poll
00:00004302 X vars.dhcp.packet.hlen
00:00004303 X vars.ntp.packet.precision
00:00004303 X vars.dhcp.packet.hops
00:00004304   vars.ping.packet.id
00:00004304 X vars.ntp.packet.delay
00:00004304   vars.dhcp.packet.xid
00:00004306   vars.ping.packet.seq
00:00004306 X vars.dhcp.packet.xid2
00:00000008   vars.ping.packet_size
00:00004308 X vars.ntp.packet.dispersion
00:00004308 X vars.dhcp.packet.secs
00:0000430A X vars.dhcp.packet.flags
00:0000430C   vars.ntp.packet.identifier
00:0000430C X vars.dhcp.packet.ciaddr
00:00004310 X vars.ntp.packet.reference
00:00004310   vars.dhcp.packet.yiaddr
00:00004314 X vars.dhcp.packet.siaddr
00:00004318 X vars.ntp.packet.originate
00:00004318 X vars.dhcp.packet.giaddr
00:0000431C   vars.dhcp.packet.chaddr
00:00004320 X vars.ntp.packet.receive
00:00004328   vars.ntp.packet.transmit
00:0000432C X vars.dhcp.packet_end
00:0000002C   vars.dhcp.packet_size
00:00004330 X vars.ntp.packet_end
00:00000030   vars.ntp.packet_size
00:00000100 X vars.http.packet_size
00:000003F9   vars.varsize


 Output: epnet.rom
-------------------------------------------------

 Page: 00
  Org: 00004007  Size: *  Used: 00004000

   Address   Length Align   Label
   00004007   16384         io

 Output: nul
-------------------------------------------------

 Page: 00
  Org: 00004007  Size: *  Used: 000003A9

   Address   Length Align   Label
   00004007     937         vars.prog_end
